/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./ui/explorer/MainView.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../libs/ff-browser/source/ManipTarget.ts":
/*!*******************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-browser/source/ManipTarget.ts ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ManipTarget; });
/**
 * FF Typescript Foundation Library
 * Copyright 2021 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
////////////////////////////////////////////////////////////////////////////////
const _DRAG_DISTANCE = 4;
/**
 * Composable class, listens for mouse and touch events on its target and converts
 * them to [[IPointerEvent]] and [[ITriggerEvent]] events. [[IManip]] receivers of these events
 * can be chained. Events are handed down the chain, starting with the [[IManip]] instance
 * assigned to [[ManipTarget.next]].
 */
class ManipTarget {
    constructor(target) {
        this.next = null;
        this.activePositions = [];
        this.activeType = "";
        this.centerX = 0;
        this.centerY = 0;
        this.startX = 0;
        this.startY = 0;
        this.isDragging = false;
        this.onPointerDown = this.onPointerDown.bind(this);
        this.onPointerMove = this.onPointerMove.bind(this);
        this.onPointerUpOrCancel = this.onPointerUpOrCancel.bind(this);
        this.onDoubleClick = this.onDoubleClick.bind(this);
        this.onContextMenu = this.onContextMenu.bind(this);
        this.onWheel = this.onWheel.bind(this);
        if (target) {
            target.addEventListener("pointerdown", this.onPointerDown);
            target.addEventListener("pointermove", this.onPointerMove);
            target.addEventListener("pointerup", this.onPointerUpOrCancel);
            target.addEventListener("pointercancel", this.onPointerUpOrCancel);
            target.addEventListener("contextmenu", this.onContextMenu);
            target.addEventListener("wheel", this.onWheel);
        }
    }
    onPointerDown(event) {
        // only events of a single pointer type can be handled at a time
        if (this.activeType && event.pointerType !== this.activeType) {
            return;
        }
        if (this.activePositions.length === 0) {
            this.startX = event.clientX;
            this.startY = event.clientY;
            this.isDragging = false;
        }
        this.activeType = event.pointerType;
        this.activePositions.push({
            id: event.pointerId,
            clientX: event.clientX,
            clientY: event.clientY
        });
        event.currentTarget.setPointerCapture(event.pointerId);
        const manipEvent = this.createManipPointerEvent(event, "pointer-down");
        if (this.sendPointerEvent(manipEvent)) {
            event.stopPropagation();
        }
        //event.preventDefault();
    }
    onPointerMove(event) {
        const activePositions = this.activePositions;
        for (let i = 0, n = activePositions.length; i < n; ++i) {
            const position = activePositions[i];
            if (event.pointerId === position.id) {
                position.clientX = event.clientX;
                position.clientY = event.clientY;
            }
        }
        if (activePositions.length > 0 && !this.isDragging) {
            const delta = Math.abs(event.clientX - this.startX) + Math.abs(event.clientY - this.startY);
            if (delta > _DRAG_DISTANCE) {
                this.isDragging = true;
            }
        }
        const eventType = activePositions.length ? "pointer-move" : "pointer-hover";
        const manipEvent = this.createManipPointerEvent(event, eventType);
        if (this.sendPointerEvent(manipEvent)) {
            event.stopPropagation();
        }
        //event.preventDefault();
    }
    onPointerUpOrCancel(event) {
        const activePositions = this.activePositions;
        let found = false;
        for (let i = 0, n = activePositions.length; i < n; ++i) {
            if (event.pointerId === activePositions[i].id) {
                activePositions.splice(i, 1);
                found = true;
                break;
            }
        }
        if (!found) {
            //console.warn("orphan pointer up/cancel event #id", event.pointerId);
            return;
        }
        const manipEvent = this.createManipPointerEvent(event, "pointer-up");
        if (activePositions.length === 0) {
            this.activeType = "";
        }
        if (this.sendPointerEvent(manipEvent)) {
            event.stopPropagation();
        }
        event.preventDefault();
    }
    onDoubleClick(event) {
        const consumed = this.sendTriggerEvent(this.createManipTriggerEvent(event, "double-click"));
        if (consumed) {
            event.preventDefault();
        }
    }
    onContextMenu(event) {
        this.sendTriggerEvent(this.createManipTriggerEvent(event, "context-menu"));
        // prevent default context menu regardless of whether event was consumed or not
        event.preventDefault();
    }
    onWheel(event) {
        const consumed = this.sendTriggerEvent(this.createManipTriggerEvent(event, "wheel"));
        if (consumed) {
            event.preventDefault();
        }
    }
    createManipPointerEvent(event, type) {
        // calculate center and movement
        let centerX = 0;
        let centerY = 0;
        let localX = 0;
        let localY = 0;
        let movementX = 0;
        let movementY = 0;
        const positions = this.activePositions;
        const count = positions.length;
        if (count > 0) {
            for (let i = 0; i < count; ++i) {
                centerX += positions[i].clientX;
                centerY += positions[i].clientY;
            }
            centerX /= count;
            centerY /= count;
            if (type === "pointer-move" || type === "pointer-hover") {
                movementX = centerX - this.centerX;
                movementY = centerY - this.centerY;
            }
            this.centerX = centerX;
            this.centerY = centerY;
        }
        else {
            centerX = this.centerX;
            centerY = this.centerY;
        }
        const element = event.currentTarget;
        if (element instanceof Element) {
            const rect = element.getBoundingClientRect();
            localX = event.clientX - rect.left;
            localY = event.clientY - rect.top;
        }
        return {
            originalEvent: event,
            type: type,
            source: event.pointerType,
            isPrimary: event.isPrimary,
            isDragging: this.isDragging,
            activePositions: positions,
            pointerCount: count,
            centerX,
            centerY,
            localX,
            localY,
            movementX,
            movementY,
            shiftKey: event.shiftKey,
            ctrlKey: event.ctrlKey,
            altKey: event.altKey,
            metaKey: event.metaKey
        };
    }
    createManipTriggerEvent(event, type) {
        let wheel = 0;
        if (type === "wheel") {
            wheel = event.deltaY;
        }
        let localX = 0;
        let localY = 0;
        const element = event.currentTarget;
        if (element instanceof Element) {
            const rect = element.getBoundingClientRect();
            localX = event.clientX - rect.left;
            localY = event.clientY - rect.top;
        }
        return {
            originalEvent: event,
            type,
            wheel,
            centerX: event.clientX,
            centerY: event.clientY,
            localX,
            localY,
            shiftKey: event.shiftKey,
            ctrlKey: event.ctrlKey,
            altKey: event.altKey,
            metaKey: event.metaKey
        };
    }
    sendPointerEvent(event) {
        return this.next && this.next.onPointer(event);
    }
    sendTriggerEvent(event) {
        return this.next && this.next.onTrigger(event);
    }
}


/***/ }),

/***/ "../../libs/ff-browser/source/download.ts":
/*!****************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-browser/source/download.ts ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * FF Typescript Foundation Library
 * Copyright 2021 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
const _triggerDownload = function (dataURL, fileName) {
    const link = document.createElement("a");
    link.download = fileName;
    link.href = dataURL;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
};
/* harmony default export */ __webpack_exports__["default"] = ({
    /**
     * Prompts the user to download the provided text content as a file.
     * @param text text string to include.
     * @param fileName name of the downloadable file.
     */
    text: function (text, fileName) {
        const dataURL = window.URL.createObjectURL(new Blob([text], { type: "text/plain" }));
        _triggerDownload(dataURL, fileName);
    },
    /**
     * Prompts the user to download the provided JSON content as a file.
     * @param json JSON data to include.
     * @param fileName name of the downloadable file.
     */
    json: function (json, fileName) {
        if (typeof json === "object") {
            json = JSON.stringify(json);
        }
        const dataURL = window.URL.createObjectURL(new Blob([json], { type: "text/json" }));
        _triggerDownload(dataURL, fileName);
    },
    /**
     * Prompts the user to download the content from the given URL.
     * @param url URL of the content to be downloaded.
     * @param fileName name of the downloadable file.
     */
    url: function (url, fileName) {
        _triggerDownload(url, fileName);
    }
});


/***/ }),

/***/ "../../libs/ff-browser/source/fetch.ts":
/*!*************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-browser/source/fetch.ts ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * FF Typescript Foundation Library
 * Copyright 2021 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* harmony default export */ __webpack_exports__["default"] = ({
    json: function (url, method, data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (data && typeof data !== "string") {
                data = JSON.stringify(data);
            }
            const params = {
                headers: {
                    "Accept": "application/json",
                    "Content-Type": "application/json",
                },
                method: method,
                credentials: "same-origin",
                body: data
            };
            return fetch(url, params).then(result => {
                if (!result.ok) {
                    const message = `fetch.json (${method} at '${url}'), error: ${result.status} - ${result.statusText}`;
                    console.warn(message);
                    throw new Error(message);
                }
                return result.json();
            }).catch(error => {
                console.warn(`fetch.json (${method} at '${url}'), error: ${error.message}`);
                throw error;
            });
        });
    },
    text: function (url, method, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = {
                headers: {
                    "Accept": "text/plain",
                    "Content-Type": "text/plain",
                },
                method: method,
                credentials: "same-origin",
                body: data
            };
            return fetch(url, params).then(result => {
                if (!result.ok) {
                    throw new Error(`status: ${result.status}`);
                }
                return result.text();
            }).catch(error => {
                console.warn(`fetch.text (${method} at '${url}'), error: ${error.message}`);
                throw error;
            });
        });
    },
    file: function (url, method, file, detectType = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = {
                method,
                credentials: "include",
                body: file
            };
            if (!detectType) {
                params.headers = {
                    "Content-Type": "application/octet-stream"
                };
            }
            return fetch(url, params).then(result => {
                if (!result.ok) {
                    throw new Error(`status: ${result.status}`);
                }
                return result;
            }).catch(error => {
                console.warn(`fetch.file (${method} at '${url}'), error: ${error.message}`);
                throw error;
            });
        });
    },
    buffer: function (url, method, buffer) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = {
                headers: {
                    "Accept": "application/octet-stream",
                    "Content-Type": "application/octet-stream"
                },
                method,
                credentials: "include",
                body: buffer
            };
            return fetch(url, params).then(result => {
                if (!result.ok) {
                    throw new Error(`status: ${result.status}`);
                }
                return result.arrayBuffer();
            }).catch(error => {
                console.warn(`fetch.buffer (${method} at '${url}'), error: ${error.message}`);
                throw error;
            });
        });
    }
});


/***/ }),

/***/ "../../libs/ff-browser/source/parseUrlParameter.ts":
/*!*************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-browser/source/parseUrlParameter.ts ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * FF Typescript Foundation Library
 * Copyright 2021 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
/**
 * Returns the value of the variable in the URL query string with the given name.
 * Source: https://stackoverflow.com/questions/901115
 * @param {string} name Name of the variable to look for.
 * @param {string} url URL to search. If omitted, the browser's current location is used.
 * @returns {any} undefined if not found, "" if empty, string value of variable otherwise
 */
/* harmony default export */ __webpack_exports__["default"] = (function (name, url) {
    if (!url) {
        url = window.location.href;
    }
    name = name.replace(/[\[\]]/g, '\\$&');
    const regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)');
    const results = regex.exec(url);
    if (!results) {
        return undefined;
    }
    if (!results[2]) {
        return "";
    }
    return decodeURIComponent(results[2].replace(/\+/g, ' '));
});


/***/ }),

/***/ "../../libs/ff-core/source/Color.ts":
/*!**********************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-core/source/Color.ts ***!
  \**********************************************************/
/*! exports provided: Vector3, Vector4, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Color; });
/* harmony import */ var _Vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3 */ "../../libs/ff-core/source/Vector3.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Vector3", function() { return _Vector3__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _Vector4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector4 */ "../../libs/ff-core/source/Vector4.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Vector4", function() { return _Vector4__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */


////////////////////////////////////////////////////////////////////////////////

/**
 * RGB color with alpha channel. The class is compatible with Vector4,
 * the field names for the colors are x (red), y (green), z (blue), and w (alpha).
 *
 * Source for RGB/HSL/HSV conversions: https://gist.github.com/mjackson/5311256
 */
class Color {
    constructor(red = 0, green = 0, blue = 0, alpha = 1) {
        if (red instanceof Color) {
            this.x = red.x;
            this.y = red.y;
            this.z = red.z;
            this.w = red.w;
        }
        else if (Array.isArray(red)) {
            this.x = red[0] || 0;
            this.y = red[1] || 0;
            this.z = red[2] || 0;
            this.w = red[3] !== undefined ? red[3] : 1;
        }
        else if (typeof red === "string") {
            this.setString(red);
        }
        else {
            this.x = red;
            this.y = green;
            this.z = blue;
            this.w = alpha;
        }
    }
    static fromString(color) {
        return (new Color()).setString(color);
    }
    static fromArray(color) {
        return new Color(color);
    }
    get r() { return this.x; }
    get g() { return this.y; }
    get b() { return this.z; }
    get a() { return this.w; }
    set r(value) { this.x = value; }
    set g(value) { this.y = value; }
    set b(value) { this.z = value; }
    set a(value) { this.w = value; }
    get red() { return this.x; }
    get green() { return this.y; }
    get blue() { return this.z; }
    get alpha() { return this.w; }
    set red(value) { this.x = value; }
    set green(value) { this.y = value; }
    set blue(value) { this.z = value; }
    set alpha(value) { this.w = value; }
    get redByte() { return Math.floor(this.x * 255); }
    get greenByte() { return Math.floor(this.y * 255); }
    get blueByte() { return Math.floor(this.z * 255); }
    get alphaByte() { return Math.floor(this.w * 255); }
    set redByte(value) { this.x = value / 255.0; }
    set greenByte(value) { this.y = value / 255.0; }
    set blueByte(value) { this.z = value / 255.0; }
    set alphaByte(value) { this.w = value / 255.0; }
    inverseMultiply(factor) {
        this.x = this.x * (1 - factor) + factor;
        this.y = this.y * (1 - factor) + factor;
        this.z = this.z * (1 - factor) + factor;
        return this;
    }
    multiply(factor) {
        this.x *= factor;
        this.y *= factor;
        this.z *= factor;
        return this;
    }
    copy(color) {
        this.x = color.x;
        this.y = color.y;
        this.z = color.z;
        this.w = color.w;
    }
    clone() {
        return new Color(this.x, this.y, this.z, this.w);
    }
    set(red, green, blue, alpha) {
        this.x = red;
        this.y = green;
        this.z = blue;
        this.w = alpha === undefined ? 1 : alpha;
        return this;
    }
    setBytes(red, green, blue, alpha) {
        this.x = red / 255;
        this.y = green / 255;
        this.z = blue / 255;
        this.w = alpha === undefined ? 1 : alpha / 255;
        return this;
    }
    setUInt24RGB(x) {
        this.x = (x >> 16) & 0xff;
        this.y = (x >> 8) & 0xff;
        this.z = x & 0xff;
        this.w = 1;
        return this;
    }
    setUInt32RGBA(x) {
        this.x = (x >> 24) & 0xff;
        this.y = (x >> 16) & 0xff;
        this.z = (x >> 8) & 0xff;
        this.w = x & 0xff;
        this.w = 1;
        return this;
    }
    setRed(red) {
        this.x = red;
        return this;
    }
    setGreen(green) {
        this.y = green;
        return this;
    }
    setBlue(blue) {
        this.z = blue;
        return this;
    }
    setAlpha(alpha) {
        this.w = alpha;
        return this;
    }
    setRedByte(red) {
        this.x = red / 255;
        return this;
    }
    setGreenByte(green) {
        this.y = green / 255;
        return this;
    }
    setBlueByte(blue) {
        this.z = blue / 255;
        return this;
    }
    setAlphaByte(alpha) {
        this.w = alpha / 255;
        return this;
    }
    setHSV(hue, saturation = 1, value = 1, alpha) {
        if (typeof hue === "object") {
            saturation = hue.y;
            value = hue.z;
            alpha = hue["w"] !== undefined ? hue["w"] : alpha;
            hue = hue.x;
        }
        const i = Math.floor(hue / 60);
        const f = hue / 60 - i;
        const p = value * (1 - saturation);
        const q = value * (1 - f * saturation);
        const t = value * (1 - (1 - f) * saturation);
        let r, g, b;
        switch (i % 6) {
            case 0:
                r = value;
                g = t;
                b = p;
                break;
            case 1:
                r = q;
                g = value;
                b = p;
                break;
            case 2:
                r = p;
                g = value;
                b = t;
                break;
            case 3:
                r = p;
                g = q;
                b = value;
                break;
            case 4:
                r = t;
                g = p;
                b = value;
                break;
            case 5:
                r = value;
                g = p;
                b = q;
                break;
        }
        this.x = r;
        this.y = g;
        this.z = b;
        if (alpha !== undefined) {
            this.w = alpha;
        }
        return this;
    }
    setHSL(hue, saturation = 1, luminance = 1, alpha) {
        if (typeof hue === "object") {
            saturation = hue.y;
            luminance = hue.z;
            alpha = hue["w"] !== undefined ? hue["w"] : alpha;
            hue = hue.x;
        }
        if (saturation === 0) {
            this.x = this.y = this.z = luminance;
        }
        else {
            hue /= 360;
            function hue2rgb(p, q, t) {
                if (t < 0)
                    t += 1;
                if (t > 1)
                    t -= 1;
                if (t < 1 / 6)
                    return p + (q - p) * 6 * t;
                if (t < 1 / 2)
                    return q;
                if (t < 2 / 3)
                    return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            }
            var q = luminance < 0.5 ? luminance * (1 + saturation) : luminance + saturation - luminance * saturation;
            var p = 2 * luminance - q;
            this.x = hue2rgb(p, q, hue + 1 / 3);
            this.y = hue2rgb(p, q, hue);
            this.z = hue2rgb(p, q, hue - 1 / 3);
        }
        if (alpha !== undefined) {
            this.w = alpha;
        }
        return this;
    }
    fromArray(arr) {
        this.x = arr[0] || 0;
        this.y = arr[1] || 0;
        this.z = arr[2] || 0;
        this.w = arr[3] !== undefined ? arr[3] : 1;
    }
    setString(color, alpha = 1, throws = true) {
        color = color.trim().toLowerCase();
        color = Color.presets[color] || color;
        let result = color.match(/^#?([0-9a-f]{3})$/i);
        if (result) {
            const text = result[1];
            const factor = 1 / 15;
            this.x = Number.parseInt(text.charAt(0), 16) * factor;
            this.y = Number.parseInt(text.charAt(1), 16) * factor;
            this.z = Number.parseInt(text.charAt(2), 16) * factor;
            this.w = alpha;
            return this;
        }
        result = color.match(/^#?([0-9a-f]{6})$/i);
        if (result) {
            const text = result[1];
            const factor = 1 / 255;
            this.x = Number.parseInt(text.substr(0, 2), 16) * factor;
            this.y = Number.parseInt(text.substr(2, 2), 16) * factor;
            this.z = Number.parseInt(text.substr(4, 2), 16) * factor;
            this.w = alpha;
            return this;
        }
        if (color.indexOf("rgb") === 0) {
            let result = color.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i);
            if (result) {
                const factor = 1 / 255;
                this.x = Number.parseInt(result[1]) * factor;
                this.y = Number.parseInt(result[2]) * factor;
                this.z = Number.parseInt(result[3]) * factor;
                this.w = alpha;
                return this;
            }
            result = color.match(/^rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+.*\d*)\s*\)$/i);
            if (result) {
                const factor = 1 / 255;
                this.x = Number.parseInt(result[1]) * factor;
                this.y = Number.parseInt(result[2]) * factor;
                this.z = Number.parseInt(result[3]) * factor;
                this.w = Number.parseFloat(result[4]);
                return this;
            }
        }
        if (color.indexOf("hsl") === 0) {
            let result = color.match(/(\d+(\.\d+)?)/g);
            if (result) {
                this.setHSL(Number.parseFloat(result[0]), Number.parseFloat(result[1]) * 0.01, Number.parseFloat(result[2]) * 0.01, result[3] !== undefined ? Number.parseFloat(result[3]) : alpha);
            }
            return this;
        }
        if (throws) {
            throw new RangeError("failed to parse color from string: " + color);
        }
        return this;
    }
    toUInt24RGB() {
        return Math.floor(this.x * 255) << 16
            + Math.floor(this.y * 255) << 8
            + Math.floor(this.z * 255);
    }
    toUInt32RGBA() {
        return Math.floor(this.x * 255) << 24
            + Math.floor(this.y * 255) << 16
            + Math.floor(this.z * 255) << 8
            + Math.floor(this.w * 255);
    }
    toVector3(rgb) {
        if (rgb) {
            rgb.x = this.r;
            rgb.y = this.g;
            rgb.z = this.b;
            return rgb;
        }
        return new _Vector3__WEBPACK_IMPORTED_MODULE_0__["default"](this.r, this.g, this.b);
    }
    toVector4(rgba) {
        if (rgba) {
            rgba.x = this.r;
            rgba.y = this.g;
            rgba.z = this.b;
            rgba.w = this.a;
            return rgba;
        }
        return new _Vector4__WEBPACK_IMPORTED_MODULE_1__["default"](this.r, this.g, this.b, this.a);
    }
    toHSV(hsv) {
        let r = this.x, g = this.y, b = this.z;
        let min = Math.min(r, g, b);
        let max = Math.max(r, g, b);
        let d = max - min;
        let h = 0;
        let s = max === 0 ? 0 : d / max;
        let v = max;
        if (d !== 0) {
            h = (r === max ? (g - b) / d + (g < b ? 6 : 0) : (g === max ? (b - r) / d + 2 : (r - g) / d + 4)) * 60;
        }
        if (hsv) {
            hsv.x = h;
            hsv.y = s;
            hsv.z = v;
            return hsv;
        }
        return new _Vector3__WEBPACK_IMPORTED_MODULE_0__["default"](h, s, v);
    }
    toHSL(hsl) {
        let r = this.x, g = this.y, b = this.z;
        let min = Math.min(r, g, b);
        let max = Math.max(r, g, b);
        let d = max - min;
        let h = 0, s = 0, l = (max + min) * 0.5;
        if (d !== 0) {
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            h = (r === max ? (g - b) / d + (g < b ? 6 : 0) : g === max ? 2 + (b - r) / d : 4 + (r - g) / d) * 60;
        }
        if (hsl) {
            hsl.x = h;
            hsl.y = s;
            hsl.z = l;
            return hsl;
        }
        return new _Vector3__WEBPACK_IMPORTED_MODULE_0__["default"](h, s, l);
    }
    toRGBArray(arr) {
        if (arr) {
            arr[0] = this.r;
            arr[1] = this.g;
            arr[2] = this.b;
            return arr;
        }
        return [this.r, this.g, this.b];
    }
    toRGBAArray(arr) {
        if (arr) {
            arr[0] = this.r;
            arr[1] = this.g;
            arr[2] = this.b;
            arr[3] = this.a;
            return arr;
        }
        return [this.r, this.g, this.b, this.a];
    }
    toString(includeAlpha = true) {
        if (includeAlpha && this.w < 1) {
            return `rgba(${this.redByte}, ${this.greenByte}, ${this.blueByte}, ${this.w})`;
        }
        else {
            const value = (1 << 24) + (this.redByte << 16) + (this.greenByte << 8) + this.blueByte;
            return `#${value.toString(16).slice(1)}`;
        }
    }
}
Color.presets = {
    "aliceblue": "#f0f8ff",
    "antiquewhite": "#faebd7",
    "aqua": "#00ffff",
    "aquamarine": "#7fffd4",
    "azure": "#f0ffff",
    "beige": "#f5f5dc",
    "bisque": "#ffe4c4",
    "black": "#000000",
    "blanchedalmond": "#ffebcd",
    "blue": "#0000ff",
    "blueviolet": "#8a2be2",
    "brown": "#a52a2a",
    "burlywood": "#deb887",
    "cadetblue": "#5f9ea0",
    "chartreuse": "#7fff00",
    "chocolate": "#d2691e",
    "coral": "#ff7f50",
    "cornflowerblue": "#6495ed",
    "cornsilk": "#fff8dc",
    "crimson": "#dc143c",
    "cyan": "#00ffff",
    "darkblue": "#00008b",
    "darkcyan": "#008b8b",
    "darkgoldenrod": "#b8860b",
    "darkgray": "#a9a9a9",
    "darkgrey": "#a9a9a9",
    "darkgreen": "#006400",
    "darkkhaki": "#bdb76b",
    "darkmagenta": "#8b008b",
    "darkolivegreen": "#556b2f",
    "darkorange": "#ff8c00",
    "darkorchid": "#9932cc",
    "darkred": "#8b0000",
    "darksalmon": "#e9967a",
    "darkseagreen": "#8fbc8f",
    "darkslateblue": "#483d8b",
    "darkslategray": "#2f4f4f",
    "darkslategrey": "#2f4f4f",
    "darkturquoise": "#00ced1",
    "darkviolet": "#9400d3",
    "deeppink": "#ff1493",
    "deepskyblue": "#00bfff",
    "dimgray": "#696969",
    "dimgrey": "#696969",
    "dodgerblue": "#1e90ff",
    "firebrick": "#b22222",
    "floralwhite": "#fffaf0",
    "forestgreen": "#228b22",
    "fuchsia": "#ff00ff",
    "gainsboro": "#dcdcdc",
    "ghostwhite": "#f8f8ff",
    "gold": "#ffd700",
    "goldenrod": "#daa520",
    "gray": "#808080",
    "grey": "#808080",
    "green": "#008000",
    "greenyellow": "#adff2f",
    "honeydew": "#f0fff0",
    "hotpink": "#ff69b4",
    "indianred": "#cd5c5c",
    "indigo": "#4b0082",
    "ivory": "#fffff0",
    "khaki": "#f0e68c",
    "lavender": "#e6e6fa",
    "lavenderblush": "#fff0f5",
    "lawngreen": "#7cfc00",
    "lemonchiffon": "#fffacd",
    "lightblue": "#add8e6",
    "lightcoral": "#f08080",
    "lightcyan": "#e0ffff",
    "lightgoldenrodyellow": "#fafad2",
    "lightgray": "#d3d3d3",
    "lightgrey": "#d3d3d3",
    "lightgreen": "#90ee90",
    "lightpink": "#ffb6c1",
    "lightsalmon": "#ffa07a",
    "lightseagreen": "#20b2aa",
    "lightskyblue": "#87cefa",
    "lightslategray": "#778899",
    "lightslategrey": "#778899",
    "lightsteelblue": "#b0c4de",
    "lightyellow": "#ffffe0",
    "lime": "#00ff00",
    "limegreen": "#32cd32",
    "linen": "#faf0e6",
    "magenta": "#ff00ff",
    "maroon": "#800000",
    "mediumaquamarine": "#66cdaa",
    "mediumblue": "#0000cd",
    "mediumorchid": "#ba55d3",
    "mediumpurple": "#9370db",
    "mediumseagreen": "#3cb371",
    "mediumslateblue": "#7b68ee",
    "mediumspringgreen": "#00fa9a",
    "mediumturquoise": "#48d1cc",
    "mediumvioletred": "#c71585",
    "midnightblue": "#191970",
    "mintcream": "#f5fffa",
    "mistyrose": "#ffe4e1",
    "moccasin": "#ffe4b5",
    "navajowhite": "#ffdead",
    "navy": "#000080",
    "oldlace": "#fdf5e6",
    "olive": "#808000",
    "olivedrab": "#6b8e23",
    "orange": "#ffa500",
    "orangered": "#ff4500",
    "orchid": "#da70d6",
    "palegoldenrod": "#eee8aa",
    "palegreen": "#98fb98",
    "paleturquoise": "#afeeee",
    "palevioletred": "#db7093",
    "papayawhip": "#ffefd5",
    "peachpuff": "#ffdab9",
    "peru": "#cd853f",
    "pink": "#ffc0cb",
    "plum": "#dda0dd",
    "powderblue": "#b0e0e6",
    "purple": "#800080",
    "rebeccapurple": "#663399",
    "red": "#ff0000",
    "rosybrown": "#bc8f8f",
    "royalblue": "#4169e1",
    "saddlebrown": "#8b4513",
    "salmon": "#fa8072",
    "sandybrown": "#f4a460",
    "seagreen": "#2e8b57",
    "seashell": "#fff5ee",
    "sienna": "#a0522d",
    "silver": "#c0c0c0",
    "skyblue": "#87ceeb",
    "slateblue": "#6a5acd",
    "slategray": "#708090",
    "slategrey": "#708090",
    "snow": "#fffafa",
    "springgreen": "#00ff7f",
    "steelblue": "#4682b4",
    "tan": "#d2b48c",
    "teal": "#008080",
    "thistle": "#d8bfd8",
    "tomato": "#ff6347",
    "turquoise": "#40e0d0",
    "violet": "#ee82ee",
    "wheat": "#f5deb3",
    "white": "#ffffff",
    "whitesmoke": "#f5f5f5",
    "yellow": "#ffff00",
    "yellowgreen": "#9acd32"
};


/***/ }),

/***/ "../../libs/ff-core/source/Command.ts":
/*!************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-core/source/Command.ts ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Command; });
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text */ "../../libs/ff-core/source/text.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */

class Command {
    constructor(args, props) {
        this._args = args;
        this._props = props;
        this._args = args;
        this._state = null;
    }
    get name() {
        return this._props.name || Object(_text__WEBPACK_IMPORTED_MODULE_0__["normalize"])(this._props.do.name);
    }
    do() {
        if (this._state) {
            throw new Error("undo should be called before execute can be applied again");
        }
        this._state = this._props.do.apply(this._props.target, this._args);
    }
    undo() {
        if (!this._props.undo) {
            throw new Error("can't undo this command");
        }
        if (!this._state) {
            throw new Error("execute should be called before undo can be applied");
        }
        this._props.undo.call(this._props.target, this._state);
        this._state = null;
    }
    canDo() {
        return this._props.canDo ? this._props.canDo() : true;
    }
    canUndo() {
        return !!this._props.undo;
    }
}


/***/ }),

/***/ "../../libs/ff-core/source/Commander.ts":
/*!**************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-core/source/Commander.ts ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Commander; });
/* harmony import */ var _Publisher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Publisher */ "../../libs/ff-core/source/Publisher.ts");
/* harmony import */ var _Command__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Command */ "../../libs/ff-core/source/Command.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */


class Commander extends _Publisher__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(capacity) {
        super();
        this.addEvent("update");
        this.stack = [];
        this.pointer = -1;
        this.capacity = capacity !== undefined ? capacity : Commander.defaultCapacity;
    }
    register(propsOrFactory) {
        let factory;
        if (typeof propsOrFactory === "function") {
            factory = propsOrFactory;
        }
        else {
            factory = (args) => new _Command__WEBPACK_IMPORTED_MODULE_1__["default"](args, propsOrFactory);
        }
        const action = (...args) => {
            const command = factory(args);
            this.do(command);
        };
        return action;
    }
    setCapacity(capacity) {
        this.capacity = capacity;
        while (this.stack.length > capacity) {
            this.stack.shift();
            this.pointer--;
        }
        if (this.pointer < 0) {
            this.stack = [];
            this.pointer = -1;
        }
    }
    do(command) {
        console.log(`Commander.do - '${command.name}'`);
        command.do();
        if (command.canUndo()) {
            this.stack.splice(this.pointer + 1);
            this.stack.push(command);
            if (this.stack.length > this.capacity) {
                this.stack.shift();
            }
            this.pointer = this.stack.length - 1;
            this.emit("update");
        }
    }
    undo() {
        if (this.pointer >= 0) {
            const command = this.stack[this.pointer];
            command.undo();
            this.pointer--;
            this.emit("update");
        }
    }
    redo() {
        if (this.pointer < this.stack.length - 1) {
            this.pointer++;
            const command = this.stack[this.pointer];
            command.do();
            this.emit("update");
        }
    }
    clear() {
        if (this.stack.length > 0) {
            this.stack = [];
            this.pointer = -1;
            this.emit("update");
        }
    }
    canUndo() {
        return this.pointer >= 0;
    }
    canRedo() {
        return this.pointer < this.stack.length - 1;
    }
    getUndoText() {
        if (this.pointer >= 0) {
            return "Undo " + this.stack[this.pointer].name;
        }
        return "Can't Undo";
    }
    getRedoText() {
        if (this.pointer < this.stack.length - 1) {
            return "Redo " + this.stack[this.pointer + 1].name;
        }
        return "Can't Redo";
    }
}
Commander.defaultCapacity = 30;


/***/ }),

/***/ "../../libs/ff-core/source/Document.ts":
/*!*************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-core/source/Document.ts ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Document; });
/* harmony import */ var _Publisher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Publisher */ "../../libs/ff-core/source/Publisher.ts");
/* harmony import */ var _uniqueId__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./uniqueId */ "../../libs/ff-core/source/uniqueId.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */


class Document extends _Publisher__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(json) {
        super();
        this.addEvents("update", "dispose");
        if (json) {
            this.fromJSON(json);
        }
        else {
            this._data = this.init();
        }
    }
    static generateId() {
        return Object(_uniqueId__WEBPACK_IMPORTED_MODULE_1__["default"])();
    }
    get id() {
        return this._data["id"];
    }
    get data() {
        return this._data;
    }
    set(key, value) {
        this._data[key] = value;
        this.update();
    }
    get(key) {
        return this._data[key];
    }
    update() {
        this.emit({ type: "update", document: this });
    }
    dispose() {
        this.emit({ type: "dispose", document: this });
        this._data = null;
    }
    fromJSON(json) {
        this._data = {};
        this.inflate(json, this._data);
        this.update();
        return this;
    }
    toJSON(json) {
        json = json || {};
        this.deflate(this._data, json);
        return json;
    }
    init() {
        return {};
    }
    inflate(json, data) {
        Object.assign(data, json);
    }
    deflate(data, json) {
        json = json || {};
        Object.assign(json, this._data);
    }
}


/***/ }),

/***/ "../../libs/ff-core/source/ObjectRegistry.ts":
/*!*******************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-core/source/ObjectRegistry.ts ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ObjectRegistry; });
/* harmony import */ var _Publisher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Publisher */ "../../libs/ff-core/source/Publisher.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */

////////////////////////////////////////////////////////////////////////////////
const _EMPTY_ARRAY = [];
/**
 * Registry of object instances, grouped by their classes and base classes.
 */
class ObjectRegistry extends _Publisher__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(rootType) {
        super({ knownEvents: false });
        const typeName = rootType.typeName;
        if (!typeName) {
            throw new Error("root type must have a 'typeName' member");
        }
        this._rootTypeName = typeName;
        this._objLists = { [this._rootTypeName]: [] };
        this._objTags = {};
        this._objDict = {};
    }
    static getTypeName(scope) {
        return typeof scope === "function" ? scope.typeName : (typeof scope === "object"
            ? scope.constructor.typeName : scope);
    }
    ;
    /**
     * Adds an object to the registry. The object is registered under its actual class
     * and all base classes in its prototype chain. An [[IObjectEvent]] is emitted
     * for each class in the object's prototype chain.
     * @param object
     */
    add(object) {
        const id = object.id;
        if (typeof id === "string") {
            if (this._objDict[id] !== undefined) {
                throw new Error("object already registered");
            }
            // add component to id dictionary
            this._objDict[id] = object;
        }
        let prototype = object;
        let typeName;
        const rootTypeName = this._rootTypeName;
        const event = { type: "", add: true, remove: false, object };
        // add all types in prototype chain
        do {
            prototype = Object.getPrototypeOf(prototype);
            typeName = prototype.constructor.typeName;
            if (typeName) {
                (this._objLists[typeName] || (this._objLists[typeName] = [])).push(object);
                event.type = typeName;
                this.emit(event);
            }
        } while (typeName !== rootTypeName);
    }
    /**
     * Removes an object from the registry.
     * @param object
     */
    remove(object) {
        const id = object.id;
        if (typeof id === "string") {
            if (this._objDict[id] !== object) {
                throw new Error("object not registered");
            }
            // remove component
            delete this._objDict[id];
        }
        let prototype = object;
        let typeName;
        const rootTypeName = this._rootTypeName;
        const event = { type: "", add: false, remove: true, object };
        // remove all types in prototype chain
        do {
            prototype = Object.getPrototypeOf(prototype);
            typeName = prototype.constructor.typeName;
            if (typeName) {
                event.type = typeName;
                this.emit(event);
                const objects = this._objLists[typeName];
                objects.splice(objects.indexOf(object), 1);
            }
        } while (typeName !== rootTypeName);
    }
    /**
     * Registers an object with a given tag.
     * @param tag The tag name. Valid tag names are all non-empty strings except "tag".
     * @param object
     */
    addByTag(tag, object) {
        if (!tag || tag === "tag") {
            throw new Error("illegal tag name");
        }
        const list = this._objTags[tag] || (this._objTags[tag] = []);
        list.push(object);
        const event = { type: "tag", add: true, remove: false, object, tag };
        this.emit(event);
        event.type = tag;
        this.emit(event);
    }
    /**
     * Unregisters an object with a given tag.
     * @param tag The tag name. Valid tag names are all non-empty strings except "tag".
     * @param object
     */
    removeByTag(tag, object) {
        if (!tag || tag === "tag") {
            throw new Error("illegal tag name");
        }
        const list = this._objTags[tag];
        if (list) {
            const index = list.indexOf(object);
            if (index >= 0) {
                const event = { type: "tag", add: false, remove: true, object, tag };
                this.emit(event);
                event.type = tag;
                this.emit(event);
                list.splice(index, 1);
                return true;
            }
        }
        return false;
    }
    /**
     * Removes all objects from the registry.
     */
    clear() {
        const objects = this.cloneArray();
        objects.forEach(object => this.remove(object));
    }
    /**
     * Returns the total number of objects in the registry.
     */
    get length() {
        return this._objLists[this._rootTypeName].length;
    }
    /**
     * Returns the number of objects (of a certain class or class name if given) in the registry.
     * @param scope Optional class or class name whose instances should be counted.
     */
    count(scope) {
        const objects = this._objLists[this.getTypeName(scope)];
        return objects ? objects.length : 0;
    }
    /**
     * Returns true if the registry contains objects (of a given class or class name) or the given instance.
     * @param scope A class, class name, or an instance of a class.
     */
    has(scope) {
        // scope is a constructor function
        if (typeof scope === "function") {
            const objects = this._objLists[scope.typeName];
            return !!objects && objects.length > 0;
        }
        // scope is a string, i.e. a type name
        if (typeof scope === "string") {
            const objects = this._objLists[scope];
            return !!objects && objects.length > 0;
        }
        // scope is an object, search by its type name
        const objects = this._objLists[scope.constructor.typeName];
        return objects && objects.indexOf(scope) >= 0;
    }
    /**
     * Returns true if the registry contains the given object.
     * @param object
     */
    contains(object) {
        const id = object.id;
        if (typeof id === "string") {
            return !!this._objDict[id];
        }
        const objects = this._objLists[object.constructor.typeName];
        return objects && objects.indexOf(object) >= 0;
    }
    /**
     * Returns the first found instance of the given class or class name.
     * @param scope Class or class name of the instance to return.
     * @param nothrow If true, the method returns undefined if no instance was found.
     * By default, an error is thrown uf no instance is registered with the given class/class name.
     */
    get(scope, nothrow = false) {
        const className = this.getTypeName(scope);
        const objects = this._objLists[className];
        const object = objects ? objects[0] : undefined;
        if (!nothrow && !object) {
            throw new Error(`no instances of class '${className}' in object registry`);
        }
        return object;
    }
    /**
     * Returns an array with all instances of the given class or class name.
     * This is a live array, it should not be kept or modified. If you need
     * a storable/editable array, use [[ObjectRegistry.cloneArray]] instead.
     * @param scope Class or class name of the instances to return.
     */
    getArray(scope) {
        return this._objLists[this.getTypeName(scope)] || _EMPTY_ARRAY;
    }
    /**
     * Returns a cloned array with all instances of the given class or class name.
     * @param scope Class or class name of the instances to return.
     */
    cloneArray(scope) {
        return this.getArray(scope).slice();
    }
    /**
     * Returns an object by its id.
     * @param id An object's id.
     */
    getById(id) {
        return this._objDict[id];
    }
    /**
     * Returns a dictionary with all objects in the registry accessible by their ids.
     * The dictionary only contains objects with an 'id' property.
     */
    getDictionary() {
        return this._objDict;
    }
    getByTag(tag) {
        return this._objTags[tag] || _EMPTY_ARRAY;
    }
    /**
     * Adds a listener for an object add/remove event.
     * @param scope Type, type instance, or type name to subscribe to.
     * @param callback Callback function, invoked when the event is emitted.
     * @param context Optional: this context for the callback invocation.
     */
    on(scope, callback, context) {
        super.on(this.getTypeName(scope), callback, context);
    }
    /**
     * Adds a one-time listener for an object add/remove event.
     * @param scope Type, type instance, or type name to subscribe to.
     * @param callback Callback function, invoked when the event is emitted.
     * @param context Optional: this context for the callback invocation.
     */
    once(scope, callback, context) {
        super.once(this.getTypeName(scope), callback, context);
    }
    /**
     * Removes a listener for an object add/remove event.
     * @param scope Type, type instance, or type name to subscribe to.
     * @param callback Callback function, invoked when the event is emitted.
     * @param context Optional: this context for the callback invocation.
     */
    off(scope, callback, context) {
        super.off(this.getTypeName(scope), callback, context);
    }
    /**
     * Returns the type name for the given instance, type or name.
     * @param scope
     */
    getTypeName(scope) {
        return typeof scope === "function" ? scope.typeName : (typeof scope === "object"
            ? scope.constructor.typeName : (scope || this._rootTypeName));
    }
}


/***/ }),

/***/ "../../libs/ff-core/source/OrderedCollection.ts":
/*!**********************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-core/source/OrderedCollection.ts ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return OrderedCollection; });
/* harmony import */ var _Publisher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Publisher */ "../../libs/ff-core/source/Publisher.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */

/**
 * Container storing an ordered list of items. Items can be retrieved and manipulated by
 * id or by positional index. Internally, the collection is stored in both an array and
 * a dictionary.
 *
 * To make use of the dictionary functionality, items must provide an 'id' property with
 * a unique identifier.
 *
 * Updates to the collection are published via [[ICollectionUpdateEvent]] events.
 */
class OrderedCollection extends _Publisher__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(items) {
        super();
        this.addEvent("update");
        this._list = items || [];
        this._dict = {};
        items && items.forEach(item => {
            if (item.id) {
                this._dict[item.id] = item;
            }
        });
    }
    /**
     * Returns the number of items in the collection.
     */
    get length() {
        return this._list.length;
    }
    /**
     * Returns an unordered array with the ids of all collection items.
     */
    get ids() {
        return Object.keys(this._dict);
    }
    /**
     * Returns an ordered array with all collection items.
     */
    get items() {
        return this._list;
    }
    /**
     * Replaces the collection items with the given list.
     * @param items
     */
    set items(items) {
        this._list = items;
        this._dict = {};
        items.forEach(item => {
            if (item.id) {
                this._dict[item.id] = item;
            }
        });
        this.emit({ type: "update", item: null, what: "update" });
    }
    /**
     * Adds an item at the end of the collection.
     * @param item
     */
    append(item) {
        this._list.push(item);
        if (item.id) {
            this._dict[item.id] = item;
        }
        this.emit({ type: "update", item, what: "add" });
    }
    /**
     * Inserts an item in front of another one.
     * @param item
     * @param beforeItem
     */
    insertBefore(item, beforeItem) {
        const index = this._list.indexOf(beforeItem);
        if (index >= 0) {
            this.insertAt(item, index);
        }
    }
    /**
     * Inserts an item at a given position index.
     * @param item
     * @param index
     */
    insertAt(item, index) {
        this._list.splice(index, 0, item);
        if (item.id) {
            this._dict[item.id] = item;
        }
        this.emit({ type: "update", item, what: "add" });
    }
    /**
     * Replaces an item with another one.
     * @param item The new item.
     * @param replaceItem The item to be replaced.
     */
    replaceItem(item, replaceItem) {
        const index = this._list.indexOf(replaceItem);
        if (index >= 0) {
            this.replaceAt(item, index);
        }
    }
    /**
     * Replaces the item at the given index position with another one.
     * @param item
     * @param index
     */
    replaceAt(item, index) {
        const existing = this._list[index];
        if (existing.id) {
            delete this._dict[existing.id];
        }
        this._list[index] = item;
        if (item.id) {
            this._dict[item.id] = item;
        }
        this.emit({ type: "update", item, what: "replace" });
    }
    /**
     * Moves the item relative to its current position.
     * @param item The item to move.
     * @param relativeIndex The number of positions to move, positive = move towards end, negative = move towards start.
     */
    moveItem(item, relativeIndex) {
        const index = this._list.indexOf(item);
        this.moveAt(index, relativeIndex);
    }
    /**
     * Moves the item at the given index position relative to its current position.
     * @param index The index of the item to move.
     * @param relativeIndex The number of positions to move, positive = move towards end, negative = move towards start.
     */
    moveAt(index, relativeIndex) {
        const items = this._list;
        if (index + relativeIndex < 0 || index + relativeIndex >= items.length) {
            return;
        }
        const item = items[index];
        if (relativeIndex > 0) {
            for (let i = 0; i < relativeIndex; ++i) {
                items[index + i] = items[index + i + 1];
            }
            items[index + relativeIndex] = item;
        }
        else if (relativeIndex < 0) {
            for (let i = 0; i > relativeIndex; --i) {
                items[index + i] = items[index + i - 1];
            }
            items[index + relativeIndex] = item;
        }
        else {
            return;
        }
        this.emit({ type: "update", item, what: "move" });
    }
    /**
     * Removes an item by its id.
     * @param id
     * @returns the removed item.
     */
    removeById(id) {
        const item = this._dict[id];
        if (item) {
            this.removeItem(item);
        }
        return item;
    }
    /**
     * Removes the given item from the collection.
     * @param item
     * @returns the position index of the removed item.
     */
    removeItem(item) {
        const index = this._list.indexOf(item);
        this.removeAt(index);
        return index;
    }
    /**
     * Removes the item at the given index position from the collection.
     * @param index
     * @returns the removed item.
     */
    removeAt(index) {
        const items = this._list;
        if (index < 0 || index >= items.length) {
            return;
        }
        const item = items[index];
        items.splice(index, 1);
        if (item.id) {
            delete this._dict[item.id];
        }
        this.emit({ type: "update", item, what: "remove" });
        return item;
    }
    /**
     * Returns the item at the given index position.
     * @param index
     */
    getAt(index) {
        return this._list[index];
    }
    /**
     * Return an item by its id.
     * @param id
     */
    getById(id) {
        return this._dict[id];
    }
    /**
     * Returns the index position of the given item.
     * @param item
     */
    getIndexOf(item) {
        return this._list.indexOf(item);
    }
    /**
     * Replaces the collection items with a shallow copy of the given list.
     * @param list
     */
    copy(list) {
        this.items = list.slice();
    }
    /**
     * Returns a shallow copy of the internal item list.
     */
    clone() {
        return this._list.slice();
    }
}
OrderedCollection.prototype[Symbol.iterator] = function () {
    return {
        index: 0,
        list: this._list,
        next: function () {
            if (this.index < this.list.length) {
                return { value: this.list[this.index++], done: false };
            }
            else {
                return { done: true };
            }
        }
    };
};


/***/ }),

/***/ "../../libs/ff-core/source/Publisher.ts":
/*!**************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-core/source/Publisher.ts ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Publisher; });
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
const _pd = Symbol("Publisher private data");
const _strict = Symbol("Publisher strict option");
/**
 * Provides subscription services for events.
 */
class Publisher {
    constructor(options) {
        const knownEvents = options ? options.knownEvents : true;
        this[_pd] = { [_strict]: knownEvents };
    }
    on(type, callback, context) {
        if (Array.isArray(type)) {
            type.forEach(type => {
                this.on(type, callback, context);
            });
            return;
        }
        if (!callback) {
            throw new Error("missing callback function");
        }
        let subscribers = this[_pd][type];
        if (!subscribers) {
            if (this[_pd][_strict]) {
                throw new Error(`can't subscribe; unknown event: '${type}'`);
            }
            subscribers = this[_pd][type] = [];
        }
        let subscriber = { callback, context };
        subscribers.push(subscriber);
    }
    /**
     * Subscribes to an event. You may find using the .on() method more handy and more flexible.
     * @param type
     * @param callback
     * @param context
     */
    addEventListener(type, callback, context) {
        this.on(type, callback, context);
    }
    once(type, callback, context) {
        if (Array.isArray(type)) {
            type.forEach(type => {
                this.once(type, callback, context);
            });
            return;
        }
        const redirect = event => {
            this.off(type, redirect, context);
            callback.call(context, event);
        };
        redirect.cb = callback;
        this.on(type, redirect, context);
    }
    off(type, callback, context) {
        if (typeof type === "object") {
            if (Array.isArray(type)) {
                // if first parameter is an array, call function for all elements of the array
                type.forEach((type) => {
                    this.off(type, callback, context);
                });
            }
            else {
                // if first parameter is an object, unsubscribe all subscriptions where the context matches the object.
                const events = this[_pd];
                const types = Object.keys(events);
                for (let i = 0, ni = types.length; i < ni; ++i) {
                    const subscribers = events[type];
                    const remainingSubscribers = [];
                    for (let j = 0, nj = subscribers.length; j < nj; ++j) {
                        const subscriber = subscribers[j];
                        if (type && subscriber.context !== type) {
                            remainingSubscribers.push(subscriber);
                        }
                    }
                    events[type] = remainingSubscribers;
                }
            }
            return;
        }
        const subscribers = this[_pd][type];
        if (!subscribers) {
            throw new Error(`can't unsubscribe; unknown event type: '${type}'`);
        }
        const remainingSubscribers = [];
        for (let i = 0, n = subscribers.length; i < n; ++i) {
            const subscriber = subscribers[i];
            if ((callback && callback !== subscriber.callback && callback !== subscriber.callback.cb)
                || (context && context !== subscriber.context)) {
                remainingSubscribers.push(subscriber);
            }
        }
        this[_pd][type] = remainingSubscribers;
    }
    /**
     * Unsubscribes from an event. You may find using the .off() method more handy and more flexible.
     * @param type Type name of the event.
     * @param callback Callback function, invoked when the event is emitted.
     * @param context Optional: this context for the callback invocation.
     */
    removeEventListener(type, callback, context) {
        this.off(type, callback, context);
    }
    emit(eventOrType, message) {
        let type, payload;
        if (typeof eventOrType === "string") {
            type = eventOrType;
            payload = message;
        }
        else {
            type = eventOrType.type;
            payload = eventOrType;
        }
        if (!type) {
            throw new Error(`empty or invalid event type: '${type}'`);
        }
        const data = this[_pd];
        const subscribers = data[type];
        if (!subscribers) {
            if (data[_strict]) {
                throw new Error(`can't emit; unknown event type: '${type}'`);
            }
            return;
        }
        for (let i = 0, n = subscribers.length; i < n; ++i) {
            const subscriber = subscribers[i];
            if (subscriber.context) {
                subscriber.callback.call(subscriber.context, payload);
            }
            else {
                subscriber.callback(payload);
            }
        }
    }
    /**
     * Registers a new event type.
     * @param name Name of the event type.
     */
    addEvent(name) {
        if (!this[_pd][name]) {
            this[_pd][name] = [];
        }
    }
    /**
     * Registers multiple new event types.
     * @param names Names of the event types.
     */
    addEvents(...names) {
        names.forEach(name => {
            if (!this[_pd][name]) {
                this[_pd][name] = [];
            }
        });
    }
    /**
     * Tests whether an event type has been registered.
     * @param name Name of the event type.
     * @returns true if an event type with the given name has been added.
     */
    hasEvent(name) {
        return !!this[_pd][name];
    }
    /**
     * Lists all registered event types.
     * @returns an array with the names of all added event types.
     */
    listEvents() {
        return Object.getOwnPropertyNames(this[_pd]);
    }
}


/***/ }),

/***/ "../../libs/ff-core/source/Subscriber.ts":
/*!***************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-core/source/Subscriber.ts ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Subscriber; });
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
////////////////////////////////////////////////////////////////////////////////
/**
 * Subscribes to events on one or multiple publishers.
 * Subscription can be started and stopped for all registered publishers at once.
 * Events are untyped and event arguments are not delivered.
 */
class Subscriber {
    constructor(type, callback, context) {
        this._type = type;
        this._callback = callback;
        this._context = context;
        this._publishers = [];
    }
    on(...publishers) {
        publishers.forEach(publisher => {
            this._publishers.push(publisher);
            publisher.on(this._type, this._callback, this._context);
        });
        return this;
    }
    off() {
        this._publishers.forEach(pub => pub.off(this._type, this._callback, this._context));
        this._publishers.length = 0;
        return this;
    }
}


/***/ }),

/***/ "../../libs/ff-core/source/TypeRegistry.ts":
/*!*****************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-core/source/TypeRegistry.ts ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TypeRegistry; });
/* harmony import */ var _Publisher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Publisher */ "../../libs/ff-core/source/Publisher.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */

class TypeRegistry extends _Publisher__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
        this._dict = {};
        this.addEvent("type");
    }
    add(type) {
        if (Array.isArray(type)) {
            type.forEach(type => this.add(type));
            return;
        }
        const typeName = type.typeName;
        if (!typeName) {
            throw new Error("type must have a 'typeName' member");
        }
        if (this._dict[typeName]) {
            throw new Error(`type '${typeName}' already registered`);
        }
        this._dict[typeName] = type;
        this.emit({ type: "type", add: true, remove: false, classType: type });
    }
    remove(type) {
        if (Array.isArray(type)) {
            type.forEach(type => this.remove(type));
            return;
        }
        const typeName = type.typeName;
        if (!typeName) {
            throw new Error("type must have a 'typeName' member");
        }
        if (!this._dict[typeName]) {
            throw new Error(`type '${typeName}' not registered`);
        }
        delete this._dict[typeName];
        this.emit({ type: "type", add: false, remove: true, classType: type });
    }
    getType(typeHint) {
        let typeName = typeHint;
        if (typeof typeHint === "function") {
            typeName = typeHint.typeName;
        }
        else if (typeof typeHint === "object") {
            typeName = typeHint.constructor.typeName;
        }
        return this._dict[typeName];
    }
    createInstance(typeHint, ...args) {
        const type = this.getType(typeHint);
        if (!type) {
            throw new Error(`type '${typeHint}' not registered`);
        }
        return new type(...args);
    }
}


/***/ }),

/***/ "../../libs/ff-core/source/UnorderedCollection.ts":
/*!************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-core/source/UnorderedCollection.ts ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UnorderedCollection; });
/* harmony import */ var _Publisher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Publisher */ "../../libs/ff-core/source/Publisher.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */

/**
 * Container storing an unordered collection of items. Items can be retrieved and manipulated by
 * id. Internally, the collection is stored in a key/value dictionary. Items may provide an
 * 'id' property with a unique identifier.
 *
 * Updates to the collection are published via [[ICollectionUpdateEvent]] events.
 */
class UnorderedCollection extends _Publisher__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(items) {
        super();
        this.addEvent("update");
        this._dict = {};
        items && items.forEach(item => {
            if (item.id) {
                this._dict[item.id] = item;
            }
        });
    }
    /**
     * Returns the number of items in the collection.
     */
    get length() {
        return this.ids.length;
    }
    /**
     * Returns an unordered array with all collection items.
     */
    get items() {
        return this.ids.map(id => this._dict[id]);
    }
    set items(items) {
        items.forEach(item => {
            if (item.id) {
                this._dict[item.id] = item;
            }
        });
        this.emit({ type: "update", item: null, what: "update" });
    }
    /**
     * Returns an unordered array with the ids of all collection items.
     */
    get ids() {
        return Object.keys(this._dict);
    }
    /**
     * Returns a shallow copy of the internal id/item dictionary.
     */
    get dictionary() {
        return this._dict;
    }
    set dictionary(dict) {
        this._dict = dict;
        this.emit({ type: "update", item: null, what: "update" });
    }
    insert(item, id) {
        id = id || item.id;
        if (!id) {
            throw new Error("can't insert, missing id");
        }
        this._dict[id] = item;
        this.emit({ type: "update", item, what: "insert" });
    }
    remove(itemOrId) {
        const id = typeof itemOrId === "string" ? itemOrId : itemOrId.id;
        const item = this._dict[id];
        if (item === undefined) {
            return;
        }
        delete this._dict[id];
        this.emit({ type: "update", item, what: "remove" });
    }
    get(id) {
        return this._dict[id];
    }
    getOrCreate(id, defaultItem) {
        let item = this._dict[id];
        if (!item) {
            item = this._dict[id] = defaultItem;
            this.emit({ type: "update", item, what: "insert" });
        }
        return item;
    }
    /**
     * Replaces the internal id/item dictionary with a shallow copy of the given id/item dictionary.
     * @param dict
     */
    copy(dict) {
        this.dictionary = Object.assign({}, dict);
    }
    /**
     * Returns a shallow copy of the internal id/item dictionary.
     */
    clone() {
        return Object.assign({}, this._dict);
    }
}


/***/ }),

/***/ "../../libs/ff-core/source/Vector2.ts":
/*!************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-core/source/Vector2.ts ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Vector2; });
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
/**
 * 2-dimensional vector.
 */
class Vector2 {
    /**
     * Constructs a new vector with the given x and y values.
     * Omitted or invalid values are set to zero.
     * @param x
     * @param y
     */
    constructor(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    }
    /**
     * Returns a new vector with all components set to zero.
     */
    static makeZeros() {
        return new Vector2(0, 0);
    }
    /**
     * Returns a new vector with all components set to one.
     */
    static makeOnes() {
        return new Vector2(1, 1);
    }
    /**
     * Returns a new vector of unit length, parallel to the X axis.
     */
    static makeUnitX() {
        return new Vector2(1, 0);
    }
    /**
     * Returns a new vector of unit length, parallel to the Y axis.
     */
    static makeUnitY() {
        return new Vector2(0, 1);
    }
    /**
     * Returns a new vector with components set from the given vector.
     * @param vector
     */
    static makeCopy(vector) {
        return new Vector2(vector.x, vector.y);
    }
    /**
     * Returns a new vector with each component set to the given scalar value.
     * @param scalar
     */
    static makeFromScalar(scalar) {
        return new Vector2(scalar, scalar);
    }
    /**
     * Returns a new vector with components set from the values of the given array.
     * @param array
     */
    static makeFromArray(array) {
        return new Vector2(array[0], array[1]);
    }
    /**
     * Returns a string representation of the given vector.
     * @param vector
     */
    static toString(vector) {
        return `[${vector.x}, ${vector.y}]`;
    }
    /**
     * Copies the components of the given vector to this.
     * @param vector
     */
    copy(vector) {
        this.x = vector.x;
        this.y = vector.y;
        return this;
    }
    /**
     * Sets the components to the given values.
     * @param x
     * @param y
     */
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    /**
     * Sets each component to the given scalar value.
     * @param scalar
     */
    setFromScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
    }
    /**
     * Sets the components to the values of the given array.
     * @param array
     * @param offset Optional start index of the array. Default is 0.
     */
    setFromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
    }
    /**
     * Sets all components to zero.
     */
    setZeros() {
        this.x = 0;
        this.y = 0;
        return this;
    }
    /**
     * Sets all components to one.
     */
    setOnes() {
        this.x = 1;
        this.y = 1;
        return this;
    }
    /**
     * Makes this a unit vector parallel to the X axis.
     */
    setUnitX() {
        this.x = 1;
        this.y = 0;
        return this;
    }
    /**
     * Makes this a unit vector parallel to the Y axis.
     */
    setUnitY() {
        this.x = 0;
        this.y = 1;
        return this;
    }
    /**
     * Adds the given vector to this.
     * @param other
     */
    add(other) {
        this.x += other.x;
        this.y += other.y;
        return this;
    }
    /**
     * Subtracts the given vector from this.
     * @param other
     */
    sub(other) {
        this.x -= other.x;
        this.y -= other.y;
        return this;
    }
    /**
     * Multiplies each component with the corresponding component of the given vector.
     * @param other
     */
    mul(other) {
        this.x *= other.x;
        this.y *= other.y;
        return this;
    }
    /**
     * Divides each component by the corresponding component of the given vector.
     * @param other
     */
    div(other) {
        this.x /= other.x;
        this.y /= other.y;
        return this;
    }
    /**
     * Adds the given scalar to each component.
     * @param scalar
     */
    addScalar(scalar) {
        this.x += scalar;
        this.y += scalar;
        return this;
    }
    /**
     * Subtracts the given scalar from each component.
     * @param scalar
     */
    subScalar(scalar) {
        this.x -= scalar;
        this.y -= scalar;
        return this;
    }
    /**
     * Multiplies each component with the given scalar.
     * @param scalar
     */
    mulScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
    }
    /**
     * Divides each component by the given scalar.
     * @param scalar
     */
    divScalar(scalar) {
        this.x /= scalar;
        this.y /= scalar;
        return this;
    }
    /**
     * Translates the vector by the given offsets.
     * @param tx
     * @param ty
     */
    translate(tx, ty) {
        this.x += tx;
        this.y += ty;
        return this;
    }
    /**
     * Rotates the vector by the given angle.
     * @param angle rotation angle in radians.
     */
    rotate(angle) {
        const co = Math.cos(angle);
        const si = Math.sin(angle);
        const x = this.x, y = this.y;
        this.x = co * x - si * y;
        this.y = si * x + co * y;
        return this;
    }
    /**
     * Scales the vector by the given factors.
     * @param sx
     * @param sy
     */
    scale(sx, sy) {
        this.x *= sx;
        this.y *= sy;
        return this;
    }
    /**
     * Inverts each component, e.g. x = 1 / x, ...
     */
    invert() {
        this.x = 1 / this.x;
        this.y = 1 / this.y;
        return this;
    }
    /**
     * Negates each component, e.g. x = -x, ...
     */
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
    }
    /**
     * Normalizes the vector, making it a unit vector.
     */
    normalize() {
        const f = 1 / Math.sqrt(this.x * this.x + this.y * this.y);
        this.x *= f;
        this.y *= f;
        return this;
    }
    /**
     * Returns the dot product of this and the given vector.
     * @param other
     */
    dot(other) {
        return this.x * other.x + this.y * other.y;
    }
    /**
     * Returns the 2-norm (length) of this.
     */
    length() {
        const x = this.x, y = this.y;
        return Math.sqrt(x * x + y * y);
    }
    /**
     * Returns the squared 2-norm of this, i.e. the dot product of the vector with itself.
     */
    lengthSquared() {
        const x = this.x, y = this.y;
        return x * x + y * y;
    }
    /**
     * Returns the distance between this and other.
      * @param other
     */
    distanceTo(other) {
        const dx = other.x - this.x;
        const dy = other.y - this.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    /**
     * Returns the angle between this and the positive X axis.
     * @returns angle in radians.
     */
    angle() {
        return Math.atan2(this.y, this.x);
    }
    /**
     * Returns the angle between this and the given vector.
     * @param other
     * @returns angle in radians.
     */
    angleTo(other) {
        const x0 = this.x, y0 = this.y, x1 = other.x, y1 = other.y;
        return Math.acos((x0 * x1 + y0 * y1) / (Math.sqrt(x0 * x0 + y0 * y0) + Math.sqrt(x1 * x1 + y1 * y1)));
    }
    /**
     * Returns the smallest component.
     */
    min() {
        return this.x < this.y ? this.x : this.y;
    }
    /**
     * Returns the largest component.
     */
    max() {
        return this.x > this.y ? this.x : this.y;
    }
    /**
     * Returns true if all components are exactly zero.
     */
    isZero() {
        return this.x === 0 && this.y === 0;
    }
    /**
     * Returns a clone.
     */
    clone() {
        return new Vector2(this.x, this.y);
    }
    /**
     * Returns an array with the components of this.
     * @param array Optional destination array.
     * @param offset Optional start index of the array. Default is 0.
     */
    toArray(array, offset) {
        if (array) {
            if (offset === undefined) {
                offset = 0;
            }
            array[offset] = this.x;
            array[offset + 1] = this.y;
            return array;
        }
        return [
            this.x,
            this.y
        ];
    }
    /**
     * Returns a text representation.
     */
    toString() {
        return Vector2.toString(this);
    }
}
Vector2.zeros = new Vector2(0, 0);
Vector2.ones = new Vector2(1, 1);
Vector2.unitX = new Vector2(1, 0);
Vector2.unitY = new Vector2(0, 1);


/***/ }),

/***/ "../../libs/ff-core/source/Vector3.ts":
/*!************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-core/source/Vector3.ts ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Vector3; });
/* harmony import */ var _Vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector2 */ "../../libs/ff-core/source/Vector2.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */

/**
 * 3-dimensional vector.
 */
class Vector3 {
    /**
     * Constructs a new vector with the given x, y, and z values.
     * Omitted or invalid values are set to zero.
     * @param x
     * @param y
     * @param z
     */
    constructor(x, y, z) {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
    }
    /**
     * Returns a new vector with all components set to zero.
     */
    static makeZeros() {
        return new Vector3(0, 0, 0);
    }
    /**
     * Returns a new vector with all components set to one.
     */
    static makeOnes() {
        return new Vector3(1, 1, 1);
    }
    /**
     * Returns a new unit-length vector, parallel to the X axis.
     */
    static makeUnitX() {
        return new Vector3(1, 0, 0);
    }
    /**
     * Returns a new unit-length vector, parallel to the Y axis.
     */
    static makeUnitY() {
        return new Vector3(0, 1, 0);
    }
    /**
     * Returns a new unit-length vector, parallel to the Z axis.
     */
    static makeUnitZ() {
        return new Vector3(0, 0, 1);
    }
    /**
     * Returns a new vector with components set from the given vector.
     * @param vector
     */
    static makeCopy(vector) {
        return new Vector3(vector.x, vector.y, vector.z);
    }
    /**
     * Returns a new vector with each component set to the given scalar value.
     * @param scalar
     */
    static makeFromScalar(scalar) {
        return new Vector3(scalar, scalar, scalar);
    }
    /**
     * Returns a new vector with components set from the values of the given array.
     * @param array
     */
    static makeFromArray(array) {
        return new Vector3(array[0], array[1], array[2]);
    }
    /**
     * Returns a string representation of the given vector.
     * @param vector
     */
    static toString(vector) {
        return `[${vector.x}, ${vector.y}, ${vector.z}]`;
    }
    /**
     * Copies the components of the given vector to this.
     * @param vector
     */
    copy(vector) {
        this.x = vector.x;
        this.y = vector.y;
        this.z = vector.z;
        return this;
    }
    /**
     * Sets the components to the given values.
     * @param x
     * @param y
     * @param z
     */
    set(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    }
    /**
     * Sets each component to the given scalar value.
     * @param scalar
     */
    setFromScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        return this;
    }
    /**
     * Sets the components to the values of the given array.
     * @param array
     * @param offset Optional start index of the array. Default is 0.
     */
    setFromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
    }
    /**
     * Sets all components to zero.
     */
    setZeros() {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        return this;
    }
    /**
     * Sets all components to one.
     */
    setOnes() {
        this.x = 1;
        this.y = 1;
        this.z = 1;
        return this;
    }
    /**
     * Makes this a unit vector parallel to the X axis.
     */
    setUnitX() {
        this.x = 1;
        this.y = 0;
        this.z = 0;
        return this;
    }
    /**
     * Makes this a unit vector parallel to the Y axis.
     */
    setUnitY() {
        this.x = 0;
        this.y = 1;
        this.z = 0;
        return this;
    }
    /**
     * Makes this a unit vector parallel to the Z axis.
     */
    setUnitZ() {
        this.x = 0;
        this.y = 0;
        this.z = 1;
        return this;
    }
    /**
     * Adds the given vector to this.
     * @param other
     */
    add(other) {
        this.x += other.x;
        this.y += other.y;
        this.z += other.z;
        return this;
    }
    /**
     * Subtracts the given vector from this.
     * @param other
     */
    sub(other) {
        this.x -= other.x;
        this.y -= other.y;
        this.z -= other.z;
        return this;
    }
    /**
     * Multiplies each component with the corresponding component of the given vector.
     * @param other
     */
    mul(other) {
        this.x *= other.x;
        this.y *= other.y;
        this.z *= other.z;
        return this;
    }
    /**
     * Divides each component by the corresponding component of the given vector.
     * @param other
     */
    div(other) {
        this.x /= other.x;
        this.y /= other.y;
        this.z /= other.z;
        return this;
    }
    /**
     * Adds the given scalar to each component.
     * @param scalar
     */
    addScalar(scalar) {
        this.x += scalar;
        this.y += scalar;
        this.z += scalar;
        return this;
    }
    /**
     * Subtracts the given scalar from each component.
     * @param scalar
     */
    subScalar(scalar) {
        this.x -= scalar;
        this.y -= scalar;
        this.z -= scalar;
        return this;
    }
    /**
     * Multiplies each component with the given scalar.
     * @param scalar
     */
    mulScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
    }
    /**
     * Divides each component by the given scalar.
     * @param scalar
     */
    divScalar(scalar) {
        this.x /= scalar;
        this.y /= scalar;
        this.z /= scalar;
        return this;
    }
    /**
     * Translates the vector by the given offsets.
     * @param tx
     * @param ty
     * @param tz
     */
    translate(tx, ty, tz) {
        this.x += tx;
        this.y += ty;
        this.z += tz;
        return this;
    }
    /**
     * Rotates the vector by the given angle about the x-axis.
     * @param angle rotation angle in radians.
     */
    rotateX(angle) {
        const co = Math.cos(angle);
        const si = Math.sin(angle);
        const y = this.y, z = this.z;
        this.y = co * y - si * z;
        this.z = si * y + co * z;
        return this;
    }
    /**
     * Rotates the vector by the given angle about the y-axis.
     * @param angle rotation angle in radians.
     */
    rotateY(angle) {
        const co = Math.cos(angle);
        const si = Math.sin(angle);
        const x = this.x, z = this.z;
        this.x = co * x + si * z;
        this.z = -si * x + co * z;
        return this;
    }
    /**
     * Rotates the vector by the given angle about the z-axis.
     * @param angle rotation angle in radians.
     */
    rotateZ(angle) {
        const co = Math.cos(angle);
        const si = Math.sin(angle);
        const x = this.x, y = this.y;
        this.x = co * x - si * y;
        this.y = si * x + co * y;
        return this;
    }
    /**
     * Scales the vector by the given factors.
     * @param sx
     * @param sy
     * @param sz
     */
    scale(sx, sy, sz) {
        this.x *= sx;
        this.y *= sy;
        this.z *= sz;
        return this;
    }
    /**
     * Inverts each component of this, e.g. x = 1 / x, ...
     */
    invert() {
        this.x = 1 / this.x;
        this.y = 1 / this.y;
        this.z = 1 / this.z;
        return this;
    }
    /**
     * Negates each component of this, e.g. x = -x, ...
     */
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
    }
    /**
     * Normalizes the vector, making it a unit vector.
     */
    normalize() {
        const f = 1 / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        this.x *= f;
        this.y *= f;
        this.z *= f;
        return this;
    }
    /**
     * Makes this vector homogeneous by dividing all components by the z component.
     */
    homogenize() {
        this.x /= this.z;
        this.y /= this.z;
        this.z = 1;
        return this;
    }
    /**
     * Returns the dot product of this and the given vector.
     * @param other
     */
    dot(other) {
        return this.x * other.x + this.y * other.y + this.z * other.z;
    }
    /**
     * Assigns to this the cross product between this and the given vector.
     * @param other
     */
    cross(other) {
        const x = this.y * other.z - this.z * other.y;
        const y = this.z * other.x - this.x * other.z;
        const z = this.x * other.y - this.y * other.x;
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    }
    /**
     * Returns the 2-norm (length) of this.
     */
    length() {
        const x = this.x, y = this.y, z = this.z;
        return Math.sqrt(x * x + y * y + z * z);
    }
    /**
     * Returns the squared 2-norm of this, i.e. the dot product of the vector with itself.
     */
    lengthSquared() {
        const x = this.x, y = this.y, z = this.z;
        return x * x + y * y + z * z;
    }
    /**
     * Returns the distance between this and other.
     * @param other
     */
    distanceTo(other) {
        const dx = other.x - this.x;
        const dy = other.y - this.y;
        const dz = other.z - this.z;
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
    /**
     * Returns the smallest component.
     */
    min() {
        return this.x < this.y ? (this.x < this.z ? this.x : this.z) : (this.y < this.z ? this.y : this.z);
    }
    /**
     * Returns the largest component.
     */
    max() {
        return this.x > this.y ? (this.x > this.z ? this.x : this.z) : (this.y > this.z ? this.y : this.z);
    }
    /**
     * Returns true if all components are exactly zero.
     */
    isZero() {
        return this.x === 0 && this.y === 0 && this.z === 0;
    }
    /**
     * Returns a clone.
     */
    clone() {
        return new Vector3(this.x, this.y, this.z);
    }
    /**
     * Returns an array with the components of this.
     * @param array Optional destination array.
     * @param offset Optional start index of the array. Default is 0.
     */
    toArray(array, offset) {
        if (array) {
            if (offset === undefined) {
                offset = 0;
            }
            array[offset] = this.x;
            array[offset + 1] = this.y;
            array[offset + 2] = this.z;
            return array;
        }
        return [
            this.x,
            this.y,
            this.z
        ];
    }
    /**
     * Returns a [[Vector2]] with the x and y components of this.
     * @param vector Optional destination vector.
     */
    toVector2(vector) {
        if (vector) {
            vector.x = this.x;
            vector.y = this.y;
            return vector;
        }
        return new _Vector2__WEBPACK_IMPORTED_MODULE_0__["default"](this.x, this.y);
    }
    /**
     * Returns a text representation.
     */
    toString() {
        return Vector3.toString(this);
    }
}
Vector3.zeros = new Vector3(0, 0, 0);
Vector3.ones = new Vector3(1, 1, 1);
Vector3.unitX = new Vector3(1, 0, 0);
Vector3.unitY = new Vector3(0, 1, 0);
Vector3.unitZ = new Vector3(0, 0, 1);


/***/ }),

/***/ "../../libs/ff-core/source/Vector4.ts":
/*!************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-core/source/Vector4.ts ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Vector4; });
/* harmony import */ var _Vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3 */ "../../libs/ff-core/source/Vector3.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */

/**
 * 4-dimensional vector.
 */
class Vector4 {
    /**
     * Constructs a new vector with the given x, y, z, and w values.
     * Omitted or invalid values are set to zero.
     * @param x
     * @param y
     * @param z
     * @param w
     */
    constructor(x, y, z, w) {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
        this.w = w || 0;
    }
    /**
     * Returns a new vector with all components set to zero: [0, 0, 0, 0].
     */
    static makeZeros() {
        return new Vector4(0, 0, 0, 0);
    }
    /**
     * Returns a new vector with all components set to one: [1, 1, 1, 1].
     */
    static makeOnes() {
        return new Vector4(1, 1, 1, 1);
    }
    /**
     * Returns a new unit-length vector, parallel to the X axis: [1, 0, 0, 0].
     */
    static makeUnitX() {
        return new Vector4(1, 0, 0, 0);
    }
    /**
     * Returns a new unit-length vector, parallel to the Y axis: [0, 1, 0, 0].
     */
    static makeUnitY() {
        return new Vector4(0, 1, 0, 0);
    }
    /**
     * Returns a new unit-length vector, parallel to the Z axis: [0, 0, 1, 0].
     */
    static makeUnitZ() {
        return new Vector4(0, 0, 1, 0);
    }
    /**
     * Returns a new unit-length vector, parallel to the W axis: [0, 0, 0, 1].
     */
    static makeUnitW() {
        return new Vector4(0, 0, 0, 1);
    }
    /**
     * Returns a new vector with components set from the given vector.
     * @param vector
     */
    static makeCopy(vector) {
        return new Vector4(vector.x, vector.y, vector.z, vector.w);
    }
    /**
     * Returns a new vector with each component set to the given scalar value.
     * @param scalar
     */
    static makeFromScalar(scalar) {
        return new Vector4(scalar, scalar, scalar, scalar);
    }
    /**
     * Returns a new vector with components set from the values of the given array.
     * @param array
     */
    static makeFromArray(array) {
        return new Vector4(array[0], array[1], array[2], array[3]);
    }
    /**
     * Returns a new positional vector from the given [[Vector3]].
     * Copies the components of the given vector to x, y, z and sets w to 1.
     * @param position
     */
    static makeFromPosition(position) {
        return new Vector4(position.x, position.y, position.z, 1);
    }
    /**
     * Returns a new directional vector from the given [[Vector3]].
     * Copies the components of the given vector to x, y, z and sets w to 0.
     * @param direction
     */
    static makeFromDirection(direction) {
        return new Vector4(direction.x, direction.y, direction.z, 0);
    }
    /**
     * Returns a string representation of the given vector.
     * @param vector
     */
    static toString(vector) {
        return `[${vector.x}, ${vector.y}, ${vector.z}, ${vector.w}]`;
    }
    /**
     * Copies the components of the given vector to this.
     * @param vector
     */
    copy(vector) {
        this.x = vector.x;
        this.y = vector.y;
        this.z = vector.z;
        this.w = vector.w;
        return this;
    }
    /**
     * Sets the components of this to the given values.
     * @param x
     * @param y
     * @param z
     * @param w Optional, is set to one if omitted.
     */
    set(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w === undefined ? 1 : w;
        return this;
    }
    /**
     * Sets each component to the given scalar value.
     * @param scalar
     */
    setFromScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        this.w = scalar;
        return this;
    }
    /**
     * Sets the components to the values of the given array.
     * @param array
     * @param offset Optional start index of the array. Default is 0.
     */
    setFromArray(array, offset = 1) {
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
    }
    /**
     * Sets this to a positional vector by copying the values of the given [[Vector3]]
     * and adding one as fourth component.
     * @param position
     */
    setPosition(position) {
        this.x = position.x;
        this.y = position.y;
        this.z = position.z;
        this.w = 1;
        return this;
    }
    /**
     * Sets this to a positional vector by copying the values of the given [[Vector3]]
     * and adding zero as fourth component.
     * @param direction
     */
    setDirection(direction) {
        this.x = direction.x;
        this.y = direction.y;
        this.z = direction.z;
        this.w = 0;
        return this;
    }
    /**
     * Sets all components to zero.
     */
    setZeros() {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 0;
        return this;
    }
    /**
     * Sets all components to one.
     */
    setOnes() {
        this.x = 1;
        this.y = 1;
        this.z = 1;
        this.w = 1;
        return this;
    }
    /**
     * Makes this a unit vector parallel to the X axis.
     */
    setUnitX() {
        this.x = 1;
        this.y = 0;
        this.z = 0;
        this.w = 0;
        return this;
    }
    /**
     * Makes this a unit vector parallel to the Y axis.
     */
    setUnitY() {
        this.x = 0;
        this.y = 1;
        this.z = 0;
        this.w = 0;
        return this;
    }
    /**
     * Makes this a unit vector parallel to the Z axis.
     */
    setUnitZ() {
        this.x = 0;
        this.y = 0;
        this.z = 1;
        this.w = 0;
        return this;
    }
    /**
     * Makes this a unit vector parallel to the W axis.
     */
    setUnitW() {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 1;
        return this;
    }
    /**
     * Adds the given vector to this.
     * @param other
     */
    add(other) {
        this.x += other.x;
        this.y += other.y;
        this.z += other.z;
        this.w += other.w;
        return this;
    }
    /**
     * Subtracts the given vector from this.
     * @param other
     */
    sub(other) {
        this.x -= other.x;
        this.y -= other.y;
        this.z -= other.z;
        this.w -= other.w;
        return this;
    }
    /**
     * Multiplies each component with the corresponding component of the given vector.
     * @param other
     */
    mul(other) {
        this.x *= other.x;
        this.y *= other.y;
        this.z *= other.z;
        this.w *= other.w;
        return this;
    }
    /**
     * Divides each component by the corresponding component of the given vector.
     * @param other
     */
    div(other) {
        this.x /= other.x;
        this.y /= other.y;
        this.z /= other.z;
        this.w /= other.w;
        return this;
    }
    /**
     * Normalizes the vector, making it a unit vector.
     */
    normalize() {
        const f = 1 / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        this.x *= f;
        this.y *= f;
        this.z *= f;
        this.w *= f;
        return this;
    }
    /**
     * Makes this vector homogeneous by dividing all components by the w-component.
     */
    homogenize() {
        this.x /= this.w;
        this.y /= this.w;
        this.z /= this.w;
        this.w = 1;
        return this;
    }
    /**
     * Projects this onto the given vector.
     * @param other
     */
    project(other) {
        //TODO: Verify
        const f = this.dot(other) / this.lengthSquared();
        this.x *= f;
        this.y *= f;
        this.z *= f;
        this.w *= f;
        return this;
    }
    /**
     * Returns the dot product of this and the given vector.
     * @param other
     */
    dot(other) {
        return this.x * other.x + this.y * other.y + this.z * other.z + this.w * other.w;
    }
    /**
     * Returns the 2-norm (length) of this.
     */
    length() {
        const x = this.x, y = this.y, z = this.z, w = this.w;
        return Math.sqrt(x * x + y * y + z * z + w * w);
    }
    /**
     * Returns the squared 2-norm of this, i.e. the dot product of the vector with itself.
     */
    lengthSquared() {
        const x = this.x, y = this.y, z = this.z, w = this.w;
        return x * x + y * y + z * z + w * w;
    }
    /**
     * Returns true if all components are exactly zero.
     * @returns {boolean}
     */
    isZero() {
        return this.x === 0 && this.y === 0 && this.z === 0 && this.w === 0;
    }
    /**
     * Returns a clone of this vector.
     */
    clone() {
        return new Vector4(this.x, this.y, this.z, this.w);
    }
    /**
     * Returns an array with the components of this.
     * @param array Optional destination array.
     * @param offset Optional start index of the array. Default is 0.
     */
    toArray(array, offset) {
        if (array) {
            if (offset === undefined) {
                offset = 0;
            }
            array[offset] = this.x;
            array[offset + 1] = this.y;
            array[offset + 2] = this.z;
            array[offset + 3] = this.w;
            return array;
        }
        return [
            this.x,
            this.y,
            this.z,
            this.w
        ];
    }
    /**
     * Returns a [[Vector3]] with the x, y, and z components of this.
     * @param vector Optional destination vector.
     */
    toVector3(vector) {
        if (vector) {
            vector.x = this.x;
            vector.y = this.y;
            vector.z = this.z;
            return vector;
        }
        return new _Vector3__WEBPACK_IMPORTED_MODULE_0__["default"](this.x, this.y, this.z);
    }
    /**
     * Returns a text representation.
     */
    toString() {
        return Vector4.toString(this);
    }
}
Vector4.zeros = new Vector4(0, 0, 0, 0);
Vector4.ones = new Vector4(1, 1, 1, 1);
Vector4.unitX = new Vector4(1, 0, 0, 0);
Vector4.unitY = new Vector4(0, 1, 0, 0);
Vector4.unitZ = new Vector4(0, 0, 1, 0);
Vector4.unitW = new Vector4(0, 0, 0, 1);


/***/ }),

/***/ "../../libs/ff-core/source/easing.ts":
/*!***********************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-core/source/easing.ts ***!
  \***********************************************************/
/*! exports provided: EEasingCurve, getEasingFunction, easingFunctions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EEasingCurve", function() { return EEasingCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEasingFunction", function() { return getEasingFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easingFunctions", function() { return easingFunctions; });
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
const PI = Math.PI;
const HALF_PI = PI * 0.5;
var EEasingCurve;
(function (EEasingCurve) {
    EEasingCurve[EEasingCurve["Linear"] = 0] = "Linear";
    EEasingCurve[EEasingCurve["EaseQuad"] = 1] = "EaseQuad";
    EEasingCurve[EEasingCurve["EaseInQuad"] = 2] = "EaseInQuad";
    EEasingCurve[EEasingCurve["EaseOutQuad"] = 3] = "EaseOutQuad";
    EEasingCurve[EEasingCurve["EaseCubic"] = 4] = "EaseCubic";
    EEasingCurve[EEasingCurve["EaseInCubic"] = 5] = "EaseInCubic";
    EEasingCurve[EEasingCurve["EaseOutCubic"] = 6] = "EaseOutCubic";
    EEasingCurve[EEasingCurve["EaseQuart"] = 7] = "EaseQuart";
    EEasingCurve[EEasingCurve["EaseInQuart"] = 8] = "EaseInQuart";
    EEasingCurve[EEasingCurve["EaseOutQuart"] = 9] = "EaseOutQuart";
    EEasingCurve[EEasingCurve["EaseQuint"] = 10] = "EaseQuint";
    EEasingCurve[EEasingCurve["EaseInQuint"] = 11] = "EaseInQuint";
    EEasingCurve[EEasingCurve["EaseOutQuint"] = 12] = "EaseOutQuint";
    EEasingCurve[EEasingCurve["EaseSine"] = 13] = "EaseSine";
    EEasingCurve[EEasingCurve["EaseInSine"] = 14] = "EaseInSine";
    EEasingCurve[EEasingCurve["EaseOutSine"] = 15] = "EaseOutSine";
})(EEasingCurve || (EEasingCurve = {}));
function getEasingFunction(curve) {
    return easingFunctions[EEasingCurve[curve]];
}
const easingFunctions = {
    Linear: function (t) { return t; },
    EaseQuad: function (t) { return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; },
    EaseInQuad: function (t) { return t * t; },
    EaseOutQuad: function (t) { return t * (2 - t); },
    EaseCubic: function (t) { return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1; },
    EaseInCubic: function (t) { return t * t * t; },
    EaseOutCubic: function (t) { return (--t) * t * t + 1; },
    EaseQuart: function (t) { return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t; },
    EaseInQuart: function (t) { return t * t * t * t; },
    EaseOutQuart: function (t) { return 1 - (--t) * t * t * t; },
    EaseQuint: function (t) { return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t; },
    EaseInQuint: function (t) { return t * t * t * t * t; },
    EaseOutQuint: function (t) { return 1 + (--t) * t * t * t * t; },
    EaseSine: function (t) { return -0.5 * (Math.cos(t * PI) - 1); },
    EaseInSine: function (t) { return 1 - Math.cos(t * HALF_PI); },
    EaseOutSine: function (t) { return Math.sin(t * HALF_PI); },
};


/***/ }),

/***/ "../../libs/ff-core/source/isSubclass.ts":
/*!***************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-core/source/isSubclass.ts ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isSubclass; });
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
function isSubclass(derived, base) {
    if (!derived || !base) {
        return false;
    }
    let prototype = derived.prototype;
    while (prototype) {
        if (prototype === base.prototype) {
            return true;
        }
        prototype = prototype.prototype;
    }
    return false;
}


/***/ }),

/***/ "../../libs/ff-core/source/math.ts":
/*!*********************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-core/source/math.ts ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
const math = {
    PI: 3.1415926535897932384626433832795,
    DOUBLE_PI: 6.283185307179586476925286766559,
    HALF_PI: 1.5707963267948966192313216916398,
    QUARTER_PI: 0.78539816339744830961566084581988,
    DEG2RAD: 0.01745329251994329576923690768489,
    RAD2DEG: 57.295779513082320876798154814105,
    limit: (v, min, max) => v < min ? min : (v > max ? max : v),
    limitInt: function (v, min, max) {
        v = Math.trunc(v);
        return v < min ? min : (v > max ? max : v);
    },
    normalize: (v, min, max) => (v - min) / (max - min),
    normalizeLimit: (v, min, max) => {
        v = (v - min) / (max - min);
        return v < 0.0 ? 0.0 : (v > 1.0 ? 1.0 : v);
    },
    denormalize: (t, min, max) => (min + t) * (max - min),
    scale: (v, minIn, maxIn, minOut, maxOut) => minOut + (v - minIn) / (maxIn - minIn) * (maxOut - minOut),
    scaleLimit: (v, minIn, maxIn, minOut, maxOut) => {
        v = v < minIn ? minIn : (v > maxIn ? maxIn : v);
        return minOut + (v - minIn) / (maxIn - minIn) * (maxOut - minOut);
    },
    deg2rad: function (degrees) {
        return degrees * 0.01745329251994329576923690768489;
    },
    rad2deg: function (radians) {
        return radians * 57.295779513082320876798154814105;
    },
    deltaRadians: function (radA, radB) {
        radA %= math.DOUBLE_PI;
        radA = radA < 0 ? radA + math.DOUBLE_PI : radA;
        radB %= math.DOUBLE_PI;
        radB = radB < 0 ? radB + math.DOUBLE_PI : radB;
        if (radB - radA > math.PI) {
            radA += math.DOUBLE_PI;
        }
        return radB - radA;
    },
    deltaDegrees: function (degA, degB) {
        degA %= math.DOUBLE_PI;
        degA = degA < 0 ? degA + math.DOUBLE_PI : degA;
        degB %= math.DOUBLE_PI;
        degB = degB < 0 ? degB + math.DOUBLE_PI : degB;
        if (degB - degA > math.PI) {
            degA += math.DOUBLE_PI;
        }
        return degB - degA;
    },
    curves: {
        linear: t => t,
        easeIn: t => Math.sin(t * math.HALF_PI),
        easeOut: t => Math.cos(t * math.HALF_PI - math.PI) + 1.0,
        ease: t => Math.cos(t * math.PI - math.PI) * 0.5 + 0.5,
        easeInQuad: t => t * t,
        easeOutQuad: t => t * (2 - t),
        easeQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
        easeInCubic: t => t * t * t,
        easeOutCubic: t => (--t) * t * t + 1,
        easeCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
        easeInQuart: t => t * t * t * t,
        easeOutQuart: t => 1 - (--t) * t * t * t,
        easeQuart: t => t < 0.5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t
    }
};
/* harmony default export */ __webpack_exports__["default"] = (math);


/***/ }),

/***/ "../../libs/ff-core/source/text.ts":
/*!*********************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-core/source/text.ts ***!
  \*********************************************************/
/*! exports provided: camelize, normalize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "camelize", function() { return camelize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
function camelize(text) {
    return text.replace(/(?:^\w|[A-Z]|\b\w)/g, (letter, index) => index == 0 ? letter.toLowerCase() : letter.toUpperCase()).replace(/\s+/g, '');
}
function normalize(text) {
    return text.replace(/([A-Z])/g, ' $1')
        .replace(/^./, str => str.toUpperCase());
}


/***/ }),

/***/ "../../libs/ff-core/source/types.ts":
/*!**********************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-core/source/types.ts ***!
  \**********************************************************/
/*! exports provided: enumToArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumToArray", function() { return enumToArray; });
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
////////////////////////////////////////////////////////////////////////////////
// ENUM HELPER FUNCTIONS
const enumToArray = function (e) {
    return Object.keys(e).filter(key => isNaN(Number(key)));
};


/***/ }),

/***/ "../../libs/ff-core/source/uniqueId.ts":
/*!*************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-core/source/uniqueId.ts ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return uniqueId; });
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
let _chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
/**
 * Creates a base64 encoded globally unique identifier with a default length of 12 characters.
 * The identifier only uses letters and digits and can safely be used for file names.
 * Unique combinations: 62 ^ 12 > 2 ^ 64
 * @param length Number of base64 characters in the identifier.
 * @param dictionary Optional object with ids. Function ensures generated id is not equal to a key of dictionary.
 * @returns Globally unique identifier
 */
function uniqueId(length, dictionary) {
    if (!length || typeof length !== "number") {
        length = 12;
    }
    let id;
    do {
        id = "";
        for (let i = 0; i < length; ++i) {
            id += _chars[Math.random() * 62 | 0];
        }
    } while (dictionary && dictionary[id]);
    return id;
}


/***/ }),

/***/ "../../libs/ff-graph/source/Component.ts":
/*!***************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-graph/source/Component.ts ***!
  \***************************************************************/
/*! exports provided: types, Node, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Component; });
/* harmony import */ var _ff_core_Publisher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/Publisher */ "../../libs/ff-core/source/Publisher.ts");
/* harmony import */ var _Property__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Property */ "../../libs/ff-graph/source/Property.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "types", function() { return _Property__WEBPACK_IMPORTED_MODULE_1__["types"]; });

/* harmony import */ var _PropertyGroup__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PropertyGroup */ "../../libs/ff-graph/source/PropertyGroup.ts");
/* harmony import */ var _ComponentTracker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ComponentTracker */ "../../libs/ff-graph/source/ComponentTracker.ts");
/* harmony import */ var _ComponentReference__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ComponentReference */ "../../libs/ff-graph/source/ComponentReference.ts");
/* harmony import */ var _Node__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Node */ "../../libs/ff-graph/source/Node.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Node", function() { return _Node__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */






////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
/**
 * Base class for components in a node-component system.
 *
 * ### Events
 * - *"change"* - emits [[IComponentChangeEvent]] after the component's state (except changed properties) has changed.
 * - *"update"* - emitted after the component has been updated due to changed properties.
 * - *"dispose"* - emits [[IComponentDisposeEvent]] if the component is about to be disposed.
 *
 * ### See also
 * - [[ComponentTracker]]
 * - [[ComponentLink]]
 * - [[ComponentType]]
 * - [[ComponentOrType]]
 * - [[Node]]
 * - [[Graph]]
 * - [[System]]
 */
class Component extends _ff_core_Publisher__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Protected constructor. Use [[Node.createComponent]] to create component instances.
     * @param node Node to attach the new component to.
     * @param id Unique id for the component.
     *
     * Note that during execution of the constructor, you have access to the component's
     * node, graph, and system. The component has not yet been advertised to other components though.
     */
    constructor(node, id) {
        super({ knownEvents: false });
        this.ins = new _PropertyGroup__WEBPACK_IMPORTED_MODULE_2__["default"](this);
        this.outs = new _PropertyGroup__WEBPACK_IMPORTED_MODULE_2__["default"](this);
        this.changed = true;
        this.updated = false;
        this._name = "";
        this._tags = new Set();
        this._trackers = [];
        this.node = node;
        this.id = id;
    }
    static getTypeName(scope) {
        return typeof scope === "function" ? scope.typeName : (typeof scope === "object"
            ? scope.constructor.typeName : (scope || Component.typeName));
    }
    /**
     * Called after the component has been constructed and attached to a node.
     * Override to perform initialization tasks where you need access to other components.
     */
    create() {
        this.node._addComponent(this);
        // if graph is active, activate component
        if (this.graph.isActive && this.activate) {
            this.activate();
        }
    }
    /**
     * Removes the component from its node and deletes it.
     * Override to perform cleanup tasks (remove event listeners, etc.).
     * Must call super implementation if overridden!
     */
    dispose() {
        // deactivate component if graph is active
        if (this.graph.isActive && this.deactivate) {
            this.deactivate();
        }
        // emit dispose event
        this.emit({ type: "dispose", component: this });
        // remove all links and trackers
        this.ins.dispose();
        this.outs.dispose();
        this._trackers.forEach(tracker => tracker.dispose());
        // remove component from node
        if (this.node) {
            this.node._removeComponent(this);
            // TODO: debug only
            this.node = null;
        }
    }
    /**
     * True if the component is a node singleton, i.e. can only be added once per node.
     */
    get isNodeSingleton() {
        return this.constructor.isNodeSingleton;
    }
    /**
     * True if the component is a graph singleton, i.e. can only be added once per graph.
     */
    get isGraphSingleton() {
        return this.constructor.isGraphSingleton;
    }
    /**
     * True if the component is a system singleton, i.e. can only be added once per system.
     */
    get isSystemSingleton() {
        return this.constructor.isSystemSingleton;
    }
    /**
     * Returns the type name of this component.
     * @returns {string}
     */
    get typeName() {
        return this.constructor.typeName;
    }
    get displayTypeName() {
        const typeName = this.typeName;
        return typeName === "Component" ? typeName : typeName.substr(1);
    }
    get text() {
        return this.constructor.text;
    }
    get icon() {
        return this.constructor.icon;
    }
    /**
     * Returns the name of this component.
     */
    get name() {
        return this._name;
    }
    get displayName() {
        return this._name || this.text || this.displayTypeName;
    }
    /**
     * Sets the name of this component.
     * This emits an [[IComponentChangeEvent]].
     * @param value
     */
    set name(value) {
        this._name = value;
        this.emit({ type: "change", component: this, what: "name" });
    }
    /**
     * Returns the set of tags this component is associated with.
     */
    get tags() {
        return this._tags;
    }
    /**
     * Adds a tag to this component. Adding a tag that already exists has no effect.
     * @param tag The tag name. Valid tag names are all non-empty strings except "tag".
     */
    addTag(tag) {
        if (!this._tags.has(tag)) {
            this._tags.add(tag);
            this.node._addComponentTag(tag, this);
        }
    }
    /**
     * Removes a tag from this component. Removing a non-existing tag has no effect.
     * @param tag The tag name. Valid tag names are all non-empty strings except "tag".
     */
    removeTag(tag) {
        if (this._tags.has(tag)) {
            this._tags.delete(tag);
            this.node._removeComponentTag(tag, this);
        }
    }
    /**
     * Returns the graph this component and its node belong to.
     */
    get graph() {
        return this.node.graph;
    }
    /**
     * Returns the system this component and its node belong to.
     */
    get system() {
        return this.node.system;
    }
    /**
     * Returns the set of sibling components of this component.
     * Sibling components are components belonging to the same node.
     */
    get components() {
        return this.node.components;
    }
    /**
     * Returns true if the component's graph is active.
     */
    get isActive() {
        return this.graph.isActive;
    }
    getComponent(componentOrType, nothrow = false) {
        return this.node.components.get(componentOrType, nothrow);
    }
    getComponents(componentOrType) {
        return this.node.components.getArray(componentOrType);
    }
    getComponentsByTag(tag) {
        return this.node.components.getByTag(tag);
    }
    createComponent(componentOrType) {
        return this.node.createComponent(componentOrType);
    }
    getOrCreateComponent(componentOrType) {
        return this.node.components.get(componentOrType, true) || this.node.createComponent(componentOrType);
    }
    hasComponent(componentOrType) {
        return this.node.components.has(componentOrType);
    }
    getGraphComponent(componentOrType, nothrow = false) {
        return this.node.graph.components.get(componentOrType, nothrow);
    }
    getGraphComponents(componentOrType) {
        return this.node.graph.components.getArray(componentOrType);
    }
    getGraphComponentsByTag(tag) {
        return this.node.graph.components.getByTag(tag);
    }
    hasGraphComponent(componentOrType) {
        return this.node.graph.components.has(componentOrType);
    }
    getMainComponent(componentOrType, nothrow = false) {
        return this.node.system.graph.components.get(componentOrType, nothrow);
    }
    getMainComponents(componentOrType) {
        return this.node.system.graph.components.getArray(componentOrType);
    }
    getMainComponentsByTag(tag) {
        return this.node.system.graph.components.getByTag(tag);
    }
    hasMainComponent(componentOrType) {
        return this.node.system.graph.components.has(componentOrType);
    }
    getSystemComponent(componentOrType, nothrow = false) {
        return this.node.system.components.get(componentOrType, nothrow);
    }
    getSystemComponents(componentOrType) {
        return this.node.system.components.getArray(componentOrType);
    }
    getSystemComponentsByTag(tag) {
        return this.node.system.components.getByTag(tag);
    }
    hasSystemComponent(componentOrType) {
        return this.node.system.components.has(componentOrType);
    }
    getComponentById(id) {
        return this.node.system.components.getById(id);
    }
    getNode(nodeOrType, nothrow = false) {
        return this.node.graph.nodes.get(nodeOrType, nothrow);
    }
    getNodes(nodeOrType) {
        return this.node.graph.nodes.getArray(nodeOrType);
    }
    getNodesByTag(tag) {
        return this.node.graph.nodes.getByTag(tag);
    }
    hasNode(nodeOrType) {
        return this.node.graph.nodes.has(nodeOrType);
    }
    getMainNode(nodeOrType, nothrow = false) {
        return this.node.system.graph.nodes.get(nodeOrType, nothrow);
    }
    getMainNodes(nodeOrType) {
        return this.node.system.graph.nodes.getArray(nodeOrType);
    }
    getMainNodesByTag(tag) {
        return this.node.system.graph.nodes.getByTag(tag);
    }
    hasMainNode(nodeOrType) {
        return this.node.system.graph.nodes.has(nodeOrType);
    }
    getSystemNode(nodeOrType, nothrow = false) {
        return this.node.system.nodes.get(nodeOrType, nothrow);
    }
    getSystemNodes(nodeOrType) {
        return this.node.system.nodes.getArray(nodeOrType);
    }
    getSystemNodesByTag(tag) {
        return this.node.system.nodes.getByTag(tag);
    }
    hasSystemNode(nodeOrType) {
        return this.node.system.nodes.has(nodeOrType);
    }
    getNodeById(id) {
        return this.node.system.nodes.getById(id);
    }
    activate() {
    }
    /**
     * Called during each cycle if the component's input properties have changed.
     * Override to update the status of the component based on the input properties.
     * @param context Information about the current update cycle.
     * @returns True if the state of the component has changed.
     */
    update(context) {
        throw new Error("this should never be called");
    }
    /**
     * Called during each cycle, after the component has been updated.
     * Override to let the component perform regular tasks.
     * @param context Information about the current update cycle.
     * @returns True if the state of the component has changed.
     */
    tick(context) {
        throw new Error("this should never be called");
    }
    /**
     * Called after rendering is completed.
     * Override to perform update operations which need to happen
     * only after all rendering is done.
     * @param context Information about the current update cycle.
     * @returns True if the state of the component has changed.
     */
    tock(context) {
        throw new Error("this should never be called");
    }
    deactivate() {
    }
    requestSort() {
        this.graph.requestSort();
    }
    /**
     * Returns true if this component has or inherits from the given type.
     * @param scope
     */
    is(scope) {
        const typeName = Component.getTypeName(scope);
        let prototype = this;
        do {
            prototype = Object.getPrototypeOf(prototype);
            if (prototype.constructor.typeName === typeName) {
                return true;
            }
        } while (prototype.constructor.typeName !== Component.typeName);
        return false;
    }
    /**
     * Removes links from all input and output properties.
     */
    unlinkAllProperties() {
        this.ins.unlinkAllProperties();
        this.outs.unlinkAllProperties();
    }
    /**
     * Sets the changed flags of this component and of all input properties to false;
     */
    resetChanged() {
        this.changed = false;
        const ins = this.ins.properties;
        for (let i = 0, n = ins.length; i < n; ++i) {
            ins[i].changed = false;
        }
        const outs = this.outs.properties;
        for (let i = 0, n = outs.length; i < n; ++i) {
            outs[i].changed = false;
        }
    }
    /**
     * Tracks the given component type. If a component of this type is added
     * to or removed from the node, it will be added or removed from the tracker.
     * @param {ComponentOrType} componentOrType
     * @param {(component: T) => void} didAdd
     * @param {(component: T) => void} willRemove
     */
    trackComponent(componentOrType, didAdd, willRemove) {
        const tracker = new _ComponentTracker__WEBPACK_IMPORTED_MODULE_3__["default"](this.node.components, componentOrType, didAdd, willRemove);
        this._trackers.push(tracker);
        return tracker;
    }
    /**
     * Returns a weak reference to a component.
     * The reference is set to null after the linked component is removed.
     * @param componentOrType The type of component this reference accepts, or the component to link.
     */
    referenceComponent(componentOrType) {
        return new _ComponentReference__WEBPACK_IMPORTED_MODULE_4__["default"](this.system, componentOrType);
    }
    /**
     * Returns a text representation of the component.
     * @returns {string}
     */
    toString() {
        return `${this.typeName}${this.name ? " (" + this.name + ")" : ""}`;
    }
    dump(indent = "") {
        console.log(indent + `%cComponent '${this.typeName}' (${this.displayName})`, "color: green");
        this.ins.properties.forEach(prop => prop.dump(indent + "  IN  "));
        this.outs.properties.forEach(prop => prop.dump(indent + "  OUT "));
    }
    toJSON() {
        let json = {};
        const jsonIns = this.ins.toJSON();
        if (jsonIns) {
            json.ins = jsonIns;
        }
        const jsonOuts = this.outs.toJSON();
        if (jsonOuts) {
            json.outs = jsonOuts;
        }
        return json;
    }
    fromJSON(json) {
        if (json.ins) {
            this.ins.fromJSON(json.ins);
        }
        if (json.outs) {
            this.outs.fromJSON(json.outs);
        }
    }
    referencesFromJSON(json) {
        const dict = this.system.components.getDictionary();
        if (json.ins) {
            this.ins.linksFromJSON(json.ins, dict);
        }
        if (json.outs) {
            this.outs.linksFromJSON(json.outs, dict);
        }
    }
    addCustomInput(path, schema, index) {
        this.changed = true;
        return this.ins.createCustomProperty(path, schema, index);
    }
    allowCustomInput(schema) {
        return false;
    }
    addCustomOutput(path, schema, index) {
        return this.outs.createCustomProperty(path, schema, index);
    }
    allowCustomOutput(schema) {
        return false;
    }
    /**
    * Adds input properties to the component, specified by the provided property templates.
    * @param templates A plain object with property templates.
    * @param index Optional index at which to insert the new properties.
    */
    addInputs(templates, index) {
        return this.ins.createProperties(templates, index);
    }
    /**
     * Adds output properties to the component, specified by the provided property templates.
     * @param templates A plain object with property templates.
     * @param index Optional index at which to insert the new properties.
     */
    addOutputs(templates, index) {
        return this.outs.createProperties(templates, index);
    }
}
Component.typeName = "Component";
Component.text = "";
Component.icon = "";
Component.isNodeSingleton = true;
Component.isGraphSingleton = false;
Component.isSystemSingleton = false;
Component.prototype.activate = null;
Component.prototype.update = null;
Component.prototype.tick = null;
Component.prototype.tock = null;
Component.prototype.deactivate = null;


/***/ }),

/***/ "../../libs/ff-graph/source/ComponentReference.ts":
/*!************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-graph/source/ComponentReference.ts ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ComponentReference; });
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component */ "../../libs/ff-graph/source/Component.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */

////////////////////////////////////////////////////////////////////////////////
/**
 * Maintains a weak reference to a component.
 * The reference is set to null after the linked component is removed.
 */
class ComponentReference {
    constructor(system, scope) {
        this._typeName = scope ? _Component__WEBPACK_IMPORTED_MODULE_0__["default"].getTypeName(scope) : null;
        this._id = scope instanceof _Component__WEBPACK_IMPORTED_MODULE_0__["default"] ? scope.id : undefined;
        this._system = system;
    }
    get component() {
        return this._id ? this._system.components.getById(this._id) || null : null;
    }
    set component(component) {
        if (component && this._typeName && !(component instanceof this._system.registry.getType(this._typeName))) {
            throw new Error(`can't assign component of class '${component.constructor.name || "unknown"}' to link of class '${this._typeName}'`);
        }
        this._id = component ? component.id : undefined;
    }
}


/***/ }),

/***/ "../../libs/ff-graph/source/ComponentTracker.ts":
/*!**********************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-graph/source/ComponentTracker.ts ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ComponentTracker; });
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component */ "../../libs/ff-graph/source/Component.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */

////////////////////////////////////////////////////////////////////////////////
/**
 * Tracks components of a specific type in the same node.
 * Maintains a reference to the component if found and executes
 * callbacks if the component of the tracked type is added or removed.
 */
class ComponentTracker {
    constructor(registry, scope, didAdd, willRemove) {
        this.typeName = _Component__WEBPACK_IMPORTED_MODULE_0__["default"].getTypeName(scope);
        this.didAdd = didAdd;
        this.willRemove = willRemove;
        this._registry = registry;
        registry.on(this.typeName, this.onComponent, this);
        this.component = registry.get(scope, true);
        if (this.component && didAdd) {
            didAdd(this.component);
        }
    }
    dispose() {
        this._registry.off(this.typeName, this.onComponent, this);
        this.component = null;
        this.didAdd = null;
        this.willRemove = null;
    }
    onComponent(event) {
        if (event.add) {
            this.component = event.object;
            this.didAdd && this.didAdd(event.object);
        }
        else if (event.remove) {
            this.willRemove && this.willRemove(event.object);
            this.component = null;
        }
    }
}


/***/ }),

/***/ "../../libs/ff-graph/source/Graph.ts":
/*!***********************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-graph/source/Graph.ts ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Graph; });
/* harmony import */ var _ff_core_uniqueId__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/uniqueId */ "../../libs/ff-core/source/uniqueId.ts");
/* harmony import */ var _ff_core_Publisher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/core/Publisher */ "../../libs/ff-core/source/Publisher.ts");
/* harmony import */ var _LinkableSorter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LinkableSorter */ "../../libs/ff-graph/source/LinkableSorter.ts");
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Node */ "../../libs/ff-graph/source/Node.ts");
/* harmony import */ var _ff_core_ObjectRegistry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ff/core/ObjectRegistry */ "../../libs/ff-core/source/ObjectRegistry.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */






////////////////////////////////////////////////////////////////////////////////
/**
 * Graph in a graph/node/component system. A graph contains a collection of nodes.
 * Graphs can be nested, i.e. a graph can be a subgraph of another graph, the parent graph.
 *
 * ### See also
 * - [[Component]]
 * - [[Node]]
 * - [[System]]
 */
class Graph extends _ff_core_Publisher__WEBPACK_IMPORTED_MODULE_1__["default"] {
    /**
     * Creates a new graph instance.
     * @param system System this graph belongs to.
     * @param parent Optional parent component of this graph.
     */
    constructor(system, parent) {
        super({ knownEvents: false });
        /** Collection of all nodes in this graph. */
        this.nodes = new _ff_core_ObjectRegistry__WEBPACK_IMPORTED_MODULE_5__["default"](_Node__WEBPACK_IMPORTED_MODULE_4__["default"]);
        /** Collection of all components in this graph. */
        this.components = new _ff_core_ObjectRegistry__WEBPACK_IMPORTED_MODULE_5__["default"](_Component__WEBPACK_IMPORTED_MODULE_3__["default"]);
        /** List of root hierarchy components in this graph. */
        this.roots = [];
        this._sorter = new _LinkableSorter__WEBPACK_IMPORTED_MODULE_2__["default"]();
        this._sortRequested = true;
        this._sortedList = null;
        this._tockList = [];
        this._isActive = false;
        this.system = system;
        this.parent = parent;
    }
    get isActive() {
        return this._isActive;
    }
    getComponent(componentOrType, nothrow = false) {
        return this.components.get(componentOrType, nothrow);
    }
    getComponents(componentOrType) {
        return this.components.getArray(componentOrType);
    }
    getComponentsByTag(tag) {
        return this.components.getByTag(tag);
    }
    hasComponent(componentOrType) {
        return this.components.has(componentOrType);
    }
    getMainComponent(componentOrType, nothrow = false) {
        return this.system.graph.components.get(componentOrType, nothrow);
    }
    getMainComponents(componentOrType) {
        return this.system.graph.components.getArray(componentOrType);
    }
    getMainComponentsByTag(tag) {
        return this.system.graph.components.getByTag(tag);
    }
    hasMainComponent(componentOrType) {
        return this.system.graph.components.has(componentOrType);
    }
    getSystemComponent(componentOrType, nothrow = false) {
        return this.system.components.get(componentOrType, nothrow);
    }
    getSystemComponents(componentOrType) {
        return this.system.components.getArray(componentOrType);
    }
    getSystemComponentsByTag(tag) {
        return this.system.components.getByTag(tag);
    }
    hasSystemComponent(componentOrType) {
        return this.system.components.has(componentOrType);
    }
    getComponentById(id) {
        return this.system.components.getById(id);
    }
    getNode(nodeOrType, nothrow = false) {
        return this.nodes.get(nodeOrType, nothrow);
    }
    getNodes(nodeOrType) {
        return this.nodes.getArray(nodeOrType);
    }
    getNodesByTag(tag) {
        return this.nodes.getByTag(tag);
    }
    hasNode(nodeOrType) {
        return this.nodes.has(nodeOrType);
    }
    getMainNode(nodeOrType, nothrow = false) {
        return this.system.graph.nodes.get(nodeOrType, nothrow);
    }
    getMainNodes(nodeOrType) {
        return this.system.graph.nodes.getArray(nodeOrType);
    }
    getMainNodesByTag(tag) {
        return this.system.graph.nodes.getByTag(tag);
    }
    hasMainNode(nodeOrType) {
        return this.system.graph.nodes.has(nodeOrType);
    }
    getSystemNode(nodeOrType, nothrow = false) {
        return this.system.nodes.get(nodeOrType, nothrow);
    }
    getSystemNodes(nodeOrType) {
        return this.system.nodes.getArray(nodeOrType);
    }
    getSystemNodesByTag(tag) {
        return this.system.nodes.getByTag(tag);
    }
    hasSystemNode(nodeOrType) {
        return this.system.nodes.has(nodeOrType);
    }
    getNodeById(id) {
        return this.system.nodes.getById(id);
    }
    /**
     * Calls activate() on all components in the graph.
     * This is done before any calls to update(), tick(), and tock().
     */
    activate() {
        if (this._isActive) {
            return;
        }
        this._isActive = true;
        if (this._sortRequested) {
            this._sortRequested = false;
            this.sort();
        }
        const components = this._sortedList;
        for (let i = 0, n = components.length; i < n; ++i) {
            const component = components[i];
            if (component.activate) {
                component.activate();
            }
        }
    }
    /**
     * Calls deactivate() on all components in the graph.
     * After a call to deactivate, there are no more calls to update(), tick(), tock().
     */
    deactivate() {
        if (!this._isActive) {
            return;
        }
        this._isActive = false;
        const components = this._sortedList;
        for (let i = 0, n = components.length; i < n; ++i) {
            const component = components[i];
            if (component.deactivate) {
                component.deactivate();
            }
        }
    }
    /**
     * Called at the begin of each frame cycle. Calls update() on all components
     * in the graph whose changed flag is set, then calls tick() on all components.
     * Returns true if at least one component changed its state.
     * @param context Context-specific information such as time, etc.
     * @returns true if at least one component was updated.
     */
    tick(context) {
        if (!this._isActive) {
            return;
        }
        if (this._sortRequested) {
            this._sortRequested = false;
            this.sort();
        }
        // call update on components in topological sort order
        const components = this._sortedList;
        let updated = false;
        for (let i = 0, n = components.length; i < n; ++i) {
            const component = components[i];
            component.updated = false;
            if (component.changed) {
                if (component.update && component.update(context)) {
                    component.updated = true;
                }
                if (component.tick && component.tick(context)) {
                    component.updated = true;
                }
                component.resetChanged();
            }
            else if (component.tick && component.tick(context)) {
                component.updated = true;
            }
            if (component.updated) {
                updated = true;
                component.emit("update");
            }
        }
        return updated;
    }
    /**
     * Calls tock() on all components in the graph.
     * The tock() call happens at the end of a frame cycle.
     * @param context Context-specific information such as time, etc.
     * @returns true if at least one component was updated.
     */
    tock(context) {
        if (!this._isActive) {
            return;
        }
        const components = this._tockList;
        let updated = false;
        for (let i = 0, n = components.length; i < n; ++i) {
            updated = components[i].tock(context) || updated;
        }
        return updated;
    }
    /**
     * Removes all content, i.e. all nodes and components from the graph.
     */
    clear() {
        const nodes = this.nodes.cloneArray().reverse();
        for (let i = 0, n = nodes.length; i < n; ++i) {
            nodes[i].dispose();
        }
        if (this.nodes.length > 0) {
            throw new Error("graph not empty");
        }
    }
    /**
     * Requests a topological sort of the list of components based on how they are interlinked.
     * The sort is executed before the next update.
     */
    requestSort() {
        this._sortRequested = true;
    }
    sort() {
        this._sortedList = this._sorter.sort(this.components.getArray());
        const name = this.parent ? this.parent.name || this.parent.typeName : "System";
        if (true) {
            console.log("Graph.sort - %s: sorted %s components", name, this._sortedList.length);
            //this._sortedList.forEach((comp, index) => console.log("#%s - %s (node: %s)", index, comp.displayName, comp.node.displayName));
        }
    }
    /**
     * Creates a new node of the given type. Adds it to the graph.
     * @param nodeOrType Type of the node to create.
     * @param name Optional name for the node.
     * @param id Optional unique identifier for the node (must omit unless serializing).
     */
    createCustomNode(nodeOrType, name, id) {
        const type = this.system.registry.getType(nodeOrType);
        if (!type) {
            throw new Error(`node type '${_Node__WEBPACK_IMPORTED_MODULE_4__["default"].getTypeName(nodeOrType)}' not registered`);
        }
        const node = new type(this, id || Object(_ff_core_uniqueId__WEBPACK_IMPORTED_MODULE_0__["default"])(12, this.system.nodes.getDictionary()));
        node.create();
        if (name) {
            node.name = name;
        }
        if (!id) {
            // only if we're not serializing
            node.createComponents();
            // TODO: Temporarily disabled
            node.unlock();
            // prohibit adding/removing components
            //node.lock();
        }
        return node;
    }
    /**
     * Creates a new, plain, empty node (of base type [[Node]]). Adds it to the graph.
     * @param name Optional name for the node.
     * @param id Optional unique identifier for the node (must omit unless serializing).
     */
    createNode(name, id) {
        const node = new _Node__WEBPACK_IMPORTED_MODULE_4__["default"](this, id || Object(_ff_core_uniqueId__WEBPACK_IMPORTED_MODULE_0__["default"])(12, this.system.nodes.getDictionary()));
        node.create();
        if (name) {
            node.name = name;
        }
        // allow adding/removing components
        node.unlock();
        return node;
    }
    findNodeByName(name, nodeOrType) {
        const nodes = this.nodes.getArray(nodeOrType);
        for (let i = 0, n = nodes.length; i < n; ++i) {
            if (nodes[i].name === name) {
                return nodes[i];
            }
        }
        return undefined;
    }
    findRootNodes(nodeOrType) {
        const nodes = this.nodes.getArray(nodeOrType);
        const result = [];
        for (let i = 0, n = nodes.length; i < n; ++i) {
            const hierarchy = nodes[i].components.get("CHierarchy", true);
            if (!hierarchy || !hierarchy.parent) {
                result.push(nodes[i]);
            }
        }
        return result;
    }
    /**
     * Returns a text representation of the graph.
     * @param verbose
     */
    toString(verbose = false) {
        const nodes = this.nodes.getArray();
        const numComponents = this.components.count();
        const text = `Graph - ${nodes.length} nodes, ${numComponents} components.`;
        if (verbose) {
            return text + "\n" + nodes.map(node => node.toString(true)).join("\n");
        }
        return text;
    }
    dump(indent = "") {
        console.log(indent + "%cGraph", "color: red");
        const roots = this.findRootNodes();
        roots.forEach(node => node.dump(indent + "  "));
    }
    /**
     * Serializes the graph, its nodes and components.
     * Returns graph serialization data, which must be cloned or stringified immediately.
     */
    toJSON() {
        const json = {};
        const jsonNodes = [];
        const nodes = this.nodes.getArray();
        for (let i = 0, n = nodes.length; i < n; ++i) {
            const node = nodes[i];
            const jsonNode = this.nodeToJSON(node);
            jsonNode.type = node.typeName;
            jsonNode.id = node.id;
            if (node.name) {
                jsonNode.name = node.name;
            }
            jsonNodes.push(jsonNode);
        }
        if (jsonNodes.length > 0) {
            json.nodes = jsonNodes;
        }
        return json;
    }
    /**
     * Deserializes the graph, its nodes and components.
     * @param json serialized graph data.
     */
    fromJSON(json) {
        if (json.nodes) {
            json.nodes.forEach(jsonNode => {
                const node = this.createCustomNode(jsonNode.type, jsonNode.name, jsonNode.id);
                node.fromJSON(jsonNode);
            });
            // deserialize references between graphs, nodes, and components
            json.nodes.forEach(jsonNode => {
                const node = this.nodes.getById(jsonNode.id);
                node.referencesFromJSON(jsonNode);
            });
        }
    }
    /**
     * Override to control how nodes are serialized.
     * Return serialization data or null if the node should be excluded from serialization.
     * @param node The node to be serialized.
     */
    nodeToJSON(node) {
        return node.toJSON();
    }
    /**
     * Adds a node to the graph and the system. Called by [[Node.attach]], do not call directly.
     * @param node
     * @private
     */
    _addNode(node) {
        this.nodes.add(node);
        this.system._addNode(node);
    }
    /**
     * Removes a node from the graph and the system. Called by [[Node.detach]], do not call directly.
     * @param node
     * @private
     */
    _removeNode(node) {
        this.system._removeNode(node);
        this.nodes.remove(node);
    }
    /**
     * Registers a node with a given tag.
     * @param tag
     * @param node
     * @private
     */
    _addNodeTag(tag, node) {
        this.nodes.addByTag(tag, node);
        this.system._addNodeTag(tag, node);
    }
    /**
     * Unregisters a node from a given tag.
     * @param tag
     * @param node
     * @private
     */
    _removeNodeTag(tag, node) {
        this.system._removeNodeTag(tag, node);
        this.nodes.removeByTag(tag, node);
    }
    /**
     * Adds a component to the graph and the system. Called by [[Component.attach]], do not call directly.
     * @param component
     * @private
     */
    _addComponent(component) {
        if (component.isGraphSingleton && this.components.has(component)) {
            throw new Error(`only one component of type '${component.typeName}' allowed per graph`);
        }
        this.components.add(component);
        this.system._addComponent(component);
        if (component.tock) {
            this._tockList.push(component);
        }
        this._sortRequested = true;
    }
    /**
     * Removes a component from the graph and the system. Called by [[Component.dispose]], do not call directly.
     * @param component
     * @private
     */
    _removeComponent(component) {
        this.system._removeComponent(component);
        this.components.remove(component);
        if (component.tock) {
            this._tockList.splice(this._tockList.indexOf(component), 1);
        }
        this._sortRequested = true;
    }
    /**
     * Registers a component with a given tag.
     * @param tag
     * @param component
     * @private
     */
    _addComponentTag(tag, component) {
        this.components.addByTag(tag, component);
        this.system._addComponentTag(tag, component);
    }
    /**
     * Unregisters a component from a given tag.
     * @param tag
     * @param component
     * @private
     */
    _removeComponentTag(tag, component) {
        this.system._removeComponentTag(tag, component);
        this.components.removeByTag(tag, component);
    }
    _addRoot(component) {
        this.roots.push(component);
        if (this.parent) {
            this.parent.onAddInnerRoot(component);
        }
    }
    _removeRoot(component) {
        if (this.parent) {
            this.parent.onRemoveInnerRoot(component);
        }
        this.roots.splice(this.roots.indexOf(component), 1);
    }
}


/***/ }),

/***/ "../../libs/ff-graph/source/LinkableSorter.ts":
/*!********************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-graph/source/LinkableSorter.ts ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LinkableSorter; });
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
////////////////////////////////////////////////////////////////////////////////
/**
 * Sorts an array of [[ILinkable]] such that if a is linked to b, a comes before b.
 */
class LinkableSorter {
    constructor() {
        this.visited = {};
        this.visiting = {};
        this.sorted = [];
    }
    sort(linkables) {
        for (let i = 0, n = linkables.length; i < n; ++i) {
            this.visit(linkables[i]);
        }
        const sorted = this.sorted;
        this.visited = {};
        this.visiting = {};
        this.sorted = [];
        return sorted;
    }
    visit(linkable) {
        const visited = this.visited;
        const visiting = this.visiting;
        if (visited[linkable.id] || visiting[linkable.id]) {
            return;
        }
        visiting[linkable.id] = true;
        // for each in/out property, follow all outgoing links
        const outProps = linkable.outs.properties.concat(linkable.ins.properties);
        for (let i0 = 0, n0 = outProps.length; i0 < n0; ++i0) {
            const outLinks = outProps[i0].outLinks;
            for (let i1 = 0, n1 = outLinks.length; i1 < n1; ++i1) {
                const ins = outLinks[i1].destination.group;
                // follow outgoing links at input properties
                const inProps = ins.properties;
                for (let i2 = 0, n2 = inProps.length; i2 < n2; ++i2) {
                    const links = inProps[i2].outLinks;
                    for (let i3 = 0, n3 = links.length; i3 < n3; ++i3) {
                        const linkedIns = links[i3].destination.group;
                        this.visit(linkedIns.linkable);
                    }
                }
                this.visit(ins.linkable);
            }
        }
        visiting[linkable.id] = undefined;
        visited[linkable.id] = true;
        this.sorted.unshift(linkable);
    }
}


/***/ }),

/***/ "../../libs/ff-graph/source/Node.ts":
/*!**********************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-graph/source/Node.ts ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Node; });
/* harmony import */ var _ff_core_uniqueId__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/uniqueId */ "../../libs/ff-core/source/uniqueId.ts");
/* harmony import */ var _ff_core_Publisher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/core/Publisher */ "../../libs/ff-core/source/Publisher.ts");
/* harmony import */ var _ff_core_ObjectRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/core/ObjectRegistry */ "../../libs/ff-core/source/ObjectRegistry.ts");
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Component */ "../../libs/ff-graph/source/Component.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */




/**
 * Node in an graph/node/component system.
 *
 * ### Events
 * - *"change"* - emits [[INodeChangeEvent]] after the node's state has changed.
 * - *"dispose"* - emits [[INodeDisposeEvent]] if the node is about to be disposed.
 *
 * ### See also
 * - [[Component]]
 * - [[Graph]]
 * - [[System]]
 */
class Node extends _ff_core_Publisher__WEBPACK_IMPORTED_MODULE_1__["default"] {
    /**
     * Protected constructor. Please use [[Graph.createNode]] / [[Graph.createCustomNode]] to create node instances.
     * @param graph
     * @param id Unique id for the node. A unique id is usually created automatically,
     * do not specify except while de-serializing the component.
     *
     * Note that during execution of the constructor, the node is not yet attached to a graph/system.
     * Do not try to get access to other nodes, components, the parent graph, or the system here.
     */
    constructor(graph, id) {
        super({ knownEvents: false });
        this.graph = null;
        /** Collection of all components in this node. */
        this.components = new _ff_core_ObjectRegistry__WEBPACK_IMPORTED_MODULE_2__["default"](_Component__WEBPACK_IMPORTED_MODULE_3__["default"]);
        this._name = "";
        this._tags = new Set();
        this._isLocked = undefined;
        this.graph = graph;
        this.id = id;
    }
    static getTypeName(scope) {
        return typeof scope === "function" ? scope.typeName : (typeof scope === "object"
            ? scope.constructor.typeName : (scope || Node.typeName));
    }
    /**
     * Returns the class name of this node.
     */
    get typeName() {
        return this.constructor.typeName;
    }
    get displayTypeName() {
        const typeName = this.typeName;
        return typeName === "Node" ? typeName : typeName.substr(1);
    }
    get isLocked() {
        return this._isLocked;
    }
    get text() {
        return this.constructor.text;
    }
    get icon() {
        return this.constructor.icon;
    }
    /**
     * Returns the name of this node.
     */
    get name() {
        return this._name;
    }
    get displayName() {
        return this._name || this.text || this.displayTypeName;
    }
    /**
     * Sets the name of this node.
     * This emits an [[INodeChangeEvent]]
     * @param value
     */
    set name(value) {
        this._name = value;
        this.emit({ type: "change", what: "name", node: this });
    }
    /**
     * Returns the set of tags this node is associated with.
     */
    get tags() {
        return this._tags;
    }
    /**
     * Adds a tag to this node. Adding a tag that already exists has no effect.
     * @param tag The tag name. Valid tag names are all non-empty strings except "tag".
     */
    addTag(tag) {
        if (!this._tags.has(tag)) {
            this._tags.add(tag);
            this.graph._addNodeTag(tag, this);
        }
    }
    /**
     * Removes a tag from this node. Removing a non-existing tag has no effect.
     * @param tag The tag name. Valid tag names are all non-empty strings except "tag".
     */
    removeTag(tag) {
        if (this._tags.has(tag)) {
            this._tags.delete(tag);
            this.graph._removeNodeTag(tag, this);
        }
    }
    /**
     * Returns the system this node and its graph belong to.
     */
    get system() {
        return this.graph.system;
    }
    getComponent(componentOrType, nothrow = false) {
        return this.components.get(componentOrType, nothrow);
    }
    getComponents(componentOrType) {
        return this.components.getArray(componentOrType);
    }
    getComponentsByTag(tag) {
        return this.components.getByTag(tag);
    }
    getOrCreateComponent(componentOrType) {
        return this.components.get(componentOrType, true) || this.createComponent(componentOrType);
    }
    hasComponent(componentOrType) {
        return this.components.has(componentOrType);
    }
    getGraphComponent(componentOrType, nothrow = false) {
        return this.graph.components.get(componentOrType, nothrow);
    }
    getGraphComponents(componentOrType) {
        return this.graph.components.getArray(componentOrType);
    }
    getGraphComponentsByTag(tag) {
        return this.graph.components.getByTag(tag);
    }
    hasGraphComponent(componentOrType) {
        return this.graph.components.has(componentOrType);
    }
    getMainComponent(componentOrType, nothrow = false) {
        return this.graph.system.graph.components.get(componentOrType, nothrow);
    }
    getMainComponents(componentOrType) {
        return this.graph.system.graph.components.getArray(componentOrType);
    }
    getMainComponentsByTag(tag) {
        return this.graph.system.graph.components.getByTag(tag);
    }
    hasMainComponent(componentOrType) {
        return this.graph.system.graph.components.has(componentOrType);
    }
    getSystemComponent(componentOrType, nothrow = false) {
        return this.graph.system.components.get(componentOrType, nothrow);
    }
    getSystemComponents(componentOrType) {
        return this.graph.system.components.getArray(componentOrType);
    }
    getSystemComponentsByTag(tag) {
        return this.graph.system.components.getByTag(tag);
    }
    hasSystemComponent(componentOrType) {
        return this.graph.system.components.has(componentOrType);
    }
    getComponentById(id) {
        return this.graph.system.components.getById(id);
    }
    getNode(nodeOrType, nothrow = false) {
        return this.graph.nodes.get(nodeOrType, nothrow);
    }
    getNodes(nodeOrType) {
        return this.graph.nodes.getArray(nodeOrType);
    }
    getNodesByTag(tag) {
        return this.graph.nodes.getByTag(tag);
    }
    hasNode(nodeOrType) {
        return this.graph.nodes.has(nodeOrType);
    }
    getMainNode(nodeOrType, nothrow = false) {
        return this.graph.system.graph.nodes.get(nodeOrType, nothrow);
    }
    getMainNodes(nodeOrType) {
        return this.graph.system.graph.nodes.getArray(nodeOrType);
    }
    getMainNodesByTag(tag) {
        return this.graph.system.graph.nodes.getByTag(tag);
    }
    hasMainNode(nodeOrType) {
        return this.graph.system.graph.nodes.has(nodeOrType);
    }
    getSystemNode(nodeOrType, nothrow = false) {
        return this.graph.system.nodes.get(nodeOrType, nothrow);
    }
    getSystemNodes(nodeOrType) {
        return this.graph.system.nodes.getArray(nodeOrType);
    }
    getSystemNodesByTag(tag) {
        return this.graph.system.nodes.getByTag(tag);
    }
    hasSystemNode(nodeOrType) {
        return this.graph.system.nodes.has(nodeOrType);
    }
    getNodeById(id) {
        return this.graph.system.nodes.getById(id);
    }
    lock() {
        if (this._isLocked === false) {
            throw new Error("can't lock an unlocked node again");
        }
        this._isLocked = true;
    }
    unlock() {
        this._isLocked = false;
    }
    /**
     * Adds this node to the given graph and the system.
     */
    create() {
        this.graph._addNode(this);
    }
    /**
     * Override in custom node types to create a predefined set of components.
     * Note that this function is not called if a node is restored from serialization data.
     */
    createComponents() {
    }
    /**
     * Removes all components from this node.
     */
    clear() {
        // dispose components
        const componentList = this.components.getArray().slice();
        componentList.forEach(component => component.dispose());
    }
    /**
     * Must be called to delete/destroy the node. This unregisters the node
     * and all its components from the system.
     */
    dispose() {
        // dispose components
        const componentList = this.components.cloneArray().reverse();
        componentList.forEach(component => component.dispose());
        // emit dispose event
        this.emit({ type: "dispose", node: this });
        // remove node from system and graph
        if (this.graph) {
            this.graph._removeNode(this);
            // TODO: debug only
            this.graph = null;
        }
    }
    /**
     * Creates a new component of the given type. Adds it to this node.
     * @param componentOrType Component constructor, type name, or instance.
     * @param name Optional name for the component.
     * @param id Optional unique identifier for the component (must omit unless serializing).
     */
    createComponent(componentOrType, name, id) {
        if (this._isLocked === true) {
            throw new Error("node is locked, can't create component");
        }
        const type = this.system.registry.getType(componentOrType);
        if (!type) {
            throw new Error(`component type '${_Component__WEBPACK_IMPORTED_MODULE_3__["default"].getTypeName(componentOrType)}' not registered`);
        }
        const component = new type(this, id || Object(_ff_core_uniqueId__WEBPACK_IMPORTED_MODULE_0__["default"])(12, this.system.components.getDictionary()));
        component.create();
        if (name) {
            component.name = name;
        }
        return component;
    }
    /**
     * Tests whether the node is of or descends from the given type.
     * @param scope Node constructor, type name, or instance.
     */
    is(scope) {
        const typeName = Node.getTypeName(scope);
        let prototype = this;
        do {
            prototype = Object.getPrototypeOf(prototype);
            if (prototype.constructor.typeName === typeName) {
                return true;
            }
        } while (prototype.constructor.typeName !== Node.typeName);
        return false;
    }
    /**
     * Returns a text representation of the node.
     * @param verbose
     */
    toString(verbose = false) {
        const components = this.components.getArray();
        const text = `Node '${this.name}' - ${components.length} components`;
        if (verbose) {
            return text + "\n" + components.map(component => "  " + component.toString()).join("\n");
        }
        return text;
    }
    dump(indent = "") {
        console.log(indent + `%cNode '${this.typeName}' (${this.displayName})`, "color: blue");
        this.components.getArray().forEach(comp => comp.dump(indent + "  "));
    }
    /**
     * Serializes the node and its components.
     * Return node serialization data, or null if the node should be excluded from serialization.
     */
    toJSON() {
        const json = {};
        const jsonComponents = [];
        if (this._isLocked) {
            json.locked = true;
        }
        const components = this.components.getArray();
        for (let i = 0, n = components.length; i < n; ++i) {
            const component = components[i];
            const jsonComp = this.componentToJSON(component);
            if (jsonComp) {
                jsonComp.type = component.typeName;
                jsonComp.id = component.id;
                if (component.name) {
                    jsonComp.name = component.name;
                }
                jsonComponents.push(jsonComp);
            }
        }
        if (jsonComponents.length > 0) {
            json.components = jsonComponents;
        }
        return json;
    }
    /**
     * Deserializes the node and its components.
     * @param json serialized node data.
     */
    fromJSON(json) {
        this._isLocked = !!json.locked;
        if (json.components) {
            json.components.forEach(jsonComp => this.componentFromJSON(jsonComp));
        }
    }
    /**
     * Override to control how components are deserialized.
     * @param jsonComp The JSON data for the component to be deserialized.
     */
    componentFromJSON(jsonComp) {
        const component = this.createComponent(jsonComp.type, jsonComp.name, jsonComp.id);
        component.fromJSON(jsonComp);
    }
    /**
     * Deserializes the links of all components.
     * @param json serialized component data.
     */
    referencesFromJSON(json) {
        if (json.components) {
            json.components.forEach(jsonComp => {
                const component = this.components.getById(jsonComp.id);
                component.referencesFromJSON(jsonComp);
            });
        }
    }
    /**
     * Override to control how components are serialized.
     * Return serialization data or null if the component should be excluded from serialization.
     * @param component The component to be serialized.
     */
    componentToJSON(component) {
        return component.toJSON();
    }
    /**
     * Adds a component to the node, the node's graph and the system. Called by [[Component.attach]],
     * do not call directly.
     * @param component
     * @private
     */
    _addComponent(component) {
        if (component.isNodeSingleton && this.components.has(component)) {
            throw new Error(`only one component of type '${component.typeName}' allowed per node`);
        }
        this.components.add(component);
        this.graph._addComponent(component);
    }
    /**
     * Removes a component from the node, the node's graph and the system. Called by [[Component.detach]],
     * do not call directly.
     * @param component
     * @private
     */
    _removeComponent(component) {
        this.graph._removeComponent(component);
        this.components.remove(component);
    }
    _addComponentTag(tag, component) {
        this.components.addByTag(tag, component);
        this.graph._addComponentTag(tag, component);
    }
    _removeComponentTag(tag, component) {
        this.graph._removeComponentTag(tag, component);
        this.components.removeByTag(tag, component);
    }
}
Node.typeName = "Node";
Node.text = "";
Node.icon = "";


/***/ }),

/***/ "../../libs/ff-graph/source/Property.ts":
/*!**************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-graph/source/Property.ts ***!
  \**************************************************************/
/*! exports provided: schemas, types, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Property; });
/* harmony import */ var _ff_core_isSubclass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/isSubclass */ "../../libs/ff-core/source/isSubclass.ts");
/* harmony import */ var _ff_core_Publisher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/core/Publisher */ "../../libs/ff-core/source/Publisher.ts");
/* harmony import */ var _convert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./convert */ "../../libs/ff-graph/source/convert.ts");
/* harmony import */ var _PropertyLink__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PropertyLink */ "../../libs/ff-graph/source/PropertyLink.ts");
/* harmony import */ var _propertyTypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./propertyTypes */ "../../libs/ff-graph/source/propertyTypes.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "schemas", function() { return _propertyTypes__WEBPACK_IMPORTED_MODULE_4__["schemas"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "types", function() { return _propertyTypes__WEBPACK_IMPORTED_MODULE_4__["types"]; });

/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */





/////////////////////////////////////////////////////////////////////////////////

/**
 * Linkable property.
 */
class Property extends _ff_core_Publisher__WEBPACK_IMPORTED_MODULE_1__["default"] {
    /**
     * Creates a new linkable property.
     * @param path Name and group(s) the property is displayed under.
     * @param schema Property schema definition.
     * @param custom Marks the property as user-defined if set to true.
     */
    constructor(path, schema, custom) {
        super();
        this.addEvents("value", "link", "change", "dispose");
        if (!schema || schema.preset === undefined) {
            throw new Error("missing schema/preset");
        }
        const preset = schema.preset;
        const isArray = Array.isArray(preset);
        this.type = typeof (isArray ? preset[0] : preset);
        this.schema = schema;
        this.custom = custom || false;
        this.elementCount = isArray ? preset.length : 1;
        this.inLinks = [];
        this.outLinks = [];
        this._group = null;
        this._key = "";
        this._path = path;
        this.value = null;
        this.reset();
        this.changed = !schema.event;
    }
    get group() {
        return this._group;
    }
    get key() {
        return this._key;
    }
    get path() {
        return this._path;
    }
    set path(path) {
        this._path = path;
        this.emit({ type: "change", what: "path", property: this });
    }
    get name() {
        return this._path.split(".").pop();
    }
    // /**
    //  * Adds the property to the given group.
    //  * @param group The property group this property should be added to.
    //  * @param key An optional key under which the property is accessible in the property group.
    //  * @param index An optional index position where the property should be inserted in the group.
    //  */
    // attach(group: PropertyGroup, key?: string, index?: number)
    // {
    //     group._addProperty(this, key, index);
    // }
    //
    // /**
    //  * Removes the property from the group it was previously added to.
    //  * Does nothing if the property is not member of a group.
    //  */
    // detach()
    // {
    //     if (this._group) {
    //         this._group._removeProperty(this);
    //     }
    // }
    /**
     * Removes the property from its group, removes all links.
     * Emits a [[IPropertyDisposeEvent]] event.
     */
    dispose() {
        this.unlink();
        if (this._group) {
            this._group.removeProperty(this);
        }
        this.emit({ type: "dispose", property: this });
    }
    setValue(value, silent, noevent) {
        this.value = value;
        if (!silent) {
            this.changed = true;
            if (this.isInput()) {
                this._group.linkable.changed = true;
            }
        }
        // TODO: Demo hack
        if (!noevent) {
            this.emit("value", value);
        }
        const outLinks = this.outLinks;
        for (let i = 0, n = outLinks.length; i < n; ++i) {
            outLinks[i].push();
        }
    }
    setOption(option, silent, noevent) {
        if (!this.schema.options) {
            throw new Error("not an 'option' type");
        }
        const value = this.schema.options.indexOf(option);
        if (value >= 0) {
            this.setValue(value, silent, noevent);
        }
    }
    copyValue(value, silent) {
        if (Array.isArray(value)) {
            value = value.slice();
        }
        this.setValue(value, silent);
    }
    set(silent) {
        if (!silent) {
            this.changed = true;
            if (this.isInput()) {
                this._group.linkable.changed = true;
            }
        }
        this.emit("value", this.value);
        const outLinks = this.outLinks;
        for (let i = 0, n = outLinks.length; i < n; ++i) {
            outLinks[i].push();
        }
    }
    cloneValue() {
        const value = this.value;
        return Array.isArray(value) ? value.slice() : value;
    }
    /**
     * Returns the property value, validated against the property schema.
     * @param result Optional array to write the validated values into.
     */
    getValidatedValue(result) {
        const value = this.value;
        if (this.isArray()) {
            result = result || [];
            for (let i = 0, n = value.length; i < n; ++i) {
                result[i] = this.validateValue(value[i]);
            }
            return result;
        }
        return this.validateValue(value);
    }
    linkTo(destination, sourceIndex, destinationIndex) {
        destination.linkFrom(this, sourceIndex, destinationIndex);
    }
    linkFrom(source, sourceIndex, destinationIndex) {
        if (!this.canLinkFrom(source, sourceIndex, destinationIndex)) {
            throw new Error(`can't link from '${source.path}' to '${this.path}'`);
        }
        const link = new _PropertyLink__WEBPACK_IMPORTED_MODULE_3__["default"](source, this, sourceIndex, destinationIndex);
        source.addOutLink(link);
        this.addInLink(link);
    }
    unlinkTo(destination, sourceIndex, destinationIndex) {
        destination.unlinkFrom(this, sourceIndex, destinationIndex);
    }
    unlinkFrom(source, sourceIndex, destinationIndex) {
        const link = this.inLinks.find(link => link.source === source
            && link.sourceIndex === sourceIndex
            && link.destinationIndex === destinationIndex);
        if (!link) {
            return false;
        }
        source.removeOutLink(link);
        this.removeInLink(link);
        return true;
    }
    unlink() {
        const inLinks = this.inLinks.slice();
        inLinks.forEach(link => {
            link.source.removeOutLink(link);
            this.removeInLink(link);
        });
        const outLinks = this.outLinks.slice();
        outLinks.forEach(link => {
            this.removeOutLink(link);
            link.destination.removeInLink(link);
        });
        if (this.inLinks.length !== 0 || this.outLinks.length !== 0) {
            throw new Error("fatal: leftover links");
        }
    }
    addInLink(link) {
        if (link.destination !== this) {
            throw new Error("input link's destination must equal this");
        }
        this.inLinks.push(link);
        this.requestSort();
        this.emit({
            type: "link", add: true, remove: false, link
        });
    }
    addOutLink(link) {
        if (link.source !== this) {
            throw new Error("output link's source must equal this");
        }
        this.outLinks.push(link);
        this.requestSort();
        // push value through added link
        link.push();
    }
    removeInLink(link) {
        const index = this.inLinks.indexOf(link);
        if (index < 0) {
            throw new Error("input link not found");
        }
        this.inLinks.splice(index, 1);
        this.requestSort();
        // if last link is removed and if object, reset to default (usually null) values
        if (this.inLinks.length === 0 && this.type === "object") {
            this.reset();
        }
        this.emit({
            type: "link", add: false, remove: true, link
        });
    }
    removeOutLink(link) {
        const index = this.outLinks.indexOf(link);
        if (index < 0) {
            throw new Error("output link not found");
        }
        this.outLinks.splice(index, 1);
        this.requestSort();
    }
    canLinkTo(destination, sourceIndex, destinationIndex) {
        return destination.canLinkFrom(this, sourceIndex, destinationIndex);
    }
    canLinkFrom(source, sourceIndex, destinationIndex) {
        // can't link to an output property
        if (this.isOutput()) {
            return false;
        }
        const hasSrcIndex = sourceIndex >= 0;
        const hasDstIndex = destinationIndex >= 0;
        if (!source.isArray() && hasSrcIndex) {
            throw new Error("non-array source property; can't link to element");
        }
        if (!this.isArray() && hasDstIndex) {
            throw new Error("non-array destination property; can't link to element");
        }
        const srcIsArray = source.isArray() && !hasSrcIndex;
        const dstIsArray = this.isArray() && !hasDstIndex;
        if (srcIsArray !== dstIsArray) {
            return false;
        }
        if (srcIsArray && source.elementCount !== this.elementCount) {
            return false;
        }
        if (source.type === "object" && this.type === "object") {
            if (!Object(_ff_core_isSubclass__WEBPACK_IMPORTED_MODULE_0__["default"])(source.schema.objectType, this.schema.objectType)) {
                return false;
            }
        }
        return Object(_convert__WEBPACK_IMPORTED_MODULE_2__["canConvert"])(source.type, this.type);
    }
    reset() {
        let value;
        if (this.isMulti()) {
            let multiArray = this.value;
            if (!multiArray) {
                value = multiArray = [];
            }
            else {
                multiArray.length = 1;
            }
            multiArray[0] = this.clonePreset();
        }
        else {
            value = this.clonePreset();
        }
        // set changed flag and push to output links
        this.setValue(value);
    }
    setMultiChannelCount(count) {
        if (!this.isMulti()) {
            throw new Error("can't set multi channel count on non-multi property");
        }
        const multiArray = this.value;
        const currentCount = multiArray.length;
        multiArray.length = count;
        for (let i = currentCount; i < count; ++i) {
            multiArray[i] = this.clonePreset();
        }
        this.changed = true;
    }
    requestSort() {
        if (this._group && this._group.linkable) {
            this._group.linkable.requestSort();
        }
    }
    setOptions(options) {
        if (!this.schema.options) {
            throw new Error(`property type mismatch, can't set options on '${this.path}'`);
        }
        this.schema.options = options.slice();
        this.emit({ type: "change", what: "options", property: this });
    }
    getOptionText() {
        const options = this.schema.options;
        if (this.type === "number" && options) {
            const i = Math.trunc(this.value);
            return options[i < 0 ? 0 : (i >= options.length ? 0 : i)] || "";
        }
    }
    isInput() {
        return this._group && this._group === this._group.linkable.ins;
    }
    isOutput() {
        return this._group && this._group === this._group.linkable.outs;
    }
    isArray() {
        return Array.isArray(this.schema.preset);
    }
    isMulti() {
        return !!this.schema.multi;
    }
    isDefault() {
        const value = this.schema.multi ? this.value[0] : this.value;
        const preset = this.schema.preset;
        const valueLength = Array.isArray(value) ? value.length : -1;
        const presetLength = Array.isArray(preset) ? preset.length : -1;
        if (valueLength !== presetLength) {
            return false;
        }
        if (valueLength >= 0) {
            for (let i = 0; i < valueLength; ++i) {
                if (value[i] !== preset[i]) {
                    return false;
                }
            }
            return true;
        }
        return value === preset;
    }
    hasLinks() {
        return this.inLinks.length > 0 || this.outLinks.length > 0;
    }
    hasInLinks(index) {
        const links = this.inLinks;
        if (!(index >= 0)) {
            return links.length > 0;
        }
        for (let i = 0, n = links.length; i < n; ++i) {
            if (links[i].destinationIndex === index) {
                return true;
            }
        }
        return false;
    }
    hasMainInLinks() {
        const links = this.inLinks;
        for (let i = 0, n = links.length; i < n; ++i) {
            if (!(links[i].destinationIndex >= 0)) {
                return true;
            }
        }
        return false;
    }
    hasOutLinks(index) {
        const links = this.outLinks;
        if (!(index >= 0)) {
            return links.length > 0;
        }
        for (let i = 0, n = links.length; i < n; ++i) {
            if (links[i].sourceIndex === index) {
                return true;
            }
        }
        return false;
    }
    inLinkCount() {
        return this.inLinks.length;
    }
    outLinkCount() {
        return this.outLinks.length;
    }
    toJSON() {
        let json = this.custom ? {
            path: this.path,
            schema: Object.assign({}, this.schema)
        } : null;
        if (!this.isOutput() && !this.hasMainInLinks() && !this.isDefault() && this.type !== "object") {
            json = json || {};
            json.value = this.value;
        }
        if (this.outLinks.length > 0) {
            json = json || {};
            json.links = this.outLinks.map(link => {
                const jsonLink = {
                    id: link.destination._group.linkable.id,
                    key: link.destination.key
                };
                if (link.sourceIndex >= 0) {
                    jsonLink.srcIndex = link.sourceIndex;
                }
                if (link.destinationIndex >= 0) {
                    jsonLink.dstIndex = link.destinationIndex;
                }
                return jsonLink;
            });
        }
        return json;
    }
    fromJSON(json, linkableDict) {
        if (json.value !== undefined) {
            this.value = json.value;
        }
        if (json.links !== undefined) {
            json.links.forEach(link => {
                const target = linkableDict[link.id];
                const property = target.ins[link.key];
                property.linkFrom(this, link.srcIndex, link.dstIndex);
            });
        }
    }
    /**
     * Returns a text representation.
     */
    toString() {
        const schema = this.schema;
        const typeName = schema.event ? "event" : (schema.options ? "enum" : this.type);
        return `${this.path} [${typeName}]`;
    }
    dump(indent = "") {
        console.log(indent + `Property '${this.path}', key: ${this.key}, value: ${this.value}`);
    }
    /**
     * Validates the given value against the property schema.
     * @param value
     */
    validateValue(value) {
        const schema = this.schema;
        if (schema.enum) {
            const i = Math.trunc(value);
            return schema.enum[i] ? i : 0;
        }
        if (schema.options) {
            const i = Math.trunc(value);
            return i < 0 ? 0 : (i >= schema.options.length ? 0 : i);
        }
        if (this.type === "number") {
            value = schema.min ? Math.max(schema.min, value) : value;
            value = schema.max ? Math.min(schema.max, value) : value;
            return value;
        }
        return value;
    }
    clonePreset() {
        const preset = this.schema.preset;
        return Array.isArray(preset) ? preset.slice() : preset;
    }
}


/***/ }),

/***/ "../../libs/ff-graph/source/PropertyGroup.ts":
/*!*******************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-graph/source/PropertyGroup.ts ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PropertyGroup; });
/* harmony import */ var _ff_core_Publisher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/Publisher */ "../../libs/ff-core/source/Publisher.ts");
/* harmony import */ var _Property__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Property */ "../../libs/ff-graph/source/Property.ts");
/* harmony import */ var _ff_core_uniqueId__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/core/uniqueId */ "../../libs/ff-core/source/uniqueId.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */



/**
 * A set of properties. Properties can be linked, such that one property updates another.
 * After adding properties to the set, they are available on the set using their key.
 * To make use of linkable properties, classes must implement the [[ILinkable]] interface.
 *
 * ### Events
 * - *"change"* - emits [[IPropertiesChangeEvent]] after properties have been added, removed, or renamed.
 */
class PropertyGroup extends _ff_core_Publisher__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(linkable) {
        super();
        this.addEvent("property");
        this.linkable = linkable;
        this.properties = [];
    }
    get customProperties() {
        return this.properties.filter(property => property.custom);
    }
    dispose() {
        this.unlinkAllProperties();
    }
    isInputGroup() {
        return this === this.linkable.ins;
    }
    isOutputGroup() {
        return this === this.linkable.outs;
    }
    /**
     * Appends properties to the set.
     * @param templates plain object with property templates.
     * @param index Optional index at which to insert the properties.
     */
    createProperties(templates, index) {
        Object.keys(templates).forEach((key, i) => {
            const ii = index === undefined ? undefined : index + i;
            const template = templates[key];
            this.createProperty(template.path, template.schema, key, ii);
        });
        return this;
    }
    createProperty(path, schema, key, index) {
        const property = new _Property__WEBPACK_IMPORTED_MODULE_1__["default"](path, schema);
        this.addProperty(property, key, index);
        return property;
    }
    createCustomProperty(path, schema, index) {
        const property = new _Property__WEBPACK_IMPORTED_MODULE_1__["default"](path, schema, /* custom */ true);
        this.addCustomProperty(property, index);
        return property;
    }
    addCustomProperty(property, index) {
        const key = Object(_ff_core_uniqueId__WEBPACK_IMPORTED_MODULE_2__["default"])(5);
        this.addProperty(property, key, index);
    }
    addProperty(property, key, index) {
        if (property.group) {
            throw new Error("can't add, property already part of a group");
        }
        if (this[key]) {
            throw new Error(`key '${key}' already exists in group`);
        }
        property._group = this;
        property._key = key;
        if (index === undefined) {
            this.properties.push(property);
        }
        else {
            this.properties.splice(index, 0, property);
        }
        this[key] = property;
        this.emit({
            type: "property", add: true, remove: false, property
        });
    }
    /**
     * Removes the given property from the set.
     * @param {Property} property The property to be removed.
     */
    removeProperty(property) {
        if (property.group !== this) {
            throw new Error("can't remove, property not in this group");
        }
        if (property.hasLinks()) {
            throw new Error("can't remove, property has links");
        }
        if (this[property.key] !== property) {
            throw new Error(`property key '${property.key}' not found in group`);
        }
        this.properties.slice(this.properties.indexOf(property), 1);
        delete this[property.key];
        property._group = null;
        property._key = "";
        this.emit({
            type: "property", add: false, remove: true, property
        });
    }
    /**
     * Returns a property by key.
     * @param {string} key The key of the property to be returned.
     * @returns {Property}
     */
    getProperty(key) {
        const property = this[key];
        if (!property) {
            throw new Error(`no property found with key '${key}'`);
        }
        return property;
    }
    getKeys(includeObjects = false) {
        const keys = [];
        this.properties.forEach(property => {
            if (includeObjects || property.type !== "object") {
                keys.push(property.key);
            }
        });
        return keys;
    }
    getValues(includeObjects = false) {
        const values = [];
        this.properties.map(property => {
            if (includeObjects || property.type !== "object") {
                values.push(property.value);
            }
        });
        return values;
    }
    cloneValues(includeObjects = false) {
        const values = [];
        this.properties.map(property => {
            if (includeObjects || property.type !== "object") {
                values.push(property.cloneValue());
            }
        });
        return values;
    }
    setValues(values) {
        Object.keys(values).forEach(key => this.getProperty(key).value = values[key]);
    }
    /**
     * Sets the values of multiple properties. Properties are identified by key.
     * @param values Dictionary of property key/value pairs.
     */
    copyValues(values) {
        Object.keys(values).forEach(key => this.getProperty(key).copyValue(values[key]));
    }
    unlinkAllProperties() {
        this.properties.forEach(property => property.unlink());
    }
    toJSON() {
        let json = null;
        this.properties.forEach(property => {
            const jsonProp = property.toJSON();
            if (jsonProp) {
                json = json || {};
                json[property.key] = jsonProp;
            }
        });
        return json;
    }
    fromJSON(json) {
        Object.keys(json).forEach(key => {
            const jsonProp = json[key];
            if (jsonProp.schema) {
                const property = new _Property__WEBPACK_IMPORTED_MODULE_1__["default"](jsonProp.path, jsonProp.schema, /* custom */ true);
                this.addProperty(property, key);
            }
        });
    }
    linksFromJSON(json, linkableDict) {
        Object.keys(json).forEach(key => {
            this[key].fromJSON(json[key], linkableDict);
        });
    }
}


/***/ }),

/***/ "../../libs/ff-graph/source/PropertyLink.ts":
/*!******************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-graph/source/PropertyLink.ts ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PropertyLink; });
/* harmony import */ var _convert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./convert */ "../../libs/ff-graph/source/convert.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */

class PropertyLink {
    constructor(source, destination, sourceIndex, destinationIndex) {
        if (source.elementCount === 1 && sourceIndex >= 0) {
            throw new Error("non-array source property; can't link to element");
        }
        if (destination.elementCount === 1 && destinationIndex >= 0) {
            throw new Error("non-array destination property; can't link to element");
        }
        this.source = source;
        this.destination = destination;
        this.sourceIndex = sourceIndex;
        this.destinationIndex = destinationIndex;
        const srcIndex = sourceIndex === undefined ? -1 : sourceIndex;
        const dstIndex = destinationIndex === undefined ? -1 : destinationIndex;
        const isArray = source.elementCount > 1 && srcIndex < 0 && dstIndex < 0;
        this.fnConvert = Object(_convert__WEBPACK_IMPORTED_MODULE_0__["getConversionFunction"])(source.type, destination.type, isArray);
        const fnElementCopy = Object(_convert__WEBPACK_IMPORTED_MODULE_0__["getElementCopyFunction"])(srcIndex, dstIndex, this.fnConvert);
        this.fnCopy = Object(_convert__WEBPACK_IMPORTED_MODULE_0__["getMultiCopyFunction"])(source.isMulti(), destination.isMulti(), fnElementCopy);
    }
    push() {
        this.destination.setValue(this.fnCopy(this.source.value, this.destination.value, this.fnConvert));
    }
}


/***/ }),

/***/ "../../libs/ff-graph/source/System.ts":
/*!************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-graph/source/System.ts ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return System; });
/* harmony import */ var _ff_core_Publisher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/Publisher */ "../../libs/ff-core/source/Publisher.ts");
/* harmony import */ var _ff_core_ObjectRegistry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/core/ObjectRegistry */ "../../libs/ff-core/source/ObjectRegistry.ts");
/* harmony import */ var _ff_core_TypeRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/core/TypeRegistry */ "../../libs/ff-core/source/TypeRegistry.ts");
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Node */ "../../libs/ff-graph/source/Node.ts");
/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Graph */ "../../libs/ff-graph/source/Graph.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */






class System extends _ff_core_Publisher__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(registry) {
        super({ knownEvents: false });
        this.nodes = new _ff_core_ObjectRegistry__WEBPACK_IMPORTED_MODULE_1__["default"](_Node__WEBPACK_IMPORTED_MODULE_4__["default"]);
        this.components = new _ff_core_ObjectRegistry__WEBPACK_IMPORTED_MODULE_1__["default"](_Component__WEBPACK_IMPORTED_MODULE_3__["default"]);
        this.registry = registry || new _ff_core_TypeRegistry__WEBPACK_IMPORTED_MODULE_2__["default"]();
        // create the main graph and activate it by default
        this.graph = new _Graph__WEBPACK_IMPORTED_MODULE_5__["default"](this, null);
        this.graph.activate();
    }
    getComponent(componentOrType, nothrow = false) {
        return this.components.get(componentOrType, nothrow);
    }
    getComponents(componentOrType) {
        return this.components.getArray(componentOrType);
    }
    getComponentsByTag(tag) {
        return this.components.getByTag(tag);
    }
    hasComponents(componentOrType) {
        return this.components.has(componentOrType);
    }
    getMainComponent(componentOrType, nothrow = false) {
        return this.graph.components.get(componentOrType, nothrow);
    }
    getMainComponents(componentOrType) {
        return this.graph.components.getArray(componentOrType);
    }
    getMainComponentsByTag(tag) {
        return this.graph.components.getByTag(tag);
    }
    hasMainComponents(componentOrType) {
        return this.graph.components.has(componentOrType);
    }
    getNode(nodeOrType, nothrow = false) {
        return this.nodes.get(nodeOrType, nothrow);
    }
    getNodes(nodeOrType) {
        return this.nodes.getArray(nodeOrType);
    }
    getNodesByTag(tag) {
        return this.nodes.getByTag(tag);
    }
    hasNodes(nodeOrType) {
        return this.nodes.has(nodeOrType);
    }
    getMainNode(nodeOrType, nothrow = false) {
        return this.graph.nodes.get(nodeOrType, nothrow);
    }
    getMainNodes(nodeOrType) {
        return this.graph.nodes.getArray(nodeOrType);
    }
    getMainNodesByTag(tag) {
        return this.graph.nodes.getByTag(tag);
    }
    hasMainNodes(nodeOrType) {
        return this.graph.nodes.has(nodeOrType);
    }
    findNodeByName(name, nodeOrType) {
        const nodes = this.nodes.getArray(nodeOrType);
        for (let i = 0, n = nodes.length; i < n; ++i) {
            if (nodes[i].name === name) {
                return nodes[i];
            }
        }
        return undefined;
    }
    /**
     * Serializes the content of the system, ready to be stringified.
     */
    toJSON() {
        return this.graph.toJSON();
    }
    /**
     * Deserializes the given JSON object.
     * @param json
     */
    fromJSON(json) {
        this.graph.clear();
        this.graph.fromJSON(json);
    }
    toString(verbose = false) {
        const nodes = this.nodes.getArray();
        const numComponents = this.components.count();
        const text = `System - ${nodes.length} nodes, ${numComponents} components.`;
        if (verbose) {
            return text + "\n" + nodes.map(node => node.toString(true)).join("\n");
        }
        return text;
    }
    _addNode(node) {
        this.nodes.add(node);
    }
    _removeNode(node) {
        this.nodes.remove(node);
    }
    _addNodeTag(tag, node) {
        this.nodes.addByTag(tag, node);
    }
    _removeNodeTag(tag, node) {
        this.nodes.removeByTag(tag, node);
    }
    _addComponent(component) {
        if (component.isSystemSingleton && this.components.has(component)) {
            throw new Error(`only one component of type '${component.typeName}' allowed per system`);
        }
        this.components.add(component);
    }
    _removeComponent(component) {
        this.components.remove(component);
    }
    _addComponentTag(tag, component) {
        this.components.addByTag(tag, component);
    }
    _removeComponentTag(tag, component) {
        this.components.removeByTag(tag, component);
    }
}


/***/ }),

/***/ "../../libs/ff-graph/source/components/CComponentProvider.ts":
/*!***********************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-graph/source/components/CComponentProvider.ts ***!
  \***********************************************************************************/
/*! exports provided: EComponentScope, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EComponentScope", function() { return EComponentScope; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CComponentProvider; });
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _Node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Node */ "../../libs/ff-graph/source/Node.ts");
/* harmony import */ var _CSelection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CSelection */ "../../libs/ff-graph/source/components/CSelection.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */



////////////////////////////////////////////////////////////////////////////////
var EComponentScope;
(function (EComponentScope) {
    // Components in the given scoped node.
    EComponentScope[EComponentScope["Node"] = 0] = "Node";
    // Components in the given scoped graph.
    EComponentScope[EComponentScope["Graph"] = 1] = "Graph";
    // Components in the main graph.
    EComponentScope[EComponentScope["Main"] = 2] = "Main";
    // All components in the system.
    EComponentScope[EComponentScope["System"] = 3] = "System";
})(EComponentScope || (EComponentScope = {}));
/**
 * Defines a scope of components. Exactly one component can be the active component. The scope
 * of candidate components is definable. The active component can be driven by the current selection.
 *
 * ### Events
 * - *"active-component"* - Emits [[IActiveComponentEvent]] if the active component changes.
 */
class CComponentProvider extends _Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this._scope = EComponentScope.Node;
        this._scopedNode = null;
        this._scopedGraph = null;
        this._activeComponent = null;
    }
    get componentType() {
        return this.constructor.componentType;
    }
    /** If a component in scope is selected, it becomes the active component. */
    get followComponentSelection() {
        return this.constructor.followComponentSelection;
    }
    /** If a node is selected containing a component in scope, the component becomes the active component. */
    get followNodeSelection() {
        return this.constructor.followNodeSelection;
    }
    /** If the active component is unselected, keep it active anyway. */
    get retainSelection() {
        return this.constructor.retainSelection;
    }
    get scope() {
        return this._scope;
    }
    set scope(scope) {
        this._scope = scope;
        if (this._activeComponent && !this.isComponentInScope(this._activeComponent)) {
            this.activeComponent = null;
        }
    }
    get scopedNode() {
        return this._scopedNode;
    }
    set scopedNode(node) {
        if (node !== this._scopedNode) {
            this._scopedNode = node;
            if (this._activeComponent && !this.isComponentInScope(this._activeComponent)) {
                this.activeComponent = null;
            }
            this.onScopedComponents();
            this.emit({ type: "scoped-components" });
        }
    }
    get scopedGraph() {
        return this._scopedGraph;
    }
    set scopedGraph(graphComponent) {
        if (graphComponent !== this._scopedGraph) {
            this._scopedGraph = graphComponent;
            if (this._activeComponent && !this.isComponentInScope(this._activeComponent)) {
                this.activeComponent = null;
            }
            this.onScopedComponents();
            this.emit({ type: "scoped-components" });
        }
    }
    get scopedComponents() {
        switch (this._scope) {
            case EComponentScope.Node:
                const node = this._scopedNode || this.node;
                return node.getComponents(this.componentType);
            case EComponentScope.Graph:
                const graph = this._scopedGraph ? this._scopedGraph.innerGraph : this.graph;
                return graph.getComponents(this.componentType);
            case EComponentScope.Main:
                return this.getMainComponents(this.componentType);
            case EComponentScope.System:
                return this.getSystemComponents(this.componentType);
        }
    }
    get activeComponent() {
        return this._activeComponent;
    }
    set activeComponent(component) {
        const activeComponent = this.activeComponent;
        if (component !== activeComponent) {
            if (activeComponent) {
                this.deactivateComponent(activeComponent);
            }
            if (component) {
                if (!this.isComponentInScope(component)) {
                    throw new Error("can't activate, component out of scope");
                }
                this.activateComponent(component);
            }
            this._activeComponent = component;
            this.onActiveComponent(activeComponent, component);
            this.emit({ type: "active-component", previous: activeComponent, next: component });
        }
    }
    get selection() {
        return this.getSystemComponent(_CSelection__WEBPACK_IMPORTED_MODULE_2__["default"]);
    }
    create() {
        super.create();
        this.system.components.on(_Component__WEBPACK_IMPORTED_MODULE_0__["default"], this.onComponent, this);
        if (this.followComponentSelection) {
            this.selection.selectedComponents.on(this.componentType, this.onSelectComponent, this);
        }
        if (this.followNodeSelection) {
            this.selection.selectedNodes.on(_Node__WEBPACK_IMPORTED_MODULE_1__["default"], this.onSelectNode, this);
        }
    }
    dispose() {
        if (this.activeComponent) {
            this.activeComponent = null;
        }
        this.system.components.off(_Component__WEBPACK_IMPORTED_MODULE_0__["default"], this.onComponent, this);
        if (this.followComponentSelection) {
            this.selection.selectedComponents.off(this.componentType, this.onSelectComponent, this);
        }
        if (this.followNodeSelection) {
            this.selection.selectedNodes.off(_Node__WEBPACK_IMPORTED_MODULE_1__["default"], this.onSelectNode, this);
        }
        super.dispose();
    }
    activateComponent(component) {
    }
    deactivateComponent(component) {
    }
    onActiveComponent(previous, next) {
    }
    onScopedComponents() {
    }
    onComponent(event) {
        // in case the active component is removed
        if (event.remove && event.object === this.activeComponent) {
            this.activeComponent = null;
        }
        if (this.isComponentInScope(event.object)) {
            this.onScopedComponents();
            this.emit({ type: "scoped-components" });
        }
    }
    onSelectComponent(event) {
        const component = event.object;
        if (this.isComponentInScope(component)) {
            if (event.add) {
                this.activeComponent = component;
            }
            else if (event.remove && !this.retainSelection && component === this.activeComponent) {
                this.activeComponent = null;
            }
        }
    }
    onSelectNode(event) {
        const node = event.object;
        if (this.isNodeInScope(node)) {
            const component = node.getComponent(this.componentType);
            if (component) {
                this.onSelectComponent({
                    type: component.typeName, object: component, add: event.add, remove: event.remove
                });
            }
        }
    }
    isComponentInScope(component) {
        if (!component.is(this.componentType)) {
            return false;
        }
        switch (this._scope) {
            case EComponentScope.Node:
                const node = this._scopedNode || this.node;
                return component.node === node;
            case EComponentScope.Graph:
                const graph = this._scopedGraph ? this._scopedGraph.innerGraph : this.graph;
                return component.graph === graph;
            case EComponentScope.Main:
                return component.graph === this.system.graph;
            case EComponentScope.System:
                return true;
        }
        return false;
    }
    isNodeInScope(node) {
        switch (this._scope) {
            case EComponentScope.Node:
                const scopedNode = this._scopedNode || this.node;
                return node === scopedNode;
            case EComponentScope.Graph:
                const graph = this._scopedGraph ? this._scopedGraph.innerGraph : this.graph;
                return node.graph === graph;
            case EComponentScope.Main:
                return node.graph === this.system.graph;
            case EComponentScope.System:
                return true;
        }
    }
}
CComponentProvider.typeName = "CComponentProvider";
CComponentProvider.componentType = _Component__WEBPACK_IMPORTED_MODULE_0__["default"];
CComponentProvider.followComponentSelection = true;
CComponentProvider.followNodeSelection = false;
CComponentProvider.retainSelection = true;


/***/ }),

/***/ "../../libs/ff-graph/source/components/CController.ts":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-graph/source/components/CController.ts ***!
  \****************************************************************************/
/*! exports provided: Commander, types, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CController; });
/* harmony import */ var _ff_core_Commander__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/Commander */ "../../libs/ff-core/source/Commander.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Commander", function() { return _ff_core_Commander__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "types", function() { return _Component__WEBPACK_IMPORTED_MODULE_1__["types"]; });

/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */


////////////////////////////////////////////////////////////////////////////////

class CController extends _Component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    createActions(commander) {
        return {};
    }
}
CController.typeName = "CController";
CController.isSystemSingleton = true;


/***/ }),

/***/ "../../libs/ff-graph/source/components/CGraph.ts":
/*!***********************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-graph/source/components/CGraph.ts ***!
  \***********************************************************************/
/*! exports provided: Node, types, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CGraph; });
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "types", function() { return _Component__WEBPACK_IMPORTED_MODULE_0__["types"]; });

/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Graph */ "../../libs/ff-graph/source/Graph.ts");
/* harmony import */ var _Node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Node */ "../../libs/ff-graph/source/Node.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Node", function() { return _Node__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */



////////////////////////////////////////////////////////////////////////////////

class CGraph extends _Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(node, id) {
        super(node, id);
        this.ins = this.addInputs(CGraph.graphIns);
        this._innerGraph = null;
        this._innerRoot = null;
        this._innerGraph = new _Graph__WEBPACK_IMPORTED_MODULE_1__["default"](this.system, this);
    }
    get innerGraph() {
        return this._innerGraph;
    }
    get innerNodes() {
        return this._innerGraph.nodes;
    }
    get innerComponents() {
        return this._innerGraph.components;
    }
    get innerRoots() {
        return this._innerGraph.roots;
    }
    getInnerComponent(componentOrClass, nothrow = false) {
        return this._innerGraph.components.get(componentOrClass, nothrow);
    }
    getInnerComponents(componentOrClass) {
        return this._innerGraph.components.getArray(componentOrClass);
    }
    hasInnerComponent(componentOrClass) {
        return this._innerGraph.components.has(componentOrClass);
    }
    getInnerNode(nodeOrClass, nothrow = false) {
        return this._innerGraph.nodes.get(nodeOrClass, nothrow);
    }
    getInnerNodes(nodeOrClass) {
        return this._innerGraph.nodes.getArray(nodeOrClass);
    }
    hasInnerNode(nodeOrClass) {
        return this._innerGraph.nodes.has(nodeOrClass);
    }
    isEmpty() {
        return this._innerGraph.nodes.count() === 0;
    }
    update(context) {
        const ins = this.ins;
        if (ins.active.changed) {
            const isActive = ins.active.value;
            const graph = this._innerGraph;
            if (isActive !== graph.isActive) {
                if (isActive) {
                    this.activateInnerGraph();
                }
                else {
                    this.deactivateInnerGraph();
                }
            }
        }
        // TODO: Evaluate interface ins/outs
        return true;
    }
    tick(context) {
        return this._innerGraph.tick(context);
    }
    tock(context) {
        return this._innerGraph.tock(context);
    }
    dispose() {
        this._innerGraph.clear();
        this._innerGraph = null;
        this._innerRoot = null;
        super.dispose();
    }
    /**
     * Removes all components and nodes from the inner graph.
     */
    clearInnerGraph() {
        this._innerGraph.clear();
    }
    fromJSON(json) {
        super.fromJSON(json);
        this._innerGraph.clear();
        this._innerGraph.fromJSON(json.graph);
    }
    toJSON() {
        const json = super.toJSON();
        json.graph = this._innerGraph.toJSON();
        return json;
    }
    dump(indent = "") {
        super.dump(indent);
        this.innerGraph.dump(indent + "  ");
    }
    onAddInnerRoot(component) {
    }
    onRemoveInnerRoot(component) {
    }
    activateInnerGraph() {
        this._innerGraph.activate();
    }
    deactivateInnerGraph() {
        this._innerGraph.deactivate();
    }
}
CGraph.typeName = "CGraph";
CGraph.graphIns = {
    active: _Component__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("Graph.Active", true),
};


/***/ }),

/***/ "../../libs/ff-graph/source/components/CHierarchy.ts":
/*!***************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-graph/source/components/CHierarchy.ts ***!
  \***************************************************************************/
/*! exports provided: Node, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CHierarchy; });
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _Node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Node */ "../../libs/ff-graph/source/Node.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Node", function() { return _Node__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _CGraph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CGraph */ "../../libs/ff-graph/source/components/CGraph.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */



////////////////////////////////////////////////////////////////////////////////

const _hasChildComponents = (hierarchy, componentOrType, recursive) => {
    let hasComponent;
    const children = hierarchy.children;
    for (let i = 0, n = children.length; i < n; ++i) {
        hasComponent = children[i].components.has(componentOrType);
        if (hasComponent) {
            return true;
        }
    }
    if (recursive) {
        for (let i = 0, n = children.length; i < n; ++i) {
            hasComponent = _hasChildComponents(children[i], componentOrType, true);
            if (hasComponent) {
                return true;
            }
        }
    }
    return false;
};
const _getChildComponent = (hierarchy, componentOrType, recursive) => {
    let component;
    const children = hierarchy.children;
    for (let i = 0, n = children.length; i < n; ++i) {
        component = children[i].components.get(componentOrType);
        if (component) {
            return component;
        }
    }
    if (recursive) {
        for (let i = 0, n = children.length; i < n; ++i) {
            component = _getChildComponent(children[i], componentOrType, true);
            if (component) {
                return component;
            }
        }
    }
    return null;
};
const _getChildComponents = (hierarchy, componentOrType, recursive) => {
    let components = [];
    const children = hierarchy.children;
    for (let i = 0, n = children.length; i < n; ++i) {
        components = components.concat(children[i].components.getArray(componentOrType));
    }
    if (recursive) {
        for (let i = 0, n = children.length; i < n; ++i) {
            components = components.concat(_getChildComponents(children[i], componentOrType, true));
        }
    }
    return components;
};
/**
 * Allows arranging components in a hierarchical structure.
 *
 * ### Events
 * - *"hierarchy"* - emits [[IHierarchyEvent]] if a hierarchy relation has changed in the component's tree line.
 * - *"child-component"* - emits [[IChildComponentEvent]] if a child component has been added or removed.
 */
class CHierarchy extends _Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this._parent = null;
        this._children = [];
    }
    /**
     * Returns the parent component of this.
     * @returns {CHierarchy}
     */
    get parent() {
        return this._parent;
    }
    /**
     * Returns an array of child components of this.
     * @returns {Readonly<CHierarchy[]>}
     */
    get children() {
        return this._children || [];
    }
    create() {
        super.create();
        this.graph._addRoot(this);
        this.node.components.on(_Component__WEBPACK_IMPORTED_MODULE_0__["default"], this.onComponent, this);
    }
    dispose() {
        this.node.components.off(_Component__WEBPACK_IMPORTED_MODULE_0__["default"], this.onComponent, this);
        // dispose of all child nodes
        this._children.slice().forEach(child => child.node.dispose());
        // detach this from its parent
        if (this._parent) {
            this._parent.removeChild(this);
        }
        this.graph._removeRoot(this);
        super.dispose();
    }
    /**
     * Returns a component at the root of the hierarchy.
     * @returns A component of the given type that is a sibling of the root hierarchy component.
     */
    getRootComponent(componentOrType) {
        let root = this;
        while (root._parent) {
            root = root._parent;
        }
        return root ? root.node.components.get(componentOrType) : null;
    }
    /**
     * Returns a component from the parent node of the node of this component.
     * @param componentOrType
     * @param recursive If true, extends search to entire chain of ancestors,
     * including parent graphs.
     */
    getParentComponent(componentOrType, recursive) {
        let parent = this;
        while (true) {
            parent = parent._parent;
            // if at root, continue search at parent graph
            if (!parent) {
                const parentGraphComponent = this.graph.parent;
                parent = parentGraphComponent ? parentGraphComponent.components.get(CHierarchy) : undefined;
            }
            if (!parent) {
                return undefined;
            }
            const component = parent.node.components.get(componentOrType, true);
            if (component) {
                return component;
            }
            if (!recursive) {
                return undefined;
            }
        }
    }
    getParentNode(nodeOrType, recursive) {
        let parent = this;
        while (true) {
            parent = parent._parent;
            // if at root, continue search at parent graph
            if (!parent) {
                const parentGraphComponent = this.graph.parent;
                parent = parentGraphComponent ? parentGraphComponent.components.get(CHierarchy) : undefined;
            }
            if (!parent) {
                return undefined;
            }
            const node = parent.node;
            if (node.is(nodeOrType)) {
                return node;
            }
            if (!recursive) {
                return undefined;
            }
        }
    }
    getSiblingNode(nodeOrType) {
        return this.getSiblingNodes(nodeOrType)[0];
    }
    getSiblingNodes(nodeOrType) {
        const thisParent = this._parent;
        return this.graph.nodes.getArray(nodeOrType).filter(node => {
            const hierarchy = node.components.get(CHierarchy);
            const parent = hierarchy ? hierarchy._parent : null;
            return parent == thisParent;
        });
    }
    hasChildComponents(componentOrType, recursive) {
        return _hasChildComponents(this, componentOrType, recursive);
    }
    /**
     * Returns the child component of the given type.
     * @param componentOrType
     * @param recursive If true, extends search to entire subtree (breadth-first).
     */
    getChildComponent(componentOrType, recursive) {
        return _getChildComponent(this, componentOrType, recursive);
    }
    /**
     * Returns all child components of the given type.
     * @param componentOrType
     * @param recursive If true, extends search to entire subtree (breadth-first).
     */
    getChildComponents(componentOrType, recursive) {
        return _getChildComponents(this, componentOrType, recursive);
    }
    /**
     * Traverses the hierarchy up starting from this component. Executes the given callback function
     * for each visited component.
     * @param includeThis Includes this component in traversal.
     * @param includeSiblings For each hierarchy component, executes callback for all sibling components in the same node.
     * @param acrossGraphs When arriving at the root hierarchy component, continues traversal at the parent graph.
     * @param callback The callback function to execute for each visited component.
     */
    traverseUp(includeThis, includeSiblings, acrossGraphs, callback) {
        if (includeThis) {
            if (includeSiblings) {
                const siblings = this.node.components.getArray();
                for (let i = 0, n = siblings.length; i < n; ++i) {
                    if (callback(siblings[i])) {
                        return;
                    }
                }
            }
            else if (callback(this)) {
                return;
            }
        }
        let parent = this._parent;
        if (!parent && acrossGraphs) {
            const graphComponent = this.node.graph.parent;
            parent = graphComponent ? graphComponent.getComponent(CHierarchy, true) : null;
        }
        if (parent) {
            parent.traverseUp(true, includeSiblings, acrossGraphs, callback);
        }
    }
    /**
     * Traverses the hierarchy down starting from this component. Executes the given callback function
     * for each visited component.
     * @param includeThis Includes this component in traversal.
     * @param includeSiblings For each hierarchy component, executes callback for all sibling components in the same node.
     * @param acrossGraphs Includes subgraphs in traversal.
     * @param callback The callback function to execute for each visited component.
     */
    traverseDown(includeThis, includeSiblings, acrossGraphs, callback) {
        if (includeThis) {
            if (includeSiblings) {
                const siblings = this.node.components.getArray();
                for (let i = 0, n = siblings.length; i < n; ++i) {
                    if (callback(siblings[i])) {
                        return;
                    }
                }
            }
            else if (callback(this)) {
                return;
            }
        }
        if (acrossGraphs) {
            const graphs = this.node.components.getArray(_CGraph__WEBPACK_IMPORTED_MODULE_2__["default"]);
            for (let i = 0, n = graphs.length; i < n; ++i) {
                const innerRoots = graphs[i].innerRoots;
                for (let j = 0, m = innerRoots.length; j < m; ++j) {
                    innerRoots[j].traverseDown(true, includeSiblings, acrossGraphs, callback);
                }
            }
        }
        const children = this._children;
        for (let i = 0, n = children.length; i < n; ++i) {
            children[i].traverseDown(true, includeSiblings, acrossGraphs, callback);
        }
    }
    /**
     * Emits the given event on this component and on all parent components.
     * Stops propagation as soon as `stopPropagation` is set to true on the event.
     * @param includeSiblings Also emits the event on all sibling components in the same node.
     * @param acrossGraphs When arriving at the root hierarchy component, continues traversal at the parent graph.
     * @param event The event to be emitted.
     */
    propagateUp(includeSiblings, acrossGraphs, event) {
        this.traverseUp(true, includeSiblings, acrossGraphs, component => {
            component.emit(event);
            return event.stopPropagation;
        });
    }
    /**
     * Emits the given event on this component and on all child components.
     * Stops propagation as soon as `stopPropagation` is set to true on the event.
     * @param includeSiblings Also emits the event on all sibling components in the same node.
     * @param acrossGraphs Includes subgraphs in traversal.
     * @param event The event to be emitted.
     */
    propagateDown(includeSiblings, acrossGraphs, event) {
        this.traverseDown(true, includeSiblings, acrossGraphs, component => {
            component.emit(event);
            return event.stopPropagation;
        });
    }
    /**
     * Adds another hierarchy component as a child to this component.
     * Emits a hierarchy event at this component, its node and all their parents.
     * @param {CHierarchy} component
     */
    addChild(component) {
        if (component === this) {
            throw new Error("can't add self as child");
        }
        if (component._parent) {
            throw new Error("can't add child, component has a parent");
        }
        if (component.graph !== this.graph) {
            throw new Error("can't add child, component in different graph");
        }
        component._parent = this;
        this._children.push(component);
        this.graph._removeRoot(component);
        const event = {
            type: "hierarchy", add: true, remove: false, parent: this, child: component
        };
        this.traverseUp(true, false, true, component => component.emit(event));
        this.traverseDown(false, false, true, component => component.emit(event));
        this.system.emit(event);
    }
    /**
     * Removes a child component from this hierarchy component.
     * Emits a hierarchy event at this component, its node and all their parents.
     * @param component
     */
    removeChild(component) {
        if (component._parent !== this) {
            throw new Error("component not a child of this");
        }
        const event = {
            type: "hierarchy", add: false, remove: true, parent: this, child: component
        };
        this.traverseUp(true, false, true, component => component.emit(event));
        this.traverseDown(false, false, true, component => component.emit(event));
        this.system.emit(event);
        const index = this._children.indexOf(component);
        this._children.splice(index, 1);
        component._parent = null;
        this.graph._addRoot(component);
    }
    onComponent(event) {
        if (event.object === this) {
            return;
        }
        const childEvent = {
            type: "child",
            add: event.add,
            remove: event.remove,
            component: event.object
        };
        this.traverseUp(true, false, true, component => component.emit(childEvent));
    }
    toJSON() {
        const json = super.toJSON();
        if (this._children.length > 0) {
            json.children = this._children.map(child => child.id);
        }
        return json;
    }
    referencesFromJSON(json) {
        super.referencesFromJSON(json);
        const dict = this.system.components.getDictionary();
        if (json.children) {
            json.children.forEach(childId => {
                const child = dict[childId];
                this.addChild(child);
            });
        }
    }
    /**
     * Returns a text representation of this object.
     * @returns {string}
     */
    toString() {
        return super.toString() + ` - children: ${this.children.length}`;
    }
    dump(indent = "") {
        super.dump(indent);
        if (this.children.length > 0) {
            console.log(indent + "%cChildren", "color: purple");
            this.children.forEach(child => child.node.dump(indent + "  "));
        }
    }
}
CHierarchy.typeName = "CHierarchy";


/***/ }),

/***/ "../../libs/ff-graph/source/components/CNodeProvider.ts":
/*!******************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-graph/source/components/CNodeProvider.ts ***!
  \******************************************************************************/
/*! exports provided: ENodeScope, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENodeScope", function() { return ENodeScope; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CNodeProvider; });
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _Node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Node */ "../../libs/ff-graph/source/Node.ts");
/* harmony import */ var _CSelection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CSelection */ "../../libs/ff-graph/source/components/CSelection.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */



////////////////////////////////////////////////////////////////////////////////
var ENodeScope;
(function (ENodeScope) {
    // Components in the given scoped graph.
    ENodeScope[ENodeScope["Graph"] = 0] = "Graph";
    // Nodes in the main graph.
    ENodeScope[ENodeScope["Main"] = 1] = "Main";
    // All nodes in the system.
    ENodeScope[ENodeScope["System"] = 2] = "System";
})(ENodeScope || (ENodeScope = {}));
/**
 * Defines a scope of nodes. Exactly one node can be the active node. The scope
 * of candidate nodes is definable. The active node can be driven by the current selection.
 *
 * ### Events
 * - *"active-node"* - Emits [[IActiveNodeEvent]] if the active node changes.
 */
class CNodeProvider extends _Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this._scope = ENodeScope.Graph;
        this._scopedGraph = null;
        this._activeNode = null;
    }
    get nodeType() {
        return this.constructor.nodeType;
    }
    /** If a node in scope is selected, it becomes the active node. */
    get followNodeSelection() {
        return this.constructor.followNodeSelection;
    }
    /** If a component is selected whose parent node is in scope, the node becomes the active node. */
    get followComponentSelection() {
        return this.constructor.followComponentSelection;
    }
    /** If the active node is unselected, keep it active anyway. */
    get retainSelection() {
        return this.constructor.retainSelection;
    }
    get scope() {
        return this._scope;
    }
    set scope(scope) {
        this._scope = scope;
        if (this._activeNode && !this.isNodeInScope(this._activeNode)) {
            this.activeNode = null;
        }
    }
    get scopedGraph() {
        return this._scopedGraph;
    }
    set scopedGraph(graphComponent) {
        if (graphComponent !== this._scopedGraph) {
            this._scopedGraph = graphComponent;
            if (this._activeNode && !this.isNodeInScope(this._activeNode)) {
                this.activeNode = null;
            }
            this.onScopedNodes();
            this.emit({ type: "scoped-nodes" });
        }
    }
    get scopedNodes() {
        switch (this._scope) {
            case ENodeScope.Graph:
                const graph = this._scopedGraph ? this._scopedGraph.innerGraph : this.graph;
                return graph.getNodes(this.nodeType);
            case ENodeScope.Main:
                return this.getMainNodes(this.nodeType);
            case ENodeScope.System:
                return this.getSystemNodes(this.nodeType);
        }
    }
    get activeNode() {
        return this._activeNode;
    }
    set activeNode(node) {
        const activeNode = this.activeNode;
        if (node !== activeNode) {
            if (activeNode) {
                this.deactivateNode(activeNode);
            }
            if (node) {
                if (!this.isNodeInScope(node)) {
                    throw new Error("can't activate, node out of scope");
                }
                this.activateNode(node);
            }
            this._activeNode = node;
            this.onActiveNode(activeNode, node);
            this.emit({ type: "active-node", previous: activeNode, next: node });
        }
    }
    get selection() {
        return this.getSystemComponent(_CSelection__WEBPACK_IMPORTED_MODULE_2__["default"]);
    }
    create() {
        super.create();
        this.system.nodes.on(_Node__WEBPACK_IMPORTED_MODULE_1__["default"], this.onNode, this);
        if (this.followNodeSelection) {
            this.selection.selectedNodes.on(this.nodeType, this.onSelectNode, this);
        }
        if (this.followComponentSelection) {
            this.selection.selectedComponents.on(_Component__WEBPACK_IMPORTED_MODULE_0__["default"], this.onSelectComponent, this);
        }
    }
    dispose() {
        if (this.activeNode) {
            this.activeNode = null;
        }
        this.system.nodes.off(_Node__WEBPACK_IMPORTED_MODULE_1__["default"], this.onNode, this);
        if (this.followNodeSelection) {
            this.selection.selectedNodes.off(this.nodeType, this.onSelectNode, this);
        }
        if (this.followComponentSelection) {
            this.selection.selectedComponents.off(_Component__WEBPACK_IMPORTED_MODULE_0__["default"], this.onSelectComponent, this);
        }
        super.dispose();
    }
    activateNode(node) {
    }
    deactivateNode(node) {
    }
    onActiveNode(previous, next) {
    }
    onScopedNodes() {
    }
    onNode(event) {
        // in case the active node is removed
        if (event.remove && event.object === this.activeNode) {
            this.activeNode = null;
        }
        if (this.isNodeInScope(event.object)) {
            this.onScopedNodes();
            this.emit({ type: "scoped-nodes" });
        }
    }
    onSelectNode(event) {
        const node = event.object;
        if (this.isNodeInScope(node)) {
            if (event.add) {
                this.activeNode = node;
            }
            else if (event.remove && !this.retainSelection && node === this.activeNode) {
                this.activeNode = null;
            }
        }
    }
    onSelectComponent(event) {
        const node = event.object.node;
        if (node.is(this.nodeType)) {
            this.onSelectNode({
                type: node.typeName, object: node, add: event.add, remove: event.remove
            });
        }
    }
    isNodeInScope(node) {
        if (!node.is(this.nodeType)) {
            return false;
        }
        switch (this._scope) {
            case ENodeScope.Graph:
                const graph = this._scopedGraph ? this._scopedGraph.innerGraph : this.graph;
                return node.graph === graph;
            case ENodeScope.Main:
                return node.graph === this.system.graph;
            case ENodeScope.System:
                return true;
        }
        return false;
    }
}
CNodeProvider.typeName = "CNodeProvider";
CNodeProvider.nodeType = _Node__WEBPACK_IMPORTED_MODULE_1__["default"];
CNodeProvider.followNodeSelection = true;
CNodeProvider.followComponentSelection = false;
CNodeProvider.retainSelection = true;


/***/ }),

/***/ "../../libs/ff-graph/source/components/CPulse.ts":
/*!***********************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-graph/source/components/CPulse.ts ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CPulse; });
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Component */ "../../libs/ff-graph/source/Component.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */

/**
 * Generates a steady stream of events based on `window.requestAnimationFrame`.
 */
class CPulse extends _Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(node, id) {
        super(node, id);
        this.outs = this.addOutputs(CPulse.pulseOuts);
        this._tockUpdated = false;
        this.addEvent("pulse");
        this.onAnimationFrame = this.onAnimationFrame.bind(this);
        this.context = {
            time: new Date(),
            secondsElapsed: 0,
            secondsDelta: 0,
            frameNumber: 0
        };
        this._secondsStarted = Date.now() * 0.001;
        this._secondsStopped = this._secondsStarted;
        this._animHandler = 0;
        this._pulseEvent = { type: "pulse", context: this.context, systemUpdated: false };
    }
    start() {
        if (this._animHandler === 0) {
            if (this._secondsStopped > 0) {
                this._secondsStarted += (Date.now() * 0.001 - this._secondsStopped);
                this._secondsStopped = 0;
            }
            this._animHandler = window.requestAnimationFrame(this.onAnimationFrame);
        }
    }
    stop() {
        if (this._animHandler !== 0) {
            if (this._secondsStopped === 0) {
                this._secondsStopped = Date.now() * 0.001;
            }
            window.cancelAnimationFrame(this._animHandler);
            this._animHandler = 0;
        }
    }
    pulse(milliseconds) {
        const { outs, context, _pulseEvent } = this;
        // update context
        context.time.setTime(milliseconds);
        const elapsed = milliseconds * 0.001 - this._secondsStarted;
        context.secondsDelta = elapsed - context.secondsElapsed;
        context.secondsElapsed = elapsed;
        context.frameNumber++;
        outs.time.setValue(context.secondsElapsed);
        outs.frame.setValue(context.frameNumber);
        // execute tick
        const tickUpdated = this.system.graph.tick(context);
        // emit pulse event
        _pulseEvent.systemUpdated = tickUpdated || this._tockUpdated;
        this.emit(_pulseEvent);
        // execute tock
        this._tockUpdated = this.system.graph.tock(context);
    }
    onAnimationFrame() {
        this.pulse(Date.now());
        this._animHandler = window.requestAnimationFrame(this.onAnimationFrame);
    }
}
CPulse.typeName = "CPulse";
CPulse.isSystemSingleton = true;
CPulse.pulseOuts = {
    time: _Component__WEBPACK_IMPORTED_MODULE_0__["types"].Number("Pulse.Time"),
    frame: _Component__WEBPACK_IMPORTED_MODULE_0__["types"].Integer("Pulse.Frame")
};


/***/ }),

/***/ "../../libs/ff-graph/source/components/CSelection.ts":
/*!***************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-graph/source/components/CSelection.ts ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CSelection; });
/* harmony import */ var _ff_core_ObjectRegistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/ObjectRegistry */ "../../libs/ff-core/source/ObjectRegistry.ts");
/* harmony import */ var _propertyTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../propertyTypes */ "../../libs/ff-graph/source/propertyTypes.ts");
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _Node__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Node */ "../../libs/ff-graph/source/Node.ts");
/* harmony import */ var _CGraph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CGraph */ "../../libs/ff-graph/source/components/CGraph.ts");
/* harmony import */ var _CController__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CController */ "../../libs/ff-graph/source/components/CController.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */






/**
 * Manages selection state for nodes and components.
 * Use [[CSelection.exclusiveSelect]] to decide whether node and component selection is mutually exclusive.
 * A selection always encompasses only items in one graph, the *active graph*. When the active graph changes,
 * an [[IActiveGraphEvent]] is fired.
 *
 * ### Events
 * - *"active-graph"* - emits an [[IActiveGraphEvent]] after the active graph has changed.
 * - *<ComponentType>* - [[CSelection.selectedComponents]] emits an [[IComponentEvent]] if a component is selected/unselected.
 * - *<NodeType>* - [[CSelection.selectedNodes]] emits an [[INodeEvent]] if a node is selected/unselected.
 */
class CSelection extends _CController__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor(node, id) {
        super(node, id);
        this.outs = this.addOutputs(CSelection.selOuts);
        this.multiSelect = false;
        this.exclusiveSelect = true;
        this.selectedNodes = new _ff_core_ObjectRegistry__WEBPACK_IMPORTED_MODULE_0__["default"](_Node__WEBPACK_IMPORTED_MODULE_3__["default"]);
        this.selectedComponents = new _ff_core_ObjectRegistry__WEBPACK_IMPORTED_MODULE_0__["default"](_Component__WEBPACK_IMPORTED_MODULE_2__["default"]);
        this._activeGraph = null;
        this.addEvents("select-node", "select-component", "active-graph", "update");
        this.selectedNodes.on(_Node__WEBPACK_IMPORTED_MODULE_3__["default"], e => this.onSelectNode(e.object, e.add));
        this.selectedComponents.on(_Component__WEBPACK_IMPORTED_MODULE_2__["default"], e => this.onSelectComponent(e.object, e.add));
        this._activeGraph = this.system.graph;
    }
    getSelectedNode(nodeOrClass) {
        return this.selectedNodes.get(nodeOrClass, true);
    }
    getSelectedNodes(nodeOrClass) {
        return this.selectedNodes.getArray(nodeOrClass);
    }
    getSelectedComponent(componentOrClass) {
        return this.selectedComponents.get(componentOrClass, true);
    }
    getSelectedComponents(componentOrClass) {
        return this.selectedComponents.getArray(componentOrClass);
    }
    get activeGraph() {
        return this._activeGraph;
    }
    set activeGraph(graph) {
        if (graph !== this.activeGraph) {
            this.clearSelection();
            const previous = this._activeGraph;
            this._activeGraph = graph;
            this.onActiveGraph(graph);
            this.emit({ type: "active-graph", previous, next: graph });
        }
    }
    hasParentGraph() {
        return this._activeGraph && this._activeGraph.parent;
    }
    activateParentGraph() {
        if (this._activeGraph && this._activeGraph.parent.graph) {
            this.activeGraph = this._activeGraph.parent.graph;
        }
    }
    hasChildGraph() {
        return this.selectedComponents.has(_CGraph__WEBPACK_IMPORTED_MODULE_4__["default"]);
    }
    activateChildGraph() {
        const graphComponent = this.selectedComponents.get(_CGraph__WEBPACK_IMPORTED_MODULE_4__["default"], true);
        if (graphComponent) {
            this.activeGraph = graphComponent.innerGraph;
        }
    }
    create() {
        super.create();
        this.system.nodes.on(_Node__WEBPACK_IMPORTED_MODULE_3__["default"], this.onSystemNode, this);
        this.system.components.on(_Component__WEBPACK_IMPORTED_MODULE_2__["default"], this.onSystemComponent, this);
    }
    dispose() {
        this.system.nodes.off(_Node__WEBPACK_IMPORTED_MODULE_3__["default"], this.onSystemNode, this);
        this.system.components.off(_Component__WEBPACK_IMPORTED_MODULE_2__["default"], this.onSystemComponent, this);
        super.dispose();
    }
    createActions(commander) {
        return {
            selectNode: commander.register({
                name: "Select Node", do: this.selectNode, target: this
            }),
            selectComponent: commander.register({
                name: "Select Component", do: this.selectComponent, target: this
            }),
            clearSelection: commander.register({
                name: "Clear Selection", do: this.clearSelection, target: this
            })
        };
    }
    nodeContainsSelectedComponent(node) {
        const components = node.components.getArray();
        for (let i = 0, n = components.length; i < n; ++i) {
            if (this.selectedComponents.contains(components[i])) {
                return true;
            }
        }
        return false;
    }
    selectNode(node, toggle = false) {
        this.activeGraph = node.graph;
        const selectedNodes = this.selectedNodes;
        const multiSelect = this.multiSelect && toggle;
        if (node && selectedNodes.contains(node)) {
            if (multiSelect) {
                selectedNodes.remove(node);
            }
        }
        else {
            if (this.exclusiveSelect) {
                this.selectedComponents.clear();
            }
            if (!multiSelect) {
                selectedNodes.clear();
            }
            if (node) {
                selectedNodes.add(node);
            }
        }
        this.updateStats();
    }
    selectComponent(component, toggle = false) {
        this.activeGraph = component.graph;
        const selectedComponents = this.selectedComponents;
        const multiSelect = this.multiSelect && toggle;
        if (component && selectedComponents.contains(component)) {
            if (multiSelect) {
                selectedComponents.remove(component);
            }
        }
        else {
            if (this.exclusiveSelect) {
                this.selectedNodes.clear();
            }
            if (!multiSelect) {
                selectedComponents.clear();
            }
            if (component) {
                selectedComponents.add(component);
            }
        }
        this.updateStats();
    }
    clearSelection() {
        this.selectedNodes.clear();
        this.selectedComponents.clear();
        this.updateStats();
    }
    onSelectNode(node, selected) {
    }
    onSelectComponent(component, selected) {
    }
    onActiveGraph(graph) {
    }
    onSystemNode(event) {
        if (event.remove && this.selectedNodes.contains(event.object)) {
            this.selectedNodes.remove(event.object);
            this.updateStats();
        }
    }
    onSystemComponent(event) {
        if (event.remove && this.selectedComponents.contains(event.object)) {
            this.selectedComponents.remove(event.object);
            this.updateStats();
        }
    }
    updateStats() {
        const outs = this.outs;
        outs.selNodeCount.setValue(this.selectedNodes.length);
        outs.selComponentCount.setValue(this.selectedComponents.length);
    }
}
CSelection.typeName = "CSelection";
CSelection.selOuts = {
    selNodeCount: _propertyTypes__WEBPACK_IMPORTED_MODULE_1__["types"].Integer("Selection.Nodes"),
    selComponentCount: _propertyTypes__WEBPACK_IMPORTED_MODULE_1__["types"].Integer("Selection.Components")
};


/***/ }),

/***/ "../../libs/ff-graph/source/components/CTweenMachine.ts":
/*!******************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-graph/source/components/CTweenMachine.ts ***!
  \******************************************************************************/
/*! exports provided: EEasingCurve, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CTweenMachine; });
/* harmony import */ var _ff_core_easing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/easing */ "../../libs/ff-core/source/easing.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EEasingCurve", function() { return _ff_core_easing__WEBPACK_IMPORTED_MODULE_0__["EEasingCurve"]; });

/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _ff_core_uniqueId__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/core/uniqueId */ "../../libs/ff-core/source/uniqueId.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



////////////////////////////////////////////////////////////////////////////////

class CTweenMachine extends _Component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(...arguments);
        this.ins = this.addInputs(CTweenMachine.ins);
        this.outs = this.addOutputs(CTweenMachine.outs);
        this.targets = [];
        this.states = {};
        this._currentValues = null;
        this._targetState = null;
        this._startTime = 0;
        this._easingFunction = null;
    }
    getState(id) {
        return this.states[id];
    }
    setState(state) {
        state.id = state.id || Object(_ff_core_uniqueId__WEBPACK_IMPORTED_MODULE_2__["default"])(6);
        this.states[state.id] = state;
        return state.id;
    }
    deleteState(id) {
        delete this.states[id];
    }
    clear() {
        this.targets.forEach(target => target.property.off("dispose", this.onPropertyDispose, this));
        this.targets.length = 0;
        this.states = {};
        this._currentValues = null;
        this._targetState = null;
        this._startTime = 0;
        this._easingFunction = null;
    }
    dispose() {
        this.clear();
        super.dispose();
    }
    tweenTo(stateId, secondsElapsed) {
        const state = this.states[stateId];
        const outs = this.outs;
        if (state) {
            this._targetState = state;
            this._currentValues = this.getCurrentValues();
            this._startTime = secondsElapsed;
            this._easingFunction = Object(_ff_core_easing__WEBPACK_IMPORTED_MODULE_0__["getEasingFunction"])(state.curve);
            outs.switched.setValue(false);
            outs.tweening.setValue(true);
            outs.start.set();
            return true;
        }
    }
    update(context) {
        const ins = this.ins;
        const states = this.states;
        const id = ins.id.value;
        const state = states[id];
        if (state) {
            if (ins.tween.changed || ins.recall.changed) {
                ins.curve.setValue(state.curve);
                ins.duration.setValue(state.duration);
                ins.threshold.setValue(state.threshold);
            }
            if (ins.tween.changed) {
                this.tweenTo(id, context.secondsElapsed);
                return true;
            }
            if (ins.recall.changed) {
                this.setValues(state.values);
                return true;
            }
            if (ins.curve.changed || ins.duration.changed || ins.threshold.changed) {
                state.curve = ins.curve.value;
                state.duration = ins.duration.value;
                state.threshold = ins.threshold.value;
            }
            if (ins.store.changed) {
                state.values = this.getCurrentValues();
            }
            if (ins.delete.changed) {
                delete states[id];
            }
        }
        else if (id && ins.store.changed) {
            const state = {
                id: this.ins.id.value,
                curve: this.ins.curve.getValidatedValue(),
                duration: this.ins.duration.value,
                threshold: this.ins.threshold.value,
                values: this.getCurrentValues(),
            };
            states[state.id] = state;
        }
        return true;
    }
    tick(context) {
        const targetState = this._targetState;
        if (!targetState) {
            return false;
        }
        const outs = this.outs;
        const currentValues = this._currentValues;
        const startTime = this._startTime;
        const tweenTime = context.secondsElapsed - startTime;
        const tweenFactor = tweenTime / targetState.duration;
        if (tweenFactor < 1) {
            const easeFactor = this._easingFunction(tweenFactor);
            const shouldSwitch = tweenFactor >= targetState.threshold && !outs.switched.value;
            this.setValues(currentValues, targetState.values, easeFactor, shouldSwitch);
            outs.time.setValue(tweenTime);
            outs.completed.setValue(tweenFactor);
            if (shouldSwitch) {
                outs.switched.setValue(true);
                outs.switch.set();
            }
        }
        else {
            this.setValues(currentValues, targetState.values, 1, !outs.switched.value);
            outs.tweening.setValue(false);
            outs.time.setValue(targetState.duration);
            outs.completed.setValue(1);
            outs.end.set();
            if (!outs.switched.value) {
                outs.switched.setValue(true);
            }
            this._currentValues = null;
            this._targetState = null;
            this._startTime = 0;
            this._easingFunction = null;
        }
        return true;
    }
    addTargetProperty(property) {
        if (property.type === "object" || property.schema.event) {
            throw new Error("can't add object or event properties");
        }
        if (this.getTarget(property)) {
            throw new Error("can't add, target already exists");
        }
        property.on("dispose", this.onPropertyDispose, this);
        const isNumber = property.type === "number" && !property.schema.options;
        const isArray = property.isArray();
        this.targets.push({ property, isNumber, isArray });
        const states = this.states;
        const keys = Object.keys(states);
        for (let i = 0, n = keys.length; i < n; ++i) {
            states[keys[i]].values.push(property.cloneValue());
        }
        if (this._currentValues) {
            this._currentValues.push(property.cloneValue());
        }
    }
    removeTargetProperty(property) {
        const target = this.getTarget(property);
        if (!target) {
            throw new Error("can't remove, target doesn't exist");
        }
        this.removeTarget(target);
    }
    hasTargetProperty(property) {
        return !!this.getTarget(property);
    }
    fromJSON(json) {
        super.fromJSON(json);
        if (json.state) {
            this.stateFromJSON(json.state);
        }
    }
    stateFromJSON(json) {
        if (json.targets) {
            this.targets = json.targets.map(jsonTarget => {
                const property = this.getProperty(jsonTarget.id, jsonTarget.key);
                return {
                    property,
                    isNumber: !!property && property.type === "number" && !property.schema.options,
                    isArray: !!property && property.isArray(),
                };
            });
        }
        if (json.states) {
            json.states.forEach(state => this.states[state.id] = state);
        }
        this._startTime = 0;
    }
    toJSON() {
        const json = super.toJSON();
        const state = this.stateToJSON();
        if (state) {
            json.state = state;
        }
        return json;
    }
    stateToJSON() {
        const json = {};
        const targets = this.targets;
        if (targets.length > 0) {
            json.targets = targets.map(target => ({
                id: target.property.group.linkable.id,
                key: target.property.key
            }));
        }
        const keys = Object.keys(this.states);
        if (keys.length > 0) {
            json.states = keys.map(key => this.states[key]);
        }
        return json;
    }
    getTargetProperties() {
        return this.targets.map(target => target.property);
    }
    onPropertyDispose(event) {
        event.property.off("dispose", this.onPropertyDispose, this);
        const target = this.getTarget(event.property);
        this.removeTarget(target);
    }
    removeTarget(target) {
        const index = this.targets.indexOf(target);
        this.targets.splice(index, 1);
        this.removeChannel(index);
    }
    removeChannel(index) {
        const states = this.states;
        const keys = Object.keys(states);
        for (let i = 0, n = keys.length; i < n; ++i) {
            states[keys[i]].values.splice(index, 1);
        }
        if (this._currentValues) {
            this._currentValues.splice(index, 1);
        }
    }
    getTarget(property) {
        return this.targets.find(target => target.property === property);
    }
    getProperty(componentId, propertyKey) {
        const component = this.system.components.getById(componentId);
        if (!component) {
            return null;
        }
        return component.ins[propertyKey];
    }
    setValues(valuesA, valuesB, factor, doSwitch) {
        const targets = this.targets;
        for (let i = 0, n = targets.length; i < n; ++i) {
            const target = targets[i];
            const property = target.property;
            if (target.isNumber && valuesB) {
                const vA = valuesA[i];
                const vB = valuesB[i];
                if (target.isArray) {
                    let changed = false;
                    for (let i = 0, n = vA.length; i < n; ++i) {
                        const v = vA[i] + factor * (vB[i] - vA[i]);
                        changed = property.value[i] !== v || changed;
                        property.value[i] = v;
                    }
                    if (changed) {
                        property.set();
                    }
                }
                else {
                    const v = vA + factor * (vB - vA);
                    if (v !== property.value) {
                        property.setValue(v);
                    }
                }
            }
            else if (!valuesB || doSwitch) {
                const value = valuesB ? valuesB[i] : valuesA[i];
                if (target.isArray) {
                    let changed = false;
                    for (let i = 0, n = value.length; i < n; ++i) {
                        changed = property.value[i] !== value[i] || changed;
                        property.value[i] = value[i];
                    }
                    if (changed) {
                        property.set();
                    }
                }
                else if (value !== property.value) {
                    property.setValue(value);
                }
            }
        }
    }
    getCurrentValues() {
        const values = [];
        const targets = this.targets;
        for (let i = 0, n = targets.length; i < n; ++i) {
            values.push(targets[i].property.cloneValue());
        }
        return values;
    }
}
CTweenMachine.typeName = "CTweenMachine";
CTweenMachine.ins = {
    id: _Component__WEBPACK_IMPORTED_MODULE_1__["types"].String("Snapshot.Id"),
    curve: _Component__WEBPACK_IMPORTED_MODULE_1__["types"].Enum("Tween.Curve", _ff_core_easing__WEBPACK_IMPORTED_MODULE_0__["EEasingCurve"]),
    duration: _Component__WEBPACK_IMPORTED_MODULE_1__["types"].Number("Tween.Duration", 2),
    threshold: _Component__WEBPACK_IMPORTED_MODULE_1__["types"].Percent("Tween.Threshold", 0.5),
    tween: _Component__WEBPACK_IMPORTED_MODULE_1__["types"].Event("Control.Tween"),
    recall: _Component__WEBPACK_IMPORTED_MODULE_1__["types"].Event("Control.Recall"),
    store: _Component__WEBPACK_IMPORTED_MODULE_1__["types"].Event("Control.Store"),
    delete: _Component__WEBPACK_IMPORTED_MODULE_1__["types"].Event("Control.Delete"),
    clear: _Component__WEBPACK_IMPORTED_MODULE_1__["types"].Event("Control.Clear"),
};
CTweenMachine.outs = {
    count: _Component__WEBPACK_IMPORTED_MODULE_1__["types"].Integer("Snapshots.Count"),
    tweening: _Component__WEBPACK_IMPORTED_MODULE_1__["types"].Boolean("Tween.IsTweening"),
    time: _Component__WEBPACK_IMPORTED_MODULE_1__["types"].Number("Tween.Time"),
    completed: _Component__WEBPACK_IMPORTED_MODULE_1__["types"].Percent("Tween.Completed"),
    switched: _Component__WEBPACK_IMPORTED_MODULE_1__["types"].Boolean("Tween.Switched"),
    start: _Component__WEBPACK_IMPORTED_MODULE_1__["types"].Event("Tween.Start"),
    switch: _Component__WEBPACK_IMPORTED_MODULE_1__["types"].Event("Tween.Switch"),
    end: _Component__WEBPACK_IMPORTED_MODULE_1__["types"].Event("Tween.End"),
};


/***/ }),

/***/ "../../libs/ff-graph/source/convert.ts":
/*!*************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-graph/source/convert.ts ***!
  \*************************************************************/
/*! exports provided: getConversionFunction, canConvert, getElementCopyFunction, getMultiCopyFunction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getConversionFunction", function() { return getConversionFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canConvert", function() { return canConvert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getElementCopyFunction", function() { return getElementCopyFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMultiCopyFunction", function() { return getMultiCopyFunction; });
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
const _identity = [
    function (srcVal) {
        return srcVal;
    },
    function (srcVal, dstVal) {
        for (let i = 0, n = dstVal.length; i < n; ++i) {
            dstVal[i] = srcVal[i];
        }
        return dstVal;
    }
];
const _toBoolean = [
    function (srcVal) {
        return !!srcVal;
    },
    function (srcVal, dstVal) {
        for (let i = 0, n = dstVal.length; i < n; ++i) {
            dstVal[i] = !!srcVal[i];
        }
        return dstVal;
    }
];
const _toString = [
    function (srcVal) {
        return String(srcVal);
    },
    function (srcVal, dstVal) {
        for (let i = 0, n = dstVal.length; i < n; ++i) {
            dstVal[i] = String(srcVal[i]);
        }
        return dstVal;
    }
];
const _parseFloat = [
    function (srcVal) {
        return parseFloat(srcVal) || 0;
    },
    function (srcVal, dstVal) {
        for (let i = 0, n = dstVal.length; i < n; ++i) {
            dstVal[i] = parseFloat(srcVal[i]) || 0;
        }
        return dstVal;
    }
];
const _booleanToNumber = [
    function (srcVal) {
        return srcVal ? 1 : 0;
    },
    function (srcVal, dstVal) {
        for (let i = 0, n = dstVal.length; i < n; ++i) {
            dstVal[i] = srcVal[i] ? 1 : 0;
        }
        return dstVal;
    }
];
const _illegalThrow = [
    function (srcVal, dstVal) {
        throw new Error(`illegal value conversion from ${typeof srcVal} to ${typeof dstVal}`);
    },
    function (srcVal, dstVal, elements) {
        throw new Error(`illegal array conversion from ${typeof srcVal[0]} to ${typeof dstVal[0]}`);
    }
];
const _conversionFunctions = {
    "number": {
        "number": _identity,
        "boolean": _toBoolean,
        "string": _toString,
        "object": _illegalThrow
    },
    "boolean": {
        "number": _booleanToNumber,
        "boolean": _identity,
        "string": _toString,
        "object": _illegalThrow
    },
    "string": {
        "number": _parseFloat,
        "boolean": _toBoolean,
        "string": _identity,
        "object": _illegalThrow
    },
    "object": {
        "number": _illegalThrow,
        "boolean": _toBoolean,
        "string": _toString,
        "object": _identity
    }
};
const _conversionTable = {
    "number": {
        "number": true,
        "boolean": true,
        "string": true,
        "object": false
    },
    "boolean": {
        "number": true,
        "boolean": true,
        "string": true,
        "object": false
    },
    "string": {
        "number": true,
        "boolean": true,
        "string": true,
        "object": false
    },
    "object": {
        "number": false,
        "boolean": true,
        "string": true,
        "object": true
    }
};
const _copyFunctions = [
    [
        function (srcVal, dstVal, fnConvert) {
            return fnConvert(srcVal, dstVal); // value > value
        },
        function (srcVal, dstVal, fnConvert) {
            dstVal[0] = fnConvert(srcVal); // value > [0]
            return dstVal;
        },
        function (srcVal, dstVal, fnConvert) {
            dstVal[1] = fnConvert(srcVal); // value > [1]
            return dstVal;
        },
        function (srcVal, dstVal, fnConvert) {
            dstVal[2] = fnConvert(srcVal); // value > [2]
            return dstVal;
        },
        function (srcVal, dstVal, fnConvert) {
            dstVal[3] = fnConvert(srcVal); // value > [3]
            return dstVal;
        }
    ],
    [
        function (srcVal, dstVal, fnConvert) {
            return fnConvert(srcVal[0]); // [0] > value
        },
        function (srcVal, dstVal, fnConvert) {
            dstVal[0] = fnConvert(srcVal[0]); // [0] > [0]
            return dstVal;
        },
        function (srcVal, dstVal, fnConvert) {
            dstVal[1] = fnConvert(srcVal[0]); // [0] > [1]
            return dstVal;
        },
        function (srcVal, dstVal, fnConvert) {
            dstVal[2] = fnConvert(srcVal[0]); // [0] > [2]
            return dstVal;
        },
        function (srcVal, dstVal, fnConvert) {
            dstVal[3] = fnConvert(srcVal[0]); // [0] > [3]
            return dstVal;
        }
    ],
    [
        function (srcVal, dstVal, fnConvert) {
            return fnConvert(srcVal[1]); // [1] > value
        },
        function (srcVal, dstVal, fnConvert) {
            dstVal[0] = fnConvert(srcVal[1]); // [1] > [0]
            return dstVal;
        },
        function (srcVal, dstVal, fnConvert) {
            dstVal[1] = fnConvert(srcVal[1]); // [1] > [1]
            return dstVal;
        },
        function (srcVal, dstVal, fnConvert) {
            dstVal[2] = fnConvert(srcVal[1]); // [1] > [2]
            return dstVal;
        },
        function (srcVal, dstVal, fnConvert) {
            dstVal[3] = fnConvert(srcVal[1]); // [1] > [3]
            return dstVal;
        }
    ],
    [
        function (srcVal, dstVal, fnConvert) {
            return fnConvert(srcVal[2]); // [2] > value
        },
        function (srcVal, dstVal, fnConvert) {
            dstVal[0] = fnConvert(srcVal[2]); // [2] > [0]
            return dstVal;
        },
        function (srcVal, dstVal, fnConvert) {
            dstVal[1] = fnConvert(srcVal[2]); // [2] > [1]
            return dstVal;
        },
        function (srcVal, dstVal, fnConvert) {
            dstVal[2] = fnConvert(srcVal[2]); // [2] > [2]
            return dstVal;
        },
        function (srcVal, dstVal, fnConvert) {
            dstVal[3] = fnConvert(srcVal[2]); // [2] > [3]
            return dstVal;
        }
    ],
    [
        function (srcVal, dstVal, fnConvert) {
            return fnConvert(srcVal[3]); // [3] > value
        },
        function (srcVal, dstVal, fnConvert) {
            dstVal[0] = fnConvert(srcVal[3]); // [3] > [0]
            return dstVal;
        },
        function (srcVal, dstVal, fnConvert) {
            dstVal[1] = fnConvert(srcVal[3]); // [3] > [1]
            return dstVal;
        },
        function (srcVal, dstVal, fnConvert) {
            dstVal[2] = fnConvert(srcVal[3]); // [3] > [2]
            return dstVal;
        },
        function (srcVal, dstVal, fnConvert) {
            dstVal[3] = fnConvert(srcVal[3]); // [3] > [3]
            return dstVal;
        }
    ]
];
function getConversionFunction(sourceType, destinationType, isArray) {
    const index = isArray ? 1 : 0;
    return _conversionFunctions[sourceType][destinationType][index];
}
function canConvert(sourceType, destinationType) {
    return _conversionTable[sourceType][destinationType];
}
function getElementCopyFunction(sourceIndex, destinationIndex, fnConvert) {
    if (sourceIndex === -1 && destinationIndex === -1) {
        return fnConvert;
    }
    if (sourceIndex <= 3 && destinationIndex <= 3) {
        return _copyFunctions[sourceIndex + 1][destinationIndex + 1];
    }
    return function (srcVal, dstVal, fnConvert) {
        dstVal[destinationIndex] = fnConvert(srcVal[sourceIndex]);
        return dstVal;
    };
}
function getMultiCopyFunction(sourceIsMulti, destinationIsMulti, fnCopy) {
    if (sourceIsMulti === false) {
        if (destinationIsMulti === false) {
            // single > single
            return fnCopy;
        }
        else {
            // single > multi
            return function (srcVal, dstVal, fnConvert) {
                for (let i = 0, n = dstVal.length; i < n; ++i) {
                    dstVal[i] = fnCopy(srcVal, dstVal[i]);
                }
                return dstVal;
            };
        }
    }
    else {
        if (destinationIsMulti === false) {
            // multi > single
            return function (srcVal, dstVal, fnConvert) {
                if (srcVal.length > 0) {
                    dstVal = fnCopy(srcVal[0], dstVal);
                }
                return dstVal;
            };
        }
        else {
            // multi > multi
            return function (srcVal, dstVal, fnConvert) {
                for (let i = 0, m = srcVal.length, n = dstVal.length; i < n; ++i) {
                    dstVal[i] = fnCopy(srcVal[i % m], dstVal[i]);
                }
                return dstVal;
            };
        }
    }
}



/***/ }),

/***/ "../../libs/ff-graph/source/propertyTypes.ts":
/*!*******************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-graph/source/propertyTypes.ts ***!
  \*******************************************************************/
/*! exports provided: labels, makeType, makeEnumType, makeOptionType, makeObjectType, schemas, types */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "labels", function() { return labels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeType", function() { return makeType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeEnumType", function() { return makeEnumType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeOptionType", function() { return makeOptionType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeObjectType", function() { return makeObjectType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "schemas", function() { return schemas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "types", function() { return types; });
/* harmony import */ var _ff_core_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/types */ "../../libs/ff-core/source/types.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */

const labels = {
    xyzw: ["X", "Y", "Z", "W"],
    rgba: ["R", "G", "B", "A"],
};
const parseProps = function (props) {
    if (props === undefined || (typeof props === "object" && !Array.isArray(props))) {
        return props;
    }
    return { preset: props };
};
const makeType = function (schema, path, props) {
    props = parseProps(props);
    return { path, schema: props ? Object.assign({}, schema, props) : schema };
};
const makeEnumType = function (enumeration, path, props) {
    props = parseProps(props);
    const schema = { enum: enumeration, options: Object(_ff_core_types__WEBPACK_IMPORTED_MODULE_0__["enumToArray"])(enumeration), preset: 0 };
    return { path, schema: props ? Object.assign({}, schema, props) : schema };
};
const makeOptionType = function (options, path, props) {
    props = parseProps(props);
    const schema = { options, preset: 0 };
    return { path, schema: props ? Object.assign({}, schema, props) : schema };
};
const makeObjectType = function (type, path, props) {
    props = parseProps(props);
    const schema = { preset: null, objectType: type };
    return { path, schema: props ? Object.assign({}, schema, props) : schema };
};
const schemas = {
    Number: { preset: 0 },
    Integer: { preset: 0, step: 1, speed: 0.34, precision: 0 },
    Natural: { preset: 0, step: 1, speed: 0.34, precision: 0, min: 0 },
    Unit: { preset: 0, min: 0, max: 1, bar: true },
    Percent: { preset: 0, min: 0, max: 1, bar: true, percent: true },
    Vector2: { preset: [0, 0] },
    Vector3: { preset: [0, 0, 0] },
    Vector4: { preset: [0, 0, 0, 0] },
    Matrix2: { preset: [1, 0, 0, 1] },
    Matrix3: { preset: [1, 0, 0, 0, 1, 0, 0, 0, 1] },
    Matrix4: { preset: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] },
    Scale: { preset: 1 },
    Scale2: { preset: [1, 1] },
    Scale3: { preset: [1, 1, 1] },
    IntVec2: { preset: [0, 0], step: 1, speed: 0.34, precision: 0 },
    IntVec3: { preset: [0, 0, 0], step: 1, speed: 0.34, precision: 0 },
    ColorRGB: { preset: [1, 1, 1], semantic: "color", labels: labels.rgba, min: 0, max: 1, bar: true },
    ColorRGBA: { preset: [1, 1, 1, 1], semantic: "color", labels: labels.rgba, min: 0, max: 1, bar: true },
    Boolean: { preset: false },
    String: { preset: "" },
    AssetPath: { preset: "", semantic: "asset-path" },
    Object: { preset: null, objectType: Object },
    Event: { preset: 0, event: true }
};
const types = {
    Property: (path, props) => makeType(undefined, path, props),
    Number: (path, props) => makeType(schemas.Number, path, props),
    Integer: (path, props) => makeType(schemas.Integer, path, props),
    Natural: (path, props) => makeType(schemas.Natural, path, props),
    Unit: (path, props) => makeType(schemas.Unit, path, props),
    Percent: (path, props) => makeType(schemas.Percent, path, props),
    Vector2: (path, props) => makeType(schemas.Vector2, path, props),
    Vector3: (path, props) => makeType(schemas.Vector3, path, props),
    Vector4: (path, props) => makeType(schemas.Vector4, path, props),
    IntVec2: (path, props) => makeType(schemas.IntVec2, path, props),
    IntVec3: (path, props) => makeType(schemas.IntVec3, path, props),
    Matrix2: (path, props) => makeType(schemas.Matrix2, path, props),
    Matrix3: (path, props) => makeType(schemas.Matrix3, path, props),
    Matrix4: (path, props) => makeType(schemas.Matrix4, path, props),
    Scale: (path, props) => makeType(schemas.Scale, path, props),
    Scale2: (path, props) => makeType(schemas.Scale2, path, props),
    Scale3: (path, props) => makeType(schemas.Scale3, path, props),
    ColorRGB: (path, props) => makeType(schemas.ColorRGB, path, props),
    ColorRGBA: (path, props) => makeType(schemas.ColorRGBA, path, props),
    Boolean: (path, props) => makeType(schemas.Boolean, path, props),
    String: (path, props) => makeType(schemas.String, path, props),
    AssetPath: (path, props) => makeType(schemas.AssetPath, path, props),
    Enum: (path, enumeration, props) => makeEnumType(enumeration, path, props),
    Option: (path, options, props) => makeOptionType(options, path, props),
    Object: (path, type, props) => makeObjectType(type, path, props),
    Event: (path, props) => makeType(schemas.Event, path, props)
};


/***/ }),

/***/ "../../libs/ff-scene/source/RenderQuadView.ts":
/*!********************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-scene/source/RenderQuadView.ts ***!
  \********************************************************************/
/*! exports provided: EQuadViewLayout, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EQuadViewLayout", function() { return EQuadViewLayout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderQuadView; });
/* harmony import */ var _ff_three_UniversalCamera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/three/UniversalCamera */ "../../libs/ff-three/source/UniversalCamera.ts");
/* harmony import */ var _RenderView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RenderView */ "../../libs/ff-scene/source/RenderView.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */


var EQuadViewLayout;
(function (EQuadViewLayout) {
    EQuadViewLayout[EQuadViewLayout["Single"] = 0] = "Single";
    EQuadViewLayout[EQuadViewLayout["HorizontalSplit"] = 1] = "HorizontalSplit";
    EQuadViewLayout[EQuadViewLayout["VerticalSplit"] = 2] = "VerticalSplit";
    EQuadViewLayout[EQuadViewLayout["Quad"] = 3] = "Quad";
})(EQuadViewLayout || (EQuadViewLayout = {}));
class RenderQuadView extends _RenderView__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(system, canvas, overlay) {
        super(system, canvas, overlay);
        this._layout = EQuadViewLayout.Quad;
        this._horizontalSplit = 0.5;
        this._verticalSplit = 0.5;
        this.addEvent("layout");
        this.layout = EQuadViewLayout.Single;
    }
    set layout(layout) {
        if (layout === this._layout) {
            return;
        }
        this._layout = layout;
        const viewports = this.viewports;
        switch (this._layout) {
            case EQuadViewLayout.Single:
                this.setViewportCount(1);
                break;
            case EQuadViewLayout.HorizontalSplit:
            case EQuadViewLayout.VerticalSplit:
                this.setViewportCount(2);
                break;
            case EQuadViewLayout.Quad:
                this.setViewportCount(4);
                break;
        }
        this.updateSplitPositions();
        if (viewports[1]) {
            viewports[1].setBuiltInCamera(_ff_three_UniversalCamera__WEBPACK_IMPORTED_MODULE_0__["EProjection"].Orthographic, _ff_three_UniversalCamera__WEBPACK_IMPORTED_MODULE_0__["EViewPreset"].Top);
            viewports[1].enableCameraControl(true).orientationEnabled = false;
        }
        if (viewports[2]) {
            viewports[2].setBuiltInCamera(_ff_three_UniversalCamera__WEBPACK_IMPORTED_MODULE_0__["EProjection"].Orthographic, _ff_three_UniversalCamera__WEBPACK_IMPORTED_MODULE_0__["EViewPreset"].Left);
            viewports[2].enableCameraControl(true).orientationEnabled = false;
        }
        if (viewports[3]) {
            viewports[3].setBuiltInCamera(_ff_three_UniversalCamera__WEBPACK_IMPORTED_MODULE_0__["EProjection"].Orthographic, _ff_three_UniversalCamera__WEBPACK_IMPORTED_MODULE_0__["EViewPreset"].Front);
            viewports[3].enableCameraControl(true).orientationEnabled = false;
        }
        this.emit({ type: "layout", layout });
    }
    get layout() {
        return this._layout;
    }
    set horizontalSplit(value) {
        this._horizontalSplit = value;
        this.updateSplitPositions();
    }
    get horizontalSplit() {
        return this._horizontalSplit;
    }
    set verticalSplit(value) {
        this._verticalSplit = value;
        this.updateSplitPositions();
    }
    get verticalSplit() {
        return this._verticalSplit;
    }
    updateSplitPositions() {
        const h = this._horizontalSplit;
        const v = this._verticalSplit;
        switch (this._layout) {
            case EQuadViewLayout.Single:
                this.viewports[0].setSize(0, 0, 1, 1);
                break;
            case EQuadViewLayout.HorizontalSplit:
                this.viewports[0].setSize(0, 0, h, 1);
                this.viewports[1].setSize(h, 0, 1 - h, 1);
                break;
            case EQuadViewLayout.VerticalSplit:
                this.viewports[0].setSize(0, 1 - v, 1, v);
                this.viewports[1].setSize(0, 0, 1, 1 - v);
                break;
            case EQuadViewLayout.Quad:
                this.viewports[0].setSize(0, 1 - v, h, v);
                this.viewports[1].setSize(h, 1 - v, 1 - h, v);
                this.viewports[2].setSize(0, 0, h, 1 - v);
                this.viewports[3].setSize(h, 0, 1 - h, 1 - v);
                break;
        }
    }
}


/***/ }),

/***/ "../../libs/ff-scene/source/RenderView.ts":
/*!****************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-scene/source/RenderView.ts ***!
  \****************************************************************/
/*! exports provided: Viewport, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderView; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_core_Publisher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/core/Publisher */ "../../libs/ff-core/source/Publisher.ts");
/* harmony import */ var _ff_graph_components_CHierarchy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/graph/components/CHierarchy */ "../../libs/ff-graph/source/components/CHierarchy.ts");
/* harmony import */ var _ff_three_Viewport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ff/three/Viewport */ "../../libs/ff-three/source/Viewport.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Viewport", function() { return _ff_three_Viewport__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _ff_three_ui_ViewportOverlay__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ff/three/ui/ViewportOverlay */ "../../libs/ff-three/source/ui/ViewportOverlay.ts");
/* harmony import */ var _ff_three_GPUPicker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ff/three/GPUPicker */ "../../libs/ff-three/source/GPUPicker.ts");
/* harmony import */ var _components_CRenderer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/CRenderer */ "../../libs/ff-scene/source/components/CRenderer.ts");
/* harmony import */ var _ff_three_UniversalCamera__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ff/three/UniversalCamera */ "../../libs/ff-three/source/UniversalCamera.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */








////////////////////////////////////////////////////////////////////////////////

class RenderView extends _ff_core_Publisher__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(system, canvas, overlay) {
        super();
        this.viewports = [];
        this.rendererComponent = null;
        this.targetViewport = null;
        this.targetObject3D = null;
        this.targetComponent = null;
        this.targetScene = null;
        this.targetCamera = null;
        this.defaultScene = new three__WEBPACK_IMPORTED_MODULE_0__["Scene"]();
        this.defaultCamera = new _ff_three_UniversalCamera__WEBPACK_IMPORTED_MODULE_7__["default"]();
        this.system = system;
        this.canvas = canvas;
        this.overlay = overlay;
        this.renderer = new three__WEBPACK_IMPORTED_MODULE_0__["WebGLRenderer"]({
            canvas,
            antialias: true
        });
        this.renderer.autoClear = false;
        //this.renderer.gammaOutput = true;
        this.renderer.gammaFactor = 2;
        this.renderer.outputEncoding = three__WEBPACK_IMPORTED_MODULE_0__["sRGBEncoding"];
        this.picker = new _ff_three_GPUPicker__WEBPACK_IMPORTED_MODULE_5__["default"](this.renderer);
    }
    dispose() {
        this.renderer.dispose();
        this.viewports.forEach(viewport => viewport.dispose());
    }
    get canvasWidth() {
        return this.canvas.width;
    }
    get canvasHeight() {
        return this.canvas.height;
    }
    attach() {
        const width = this.canvasWidth;
        const height = this.canvasHeight;
        this.viewports.forEach(viewport => viewport.setCanvasSize(width, height));
        this.renderer.setSize(width, height, false);
        this.rendererComponent = this.system.getComponent(_components_CRenderer__WEBPACK_IMPORTED_MODULE_6__["default"], true);
        this.rendererComponent.attachView(this);
    }
    detach() {
        this.rendererComponent = this.system.getComponent(_components_CRenderer__WEBPACK_IMPORTED_MODULE_6__["default"], true);
        this.rendererComponent.detachView(this);
        this.rendererComponent = null;
    }
    renderImage(width, height, format, quality) {
        if (true) {
            console.log("RenderView.renderImage - width: %s, height: %s, format: %s, quality: %s", width, height, format, quality);
        }
        const canvasWidth = this.canvas.width;
        const canvasHeight = this.canvas.height;
        this.setRenderSize(width, height);
        this.render();
        const dataURL = this.canvas.toDataURL(format, quality);
        this.setRenderSize(canvasWidth, canvasHeight);
        return dataURL;
    }
    render() {
        const sceneComponent = this.rendererComponent.activeSceneComponent;
        if (!sceneComponent) {
            return;
        }
        let scene = sceneComponent.scene;
        let camera = sceneComponent.activeCamera;
        if (!scene || !camera) {
            if (true) {
                console.warn(!scene ? !camera ? "no scene/camera" : "no scene" : "no camera");
            }
            scene = this.defaultScene;
            camera = this.defaultCamera;
        }
        const renderer = this.renderer;
        renderer.clear();
        renderer["__view"] = this;
        const viewports = this.viewports;
        for (let i = 0, n = viewports.length; i < n; ++i) {
            const viewport = viewports[i];
            renderer["__viewport"] = viewport;
            const currentCamera = viewport.updateCamera(camera);
            viewport.applyViewport(this.renderer);
            renderer.render(scene, currentCamera);
        }
    }
    setRenderSize(width, height) {
        this.canvas.width = width;
        this.canvas.height = height;
        this.viewports.forEach(viewport => viewport.setCanvasSize(width, height));
        if (!this.renderer.xr.isPresenting) {
            this.renderer.setSize(width, height, false);
        }
    }
    resize() {
        this.setRenderSize(this.canvas.clientWidth, this.canvas.clientHeight);
        if (!this.renderer.xr.isPresenting) {
            this.render();
        }
    }
    setViewportCount(count) {
        const viewports = this.viewports;
        for (let i = count; i < viewports.length; ++i) {
            viewports[i].dispose();
        }
        for (let i = viewports.length; i < count; ++i) {
            const overlay = new _ff_three_ui_ViewportOverlay__WEBPACK_IMPORTED_MODULE_4__["default"]().appendTo(this.overlay);
            viewports[i] = new _ff_three_Viewport__WEBPACK_IMPORTED_MODULE_3__["default"]();
            viewports[i].setCanvasSize(this.canvasWidth, this.canvasHeight);
            viewports[i].overlay = overlay;
        }
        viewports.length = count;
    }
    getViewportCount() {
        return this.viewports.length;
    }
    onPointer(event) {
        const system = this.system;
        if (!system) {
            return false;
        }
        let doPick = false;
        let doHitTest = false;
        if (event.type === "pointer-hover") {
            doHitTest = true;
        }
        else if (event.isPrimary && event.type === "pointer-down") {
            doHitTest = true;
            doPick = true;
        }
        const viewEvent = this.routeEvent(event, doHitTest, doPick);
        if (viewEvent) {
            const component = viewEvent.component;
            if (component) {
                component.emit(viewEvent);
                const hierarchy = component.getComponent(_ff_graph_components_CHierarchy__WEBPACK_IMPORTED_MODULE_2__["default"]);
                if (!viewEvent.stopPropagation && hierarchy) {
                    hierarchy.propagateUp(false, true, viewEvent);
                }
            }
            if (!viewEvent.stopPropagation) {
                this.system.emit(viewEvent);
            }
            if (!viewEvent.stopPropagation) {
                const updated = viewEvent.viewport.onPointer(viewEvent);
                if (updated) {
                    this.system.getMainComponent(_components_CRenderer__WEBPACK_IMPORTED_MODULE_6__["default"]).forceRender();
                }
            }
            return true;
        }
        return false;
    }
    onTrigger(event) {
        const system = this.system;
        if (!system) {
            return false;
        }
        const viewEvent = this.routeEvent(event, true, true);
        if (viewEvent) {
            const component = viewEvent.component;
            if (component) {
                component.emit(viewEvent);
                const hierarchy = component.getComponent(_ff_graph_components_CHierarchy__WEBPACK_IMPORTED_MODULE_2__["default"]);
                if (!viewEvent.stopPropagation && hierarchy) {
                    hierarchy.propagateUp(false, true, viewEvent);
                }
            }
            if (!viewEvent.stopPropagation) {
                this.system.emit(viewEvent);
            }
            if (!viewEvent.stopPropagation) {
                const updated = viewEvent.viewport.onTrigger(viewEvent);
                if (updated) {
                    this.system.getMainComponent(_components_CRenderer__WEBPACK_IMPORTED_MODULE_6__["default"]).forceRender();
                }
            }
            return true;
        }
        return false;
    }
    pickPosition(event, range, result) {
        return this.picker.pickPosition(this.targetScene, this.targetCamera, event, range, result);
    }
    pickNormal(event, result) {
        return this.picker.pickNormal(this.targetScene, this.targetCamera, event, result);
    }
    routeEvent(event, doHitTest, doPick) {
        let viewport = this.targetViewport;
        let object3D = this.targetObject3D;
        let component = this.targetComponent;
        // if no active viewport, perform a hit test against all viewports
        if (doHitTest) {
            viewport = null;
            const viewports = this.viewports;
            for (let i = 0, n = viewports.length; i < n; ++i) {
                const vp = viewports[i];
                if (vp.isInside(event)) {
                    viewport = vp;
                    break;
                }
            }
        }
        // without an active viewport, return null to cancel the event
        if (!viewport) {
            return null;
        }
        // if we have an active viewport now, augment event with viewport/view information
        const viewEvent = event;
        viewEvent.view = this;
        viewEvent.viewport = viewport;
        viewEvent.deviceX = viewport.getDeviceX(event.localX);
        viewEvent.deviceY = viewport.getDeviceY(event.localY);
        viewEvent.stopPropagation = false;
        // perform 3D pick
        if (doPick) {
            const sceneComponent = this.rendererComponent.activeSceneComponent;
            const scene = this.targetScene = sceneComponent && sceneComponent.scene;
            const camera = this.targetCamera = sceneComponent && sceneComponent.activeCamera;
            object3D = null;
            component = null;
            if (scene && camera) {
                object3D = this.picker.pickObject(scene, camera, event);
                if (object3D === undefined) {
                    if (true) {
                        console.log("Pick Index - Background");
                    }
                }
                else {
                    let componentObject3D = object3D;
                    while (componentObject3D && !component) {
                        component = componentObject3D.userData["component"];
                        if (!component) {
                            componentObject3D = componentObject3D.parent;
                        }
                    }
                    if (true) {
                        if (component) {
                            console.log("Pick Index - Component: %s", component.typeName);
                        }
                        else {
                            console.warn("Pick Index - Object without component");
                        }
                    }
                }
            }
        }
        viewEvent.object3D = object3D;
        viewEvent.component = component;
        this.targetViewport = viewport;
        this.targetObject3D = object3D;
        this.targetComponent = component;
        return viewEvent;
    }
}


/***/ }),

/***/ "../../libs/ff-scene/source/components/CBackground.ts":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-scene/source/components/CBackground.ts ***!
  \****************************************************************************/
/*! exports provided: EBackgroundStyle, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CBackground; });
/* harmony import */ var _CObject3D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CObject3D */ "../../libs/ff-scene/source/components/CObject3D.ts");
/* harmony import */ var _ff_three_Background__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/three/Background */ "../../libs/ff-three/source/Background.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EBackgroundStyle", function() { return _ff_three_Background__WEBPACK_IMPORTED_MODULE_1__["EBackgroundStyle"]; });

/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */


////////////////////////////////////////////////////////////////////////////////

class CBackground extends _CObject3D__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(node, id) {
        super(node, id);
        this.ins = this.addInputs(CBackground.backgroundIns);
        this.object3D = new _ff_three_Background__WEBPACK_IMPORTED_MODULE_1__["default"]();
    }
    get background() {
        return this.object3D;
    }
    update(context) {
        super.update(context);
        const ins = this.ins;
        const material = this.background.material;
        if (ins.style.changed) {
            material.style = ins.style.getValidatedValue();
        }
        if (ins.color0.changed) {
            material.color0.fromArray(ins.color0.value);
        }
        if (ins.color1.changed) {
            material.color1.fromArray(ins.color1.value);
        }
        if (ins.noise.changed) {
            material.noise = ins.noise.value;
        }
        return true;
    }
    dispose() {
        this.background.dispose();
        super.dispose();
    }
}
CBackground.typeName = "CBackground";
CBackground.backgroundIns = {
    style: _CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].Enum("Background.Style", _ff_three_Background__WEBPACK_IMPORTED_MODULE_1__["EBackgroundStyle"], _ff_three_Background__WEBPACK_IMPORTED_MODULE_1__["EBackgroundStyle"].RadialGradient),
    color0: _CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].ColorRGB("Background.Color0", [0.2, 0.25, 0.3]),
    color1: _CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].ColorRGB("Background.Color1", [0.01, 0.03, 0.05]),
    noise: _CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].Number("Background.Noise", { min: 0, max: 1, bar: true, preset: 0.02 }),
};


/***/ }),

/***/ "../../libs/ff-scene/source/components/CCamera.ts":
/*!************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-scene/source/components/CCamera.ts ***!
  \************************************************************************/
/*! exports provided: EProjection, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CCamera; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _ff_three_UniversalCamera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/three/UniversalCamera */ "../../libs/ff-three/source/UniversalCamera.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EProjection", function() { return _ff_three_UniversalCamera__WEBPACK_IMPORTED_MODULE_2__["EProjection"]; });

/* harmony import */ var _CObject3D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CObject3D */ "../../libs/ff-scene/source/components/CObject3D.ts");
/* harmony import */ var _ff_core_math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ff/core/math */ "../../libs/ff-core/source/math.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */





////////////////////////////////////////////////////////////////////////////////
const _vec3a = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vec3b = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _euler = new three__WEBPACK_IMPORTED_MODULE_0__["Euler"]();
const _quat = new three__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();

class CCamera extends _CObject3D__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(node, id) {
        super(node, id);
        this.ins = this.addInputs(CCamera.camIns);
        this.object3D = new _ff_three_UniversalCamera__WEBPACK_IMPORTED_MODULE_2__["default"]();
    }
    /**
     * Returns the internal [[UniversalCamera]] camera object of this component.
     */
    get camera() {
        return this.object3D;
    }
    update() {
        const { autoActivate, activate } = this.ins;
        // set the camera as active in the containing scene
        if (activate.changed || autoActivate.changed && autoActivate.value) {
            const scene = this.scene;
            if (scene) {
                scene.activeCameraComponent = this;
            }
        }
        const camera = this.camera;
        const { position, rotation, projection, fov, size, zoom, near, far } = this.ins;
        if (position.changed || rotation.changed) {
            camera.position.fromArray(position.value);
            camera.rotation.fromArray(rotation.value);
            camera.updateMatrix();
        }
        if (projection.changed) {
            camera.setProjection(projection.getValidatedValue());
        }
        camera.fov = fov.value;
        camera.size = size.value;
        camera.zoom = zoom.value;
        camera.near = near.value;
        camera.far = far.value;
        camera.updateProjectionMatrix();
        return true;
    }
    dispose() {
        const scene = this.scene;
        if (scene && scene.activeCameraComponent === this) {
            scene.activeCameraComponent = null;
        }
        super.dispose();
    }
    /**
     * Sets the position, rotation, and order properties from the given 4x4 transform matrix.
     * Updating the properties then also updates the matrix of the internal universal camera object.
     * @param matrix A 4x4 transform matrix. If omitted, properties are updated from the matrix of the internal camera.
     */
    setPropertiesFromMatrix(matrix) {
        const silent = !matrix;
        matrix = matrix || this.object3D.matrix;
        const { position, rotation, order } = this.ins;
        matrix.decompose(_vec3a, _quat, _vec3b);
        _vec3a.toArray(position.value);
        const orderName = order.getOptionText();
        _euler.setFromQuaternion(_quat, orderName);
        _euler.toVector3(_vec3a);
        _vec3a.multiplyScalar(_ff_core_math__WEBPACK_IMPORTED_MODULE_4__["default"].RAD2DEG).toArray(rotation.value);
        position.set(silent);
        rotation.set(silent);
    }
}
CCamera.typeName = "CCamera";
CCamera.camIns = {
    autoActivate: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Boolean("Camera.AutoActivate", true),
    activate: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Event("Camera.Activate"),
    position: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Vector3("Transform.Position"),
    rotation: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Vector3("Transform.Rotation"),
    order: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Enum("Transform.Order", _CObject3D__WEBPACK_IMPORTED_MODULE_3__["ERotationOrder"], _CObject3D__WEBPACK_IMPORTED_MODULE_3__["ERotationOrder"].ZYX),
    projection: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Enum("Projection.Type", _ff_three_UniversalCamera__WEBPACK_IMPORTED_MODULE_2__["EProjection"], _ff_three_UniversalCamera__WEBPACK_IMPORTED_MODULE_2__["EProjection"].Perspective),
    fov: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Number("Projection.FovY", 52),
    size: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Number("Projection.Size", 20),
    zoom: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Number("Projection.Zoom", 1),
    near: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Number("Frustum.ZNear", 0.01),
    far: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Number("Frustum.ZFar", 10000),
};


/***/ }),

/***/ "../../libs/ff-scene/source/components/CDirectionalLight.ts":
/*!**********************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-scene/source/components/CDirectionalLight.ts ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CDirectionalLight; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _CLight__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CLight */ "../../libs/ff-scene/source/components/CLight.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */



////////////////////////////////////////////////////////////////////////////////
class CDirectionalLight extends _CLight__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(node, id) {
        super(node, id);
        this.ins = this.addInputs(CDirectionalLight.dirLightIns);
        this.object3D = new three__WEBPACK_IMPORTED_MODULE_0__["DirectionalLight"]();
        this.light.target.matrixAutoUpdate = false;
    }
    get light() {
        return this.object3D;
    }
    update(context) {
        super.update(context);
        const light = this.light;
        const ins = this.ins;
        if (ins.position.changed || ins.target.changed) {
            light.position.fromArray(ins.position.value);
            light.target.position.fromArray(ins.target.value);
            light.updateMatrix();
            light.target.updateMatrix();
        }
        if (ins.shadowSize.changed) {
            const camera = light.shadow.camera;
            const halfSize = ins.shadowSize.value * 0.5;
            camera.left = camera.bottom = -halfSize;
            camera.right = camera.top = halfSize;
            camera.updateProjectionMatrix();
        }
        return true;
    }
    onAddToParent(parent) {
        super.onAddToParent(parent);
        parent.add(this.light.target);
    }
    onRemoveFromParent(parent) {
        super.onRemoveFromParent(parent);
        parent.remove(this.light.target);
    }
}
CDirectionalLight.typeName = "CDirectionalLight";
CDirectionalLight.dirLightIns = {
    position: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Vector3("Light.Position"),
    target: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Vector3("Light.Target", [0, -1, 0]),
    shadowSize: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Number("Shadow.Size", 100),
};


/***/ }),

/***/ "../../libs/ff-scene/source/components/CFloor.ts":
/*!***********************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-scene/source/components/CFloor.ts ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CFloor; });
/* harmony import */ var _CObject3D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CObject3D */ "../../libs/ff-scene/source/components/CObject3D.ts");
/* harmony import */ var _ff_three_Floor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/three/Floor */ "../../libs/ff-three/source/Floor.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */


////////////////////////////////////////////////////////////////////////////////
class CFloor extends _CObject3D__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(node, id) {
        super(node, id);
        this.ins = this.addInputs(CFloor.floorIns);
        this.object3D = new _ff_three_Floor__WEBPACK_IMPORTED_MODULE_1__["default"]();
    }
    get floor() {
        return this.object3D;
    }
    update(context) {
        super.update(context);
        const ins = this.ins;
        const floor = this.floor;
        if (ins.position.changed || ins.radius.changed) {
            floor.position.fromArray(ins.position.value);
            floor.scale.setScalar(ins.radius.value);
            floor.updateMatrix();
        }
        if (ins.color.changed) {
            floor.material.color.fromArray(ins.color.value);
        }
        if (ins.opacity.changed) {
            floor.material.opacity = ins.opacity.value;
        }
        return true;
    }
    dispose() {
        this.floor.dispose();
        super.dispose();
    }
}
CFloor.typeName = "CFloor";
CFloor.floorIns = {
    position: _CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].Vector3("Floor.Position", [0, -25, 0]),
    radius: _CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].Number("Floor.Radius", 50),
    color: _CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].ColorRGB("Floor.Color", [0.6, 0.75, 0.8]),
    opacity: _CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].Percent("Floor.Opacity", 0.5),
    castShadow: _CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("Shadow.Cast"),
    receiveShadow: _CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("Shadow.Receive"),
};


/***/ }),

/***/ "../../libs/ff-scene/source/components/CFullscreen.ts":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-scene/source/components/CFullscreen.ts ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CFullscreen; });
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */

////////////////////////////////////////////////////////////////////////////////
class CFullscreen extends _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(node, id) {
        super(node, id);
        this.ins = this.addInputs(CFullscreen.ins);
        this.outs = this.addOutputs(CFullscreen.outs);
        this._fullscreenElement = null;
        this.onFullscreenChange = this.onFullscreenChange.bind(this);
        const e = document.documentElement;
        const fullscreenAvailable = e.requestFullscreen || e.mozRequestFullScreen || e.webkitRequestFullscreen;
        this.outs.fullscreenAvailable.setValue(!!fullscreenAvailable);
        this.ins.toggle.on("value", this.toggle, this);
    }
    get fullscreenElement() {
        return this._fullscreenElement;
    }
    set fullscreenElement(element) {
        if (element !== this._fullscreenElement) {
            if (this._fullscreenElement) {
                this._fullscreenElement.removeEventListener("fullscreenchange", this.onFullscreenChange);
            }
            this._fullscreenElement = element;
            if (element) {
                element.addEventListener("fullscreenchange", this.onFullscreenChange);
            }
        }
    }
    update(context) {
        return true;
    }
    toggle() {
        const outs = this.outs;
        const e = this._fullscreenElement;
        if (e) {
            const state = outs.fullscreenActive.value;
            if (!state && outs.fullscreenAvailable.value) {
                if (e.requestFullscreen) {
                    e.requestFullscreen();
                }
                else if (e.mozRequestFullScreen) {
                    e.mozRequestFullScreen();
                }
                else if (e.webkitRequestFullscreen) {
                    e.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                }
            }
            else if (state) {
                const d = document;
                if (d.exitFullscreen) {
                    d.exitFullscreen();
                }
                else if (d.cancelFullScreen) {
                    d.cancelFullScreen();
                }
                else if (d.mozCancelFullScreen) {
                    d.mozCancelFullScreen();
                }
                else if (d.webkitCancelFullScreen) {
                    d.webkitCancelFullScreen();
                }
            }
        }
    }
    onFullscreenChange(event) {
        const d = document;
        const element = d.fullscreenElement || d.mozFullScreenElement || d.webkitFullscreenElement;
        this.outs.fullscreenActive.setValue(!!element);
    }
}
CFullscreen.typeName = "CFullscreen";
CFullscreen.ins = {
    toggle: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Event("Fullscreen.Toggle"),
};
CFullscreen.outs = {
    fullscreenAvailable: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("Fullscreen.Available", false),
    fullscreenActive: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("Fullscreen.Active", false),
};


/***/ }),

/***/ "../../libs/ff-scene/source/components/CLight.ts":
/*!***********************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-scene/source/components/CLight.ts ***!
  \***********************************************************************/
/*! exports provided: EShadowMapResolution, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EShadowMapResolution", function() { return EShadowMapResolution; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CLight; });
/* harmony import */ var _ff_graph_propertyTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/propertyTypes */ "../../libs/ff-graph/source/propertyTypes.ts");
/* harmony import */ var _CObject3D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CObject3D */ "../../libs/ff-scene/source/components/CObject3D.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */


////////////////////////////////////////////////////////////////////////////////
var EShadowMapResolution;
(function (EShadowMapResolution) {
    EShadowMapResolution[EShadowMapResolution["Low"] = 0] = "Low";
    EShadowMapResolution[EShadowMapResolution["Medium"] = 1] = "Medium";
    EShadowMapResolution[EShadowMapResolution["High"] = 2] = "High";
})(EShadowMapResolution || (EShadowMapResolution = {}));
const _mapResolution = {
    [EShadowMapResolution.Low]: 512,
    [EShadowMapResolution.Medium]: 1024,
    [EShadowMapResolution.High]: 2048,
};
class CLight extends _CObject3D__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(...arguments);
        this.ins = this.addInputs(CLight.lightIns);
    }
    get light() {
        return this.object3D;
    }
    update(context) {
        super.update(context);
        const light = this.light;
        const ins = this.ins;
        if (ins.color.changed || ins.intensity.changed) {
            light.color.fromArray(ins.color.value);
            light.intensity = ins.intensity.value;
        }
        if (ins.shadowEnabled.changed || (ins.shadowEnabled.value && (ins.shadowResolution.changed || ins.shadowBlur.changed))) {
            light.castShadow = ins.shadowEnabled.value;
            light.shadow.radius = ins.shadowBlur.value;
            if (ins.shadowResolution.changed) {
                const mapResolution = _mapResolution[ins.shadowResolution.getValidatedValue()];
                light.shadow.mapSize.set(mapResolution, mapResolution);
                light.shadow.map = null; // TODO: check for resource leak
            }
        }
        return true;
    }
}
CLight.typeName = "CLight";
CLight.lightIns = {
    color: _ff_graph_propertyTypes__WEBPACK_IMPORTED_MODULE_0__["types"].ColorRGB("Light.Color"),
    intensity: _ff_graph_propertyTypes__WEBPACK_IMPORTED_MODULE_0__["types"].Number("Light.Intensity", 1),
    shadowEnabled: _ff_graph_propertyTypes__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("Shadow.Enabled"),
    shadowResolution: _ff_graph_propertyTypes__WEBPACK_IMPORTED_MODULE_0__["types"].Enum("Shadow.Resolution", EShadowMapResolution, EShadowMapResolution.Medium),
    shadowBlur: _ff_graph_propertyTypes__WEBPACK_IMPORTED_MODULE_0__["types"].Number("Shadow.Blur", 1),
};


/***/ }),

/***/ "../../libs/ff-scene/source/components/CObject3D.ts":
/*!**************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-scene/source/components/CObject3D.ts ***!
  \**************************************************************************/
/*! exports provided: Node, types, ERotationOrder, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CObject3D; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Node", function() { return _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["Node"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "types", function() { return _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"]; });

/* harmony import */ var _ff_three_GPUPicker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/three/GPUPicker */ "../../libs/ff-three/source/GPUPicker.ts");
/* harmony import */ var _CScene__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CScene */ "../../libs/ff-scene/source/components/CScene.ts");
/* harmony import */ var _CTransform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CTransform */ "../../libs/ff-scene/source/components/CTransform.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ERotationOrder", function() { return _CTransform__WEBPACK_IMPORTED_MODULE_4__["ERotationOrder"]; });

/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */





////////////////////////////////////////////////////////////////////////////////
const _vec3 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

/**
 * Base class for drawable components. Wraps a THREE.Object3D based instance.
 * If component is added to a node together with a [[Transform]] component,
 * it is automatically added as a child to the transform.
 */
class CObject3D extends _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(node, id) {
        super(node, id);
        this.ins = this.addInputs(CObject3D.object3DIns);
        this.outs = this.addOutputs(CObject3D.object3DOuts);
        this._object3D = null;
        this._isPickable = false;
        this.addEvent("object");
        this.node.components.on(this.parentComponentClass, this._onParent, this);
    }
    /** The class of a component in the same node this component uses as parent transform. */
    get parentComponentClass() {
        return this.constructor.parentComponentClass;
    }
    /** The transform parent of this object. */
    get parentComponent() {
        return this.node.components.get(this.parentComponentClass, true);
    }
    /** The component node's transform component. */
    get transform() {
        return this.node.components.get(_CTransform__WEBPACK_IMPORTED_MODULE_4__["default"], true);
    }
    /** The scene this renderable object is part of. */
    get scene() {
        const transform = this.transform;
        return transform ? transform.getParentComponent(_CScene__WEBPACK_IMPORTED_MODULE_3__["default"], true) : undefined;
    }
    /** The underlying [[THREE.Object3D]] of this component. */
    get object3D() {
        return this._object3D;
    }
    /**
     * Assigns a [[THREE.Object3D]] to this component. The object automatically becomes a child
     * of the parent component's object.
     * @param object
     */
    set object3D(object) {
        const currentObject = this._object3D;
        if (currentObject) {
            currentObject.userData["component"] = null;
            this.unregisterPickableObject3D(currentObject, true);
            if (currentObject.parent) {
                this.onRemoveFromParent(currentObject.parent);
            }
        }
        this.emit({ type: "object", current: currentObject, next: object });
        this._object3D = object;
        if (object) {
            object.userData["component"] = this;
            object.matrixAutoUpdate = false;
            object.visible = this.ins.visible.value;
            this.registerPickableObject3D(object, true);
            const parentComponent = this.parentComponent;
            if (parentComponent) {
                this.onAddToParent(parentComponent.object3D);
            }
        }
    }
    update(context) {
        const { visible, pickable } = this.ins;
        if (visible.changed && this._object3D) {
            this._object3D.visible = visible.value;
        }
        if (pickable.changed && pickable.value !== this._isPickable) {
            this._isPickable = pickable.value;
            if (pickable.value) {
                this.enablePointerEvents();
            }
            else {
                this.disablePointerEvents();
            }
        }
        return true;
    }
    dispose() {
        this.object3D = null;
        if (this.ins.pickable.value) {
            this.disablePointerEvents();
        }
        this.node.components.off(this.parentComponentClass, this._onParent, this);
        super.dispose();
    }
    /**
     * This is called right before the graph's scene is rendered to a specific viewport/view.
     * Override to make adjustments specific to the renderer, view or viewport.
     * @param context
     */
    preRender(context) {
    }
    /**
     * This is called right after the graph's scene has been rendered to a specific viewport/view.
     * Override to make adjustments specific to the renderer, view or viewport.
     * @param context
     */
    postRender(context) {
    }
    /**
     * Returns a text representation.
     */
    toString() {
        return super.toString() + (this._object3D ? ` - type: ${this._object3D.type}` : " - (null)");
    }
    onPointer(event) {
        const outs = this.outs;
        if (event.type === "pointer-down") {
            outs.pointerDown.set();
            outs.pointerActive.setValue(true);
        }
        else if (event.type === "pointer-up") {
            outs.pointerUp.set();
            outs.pointerActive.setValue(false);
        }
        event.stopPropagation = true;
    }
    enablePointerEvents() {
        this.on("pointer-down", this.onPointer, this);
        this.on("pointer-up", this.onPointer, this);
    }
    disablePointerEvents() {
        this.off("pointer-down", this.onPointer, this);
        this.off("pointer-up", this.onPointer, this);
        const outs = this.outs;
        if (outs.pointerActive.value) {
            outs.pointerUp.set();
            outs.pointerActive.setValue(false);
        }
    }
    updateTransform() {
        const object3D = this._object3D;
        if (!object3D) {
            return;
        }
        const { position, rotation, order, scale } = this.ins;
        if (position.changed || rotation.changed || order.changed || scale.changed) {
            // update position
            object3D.position.fromArray(position.value);
            // update rotation angles, rotation order
            _vec3.fromArray(rotation.value).multiplyScalar(three__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].DEG2RAD);
            const orderName = order.getOptionText();
            object3D.rotation.setFromVector3(_vec3, orderName);
            // update scale
            object3D.scale.fromArray(scale.value);
            // compose matrix
            object3D.updateMatrix();
        }
        return true;
    }
    onAddToParent(parent) {
        parent.add(this._object3D);
    }
    onRemoveFromParent(parent) {
        parent.remove(this._object3D);
    }
    /**
     * Adds a [[THREE.Object3D]] as a child to this component's object.
     * Registers the object with the picking service to make it pickable.
     * @param object
     */
    addObject3D(object) {
        this._object3D.add(object);
        this.registerPickableObject3D(object, true);
    }
    /**
     * Removes a [[THREE.Object3D]] child from this component's object.
     * Also unregisters the object from the picking service.
     * @param object
     */
    removeObject3D(object) {
        this.unregisterPickableObject3D(object, true);
        this._object3D.remove(object);
    }
    /**
     * This should be called after an external change to this component's Object3D subtree.
     * It registers newly added mesh objects with the picking service.
     * @param object
     * @param recursive
     */
    registerPickableObject3D(object, recursive) {
        _ff_three_GPUPicker__WEBPACK_IMPORTED_MODULE_2__["default"].add(object, recursive);
    }
    /**
     * This should be called before an external change to this component's Object3D subtree.
     * It unregisters the mesh objects in the subtree from the picking service.
     * @param object
     * @param recursive
     */
    unregisterPickableObject3D(object, recursive) {
        _ff_three_GPUPicker__WEBPACK_IMPORTED_MODULE_2__["default"].remove(object, recursive);
    }
    _onParent(event) {
        // add this THREE.Object3D to the parent THREE.Object3D
        if (this._object3D && !this._object3D.parent && event.add) {
            this.onAddToParent(event.object.object3D);
        }
    }
}
CObject3D.typeName = "CObject3D";
/** The component type whose object3D is the parent of this component's object3D. */
CObject3D.parentComponentClass = _CTransform__WEBPACK_IMPORTED_MODULE_4__["default"];
CObject3D.object3DIns = {
    visible: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Boolean("Object.Visible", true),
    pickable: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Boolean("Object.Pickable"),
};
CObject3D.object3DOuts = {
    pointerDown: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Event("Pointer.Down"),
    pointerUp: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Event("Pointer.Up"),
    pointerActive: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Boolean("Pointer.Active")
};
CObject3D.transformIns = _CTransform__WEBPACK_IMPORTED_MODULE_4__["default"].transformIns;
CObject3D.prototype.preRender = null;
CObject3D.prototype.postRender = null;


/***/ }),

/***/ "../../libs/ff-scene/source/components/CPickSelection.ts":
/*!*******************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-scene/source/components/CPickSelection.ts ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CPickSelection; });
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _ff_graph_ComponentTracker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/graph/ComponentTracker */ "../../libs/ff-graph/source/ComponentTracker.ts");
/* harmony import */ var _ff_graph_components_CSelection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/graph/components/CSelection */ "../../libs/ff-graph/source/components/CSelection.ts");
/* harmony import */ var _ff_three_Bracket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ff/three/Bracket */ "../../libs/ff-three/source/Bracket.ts");
/* harmony import */ var _CObject3D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CObject3D */ "../../libs/ff-scene/source/components/CObject3D.ts");
/* harmony import */ var _CTransform__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CTransform */ "../../libs/ff-scene/source/components/CTransform.ts");
/* harmony import */ var _CScene__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CScene */ "../../libs/ff-scene/source/components/CScene.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */







////////////////////////////////////////////////////////////////////////////////
const _inputs = {
    viewportPicking: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("Viewport.Picking", true),
    viewportBrackets: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("Viewport.Brackets", true),
};
class CPickSelection extends _ff_graph_components_CSelection__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super(...arguments);
        this.ins = this.addInputs(_inputs);
        this._brackets = new Map();
        this._sceneTracker = null;
    }
    create() {
        super.create();
        this.system.on("pointer-up", this.onPointerUp, this);
        this._sceneTracker = new _ff_graph_ComponentTracker__WEBPACK_IMPORTED_MODULE_1__["default"](this.system.components, _CScene__WEBPACK_IMPORTED_MODULE_6__["default"], component => {
            component.on("after-render", this.onSceneAfterRender, this);
        }, component => {
            component.off("after-render", this.onSceneAfterRender, this);
        });
    }
    dispose() {
        this._sceneTracker.dispose();
        this.system.off("pointer-up", this.onPointerUp, this);
        this._sceneTracker.dispose();
        super.dispose();
    }
    update() {
        return true;
    }
    onSelectNode(node, selected) {
        super.onSelectNode(node, selected);
        const transform = node.getComponent(_CTransform__WEBPACK_IMPORTED_MODULE_5__["default"], true);
        if (transform) {
            this.updateBracket(transform, selected);
        }
    }
    onSelectComponent(component, selected) {
        super.onSelectComponent(component, selected);
        if (component instanceof _CObject3D__WEBPACK_IMPORTED_MODULE_4__["default"] || component instanceof _CTransform__WEBPACK_IMPORTED_MODULE_5__["default"]) {
            this.updateBracket(component, selected);
        }
    }
    // protected onActiveGraph(graph: Graph)
    // {
    //     if (this._sceneTracker) {
    //         this._sceneTracker.dispose();
    //     }
    //
    //     if (graph) {
    //         this._sceneTracker = new ComponentTracker(graph.components, CScene, component => {
    //             component.on<ISceneAfterRenderEvent>("after-render", this.onSceneAfterRender, this);
    //         }, component => {
    //             component.off<ISceneAfterRenderEvent>("after-render", this.onSceneAfterRender, this);
    //         });
    //     }
    // }
    onPointerUp(event) {
        if (!this.ins.viewportPicking.value || !event.isPrimary || event.isDragging) {
            return;
        }
        if (event.component) {
            this.selectComponent(event.component, event.ctrlKey);
        }
        else if (!event.ctrlKey) {
            this.clearSelection();
        }
    }
    onSceneAfterRender(event) {
        if (!this.ins.viewportBrackets.value) {
            return;
        }
        const renderer = event.context.renderer;
        const camera = event.context.camera;
        for (let entry of this._brackets) {
            renderer.render(entry[1], camera);
        }
    }
    updateBracket(component, selected) {
        if (!component) {
            return;
        }
        if (selected) {
            const object3D = component.object3D;
            if (object3D) {
                const bracket = new _ff_three_Bracket__WEBPACK_IMPORTED_MODULE_3__["default"](component.object3D);
                this._brackets.set(component, bracket);
            }
        }
        else {
            const bracket = this._brackets.get(component);
            if (bracket) {
                this._brackets.delete(component);
                bracket.dispose();
            }
        }
        this.changed = true;
    }
}
CPickSelection.typeName = "CPickSelection";


/***/ }),

/***/ "../../libs/ff-scene/source/components/CPointLight.ts":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-scene/source/components/CPointLight.ts ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CPointLight; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _CLight__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CLight */ "../../libs/ff-scene/source/components/CLight.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */



////////////////////////////////////////////////////////////////////////////////
const _vec3 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
class CPointLight extends _CLight__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(node, id) {
        super(node, id);
        this.ins = this.addInputs(CPointLight.pointLightIns);
        this.object3D = new three__WEBPACK_IMPORTED_MODULE_0__["PointLight"]();
    }
    get light() {
        return this.object3D;
    }
    update(context) {
        super.update(context);
        const light = this.light;
        const ins = this.ins;
        if (ins.position.changed) {
            light.position.fromArray(ins.position.value);
            light.updateMatrix();
        }
        if (ins.distance.changed || ins.decay.changed) {
            light.distance = ins.distance.value;
            light.decay = ins.decay.value;
        }
        light.updateMatrix();
        return true;
    }
}
CPointLight.typeName = "CPointLight";
CPointLight.pointLightIns = {
    position: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Vector3("Light.Position"),
    distance: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Number("Light.Distance"),
    decay: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Number("Light.Decay", 1),
};


/***/ }),

/***/ "../../libs/ff-scene/source/components/CRenderGraph.ts":
/*!*****************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-scene/source/components/CRenderGraph.ts ***!
  \*****************************************************************************/
/*! exports provided: Node, types, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CRenderGraph; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_graph_components_CGraph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/graph/components/CGraph */ "../../libs/ff-graph/source/components/CGraph.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Node", function() { return _ff_graph_components_CGraph__WEBPACK_IMPORTED_MODULE_1__["Node"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "types", function() { return _ff_graph_components_CGraph__WEBPACK_IMPORTED_MODULE_1__["types"]; });

/* harmony import */ var _CTransform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CTransform */ "../../libs/ff-scene/source/components/CTransform.ts");
/* harmony import */ var _CScene__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CScene */ "../../libs/ff-scene/source/components/CScene.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */




////////////////////////////////////////////////////////////////////////////////

class CRenderGraph extends _ff_graph_components_CGraph__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(node, id) {
        super(node, id);
        this.ins = this.addInputs(CRenderGraph.rgIns);
        this._object3D = null;
        this._isAttached = false;
        this._object3D = new three__WEBPACK_IMPORTED_MODULE_0__["Object3D"]();
        this._object3D.matrixAutoUpdate = false;
    }
    /** The component node's transform component. */
    get transform() {
        return this.node.components.get(_CTransform__WEBPACK_IMPORTED_MODULE_2__["default"], true);
    }
    /** The scene this renderable object is part of. */
    get scene() {
        const transform = this.transform;
        return transform ? transform.getParentComponent(_CScene__WEBPACK_IMPORTED_MODULE_3__["default"], true) : undefined;
    }
    /** The underlying [[Object3D]] of this component. */
    get object3D() {
        return this._object3D;
    }
    create() {
        super.create();
        // add existing inner root transforms
        this.innerRoots
            .filter(root => root.is(_CTransform__WEBPACK_IMPORTED_MODULE_2__["default"]))
            .forEach((root) => this._object3D.add(root.object3D));
        // track transform component
        this.trackComponent(_CTransform__WEBPACK_IMPORTED_MODULE_2__["default"], component => this.ins.visible.value && this.attachObject3D(component), component => this.detachObject3D(component));
    }
    dispose() {
        this.detachObject3D(this.transform);
        // remove all inner root transforms
        this.innerRoots
            .filter(root => root.is(_CTransform__WEBPACK_IMPORTED_MODULE_2__["default"]))
            .forEach((root) => this._object3D.remove(root.object3D));
        super.dispose();
    }
    update(context) {
        super.update(context);
        const ins = this.ins;
        if (ins.visible.changed) {
            const parent = this.transform;
            if (ins.visible.value) {
                this.attachObject3D(parent);
            }
            else {
                this.detachObject3D(parent);
            }
        }
        return true;
    }
    onAddInnerRoot(component) {
        if (component.is(_CTransform__WEBPACK_IMPORTED_MODULE_2__["default"])) {
            this._object3D.add(component.object3D);
        }
    }
    onRemoveInnerRoot(component) {
        if (component.is(_CTransform__WEBPACK_IMPORTED_MODULE_2__["default"])) {
            this._object3D.remove(component.object3D);
        }
    }
    attachObject3D(parent) {
        if (this._isAttached) {
            return;
        }
        if (parent) {
            parent.object3D.add(this._object3D);
            this._isAttached = true;
        }
    }
    detachObject3D(parent) {
        if (!this._isAttached) {
            return;
        }
        if (parent) {
            parent.object3D.remove(this._object3D);
            this._isAttached = false;
        }
    }
}
CRenderGraph.typeName = "CRenderGraph";
CRenderGraph.rgIns = {
    visible: _ff_graph_components_CGraph__WEBPACK_IMPORTED_MODULE_1__["types"].Boolean("Graph.Visible", true),
};


/***/ }),

/***/ "../../libs/ff-scene/source/components/CRenderer.ts":
/*!**************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-scene/source/components/CRenderer.ts ***!
  \**************************************************************************/
/*! exports provided: EShadowMapType, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EShadowMapType", function() { return EShadowMapType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CRenderer; });
/* harmony import */ var three_src_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three/src/constants */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _ff_graph_components_CPulse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/graph/components/CPulse */ "../../libs/ff-graph/source/components/CPulse.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */



////////////////////////////////////////////////////////////////////////////////
var EShadowMapType;
(function (EShadowMapType) {
    EShadowMapType[EShadowMapType["Basic"] = 0] = "Basic";
    EShadowMapType[EShadowMapType["PCF"] = 1] = "PCF";
    EShadowMapType[EShadowMapType["PCFSoft"] = 2] = "PCFSoft"; /* , VSM */
})(EShadowMapType || (EShadowMapType = {}));
const _shadowMapType = {
    [EShadowMapType.Basic]: three_src_constants__WEBPACK_IMPORTED_MODULE_0__["BasicShadowMap"],
    [EShadowMapType.PCF]: three_src_constants__WEBPACK_IMPORTED_MODULE_0__["PCFShadowMap"],
    [EShadowMapType.PCFSoft]: three_src_constants__WEBPACK_IMPORTED_MODULE_0__["PCFSoftShadowMap"],
};
/**
 * Manages 3D rendering. Keeps track of one "active" scene/camera pair,
 * and of a number of render views. During each render cycle, the active scene
 * and camera are rendered to each render view.
 *
 * ### Events
 * - *"active-scene"* - emits [[IActiveSceneEvent]] when the active scene changes.
 * - *"active-camera"* - emits [[IActiveCameraEvent]] when the active camera changes.
 *
 * ### See also
 * - [[CScene]]
 * - [[CCamera]]
 * - [[RenderView]]
 */
class CRenderer extends _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(node, id) {
        super(node, id);
        this.ins = this.addInputs(CRenderer.ins);
        this.outs = this.addOutputs(CRenderer.outs);
        this.views = [];
        this._activeSceneComponent = null;
        this._forceRender = false;
        this.addEvents("active-scene", "active-camera");
    }
    get activeSceneComponent() {
        return this._activeSceneComponent;
    }
    set activeSceneComponent(component) {
        if (component !== this._activeSceneComponent) {
            const previousScene = this._activeSceneComponent;
            const previousCamera = this.activeCameraComponent;
            if (previousScene) {
                previousScene.off("active-camera", this.onActiveCamera, this);
            }
            if (component) {
                component.on("active-camera", this.onActiveCamera, this);
            }
            this._activeSceneComponent = component;
            const nextCamera = this.activeCameraComponent;
            const sceneEvent = { type: "active-scene", previous: previousScene, next: component };
            this.emit(sceneEvent);
            const cameraEvent = { type: "active-camera", previous: previousCamera, next: nextCamera };
            this.emit(cameraEvent);
        }
    }
    get activeSceneGraph() {
        return this._activeSceneComponent ? this._activeSceneComponent.graph : null;
    }
    get activeScene() {
        return this._activeSceneComponent ? this._activeSceneComponent.scene : null;
    }
    get activeCameraComponent() {
        return this._activeSceneComponent ? this._activeSceneComponent.activeCameraComponent : null;
    }
    get activeCamera() {
        const component = this._activeSceneComponent ? this._activeSceneComponent.activeCameraComponent : null;
        return component ? component.camera : null;
    }
    forceRender() {
        this._forceRender = true;
    }
    create() {
        super.create();
        this.trackComponent(_ff_graph_components_CPulse__WEBPACK_IMPORTED_MODULE_2__["default"], component => {
            component.on("pulse", this.onPulse, this);
        }, component => {
            component.off("pulse", this.onPulse, this);
        });
    }
    update() {
        const ins = this.ins;
        if (ins.exposure.changed) {
            this.views.forEach(view => view.renderer.toneMappingExposure = ins.exposure.value);
        }
        if (ins.gamma.changed) {
            this.views.forEach(view => view.renderer.gammaFactor = ins.gamma.value);
            const scene = this.activeScene;
            if (scene) {
                scene.traverse(object => {
                    const mesh = object;
                    if (mesh.isMesh) {
                        if (Array.isArray(mesh.material)) {
                            mesh.material.forEach(material => material.needsUpdate = true);
                        }
                        else {
                            mesh.material.needsUpdate = true;
                        }
                    }
                });
            }
        }
        if (ins.shadowsEnabled.changed) {
            this.views.forEach(view => view.renderer.shadowMap.enabled = ins.shadowsEnabled.value);
        }
        if (ins.shadowMapType.changed) {
            this.views.forEach(view => view.renderer.shadowMap.type = _shadowMapType[ins.shadowMapType.getValidatedValue()]);
        }
        return true;
    }
    attachView(view) {
        // set WebGL caps if it's the first view attached
        if (this.views.length === 0) {
            const renderer = view.renderer;
            const outs = this.outs;
            outs.maxTextureSize.setValue(renderer.capabilities.maxTextureSize);
            outs.maxCubemapSize.setValue(renderer.capabilities.maxCubemapSize);
        }
        this.views.push(view);
        if (true) {
            console.log("RenderSystem.attachView - total views: %s", this.views.length);
        }
    }
    detachView(view) {
        const index = this.views.indexOf(view);
        if (index < 0) {
            throw new Error("render view not registered");
        }
        this.views.splice(index, 1);
        if (true) {
            console.log("RenderSystem.detachView - total views: %s", this.views.length);
        }
    }
    logInfo() {
        this.views.forEach(view => {
            console.log(view.renderer.info);
        });
    }
    onPulse(event) {
        if (event.systemUpdated || this._forceRender) {
            if (true) {
                console.log("CRenderer.onPulse - render views...");
            }
            this.views.forEach(view => {
                if (!view.renderer.xr.isPresenting) {
                    view.render();
                }
            });
            this._forceRender = false;
        }
    }
    onActiveCamera(event) {
        this.emit(event);
    }
}
CRenderer.typeName = "CRenderer";
CRenderer.isSystemSingleton = true;
CRenderer.ins = {
    exposure: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Number("Shading.Exposure", 1),
    gamma: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Number("Shading.Gamma", 2),
    shadowsEnabled: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Boolean("Shadows.Enabled", true),
    shadowMapType: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Enum("Shadows.MapType", EShadowMapType, EShadowMapType.PCF),
};
CRenderer.outs = {
    maxTextureSize: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Integer("Caps.MaxTextureSize"),
    maxCubemapSize: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Integer("Caps.MaxCubemapSize"),
};


/***/ }),

/***/ "../../libs/ff-scene/source/components/CScene.ts":
/*!***********************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-scene/source/components/CScene.ts ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CScene; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _CRenderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CRenderer */ "../../libs/ff-scene/source/components/CRenderer.ts");
/* harmony import */ var _CTransform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CTransform */ "../../libs/ff-scene/source/components/CTransform.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */




const _context = {
    view: null,
    viewport: null,
    renderer: null,
    scene: null,
    camera: null
};
const _beforeRenderEvent = {
    type: "before-render",
    component: null,
    context: _context
};
const _afterRenderEvent = {
    type: "after-render",
    component: null,
    context: _context
};
const _inputs = {
    activate: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Event("Scene.Activate")
};
/**
 * Represents a 3D scene. Root of a hierarchy of a number of 3D renderable objects and one
 * or multiple cameras. Only one camera at a time can be the "active" camera which is
 * used during each render cycle to render the currently active scene to one or multiple render views.
 */
class CScene extends _CTransform__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(node, id) {
        super(node, id);
        this._activeCameraComponent = null;
        this._preRenderList = [];
        this._postRenderList = [];
        this._renderListsNeedUpdate = true;
        this.ins = this.addInputs(_inputs, 0);
        this.addEvents("before-render", "after-render", "active-camera");
    }
    get scene() {
        return this.object3D;
    }
    get activeCameraComponent() {
        return this._activeCameraComponent;
    }
    set activeCameraComponent(component) {
        if (component !== this._activeCameraComponent) {
            const previous = this._activeCameraComponent;
            this._activeCameraComponent = component;
            const event = { type: "active-camera", previous, next: component };
            this.emit(event);
        }
    }
    get activeCamera() {
        return this._activeCameraComponent ? this._activeCameraComponent.camera : null;
    }
    get renderer() {
        return this.getMainComponent(_CRenderer__WEBPACK_IMPORTED_MODULE_2__["default"]);
    }
    create() {
        super.create();
        this.on("hierarchy", this.shouldUpdateRenderLists, this);
        this.on("child", this.shouldUpdateRenderLists, this);
        const renderer = this.renderer;
        if (renderer && !renderer.activeSceneComponent) {
            renderer.activeSceneComponent = this;
        }
    }
    update(context) {
        super.update(context);
        if (this.ins.activate.changed) {
            const renderer = this.renderer;
            if (renderer) {
                renderer.activeSceneComponent = this;
            }
        }
        return true;
    }
    tick(context) {
        if (this._renderListsNeedUpdate) {
            this.updateRenderLists();
            this._renderListsNeedUpdate = false;
        }
        return false;
    }
    dispose() {
        const renderer = this.renderer;
        if (renderer && renderer.activeSceneComponent === this) {
            renderer.activeSceneComponent = null;
        }
        this.off("hierarchy", this.shouldUpdateRenderLists, this);
        this.off("child", this.shouldUpdateRenderLists, this);
        super.dispose();
    }
    preRender(context) {
        const preRenderList = this._preRenderList;
        for (let i = 0, n = preRenderList.length; i < n; ++i) {
            preRenderList[i].preRender(context);
        }
    }
    postRender(context) {
        const postRenderList = this._postRenderList;
        for (let i = 0, n = postRenderList.length; i < n; ++i) {
            postRenderList[i].postRender(context);
        }
    }
    createObject3D() {
        const scene = new three__WEBPACK_IMPORTED_MODULE_0__["Scene"]();
        scene.onBeforeRender = this._onBeforeRender.bind(this);
        scene.onAfterRender = this._onAfterRender.bind(this);
        return scene;
    }
    shouldUpdateRenderLists() {
        this._renderListsNeedUpdate = true;
    }
    updateRenderLists() {
        this._preRenderList = [];
        this._postRenderList = [];
        this.traverseDown(false, true, true, (component) => {
            if (component.preRender) {
                this._preRenderList.push(component);
            }
            if (component.postRender) {
                this._postRenderList.push(component);
            }
            return false;
        });
        this.changed = true;
    }
    _onBeforeRender(renderer, scene, camera) {
        _context.view = renderer["__view"];
        _context.viewport = renderer["__viewport"];
        _context.renderer = renderer;
        _context.scene = scene;
        _context.camera = camera;
        this.preRender(_context);
        _beforeRenderEvent.component = this;
        this.emit(_beforeRenderEvent);
    }
    _onAfterRender(renderer, scene, camera) {
        _context.view = renderer["__view"];
        _context.viewport = renderer["__viewport"];
        _context.renderer = renderer;
        _context.scene = scene;
        _context.camera = camera;
        this.postRender(_context);
        _afterRenderEvent.component = this;
        this.emit(_afterRenderEvent);
    }
}
CScene.typeName = "CScene";
CScene.isGraphSingleton = true;


/***/ }),

/***/ "../../libs/ff-scene/source/components/CSpotLight.ts":
/*!***************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-scene/source/components/CSpotLight.ts ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CSpotLight; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _CLight__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CLight */ "../../libs/ff-scene/source/components/CLight.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */



////////////////////////////////////////////////////////////////////////////////
class CSpotLight extends _CLight__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(node, id) {
        super(node, id);
        this.ins = this.addInputs(CSpotLight.spotLightIns);
        this.object3D = new three__WEBPACK_IMPORTED_MODULE_0__["SpotLight"]();
        this.light.target.matrixAutoUpdate = false;
    }
    get light() {
        return this.object3D;
    }
    update(context) {
        super.update(context);
        const light = this.light;
        const ins = this.ins;
        if (ins.position.changed || ins.target.changed) {
            light.position.fromArray(ins.position.value);
            light.target.position.fromArray(ins.target.value);
            light.updateMatrix();
            light.target.updateMatrix();
        }
        if (ins.distance.changed || ins.decay.changed || ins.angle.changed || ins.penumbra.changed) {
            light.distance = ins.distance.value;
            light.decay = ins.decay.value;
            light.angle = ins.angle.value * three__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].DEG2RAD;
            light.penumbra = ins.penumbra.value;
        }
        return true;
    }
    onAddToParent(parent) {
        super.onAddToParent(parent);
        parent.add(this.light.target);
    }
    onRemoveFromParent(parent) {
        super.onRemoveFromParent(parent);
        parent.remove(this.light.target);
    }
}
CSpotLight.typeName = "CSpotLight";
CSpotLight.spotLightIns = {
    position: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Vector3("Light.Position"),
    target: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Vector3("Light.Target", [0, -1, 0]),
    distance: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Number("Light.Distance"),
    decay: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Number("Light.Decay", 1),
    angle: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Number("Light.Angle", 45),
    penumbra: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Percent("Light.Penumbra", 0.5),
};


/***/ }),

/***/ "../../libs/ff-scene/source/components/CTransform.ts":
/*!***************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-scene/source/components/CTransform.ts ***!
  \***************************************************************************/
/*! exports provided: types, ERotationOrder, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERotationOrder", function() { return ERotationOrder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CTransform; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_core_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/core/math */ "../../libs/ff-core/source/math.ts");
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "types", function() { return _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"]; });

/* harmony import */ var _ff_graph_components_CHierarchy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ff/graph/components/CHierarchy */ "../../libs/ff-graph/source/components/CHierarchy.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */




////////////////////////////////////////////////////////////////////////////////
const _vec3a = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vec3b = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _quat = new three__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();
const _euler = new three__WEBPACK_IMPORTED_MODULE_0__["Euler"]();

var ERotationOrder;
(function (ERotationOrder) {
    ERotationOrder[ERotationOrder["XYZ"] = 0] = "XYZ";
    ERotationOrder[ERotationOrder["YZX"] = 1] = "YZX";
    ERotationOrder[ERotationOrder["ZXY"] = 2] = "ZXY";
    ERotationOrder[ERotationOrder["XZY"] = 3] = "XZY";
    ERotationOrder[ERotationOrder["YXZ"] = 4] = "YXZ";
    ERotationOrder[ERotationOrder["ZYX"] = 5] = "ZYX";
})(ERotationOrder || (ERotationOrder = {}));
/**
 * Allows arranging components in a hierarchical structure. Each [[TransformComponent]]
 * contains a transformation which affects its children as well as other components which
 * are part of the same entity.
 */
class CTransform extends _ff_graph_components_CHierarchy__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(node, id) {
        super(node, id);
        this.ins = this.addInputs(CTransform.transformIns);
        this.outs = this.addOutputs(CTransform.transformOuts);
        this._object3D = this.createObject3D();
        this._object3D.matrixAutoUpdate = false;
    }
    get transform() {
        return this;
    }
    /**
     * Returns the three.js renderable object wrapped in this component.
     */
    get object3D() {
        return this._object3D;
    }
    /**
     * Returns an array of child components of this.
     */
    get children() {
        return this._children || [];
    }
    /**
     * Returns a reference to the local transformation matrix.
     */
    get matrix() {
        return this._object3D.matrix;
    }
    update(context) {
        const object3D = this._object3D;
        const { position, rotation, order, scale } = this.ins;
        const { matrix } = this.outs;
        object3D.position.fromArray(position.value);
        _vec3a.fromArray(rotation.value).multiplyScalar(_ff_core_math__WEBPACK_IMPORTED_MODULE_1__["default"].DEG2RAD);
        const orderName = order.getOptionText();
        object3D.rotation.setFromVector3(_vec3a, orderName);
        object3D.scale.fromArray(scale.value);
        object3D.updateMatrix();
        object3D.matrix.toArray(matrix.value);
        matrix.set();
        return true;
    }
    dispose() {
        if (this._object3D) {
            // detach all children
            this._object3D.children.slice().forEach(child => this._object3D.remove(child));
            // detach from parent
            if (this._object3D.parent) {
                this._object3D.parent.remove(this._object3D);
            }
        }
        super.dispose();
    }
    setPropertiesFromMatrix(matrix) {
        const silent = !matrix;
        matrix = matrix || this._object3D.matrix;
        const { position, rotation, order, scale } = this.ins;
        matrix.decompose(_vec3a, _quat, _vec3b);
        _vec3a.toArray(position.value);
        const orderName = order.getOptionText();
        _euler.setFromQuaternion(_quat, orderName);
        _euler.toVector3(_vec3a);
        _vec3a.multiplyScalar(_ff_core_math__WEBPACK_IMPORTED_MODULE_1__["default"].RAD2DEG).toArray(rotation.value);
        _vec3b.toArray(scale.value);
        position.set(silent);
        rotation.set(silent);
        scale.set(silent);
    }
    /**
     * Adds the given transform component as a children to this.
     * @param component
     */
    addChild(component) {
        super.addChild(component);
        this._object3D.add(component._object3D);
    }
    /**
     * Removes the given transform component from the list of children of this.
     * @param component
     */
    removeChild(component) {
        this._object3D.remove(component._object3D);
        super.removeChild(component);
    }
    createObject3D() {
        return new three__WEBPACK_IMPORTED_MODULE_0__["Object3D"]();
    }
}
CTransform.typeName = "CTransform";
CTransform.transformIns = {
    position: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Vector3("Transform.Position"),
    rotation: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Vector3("Transform.Rotation"),
    order: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Enum("Transform.Order", ERotationOrder),
    scale: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Scale3("Transform.Scale")
};
CTransform.transformOuts = {
    matrix: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Matrix4("Transform.Matrix")
};


/***/ }),

/***/ "../../libs/ff-scene/source/ui/SystemView.ts":
/*!*******************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-scene/source/ui/SystemView.ts ***!
  \*******************************************************************/
/*! exports provided: System, customElement, property, html, TemplateResult, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SystemView; });
/* harmony import */ var _ff_graph_System__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/System */ "../../libs/ff-graph/source/System.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "System", function() { return _ff_graph_System__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/ui/CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "customElement", function() { return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_1__["customElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "property", function() { return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "html", function() { return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_1__["html"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TemplateResult", function() { return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_1__["TemplateResult"]; });

/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


////////////////////////////////////////////////////////////////////////////////

class SystemView extends _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(system) {
        super();
        this.system = system;
    }
}
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])({ attribute: false })
], SystemView.prototype, "system", void 0);


/***/ }),

/***/ "../../libs/ff-three/source/Background.ts":
/*!****************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-three/source/Background.ts ***!
  \****************************************************************/
/*! exports provided: EBackgroundStyle, default, BackgroundGeometry, BackgroundMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EBackgroundStyle", function() { return EBackgroundStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Background; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BackgroundGeometry", function() { return BackgroundGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BackgroundMaterial", function() { return BackgroundMaterial; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/**
 * FF Typescript Foundation Library
 * Copyright 2020 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */

////////////////////////////////////////////////////////////////////////////////
var EBackgroundStyle;
(function (EBackgroundStyle) {
    EBackgroundStyle[EBackgroundStyle["Solid"] = 0] = "Solid";
    EBackgroundStyle[EBackgroundStyle["LinearGradient"] = 1] = "LinearGradient";
    EBackgroundStyle[EBackgroundStyle["RadialGradient"] = 2] = "RadialGradient";
})(EBackgroundStyle || (EBackgroundStyle = {}));
class Background extends three__WEBPACK_IMPORTED_MODULE_0__["Mesh"] {
    constructor() {
        super(new BackgroundGeometry(), new BackgroundMaterial());
        this.frustumCulled = false;
        this.renderOrder = -Infinity;
        this.matrixAutoUpdate = false;
    }
    dispose() {
        this.geometry.dispose();
        this.material.dispose();
    }
    updateMatrixWorld(force) {
    }
}
class BackgroundGeometry extends three__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"] {
    constructor() {
        super();
        const vertices = new Float32Array([
            -1, -1, 0, 0, 0,
            1, -1, 0, 1, 0,
            1, 1, 0, 1, 1,
            -1, 1, 0, 0, 1
        ]);
        const buffer = new three__WEBPACK_IMPORTED_MODULE_0__["InterleavedBuffer"](vertices, 5);
        this.setIndex([0, 1, 2, 0, 2, 3]);
        this.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_0__["InterleavedBufferAttribute"](buffer, 3, 0, false));
        this.setAttribute('uv', new three__WEBPACK_IMPORTED_MODULE_0__["InterleavedBufferAttribute"](buffer, 2, 3, false));
    }
}
class BackgroundMaterial extends three__WEBPACK_IMPORTED_MODULE_0__["RawShaderMaterial"] {
    constructor() {
        super(...arguments);
        this.depthTest = false;
        this.depthWrite = false;
        this.transparent = false;
        this.uniforms = {
            style: { value: EBackgroundStyle.LinearGradient },
            color0: { value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0.15, 0.2, 0.25) },
            color1: { value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0) },
            noise: { value: 0.02 }
        };
        this.vertexShader = [
            "precision highp float;",
            "attribute vec3 position;",
            "attribute vec2 uv;",
            "varying vec2 ndc;",
            "void main() {",
            "  ndc = position.xy;",
            "  gl_Position = vec4(position, 1.0);",
            "}",
        ].join("\n");
        // NOTE: Source of random function:
        // http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
        this.fragmentShader = [
            "precision highp float;",
            "uniform vec3 color0;",
            "uniform vec3 color1;",
            "uniform float noise;",
            "uniform int style;",
            "varying vec2 ndc;",
            "float rand(vec2 co) {",
            "float dt = dot(co.xy ,vec2(12.9898, 78.233));",
            "float sn = mod(dt, 3.14);",
            "return fract(sin(sn) * 43758.5453);",
            "}",
            "void main() {",
            "  float f = style == 0 ? 0.0 : (style == 1 ? ndc.y * 0.5 + 0.5 : length(ndc) * 0.707);",
            "  gl_FragColor = vec4(mix(color0, color1, f) + noise * rand(ndc), 1.0);",
            "}"
        ].join("\n");
    }
    set style(style) {
        this.uniforms.style.value = style;
    }
    get style() {
        return this.uniforms.style.value;
    }
    set color0(color) {
        if (color instanceof three__WEBPACK_IMPORTED_MODULE_0__["Color"]) {
            const value = this.uniforms.color0.value;
            value.x = color.r;
            value.y = color.g;
            value.z = color.b;
        }
        else {
            this.uniforms.color0.value.copy(color);
        }
    }
    get color0() {
        return this.uniforms.color0.value;
    }
    set color1(color) {
        if (color instanceof three__WEBPACK_IMPORTED_MODULE_0__["Color"]) {
            const value = this.uniforms.color1.value;
            value.x = color.r;
            value.y = color.g;
            value.z = color.b;
        }
        else {
            this.uniforms.color1.value.copy(color);
        }
    }
    get color1() {
        return this.uniforms.color1.value;
    }
    set noise(noise) {
        this.uniforms.noise.value = noise;
    }
    get noise() {
        return this.uniforms.noise.value;
    }
}


/***/ }),

/***/ "../../libs/ff-three/source/Bracket.ts":
/*!*************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-three/source/Bracket.ts ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Bracket; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "../../libs/ff-three/source/helpers.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2020 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */


////////////////////////////////////////////////////////////////////////////////
const _vec3 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _mat4 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
/**
 * Wireframe selection bracket.
 */
class Bracket extends three__WEBPACK_IMPORTED_MODULE_0__["LineSegments"] {
    constructor(target, props) {
        props = Object.assign({}, Bracket.defaultProps, props);
        const box = new three__WEBPACK_IMPORTED_MODULE_0__["Box3"]();
        box.makeEmpty();
        Object(_helpers__WEBPACK_IMPORTED_MODULE_1__["computeLocalBoundingBox"])(target, box);
        const length = props.length;
        const min = [box.min.x, box.min.y, box.min.z];
        const max = [box.max.x, box.max.y, box.max.z];
        const size = [(max[0] - min[0]) * length, (max[1] - min[1]) * length, (max[2] - min[2]) * length];
        let vertices;
        if (isFinite(size[0]) && isFinite(size[1]) && isFinite(size[2])) {
            vertices = [
                min[0], min[1], min[2], min[0] + size[0], min[1], min[2],
                min[0], min[1], min[2], min[0], min[1] + size[1], min[2],
                min[0], min[1], min[2], min[0], min[1], min[2] + size[2],
                max[0], min[1], min[2], max[0] - size[0], min[1], min[2],
                max[0], min[1], min[2], max[0], min[1] + size[1], min[2],
                max[0], min[1], min[2], max[0], min[1], min[2] + size[2],
                min[0], max[1], min[2], min[0] + size[0], max[1], min[2],
                min[0], max[1], min[2], min[0], max[1] - size[1], min[2],
                min[0], max[1], min[2], min[0], max[1], min[2] + size[2],
                min[0], min[1], max[2], min[0] + size[0], min[1], max[2],
                min[0], min[1], max[2], min[0], min[1] + size[1], max[2],
                min[0], min[1], max[2], min[0], min[1], max[2] - size[2],
                min[0], max[1], max[2], min[0] + size[0], max[1], max[2],
                min[0], max[1], max[2], min[0], max[1] - size[1], max[2],
                min[0], max[1], max[2], min[0], max[1], max[2] - size[2],
                max[0], min[1], max[2], max[0] - size[0], min[1], max[2],
                max[0], min[1], max[2], max[0], min[1] + size[1], max[2],
                max[0], min[1], max[2], max[0], min[1], max[2] - size[2],
                max[0], max[1], min[2], max[0] - size[0], max[1], min[2],
                max[0], max[1], min[2], max[0], max[1] - size[1], min[2],
                max[0], max[1], min[2], max[0], max[1], min[2] + size[2],
                max[0], max[1], max[2], max[0] - size[0], max[1], max[2],
                max[0], max[1], max[2], max[0], max[1] - size[1], max[2],
                max[0], max[1], max[2], max[0], max[1], max[2] - size[2],
            ];
        }
        else {
            vertices = [
                -1, 0, 0, 1, 0, 0,
                0, -1, 0, 0, 1, 0,
                0, 0, -1, 0, 0, 1,
            ];
        }
        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]();
        geometry.setAttribute("position", new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"](vertices, 3));
        const material = new three__WEBPACK_IMPORTED_MODULE_0__["LineBasicMaterial"]({
            color: props.color,
            depthTest: false
        });
        super(geometry, material);
        this.renderOrder = 1;
        this.onBeforeRender = () => {
            target.updateMatrixWorld(false);
            this.matrixWorld.copy(target.matrixWorld);
        };
    }
    dispose() {
        if (this.parent) {
            this.parent.remove(this);
        }
        this.geometry.dispose();
    }
    static expandBoundingBox(object, root, box) {
        const geometry = object.geometry;
        if (geometry !== undefined) {
            let parent = object;
            _mat4.identity();
            while (parent && parent !== root) {
                _mat4.premultiply(parent.matrix);
                parent = parent.parent;
            }
            if (geometry.isGeometry) {
                const vertices = geometry.vertices;
                for (let i = 0, n = vertices.length; i < n; ++i) {
                    _vec3.copy(vertices[i]).applyMatrix4(_mat4);
                    box.expandByPoint(_vec3);
                }
            }
            else if (geometry.isBufferGeometry) {
                const attribute = geometry.attributes.position;
                if (attribute !== undefined) {
                    for (let i = 0, n = attribute.count; i < n; ++i) {
                        _vec3.fromBufferAttribute(attribute, i).applyMatrix4(_mat4);
                        box.expandByPoint(_vec3);
                    }
                }
            }
        }
        const children = object.children;
        for (let i = 0, n = children.length; i < n; ++i) {
            Bracket.expandBoundingBox(children[i], root, box);
        }
    }
}
Bracket.defaultProps = {
    color: new three__WEBPACK_IMPORTED_MODULE_0__["Color"]("#ffd633"),
    length: 0.25
};


/***/ }),

/***/ "../../libs/ff-three/source/CameraController.ts":
/*!**********************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-three/source/CameraController.ts ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CameraController; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_core_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/core/math */ "../../libs/ff-core/source/math.ts");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "../../libs/ff-three/source/math.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2020 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */



////////////////////////////////////////////////////////////////////////////////
const _mat4 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
const _box3 = new three__WEBPACK_IMPORTED_MODULE_0__["Box3"]();
const _vec3a = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vec3b = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
var EControllerMode;
(function (EControllerMode) {
    EControllerMode[EControllerMode["Orbit"] = 0] = "Orbit";
    EControllerMode[EControllerMode["FirstPerson"] = 1] = "FirstPerson";
})(EControllerMode || (EControllerMode = {}));
var EManipMode;
(function (EManipMode) {
    EManipMode[EManipMode["Off"] = 0] = "Off";
    EManipMode[EManipMode["Pan"] = 1] = "Pan";
    EManipMode[EManipMode["Orbit"] = 2] = "Orbit";
    EManipMode[EManipMode["Dolly"] = 3] = "Dolly";
    EManipMode[EManipMode["Zoom"] = 4] = "Zoom";
    EManipMode[EManipMode["PanDolly"] = 5] = "PanDolly";
    EManipMode[EManipMode["Roll"] = 6] = "Roll";
})(EManipMode || (EManipMode = {}));
var EManipPhase;
(function (EManipPhase) {
    EManipPhase[EManipPhase["Off"] = 0] = "Off";
    EManipPhase[EManipPhase["Active"] = 1] = "Active";
    EManipPhase[EManipPhase["Release"] = 2] = "Release";
})(EManipPhase || (EManipPhase = {}));
class CameraController {
    constructor(camera) {
        this.orbit = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0);
        this.offset = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 50);
        this.minOrbit = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](-90, -Infinity, -Infinity);
        this.maxOrbit = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](90, Infinity, Infinity);
        this.minOffset = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](-Infinity, -Infinity, 0.1);
        this.maxOffset = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](Infinity, Infinity, 1000);
        this.orientationEnabled = true;
        this.offsetEnabled = true;
        this.mode = EManipMode.Off;
        this.phase = EManipPhase.Off;
        this.prevPinchDist = 0;
        this.deltaX = 0;
        this.deltaY = 0;
        this.deltaPinch = 0;
        this.deltaWheel = 0;
        this.viewportWidth = 100;
        this.viewportHeight = 100;
        this.camera = camera;
    }
    onPointer(event) {
        if (event.isPrimary) {
            if (event.type === "pointer-down") {
                this.phase = EManipPhase.Active;
            }
            else if (event.type === "pointer-up") {
                this.phase = EManipPhase.Release;
                return true;
            }
        }
        if (event.type === "pointer-down") {
            this.mode = this.getModeFromEvent(event);
        }
        const keyMultiplier = 1;
        this.deltaX += event.movementX * keyMultiplier;
        this.deltaY += event.movementY * keyMultiplier;
        // calculate pinch
        if (event.pointerCount === 2) {
            const positions = event.activePositions;
            const dx = positions[1].clientX - positions[0].clientX;
            const dy = positions[1].clientY - positions[0].clientY;
            const pinchDist = Math.sqrt(dx * dx + dy * dy);
            const prevPinchDist = this.prevPinchDist || pinchDist;
            this.deltaPinch *= prevPinchDist > 0 ? (pinchDist / prevPinchDist) : 1;
            this.prevPinchDist = pinchDist;
        }
        else {
            this.deltaPinch = 1;
            this.prevPinchDist = 0;
        }
        return true;
    }
    onTrigger(event) {
        if (event.type === "wheel") {
            this.deltaWheel += _ff_core_math__WEBPACK_IMPORTED_MODULE_1__["default"].limit(event.wheel, -1, 1);
            return true;
        }
        return false;
    }
    setViewportSize(width, height) {
        this.viewportWidth = width;
        this.viewportHeight = height;
    }
    updateController(object, adaptLimits) {
        const camera = this.camera;
        object = object || camera;
        const orbit = this.orbit;
        const offset = this.offset;
        _math__WEBPACK_IMPORTED_MODULE_2__["default"].decomposeOrbitMatrix(object.matrix, orbit, offset);
        this.orbit.multiplyScalar(_math__WEBPACK_IMPORTED_MODULE_2__["default"].RAD2DEG);
        if (adaptLimits) {
            this.minOffset.min(offset);
            this.maxOffset.max(offset);
        }
    }
    /**
     * Adjusts the camera such that the given bounding box is entirely visible.
     * This method can only be called if an internal camera has been assigned.
     * @param box Bounding box
     */
    zoomExtents(box) {
        const camera = this.camera;
        const offset = this.offset;
        if (!camera) {
            console.warn("CameraController.zoomExtents - camera not set");
            return;
        }
        // rotate box to camera space
        _vec3a.copy(this.orbit).multiplyScalar(_ff_core_math__WEBPACK_IMPORTED_MODULE_1__["default"].DEG2RAD);
        _vec3b.setScalar(0);
        _math__WEBPACK_IMPORTED_MODULE_2__["default"].composeOrbitMatrix(_vec3a, _vec3b, _mat4);
        _box3.copy(box).applyMatrix4(_mat4.transpose());
        _box3.getSize(_vec3a);
        _box3.getCenter(_vec3b);
        offset.x = _vec3b.x;
        offset.y = _vec3b.y;
        const size = Math.max(_vec3a.x / camera.aspect, _vec3a.y);
        if (camera.isOrthographicCamera) {
            offset.z = size * 1.1; // add some padding
        }
        else {
            const fovFactor = 1 / (2 * Math.tan(camera.fov * _ff_core_math__WEBPACK_IMPORTED_MODULE_1__["default"].DEG2RAD * 0.5));
            offset.z = (_vec3b.z + size * fovFactor + _vec3a.z * 0.25 /* was 0.5 */);
        }
        this.maxOffset.z = Math.max(this.maxOffset.z, offset.z + _vec3a.z * 4);
    }
    /**
     * Updates the matrix of the given camera. If the camera's projection is orthographic,
     * updates the camera's size parameter as well.
     * @param object Updates this object if given, otherwise updates the internal camera.
     * @param force If true always updates, even if there haven't been any changes since the last update.
     */
    updateCamera(object, force) {
        const camera = this.camera;
        object = object || camera;
        if (!this.update() && !force) {
            return false;
        }
        _vec3a.copy(this.orbit).multiplyScalar(_ff_core_math__WEBPACK_IMPORTED_MODULE_1__["default"].DEG2RAD);
        _vec3b.copy(this.offset);
        if (camera.isOrthographicCamera) {
            _vec3b.z = this.maxOffset.z; // fixed distance = maxOffset.z
            camera.size = this.offset.z; // use size to visualize distance
            camera.far = 2 * this.maxOffset.z; // adjust far clipping
            camera.updateProjectionMatrix();
        }
        _math__WEBPACK_IMPORTED_MODULE_2__["default"].composeOrbitMatrix(_vec3a, _vec3b, object.matrix);
        object.matrixWorldNeedsUpdate = true;
        return true;
    }
    /**
     * Updates the manipulator.
     * @returns true if the state has changed during the update.
     */
    update() {
        if (this.phase === EManipPhase.Off && this.deltaWheel === 0) {
            return false;
        }
        if (this.deltaWheel !== 0) {
            this.updatePose(0, 0, this.deltaWheel * 0.07 + 1, 0, 0, 0);
            this.deltaWheel = 0;
            return true;
        }
        if (this.phase === EManipPhase.Active) {
            if (this.deltaX === 0 && this.deltaY === 0 && this.deltaPinch === 1) {
                return false;
            }
            this.updateByMode();
            this.deltaX = 0;
            this.deltaY = 0;
            this.deltaPinch = 1;
            return true;
        }
        else if (this.phase === EManipPhase.Release) {
            this.deltaX *= 0.85;
            this.deltaY *= 0.85;
            this.deltaPinch = 1;
            this.updateByMode();
            const delta = Math.abs(this.deltaX) + Math.abs(this.deltaY);
            if (delta < 0.1) {
                this.mode = EManipMode.Off;
                this.phase = EManipPhase.Off;
            }
            return true;
        }
        return false;
    }
    updateByMode() {
        switch (this.mode) {
            case EManipMode.Orbit:
                this.updatePose(0, 0, 1, this.deltaY, this.deltaX, 0);
                break;
            case EManipMode.Pan:
                this.updatePose(this.deltaX, this.deltaY, 1, 0, 0, 0);
                break;
            case EManipMode.Roll:
                this.updatePose(0, 0, 1, 0, 0, this.deltaX);
                break;
            case EManipMode.Dolly:
                this.updatePose(0, 0, this.deltaY * 0.0075 + 1, 0, 0, 0);
                break;
            case EManipMode.PanDolly:
                const pinchScale = (this.deltaPinch - 1) * 0.42 + 1;
                this.updatePose(this.deltaX * 0.75, this.deltaY * 0.75, 1 / pinchScale, 0, 0, 0);
                break;
        }
    }
    updatePose(dX, dY, dScale, dPitch, dHead, dRoll) {
        const { orbit, minOrbit, maxOrbit, offset, minOffset, maxOffset } = this;
        let inverse = -1;
        if (this.orientationEnabled) {
            orbit.x += inverse * dPitch * 220 / this.viewportHeight;
            orbit.y += inverse * dHead * 220 / this.viewportHeight;
            orbit.z += inverse * dRoll * 220 / this.viewportHeight;
            // check limits
            orbit.x = _ff_core_math__WEBPACK_IMPORTED_MODULE_1__["default"].limit(orbit.x, minOrbit.x, maxOrbit.x);
            orbit.y = _ff_core_math__WEBPACK_IMPORTED_MODULE_1__["default"].limit(orbit.y, minOrbit.y, maxOrbit.y);
            orbit.z = _ff_core_math__WEBPACK_IMPORTED_MODULE_1__["default"].limit(orbit.z, minOrbit.z, maxOrbit.z);
        }
        if (this.offsetEnabled) {
            const factor = offset.z = dScale * offset.z;
            offset.x += dX * factor * inverse / this.viewportHeight;
            offset.y -= dY * factor * inverse / this.viewportHeight;
            // check limits
            offset.x = _ff_core_math__WEBPACK_IMPORTED_MODULE_1__["default"].limit(offset.x, minOffset.x, maxOffset.x);
            offset.y = _ff_core_math__WEBPACK_IMPORTED_MODULE_1__["default"].limit(offset.y, minOffset.y, maxOffset.y);
            offset.z = _ff_core_math__WEBPACK_IMPORTED_MODULE_1__["default"].limit(offset.z, minOffset.z, maxOffset.z);
        }
    }
    getModeFromEvent(event) {
        if (event.source === "mouse") {
            const button = event.originalEvent.button;
            // left button
            if (button === 0) {
                if (event.ctrlKey) {
                    return EManipMode.Pan;
                }
                if (event.altKey) {
                    return EManipMode.Dolly;
                }
                return EManipMode.Orbit;
            }
            // right button
            if (button === 2) {
                if (event.altKey) {
                    return EManipMode.Roll;
                }
                else {
                    return EManipMode.Pan;
                }
            }
            // middle button
            if (button === 1) {
                return EManipMode.Dolly;
            }
        }
        else if (event.source === "touch") {
            const count = event.pointerCount;
            if (count === 1) {
                return EManipMode.Orbit;
            }
            if (count === 2) {
                return EManipMode.PanDolly;
            }
            return EManipMode.Pan;
        }
    }
}


/***/ }),

/***/ "../../libs/ff-three/source/Floor.ts":
/*!***********************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-three/source/Floor.ts ***!
  \***********************************************************/
/*! exports provided: default, FloorMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FloorMaterial", function() { return FloorMaterial; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/**
 * FF Typescript Foundation Library
 * Copyright 2020 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */

const fragmentShader = __webpack_require__(/*! ./shaders/floorPhongShader.frag */ "../../libs/ff-three/source/shaders/floorPhongShader.frag").default;
const vertexShader = __webpack_require__(/*! ./shaders/floorPhongShader.vert */ "../../libs/ff-three/source/shaders/floorPhongShader.vert").default;
////////////////////////////////////////////////////////////////////////////////
class Floor extends three__WEBPACK_IMPORTED_MODULE_0__["Mesh"] {
    constructor() {
        super(new three__WEBPACK_IMPORTED_MODULE_0__["PlaneBufferGeometry"](2, 2, 1, 1), new FloorMaterial());
        this.geometry.rotateX(-90 * three__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].DEG2RAD);
        this.receiveShadow = true;
    }
    dispose() {
        this.geometry.dispose();
        this.material.dispose();
    }
}
class FloorMaterial extends three__WEBPACK_IMPORTED_MODULE_0__["MeshPhongMaterial"] {
    constructor(params) {
        super(params);
        this.defines = {};
        this.type = "FloorMaterial";
        this.isMeshPhongMaterial = true;
        this.isFloorMaterial = true;
        this.defines = {};
        this.uniforms = three__WEBPACK_IMPORTED_MODULE_0__["UniformsUtils"].merge([
            three__WEBPACK_IMPORTED_MODULE_0__["ShaderLib"].phong.uniforms
        ]);
        this.vertexShader = vertexShader;
        this.fragmentShader = fragmentShader;
        this.transparent = true;
        this.shininess = 0;
    }
}


/***/ }),

/***/ "../../libs/ff-three/source/GPUPicker.ts":
/*!***************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-three/source/GPUPicker.ts ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GPUPicker; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _shaders_IndexShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shaders/IndexShader */ "../../libs/ff-three/source/shaders/IndexShader.ts");
/* harmony import */ var _shaders_PositionShader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shaders/PositionShader */ "../../libs/ff-three/source/shaders/PositionShader.ts");
/* harmony import */ var _shaders_NormalShader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shaders/NormalShader */ "../../libs/ff-three/source/shaders/NormalShader.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2020 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */




////////////////////////////////////////////////////////////////////////////////
const _vec3 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _color = new three__WEBPACK_IMPORTED_MODULE_0__["Color"]();
const _range = 10000;
const _pickPositionRange = new three__WEBPACK_IMPORTED_MODULE_0__["Box3"](new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](-_range, -_range, -_range), new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](_range, _range, _range));
class GPUPicker {
    constructor(renderer) {
        this.renderer = renderer;
        this.pickTextures = [];
        for (let i = 0; i < 3; ++i) {
            this.pickTextures[i] = new three__WEBPACK_IMPORTED_MODULE_0__["WebGLRenderTarget"](1, 1, { stencilBuffer: false });
        }
        this.pickBuffer = new Uint8Array(4);
        this.indexShader = new _shaders_IndexShader__WEBPACK_IMPORTED_MODULE_1__["default"]();
        this.positionShader = new _shaders_PositionShader__WEBPACK_IMPORTED_MODULE_2__["default"]();
        this.normalShader = new _shaders_NormalShader__WEBPACK_IMPORTED_MODULE_3__["default"]();
    }
    static add(object, recursive) {
        const hookObject3D = object => {
            if (object.material) {
                object.onBeforeRender = function (r, s, c, g, material) {
                    if (material.isIndexShader) {
                        //console.log("setIndex #%s for %s", object.id, object);
                        material.setIndex(object.id);
                    }
                };
            }
        };
        if (recursive) {
            object.traverse(object => hookObject3D(object));
        }
        else {
            hookObject3D(object);
        }
    }
    static remove(object, recursive) {
        const unhookObject3D = object => {
            if (object.material) {
                object.onBeforeRender = null;
            }
        };
        if (recursive) {
            object.traverse(object => unhookObject3D(object));
        }
        else {
            unhookObject3D(object);
        }
    }
    pickObject(scene, camera, event) {
        const index = this.pickIndex(scene, camera, event);
        if (index > 0) {
            return scene.getObjectById(index);
        }
        return undefined;
    }
    /**
     * Picks the index of the object at the position given by the event.
     * @param scene The scene containing the objects available for picking.
     * @param camera The active camera.
     * @param event A UI event providing the screen position at which to pick.
     */
    pickIndex(scene, camera, event) {
        const viewport = event.viewport;
        camera = viewport.updateCamera(camera);
        const overrideMaterial = scene.overrideMaterial;
        scene.overrideMaterial = this.indexShader;
        const renderer = this.renderer;
        const pickTexture = this.pickTextures[0];
        renderer.getClearColor(_color);
        viewport.applyPickViewport(pickTexture, event);
        renderer.setRenderTarget(pickTexture);
        renderer.setClearColor(0);
        const xrFlag = renderer.xr.enabled;
        renderer.xr.enabled = false;
        renderer.clear();
        renderer.render(scene, camera);
        renderer.xr.enabled = xrFlag;
        renderer.setRenderTarget(null);
        renderer.setClearColor(_color);
        scene.overrideMaterial = overrideMaterial;
        const buffer = this.pickBuffer;
        renderer.readRenderTargetPixels(pickTexture, 0, 0, 1, 1, buffer);
        return buffer[0] + buffer[1] * 256 + buffer[2] * 65536;
    }
    /**
     * Picks the local position on the surface of the object at the screen position of the given UI event.
     * @param scene The scene containing the objects available for picking.
     * @param camera The active camera.
     * @param event A UI event providing the screen position at which to pick.
     * @param range Optional range for the possible position values to be picked. Can be omitted. If given, should
     * be set to the local bounding box of the object whose position is picked.
     * @param result A vector containing the picked position in object-local coordinates.
     */
    pickPosition(scene, camera, event, range, result) {
        range = range || _pickPositionRange;
        result = result || new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
        const viewport = event.viewport;
        camera = viewport.updateCamera(camera);
        const overrideMaterial = scene.overrideMaterial;
        const shader = scene.overrideMaterial = this.positionShader;
        const renderer = this.renderer;
        const pickTextures = this.pickTextures;
        renderer.getClearColor(_color);
        renderer.setClearColor(0);
        for (let i = 0; i < 3; ++i) {
            shader.uniforms.index.value = i;
            shader.uniforms.range.value[0] = range.min.getComponent(i);
            shader.uniforms.range.value[1] = range.max.getComponent(i);
            viewport.applyPickViewport(pickTextures[i], event);
            renderer.setRenderTarget(pickTextures[i]);
            renderer.clear();
            renderer.render(scene, camera);
        }
        renderer.setRenderTarget(null);
        renderer.setClearColor(_color);
        scene.overrideMaterial = overrideMaterial;
        const buffer = this.pickBuffer;
        for (let i = 0; i < 3; ++i) {
            renderer.readRenderTargetPixels(pickTextures[i], 0, 0, 1, 1, buffer);
            result.setComponent(i, buffer[3] * 2.337437050015319e-10 /* / 255 / 16777216 */
                + buffer[2] * 5.983838848039216e-8 /* / 255 / 65536 */
                + buffer[1] * 1.531862745098039e-5 /* / 255 / 256 */
                + buffer[0] * 0.003921568627451 /* / 255 */);
        }
        range.getSize(_vec3);
        return result.multiply(_vec3).add(range.min);
    }
    /**
     * Picks the surface normal of the object at the screen position of the given UI event.
     * @param scene The scene containing the objects available for picking.
     * @param camera The active camera.
     * @param event A UI event providing the screen position at which to pick.
     * @param result A vector containing the picked normal in object-local coordinates.
     */
    pickNormal(scene, camera, event, result) {
        result = result || new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
        const viewport = event.viewport;
        camera = viewport.updateCamera(camera);
        const overrideMaterial = scene.overrideMaterial;
        scene.overrideMaterial = this.normalShader;
        const renderer = this.renderer;
        const pickTexture = this.pickTextures[0];
        renderer.getClearColor(_color);
        viewport.applyPickViewport(pickTexture, event);
        renderer.setRenderTarget(pickTexture);
        renderer.setClearColor(0);
        renderer.clear();
        renderer.render(scene, camera);
        renderer.setRenderTarget(null);
        renderer.setClearColor(_color);
        scene.overrideMaterial = overrideMaterial;
        const buffer = this.pickBuffer;
        renderer.readRenderTargetPixels(pickTexture, 0, 0, 1, 1, buffer);
        return result.set(buffer[0] / 255 * 2 - 1, buffer[1] / 255 * 2 - 1, buffer[2] / 255 * 2 - 1).normalize();
    }
}


/***/ }),

/***/ "../../libs/ff-three/source/Grid.ts":
/*!**********************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-three/source/Grid.ts ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Grid; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/**
 * FF Typescript Foundation Library
 * Copyright 2020 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */

class Grid extends three__WEBPACK_IMPORTED_MODULE_0__["LineSegments"] {
    constructor(props) {
        const geometry = Grid.generate(props);
        const material = new three__WEBPACK_IMPORTED_MODULE_0__["LineBasicMaterial"]({
            color: 0xffffffff,
            vertexColors: true,
        });
        super(geometry, material);
    }
    set opacity(value) {
        this.material["opacity"] = value;
        this.material["transparent"] = value < 1;
    }
    update(props) {
        if (this.geometry) {
            this.geometry.dispose();
        }
        this.geometry = Grid.generate(props);
    }
    static generate(props) {
        const mainColor = new three__WEBPACK_IMPORTED_MODULE_0__["Color"](props.mainColor);
        const subColor = new three__WEBPACK_IMPORTED_MODULE_0__["Color"](props.subColor);
        const divisions = props.mainDivisions * props.subDivisions;
        const step = props.size / divisions;
        const halfSize = props.size * 0.5;
        const vertices = [];
        const colors = [];
        for (let i = 0, j = 0, k = -halfSize; i <= divisions; ++i, k += step) {
            vertices.push(-halfSize, 0, k, halfSize, 0, k);
            vertices.push(k, 0, -halfSize, k, 0, halfSize);
            const color = i % props.subDivisions === 0 ? mainColor : subColor;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
        }
        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]();
        geometry.setAttribute("position", new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"](vertices, 3));
        geometry.setAttribute("color", new three__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"](colors, 3));
        return geometry;
    }
}


/***/ }),

/***/ "../../libs/ff-three/source/HTMLSprite.ts":
/*!****************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-three/source/HTMLSprite.ts ***!
  \****************************************************************/
/*! exports provided: html, EQuadrant, default, SpriteElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EQuadrant", function() { return EQuadrant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HTMLSprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteElement", function() { return SpriteElement; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/ui/CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "html", function() { return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_1__["html"]; });

/**
 * FF Typescript Foundation Library
 * Copyright 2020 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


////////////////////////////////////////////////////////////////////////////////

const _vec3a = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vec3b = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vec3c = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vec3d = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vec2a = new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();
const _vec2b = new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();
var EQuadrant;
(function (EQuadrant) {
    EQuadrant[EQuadrant["TopRight"] = 0] = "TopRight";
    EQuadrant[EQuadrant["TopLeft"] = 1] = "TopLeft";
    EQuadrant[EQuadrant["BottomLeft"] = 2] = "BottomLeft";
    EQuadrant[EQuadrant["BottomRight"] = 3] = "BottomRight";
})(EQuadrant || (EQuadrant = {}));
/**
 * A Three.js Object representing a 3D renderable part and a 2D (HTML) part.
 * HTML sprites should have a [[HTMLSpriteGroup]] as their parent.
 */
class HTMLSprite extends three__WEBPACK_IMPORTED_MODULE_0__["Object3D"] {
    constructor() {
        super();
        this.isHTMLSprite = true;
        this.viewAngle = 0;
        this.orientationAngle = 0;
        this.orientationQuadrant = EQuadrant.TopLeft;
        this._elements = new Map();
        this._visible = true;
        this.frustumCulled = false;
    }
    get visible() {
        return this._visible;
    }
    set visible(visible) {
        if (visible !== this._visible && this._elements) {
            this._visible = visible;
            this._elements.forEach(element => {
                if (element) {
                    element.setVisible(visible);
                }
            });
        }
    }
    dispose() {
        this._elements.forEach((element, container) => {
            if (element) {
                container.removeChild(element);
            }
        });
        this._elements.clear();
    }
    disposeHTMLElement(container) {
        const element = this._elements.get(container);
        if (element) {
            this._elements.delete(container);
            container.removeChild(element);
        }
    }
    /**
     * Called when the 3D parts of the sprite should be updated because
     * the underlying data has been changed.
     */
    update() {
        this._elements.forEach(element => {
            if (element) {
                this.updateHTMLElement(element);
            }
        });
    }
    /**
     * Called when the model-view of the sprite has changed.
     * This updates the position and orientation of the HTML element.
     * @param element The sprite HTML element to be updated.
     * @param container The container holding the sprite element.
     * @param camera The current scene camera.
     * @param anchor The 3D object to which the HTML sprite element is attached.
     * @param offset An offset to be added to the anchor 3D object.
     */
    renderHTMLElement(element, container, camera, anchor, offset) {
        anchor = anchor || this;
        _vec3a.set(0, 0, 0);
        _vec3a.applyMatrix4(anchor.modelViewMatrix);
        offset ? _vec3b.copy(offset) : _vec3b.set(0, 1, 0);
        _vec3b.applyMatrix4(anchor.modelViewMatrix);
        _vec3c.copy(_vec3b).sub(_vec3a).normalize();
        _vec3d.set(0, 0, 1);
        this.viewAngle = _vec3c.angleTo(_vec3d);
        _vec3a.applyMatrix4(camera.projectionMatrix);
        _vec3b.applyMatrix4(camera.projectionMatrix);
        _vec2b.set(_vec3b.x, _vec3b.y);
        _vec2a.set(_vec3a.x, _vec3a.y);
        _vec2b.sub(_vec2a);
        const x = (_vec3b.x + 1) * 0.5 * container.clientWidth;
        const y = (1 - _vec3b.y) * 0.5 * container.clientHeight;
        element.setPosition(x, y);
        const angle = this.orientationAngle = _vec2b.angle();
        this.orientationQuadrant = Math.floor(2 * angle / Math.PI);
    }
    getHTMLElement(container) {
        let element = this._elements.get(container);
        if (!element) {
            element = this.createHTMLElement();
            if (element) {
                element.setVisible(this._visible);
                container.appendChild(element);
                this._elements.set(container, element);
            }
        }
        return element;
    }
    /**
     * Called when the sprite becomes visible in a viewport.
     * Override to return a HTML element to visualize the 2D part of the sprite in the viewport.
     * The default implementation returns null, i.e. no HTML elements are created for this sprite.
     */
    createHTMLElement() {
        return null;
    }
    /**
     * Called when the HTML parts of the sprite should be updated because
     * the underlying data has been changed. This is called once for each viewport
     * the sprite is represented in with a HTML element.
     * Method is not called if the sprite has no HTML element.
     * @param element The HTML element that should be updated.
     */
    updateHTMLElement(element) {
        element.requestUpdate();
    }
}
////////////////////////////////////////////////////////////////////////////////
let SpriteElement = class SpriteElement extends _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_1__["default"] {
    setVisible(visible) {
        this.style.display = visible ? "block" : "none";
    }
    setOpacity(opacity) {
        this.style.opacity = opacity.toString();
        this.style.visibility = opacity > 0 ? "visible" : "hidden";
    }
    setPosition(x, y) {
        this.style.left = x.toString() + "px";
        this.style.top = y.toString() + "px";
    }
};
SpriteElement = __decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_1__["customElement"])("ff-sprite-element")
], SpriteElement);



/***/ }),

/***/ "../../libs/ff-three/source/HTMLSpriteGroup.ts":
/*!*********************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-three/source/HTMLSpriteGroup.ts ***!
  \*********************************************************************/
/*! exports provided: HTMLSprite, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HTMLSpriteGroup; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _HTMLSprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HTMLSprite */ "../../libs/ff-three/source/HTMLSprite.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HTMLSprite", function() { return _HTMLSprite__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/**
 * FF Typescript Foundation Library
 * Copyright 2020 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */


////////////////////////////////////////////////////////////////////////////////

/**
 * THREE 3D object, grouping a number of HTML sprites.
 */
class HTMLSpriteGroup extends three__WEBPACK_IMPORTED_MODULE_0__["Object3D"] {
    constructor() {
        super(...arguments);
        this.isHTMLSpriteGroup = true;
        this._visible = true;
    }
    get visible() {
        return this._visible;
    }
    set visible(visible) {
        if (visible !== this._visible) {
            this._visible = visible;
            const children = this.children;
            for (let i = 0, n = children.length; i < n; ++i) {
                children[i].visible = visible;
            }
        }
    }
    /**
     * Disposes of the group including all sprite objects and HTML elements.
     */
    dispose() {
        const children = this.children;
        for (let i = 0, n = children.length; i < n; ++i) {
            children[i].dispose();
        }
    }
    /**
     * Must be called if the container element is removed. Disposes of all sprite HTML elements
     * attached to the container.
     * @param container The HTML container element to be removed.
     */
    disposeHTMLElements(container) {
        const children = this.children;
        for (let i = 0, n = children.length; i < n; ++i) {
            children[i].disposeHTMLElement(container);
        }
    }
    /**
     * If necessary, adds HTML elements for all sprites to the given HTML container element.
     * Updates existing elements according to each sprite's position.
     * @param container HTML container element for the HTML elements.
     * @param camera The camera used to render the 3D scene.
     */
    render(container, camera) {
        if (!this.visible) {
            return;
        }
        const children = this.children;
        for (let i = 0, n = children.length; i < n; ++i) {
            const child = children[i];
            const element = child.getHTMLElement(container);
            if (element) {
                child.renderHTMLElement(element, container, camera);
            }
        }
    }
    /**
     * Calls update on all sprites in the group.
     */
    update() {
        const children = this.children;
        for (let i = 0, n = children.length; i < n; ++i) {
            children[i].update();
        }
    }
}


/***/ }),

/***/ "../../libs/ff-three/source/UniversalCamera.ts":
/*!*********************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-three/source/UniversalCamera.ts ***!
  \*********************************************************************/
/*! exports provided: EProjection, EViewPreset, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EProjection", function() { return EProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EViewPreset", function() { return EViewPreset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UniversalCamera; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_core_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/core/math */ "../../libs/ff-core/source/math.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2020 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */


////////////////////////////////////////////////////////////////////////////////
const _halfPi = Math.PI * 0.5;
const _box = new three__WEBPACK_IMPORTED_MODULE_0__["Box3"]();
const _size = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _center = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _translation = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _mat4a = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
const _mat4b = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
const _cameraOrientation = [
    new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, -_halfPi, 0),
    new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, _halfPi, 0),
    new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](-_halfPi, 0, 0),
    new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](_halfPi, 0, 0),
    new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0),
    new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, Math.PI, 0),
];
var EProjection;
(function (EProjection) {
    EProjection[EProjection["Perspective"] = 0] = "Perspective";
    EProjection[EProjection["Orthographic"] = 1] = "Orthographic";
})(EProjection || (EProjection = {}));
var EViewPreset;
(function (EViewPreset) {
    EViewPreset[EViewPreset["None"] = -1] = "None";
    EViewPreset[EViewPreset["Left"] = 0] = "Left";
    EViewPreset[EViewPreset["Right"] = 1] = "Right";
    EViewPreset[EViewPreset["Top"] = 2] = "Top";
    EViewPreset[EViewPreset["Bottom"] = 3] = "Bottom";
    EViewPreset[EViewPreset["Front"] = 4] = "Front";
    EViewPreset[EViewPreset["Back"] = 5] = "Back";
})(EViewPreset || (EViewPreset = {}));
class UniversalCamera extends three__WEBPACK_IMPORTED_MODULE_0__["Camera"] {
    constructor(projection) {
        super();
        this.isUniversalCamera = true;
        this.fov = 50;
        this.size = 20;
        this.aspect = 1;
        this.distance = 20;
        this.zoom = 1;
        this.near = 0.1;
        this.far = 2000;
        // additional perspective parameters
        this.focus = 10;
        this.filmGauge = 35;
        this.filmOffset = 0;
        // view offset
        this.view = null;
        this.setProjection(projection);
    }
    setProjection(type) {
        if (type === EProjection.Orthographic) {
            this.type = "OrthographicCamera";
            this.isPerspectiveCamera = false;
            this.isOrthographicCamera = true;
        }
        else {
            this.type = "PerspectiveCamera";
            this.isPerspectiveCamera = true;
            this.isOrthographicCamera = false;
        }
        this.updateProjectionMatrix();
    }
    getProjection() {
        return this.isOrthographicCamera ? EProjection.Orthographic : EProjection.Perspective;
    }
    setPreset(preset) {
        if (preset !== EViewPreset.None) {
            this.rotation.setFromVector3(_cameraOrientation[preset], "XYZ");
            this.position.set(0, 0, this.distance).applyQuaternion(this.quaternion);
        }
        else {
            this.rotation.set(0, 0, 0);
            this.position.set(0, 0, 0);
        }
        this.updateMatrix();
    }
    setFocalLength(focalLength) {
        const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
        this.fov = three__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].RAD2DEG * 2 * Math.atan(vExtentSlope);
        this.updateProjectionMatrix();
    }
    getFocalLength() {
        const vExtentSlope = Math.tan(three__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].DEG2RAD * 0.5 * this.fov);
        return 0.5 * this.getFilmHeight() / vExtentSlope;
    }
    getEffectiveFOV() {
        return three__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].RAD2DEG * 2 * Math.atan(Math.tan(three__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].DEG2RAD * 0.5 * this.fov) / this.zoom);
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(viewportWidth, viewportHeight, windowX, windowY, windowWidth, windowHeight) {
        if (this.isPerspectiveCamera) {
            three__WEBPACK_IMPORTED_MODULE_0__["PerspectiveCamera"].prototype.setViewOffset.call(this, viewportWidth, viewportHeight, windowX, windowY, windowWidth, windowHeight);
        }
        else {
            three__WEBPACK_IMPORTED_MODULE_0__["OrthographicCamera"].prototype.setViewOffset.call(this, viewportWidth, viewportHeight, windowX, windowY, windowWidth, windowHeight);
        }
    }
    clearViewOffset() {
        if (this.view !== null) {
            this.view.enabled = false;
        }
        this.updateProjectionMatrix();
    }
    zoomToView() {
        // TODO: Implement
    }
    moveToView(boundingBox) {
        this.updateMatrixWorld(false);
        _box.copy(boundingBox);
        _mat4a.extractRotation(this.matrixWorldInverse);
        _box.applyMatrix4(_mat4a);
        _box.getSize(_size);
        _box.getCenter(_center);
        const objectSize = Math.max(_size.x / this.aspect, _size.y);
        _translation.set(-_center.x, -_center.y, 0);
        if (this.isPerspectiveCamera) {
            _translation.z = _size.z / (2 * Math.tan(this.fov * _ff_core_math__WEBPACK_IMPORTED_MODULE_1__["default"].DEG2RAD * 0.5));
        }
        else {
            this.size = objectSize * 0.5;
            _translation.z = _size.z * 2;
            this.far = Math.max(this.far, _translation.z * 2);
        }
        _mat4a.extractRotation(this.matrixWorld);
        _translation.applyMatrix4(_mat4a);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
        this.position.copy(_translation);
        this.updateMatrix();
    }
    updateProjectionMatrix() {
        const near = this.near;
        const far = this.far;
        const aspect = this.aspect;
        const zoom = this.zoom;
        const view = this.view;
        if (this.isOrthographicCamera) {
            const size = this.size;
            const dy = size / (2 * zoom);
            const dx = dy * aspect;
            let left = -dx;
            let right = dx;
            let top = dy;
            let bottom = -dy;
            if (view && view.enabled) {
                const zoomW = zoom / (view.width / view.fullWidth);
                const zoomH = zoom / (view.height / view.fullHeight);
                const scaleW = size * aspect / view.width;
                const scaleH = size / view.height;
                left += scaleW * (view.offsetX / zoomW);
                right = left + scaleW * (view.width / zoomW);
                top -= scaleH * (view.offsetY / zoomH);
                bottom = top - scaleH * (view.height / zoomH);
            }
            this.projectionMatrix.makeOrthographic(left, right, top, bottom, near, far);
        }
        else {
            let top = near * Math.tan(three__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].DEG2RAD * 0.5 * this.fov) / zoom;
            let height = 2 * top;
            let width = aspect * height;
            let left = -0.5 * width;
            if (view && view.enabled) {
                left += view.offsetX * width / view.fullWidth;
                top -= view.offsetY * height / view.fullHeight;
                width *= view.width / view.fullWidth;
                height *= view.height / view.fullHeight;
            }
            var skew = this.filmOffset;
            if (skew !== 0) {
                left += near * skew / this.getFilmWidth();
            }
            this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, far);
        }
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.type = source.type;
        this.isOrthographicCamera = source.isOrthographicCamera;
        this.isPerspectiveCamera = source.isPerspectiveCamera;
        this.fov = source.fov;
        this.size = source.size;
        this.aspect = source.aspect;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset;
        this.view = source.view ? Object.assign({}, source.view) : null;
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.fov = this.fov;
        data.object.size = this.size;
        data.object.aspect = this.aspect;
        data.object.zoom = this.zoom;
        data.object.near = this.near;
        data.object.far = this.far;
        data.object.focus = this.focus;
        data.object.filmGauge = this.filmGauge;
        data.object.filmOffset = this.filmOffset;
        if (this.view !== null) {
            data.object.view = Object.assign({}, this.view);
        }
        return data;
    }
}


/***/ }),

/***/ "../../libs/ff-three/source/Viewport.ts":
/*!**************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-three/source/Viewport.ts ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Viewport; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_core_Publisher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/core/Publisher */ "../../libs/ff-core/source/Publisher.ts");
/* harmony import */ var _UniversalCamera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./UniversalCamera */ "../../libs/ff-three/source/UniversalCamera.ts");
/* harmony import */ var _ui_ViewportOverlay__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ui/ViewportOverlay */ "../../libs/ff-three/source/ui/ViewportOverlay.ts");
/* harmony import */ var _CameraController__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CameraController */ "../../libs/ff-three/source/CameraController.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2020 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */





class Viewport extends _ff_core_Publisher__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(props) {
        super();
        this.next = null;
        this._canvasWidth = 1;
        this._canvasHeight = 1;
        this._overlay = null;
        this._camera = null;
        this._controller = null;
        this.addEvent("dispose");
        this.next = null;
        props = props || {};
        this._relRect = {
            x: props.x || 0,
            y: props.y || 0,
            width: props.width || 1,
            height: props.height || 1
        };
        this._absRect = {
            x: 0,
            y: 0,
            width: 1,
            height: 1
        };
        if (props.overlay) {
            this._overlay = props.overlay;
        }
    }
    /**
     * The x-coordinate of the viewport's bottom-left corner in canvas pixels. The origin is at the bottom left.
     */
    get x() {
        return this._absRect.x;
    }
    /**
     * The y-coordinate of the viewport's bottom-left corner in canvas pixels. The origin is at the bottom left.
     */
    get y() {
        return this._absRect.y;
    }
    /**
     * The viewport's width in canvas pixels.
     */
    get width() {
        return this._absRect.width;
    }
    /**
     * The viewport's height in canvas pixels.
     */
    get height() {
        return this._absRect.height;
    }
    /** The width of the canvas in pixels. */
    get canvasWidth() {
        return this._canvasWidth;
    }
    /**
     * The height of the canvas in pixels.
     */
    get canvasHeight() {
        return this._canvasHeight;
    }
    /** The viewport's built-in camera. */
    get camera() {
        return this._camera;
    }
    /**
     * The controller of the build-in camera.
     */
    get controller() {
        return this._controller;
    }
    /**
     * The viewport's overlay HTML element.
     */
    get overlay() {
        return this._overlay;
    }
    set overlay(overlay) {
        this._overlay = overlay;
        this.updateGeometry();
    }
    /**
     * Frees all resources the viewport object may have claimed.
     */
    dispose() {
        if (true) {
            console.log("Viewport.dispose - " + this.toString());
        }
        this.emit({ type: "dispose", viewport: this });
        if (this._overlay) {
            this._overlay.remove();
            this._overlay = null;
        }
    }
    /**
     * Sets the size of the viewport in relative coordinates (origin at the bottom left, canvas width and height are 1).
     */
    setSize(x, y, width, height) {
        const relRect = this._relRect;
        relRect.x = x;
        relRect.y = y;
        relRect.width = width;
        relRect.height = height;
        this.updateGeometry();
    }
    /**
     *  Sets the size of the rendering canvas in pixels.
     */
    setCanvasSize(width, height) {
        this._canvasWidth = width;
        this._canvasHeight = height;
        this.updateGeometry();
        if (this._controller) {
            this._controller.setViewportSize(width, height);
        }
    }
    /** Creates or updates a built-in camera for the viewport. This camera will be used for rendering
     * instead of the scene camera.
     * @param type The camera's projection type (perspective or orthographic).
     * @param preset The camera's preset view (one of six principal directions).
     */
    setBuiltInCamera(type, preset) {
        if (!this._camera) {
            this._camera = new _UniversalCamera__WEBPACK_IMPORTED_MODULE_2__["default"](type);
            this._camera.matrixAutoUpdate = false;
        }
        else {
            this._camera.setProjection(type);
        }
        if (preset !== undefined) {
            this._camera.setPreset(preset);
            this.overlay.setLabel(_ui_ViewportOverlay__WEBPACK_IMPORTED_MODULE_3__["ELocation"].TopRight, "view", _UniversalCamera__WEBPACK_IMPORTED_MODULE_2__["EViewPreset"][preset], "ff-label-box");
        }
    }
    /**
     * Removes a previously set built-in camera. The scene camera will be used for rendering.
     */
    unsetBuiltInCamera() {
        this._camera = null;
        this._controller = null;
        this.overlay.unsetLabel(_ui_ViewportOverlay__WEBPACK_IMPORTED_MODULE_3__["ELocation"].TopRight, "view");
    }
    enableCameraControl(state) {
        if (!state && this._controller) {
            this._controller = null;
        }
        else if (state && this._camera) {
            if (!this._controller) {
                this._controller = new _CameraController__WEBPACK_IMPORTED_MODULE_4__["default"](this._camera);
                this._controller.setViewportSize(this.width, this.height);
                this._controller.updateController();
            }
        }
        return this._controller;
    }
    /**
     * Centers and positions the built-in camera such that the given box is entirely visible.
     * Does nothing if the viewport doesn't have a built-in camera and controller.
     * @param box
     */
    zoomExtents(box) {
        const camera = this._camera;
        const controller = this._controller;
        if (camera && controller) {
            controller.zoomExtents(box);
            controller.updateCamera(null, true);
        }
    }
    /**
     * Tests whether the pointer coordinates of the given UI event lie inside the viewport.
     * @param event
     */
    isInside(event) {
        return this.isPointInside(event.localX, event.localY);
    }
    isPointInside(x, y) {
        const absRect = this._absRect;
        y = this.canvasHeight - y;
        return x >= absRect.x && x < absRect.x + absRect.width
            && y >= absRect.y && y < absRect.y + absRect.height;
    }
    /**
     * Transforms the given local screen coordinates to normalized device coordinates.
     * @param localX canvas-local x coordinate.
     * @param localY canvas-local y coordinate.
     * @param result An optional 2-vector receiving the transformed coordinates.
     */
    getDevicePoint(localX, localY, result) {
        const absRect = this._absRect;
        const ndx = ((localX - absRect.x) / absRect.width) * 2 - 1;
        const ndy = ((this.canvasHeight - localY - absRect.y) / absRect.height) * 2 - 1;
        return result ? result.set(ndx, ndy) : new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"](ndx, ndy);
    }
    getDeviceX(x) {
        const absRect = this._absRect;
        return ((x - absRect.x) / absRect.width) * 2 - 1;
    }
    getDeviceY(y) {
        const absRect = this._absRect;
        return ((this.canvasHeight - y - absRect.y) / absRect.height) * 2 - 1;
    }
    updateCamera(sceneCamera) {
        let currentCamera = sceneCamera;
        if (this._camera) {
            currentCamera = this._camera;
            if (this._controller) {
                this._controller.updateCamera();
            }
        }
        if (!currentCamera) {
            return;
        }
        const absRect = this._absRect;
        const aspect = absRect.width / absRect.height;
        if (aspect !== currentCamera.userData["aspect"]) {
            currentCamera.userData["aspect"] = aspect;
            if (currentCamera.isUniversalCamera || currentCamera.isPerspectiveCamera) {
                currentCamera.aspect = aspect;
                currentCamera.updateProjectionMatrix();
            }
            else if (currentCamera.isOrthographicCamera) {
                const dy = (currentCamera.top - currentCamera.bottom) * 0.5;
                currentCamera.left = -dy * aspect;
                currentCamera.right = dy * aspect;
                currentCamera.updateProjectionMatrix();
            }
        }
        return currentCamera;
    }
    applyViewport(renderer) {
        const absRect = this._absRect;
        renderer.setViewport(absRect.x, absRect.y, absRect.width, absRect.height);
        renderer["viewport"] = this;
    }
    applyPickViewport(target, event) {
        const absRect = this._absRect;
        const x = event.localX - absRect.x;
        const y = this.canvasHeight - event.localY - absRect.y;
        target.viewport.set(-x, -y, absRect.width, absRect.height);
        //console.log("Viewport.applyPickViewport - offset: ", -left, -top);
    }
    toViewportEvent(event) {
        const vpEvent = event;
        vpEvent.viewport = this;
        vpEvent.deviceX = this.getDeviceX(event.localX);
        vpEvent.deviceY = this.getDeviceY(event.localY);
        return vpEvent;
    }
    onPointer(event) {
        if (this._controller) {
            return this._controller.onPointer(event);
        }
        return false;
    }
    onTrigger(event) {
        if (this._controller) {
            return this._controller.onTrigger(event);
        }
        return false;
    }
    toString() {
        return `Viewport (x: ${this.x}, y: ${this.y}, width: ${this.width}, height: ${this.height})`;
    }
    updateGeometry() {
        const relRect = this._relRect;
        const absRect = this._absRect;
        const canvasWidth = this._canvasWidth;
        const canvasHeight = this._canvasHeight;
        absRect.x = Math.round(relRect.x * canvasWidth);
        absRect.y = Math.round(relRect.y * canvasHeight);
        absRect.width = Math.round(relRect.width * canvasWidth);
        absRect.height = Math.round(relRect.height * canvasHeight);
        const overlay = this._overlay;
        if (overlay) {
            const top = this.canvasHeight - absRect.y - absRect.height;
            overlay.style.left = (absRect.x ? absRect.x.toFixed() + "px" : "0");
            overlay.style.top = (top ? top.toFixed() + "px" : "0");
            overlay.style.width = absRect.width.toFixed() + "px";
            overlay.style.height = absRect.height.toFixed() + "px";
        }
    }
}


/***/ }),

/***/ "../../libs/ff-three/source/helpers.ts":
/*!*************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-three/source/helpers.ts ***!
  \*************************************************************/
/*! exports provided: degreesToQuaternion, quaternionToDegrees, disposeObject, computeLocalBoundingBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degreesToQuaternion", function() { return degreesToQuaternion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quaternionToDegrees", function() { return quaternionToDegrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disposeObject", function() { return disposeObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeLocalBoundingBox", function() { return computeLocalBoundingBox; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/**
 * FF Typescript Foundation Library
 * Copyright 2020 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */

////////////////////////////////////////////////////////////////////////////////
const _vec3 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _mat4 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
const _euler = new three__WEBPACK_IMPORTED_MODULE_0__["Euler"]();
const _quat = new three__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();
function degreesToQuaternion(rotation, order, quaternion) {
    const result = quaternion || new three__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();
    _vec3.fromArray(rotation).multiplyScalar(three__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].DEG2RAD);
    _euler.setFromVector3(_vec3, order);
    result.setFromEuler(_euler);
    return result;
}
function quaternionToDegrees(quaternion, order, rotation) {
    const result = rotation || [0, 0, 0];
    _euler.setFromQuaternion(quaternion, order);
    _euler.toVector3(_vec3);
    _vec3.multiplyScalar(three__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].RAD2DEG).toArray(result);
    return result;
}
function disposeObject(object) {
    const geometries = new Map();
    const materials = new Map();
    const textures = new Map();
    object.traverse(object => {
        const mesh = object;
        if (mesh.isMesh) {
            const geometry = mesh.geometry;
            if (geometry) {
                geometries.set(geometry.uuid, geometry);
            }
            const material = mesh.material;
            if (material) {
                materials.set(material.uuid, material);
                for (let key in material) {
                    const texture = material[key]; // Texture;
                    if (texture && texture.isTexture) {
                        textures.set(texture.uuid, texture);
                    }
                }
            }
        }
    });
    if (true) {
        console.log("disposeObject - %s geometries, %s materials, %s textures", geometries.size, materials.size, textures.size);
    }
    for (let entry of textures) {
        entry[1].dispose();
    }
    for (let entry of materials) {
        entry[1].dispose();
    }
    for (let entry of geometries) {
        entry[1].dispose();
    }
}
/**
 * Computes the bounding box of the given object, relative to the given root (same as object if
 * not specified explicitly). Accounts for the transforms of all children relative to the root.
 * Caller is responsible for emptying the given bounding box, and for updating the matrices of
 * all child objects.
 * @param object
 * @param box The box to be updated.
 * @param root
 */
function computeLocalBoundingBox(object, box, root) {
    if (!root) {
        root = object;
    }
    const geometry = object.geometry;
    if (geometry && object.visible) {
        let current = object;
        _mat4.identity();
        while (current && current !== root) {
            _mat4.premultiply(current.matrix);
            current = current.parent;
        }
        if (geometry.isGeometry) {
            const vertices = geometry.vertices;
            for (let i = 0, n = vertices.length; i < n; ++i) {
                _vec3.copy(vertices[i]).applyMatrix4(_mat4);
                box.expandByPoint(_vec3);
            }
        }
        else if (geometry.isBufferGeometry) {
            const attribute = geometry.attributes.position;
            if (attribute !== undefined) {
                for (let i = 0, n = attribute.count; i < n; ++i) {
                    _vec3.fromBufferAttribute(attribute, i).applyMatrix4(_mat4);
                    box.expandByPoint(_vec3);
                }
            }
        }
    }
    const children = object.children;
    for (let i = 0, n = children.length; i < n; ++i) {
        computeLocalBoundingBox(children[i], box, root);
    }
}


/***/ }),

/***/ "../../libs/ff-three/source/math.ts":
/*!**********************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-three/source/math.ts ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_core_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/core/math */ "../../libs/ff-core/source/math.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2020 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */


////////////////////////////////////////////////////////////////////////////////
const _vec4a = new three__WEBPACK_IMPORTED_MODULE_0__["Vector4"]();
const _vec4b = new three__WEBPACK_IMPORTED_MODULE_0__["Vector4"]();
const _vec3a = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vec3b = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _mat4 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
const _euler = new three__WEBPACK_IMPORTED_MODULE_0__["Euler"]();
const _quat = new three__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();
////////////////////////////////////////////////////////////////////////////////
//export type Matrix4 = Float32Array | number[];
const math = {
    PI: 3.1415926535897932384626433832795,
    DOUBLE_PI: 6.283185307179586476925286766559,
    HALF_PI: 1.5707963267948966192313216916398,
    QUARTER_PI: 0.78539816339744830961566084581988,
    DEG2RAD: 0.01745329251994329576923690768489,
    RAD2DEG: 57.295779513082320876798154814105,
    composeOrbitMatrix: function (orientation, offset, result) {
        const pitch = orientation.x;
        const head = orientation.y;
        const roll = orientation.z;
        const ox = offset.x;
        const oy = offset.y;
        const oz = offset.z;
        const sinX = Math.sin(pitch);
        const cosX = Math.cos(pitch);
        const sinY = Math.sin(head);
        const cosY = Math.cos(head);
        const sinZ = Math.sin(roll);
        const cosZ = Math.cos(roll);
        const m00 = cosY * cosZ;
        const m01 = cosZ * sinY * sinX - sinZ * cosX;
        const m02 = cosZ * sinY * cosX + sinZ * sinX;
        const m10 = cosY * sinZ;
        const m11 = sinX * sinY * sinZ + cosZ * cosX;
        const m12 = sinZ * sinY * cosX - cosZ * sinX;
        const m20 = -sinY;
        const m21 = cosY * sinX;
        const m22 = cosY * cosX;
        result = result || new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
        const e = result.elements;
        e[0] = m00;
        e[1] = m10;
        e[2] = m20;
        e[3] = 0;
        e[4] = m01;
        e[5] = m11;
        e[6] = m21;
        e[7] = 0;
        e[8] = m02;
        e[9] = m12;
        e[10] = m22;
        e[11] = 0;
        e[12] = ox * m00 + oy * m01 + oz * m02;
        e[13] = ox * m10 + oy * m11 + oz * m12;
        e[14] = ox * m20 + oy * m21 + oz * m22;
        e[15] = 1;
        return result;
    },
    decomposeOrbitMatrix: function (matrix, orientationOut, offsetOut) {
        _euler.setFromRotationMatrix(matrix, "ZYX");
        _euler.toVector3(orientationOut);
        _mat4.copy(matrix).invert();
        _vec4a.set(0, 0, 0, 1);
        _vec4a.applyMatrix4(_mat4);
        offsetOut.x = -_vec4a.x;
        offsetOut.y = -_vec4a.y;
        offsetOut.z = -_vec4a.z;
    },
    isMatrix4Identity: function (matrix) {
        const e = matrix.elements;
        return e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 0
            && e[4] === 0 && e[5] === 1 && e[6] === 0 && e[7] === 0
            && e[8] === 0 && e[9] === 0 && e[10] === 1 && e[11] === 0
            && e[12] === 0 && e[13] === 0 && e[14] === 0 && e[15] === 1;
    },
    decomposeTransformMatrix: function (matrix, posOut, rotOut, scaleOut) {
        _mat4.fromArray(matrix);
        _mat4.decompose(_vec3a, _quat, _vec3b);
        _euler.setFromQuaternion(_quat, "XYZ");
        _vec3a.toArray(posOut);
        _vec3b.toArray(scaleOut);
        _euler.toVector3(_vec3a);
        _vec4a.multiplyScalar(_ff_core_math__WEBPACK_IMPORTED_MODULE_1__["default"].RAD2DEG);
        _vec3a.toArray(rotOut);
    }
};
/* harmony default export */ __webpack_exports__["default"] = (math);


/***/ }),

/***/ "../../libs/ff-three/source/shaders/IndexShader.ts":
/*!*************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-three/source/shaders/IndexShader.ts ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IndexShader; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/**
 * FF Typescript Foundation Library
 * Copyright 2020 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */

////////////////////////////////////////////////////////////////////////////////
class IndexShader extends three__WEBPACK_IMPORTED_MODULE_0__["ShaderMaterial"] {
    constructor() {
        super(...arguments);
        this.isIndexShader = true;
        this.uniformsNeedUpdate = false;
        this.lights = false;
        this.uniforms = {
            index: { value: [0, 0, 0] }
        };
        this.vertexShader = [
            "void main() {",
            "  #include <begin_vertex>",
            "  #include <project_vertex>",
            "}",
        ].join("\n");
        this.fragmentShader = [
            "uniform vec3 index;",
            "void main() {",
            "  gl_FragColor = vec4(index, 1.0);",
            "}"
        ].join("\n");
    }
    static indexFromPixel(pixel) {
        return pixel[0] + pixel[1] << 8 + pixel[2] << 16;
    }
    static zoneFromPixel(pixel) {
        return pixel[3];
    }
    setIndex(index) {
        const hb = index >> 16;
        const mb = (index >> 8) - (hb << 8);
        const lb = index - (hb << 16) - (mb << 8);
        const value = this.uniforms.index.value;
        value[0] = lb / 255;
        value[1] = mb / 255;
        value[2] = hb / 255;
        this.uniformsNeedUpdate = true;
    }
}


/***/ }),

/***/ "../../libs/ff-three/source/shaders/NormalShader.ts":
/*!**************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-three/source/shaders/NormalShader.ts ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NormalShader; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/**
 * FF Typescript Foundation Library
 * Copyright 2020 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */

////////////////////////////////////////////////////////////////////////////////
class NormalShader extends three__WEBPACK_IMPORTED_MODULE_0__["ShaderMaterial"] {
    constructor() {
        super(...arguments);
        this.isNormalShader = true;
        this.uniforms = {
            index: { value: 0 }
        };
        this.vertexShader = [
            "varying vec3 vLocalNormal;",
            "void main() {",
            "  #include <beginnormal_vertex>",
            "  #include <begin_vertex>",
            "  #include <project_vertex>",
            "  vLocalNormal = vec3(normal);",
            "}",
        ].join("\n");
        this.fragmentShader = [
            "uniform vec3 index;",
            "varying vec3 vLocalNormal;",
            "void main() {",
            "  vec3 normal = normalize(vLocalNormal);",
            "  gl_FragColor = vec4(normal * 0.5 + 0.5, 1.0);",
            "}"
        ].join("\n");
    }
}


/***/ }),

/***/ "../../libs/ff-three/source/shaders/PositionShader.ts":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-three/source/shaders/PositionShader.ts ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PositionShader; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/**
 * FF Typescript Foundation Library
 * Copyright 2020 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */

////////////////////////////////////////////////////////////////////////////////
/**
 * Renders the local position, requires one pass per component (x, y, z).
 */
class PositionShader extends three__WEBPACK_IMPORTED_MODULE_0__["ShaderMaterial"] {
    constructor() {
        super(...arguments);
        this.isPositionShader = true;
        this.uniforms = {
            index: { value: 0 },
            range: { value: [-1, 1] }
        };
        this.vertexShader = [
            "varying vec3 vLocalPosition;",
            "void main() {",
            "  #include <begin_vertex>",
            "  #include <project_vertex>",
            "  vLocalPosition = vec3(position);",
            "}",
        ].join("\n");
        this.fragmentShader = [
            "uniform float index;",
            "uniform vec2 range;",
            "varying vec3 vLocalPosition;",
            "vec4 toVec4(float v) {",
            "  float vn = (v - range.x) / (range.y - range.x);",
            "  float b0 = floor(vn * 255.0) / 255.0; vn = (vn - b0) * 256.0;",
            "  float b1 = floor(vn * 255.0) / 255.0; vn = (vn - b1) * 256.0;",
            "  float b2 = floor(vn * 255.0) / 255.0; vn = (vn - b2) * 256.0;",
            "  float b3 = floor(vn * 255.0) / 255.0;",
            "  return vec4(clamp(b0, 0.0, 1.0), clamp(b1, 0.0, 1.0), clamp(b2, 0.0, 1.0), clamp(b3, 0.0, 1.0));",
            "}",
            "void main() {",
            "  gl_FragColor = (index == 0.0 ? toVec4(vLocalPosition.x)",
            "    : (index == 1.0 ? toVec4(vLocalPosition.y) : toVec4(vLocalPosition.z)));",
            "}"
        ].join("\n");
    }
}


/***/ }),

/***/ "../../libs/ff-three/source/shaders/floorPhongShader.frag":
/*!********************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-three/source/shaders/floorPhongShader.frag ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("\n#define PHONG\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n\n// #include <uv_pars_fragment>\n// replaced with\nvarying vec2 vUv;\n\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n    vec2 coords = vUv * 2.0 - 1.0;\n    float f = dot(coords, coords);\n\tgl_FragColor = vec4(outgoingLight, mix(diffuseColor.a, 0.0, f));\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n\n");

/***/ }),

/***/ "../../libs/ff-three/source/shaders/floorPhongShader.vert":
/*!********************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-three/source/shaders/floorPhongShader.vert ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("\n#define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n\n// #include <uv_pars_vertex>\n// replaced with\nvarying vec2 vUv;\nuniform mat3 uvTransform;\n\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t// #include <uv_vertex>\n\t// replaced with\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n\n");

/***/ }),

/***/ "../../libs/ff-three/source/ui/ViewportOverlay.ts":
/*!************************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-three/source/ui/ViewportOverlay.ts ***!
  \************************************************************************/
/*! exports provided: ELocation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ELocation", function() { return ELocation; });
/* harmony import */ var _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/ui/CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2020 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

////////////////////////////////////////////////////////////////////////////////
/** Location enumeration for [[ViewportOverlay]]. */
var ELocation;
(function (ELocation) {
    ELocation[ELocation["TopLeft"] = 0] = "TopLeft";
    ELocation[ELocation["TopCenter"] = 1] = "TopCenter";
    ELocation[ELocation["TopRight"] = 2] = "TopRight";
    ELocation[ELocation["BottomLeft"] = 3] = "BottomLeft";
    ELocation[ELocation["BottomCenter"] = 4] = "BottomCenter";
    ELocation[ELocation["BottomRight"] = 5] = "BottomRight";
})(ELocation || (ELocation = {}));
/**
 * Custom HTML Element to be used as an overlay on top of a viewport.
 * Labels can be added to the overlay in six different locations. Each label is associated
 * with a key. Use the key to change or remove the label. Each label can be styled differently
 * using custom CSS classes.
 */
let ViewportOverlay = class ViewportOverlay extends _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
        this.labels = [];
        this.labels.push({}, {}, {}, {}, {}, {});
    }
    setLabel(location, key, text, className) {
        this.labels[location][key] = { text, className };
        this.requestUpdate();
    }
    unsetLabel(location, key) {
        delete this.labels[location][key];
        this.requestUpdate();
    }
    firstConnected() {
        this.classList.add("ff-container", "ff-viewport-overlay");
    }
    render() {
        const labels = this.labels;
        return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<div class="ff-row">
            <div class="ff-labels ff-top-left">${Object.keys(labels[ELocation.TopLeft]).map(key => {
            const label = labels[ELocation.TopLeft][key];
            return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<div class=${"ff-label " + label.className || false}>${label.text}</div>`;
        })}</div>
            <div class="ff-labels ff-top-center">${Object.keys(labels[ELocation.TopCenter]).map(key => {
            const label = labels[ELocation.TopCenter][key];
            return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<div class=${"ff-label " + label.className || false}>${label.text}</div>`;
        })}</div>
            <div class="ff-labels ff-top-right">${Object.keys(labels[ELocation.TopRight]).map(key => {
            const label = labels[ELocation.TopRight][key];
            return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<div class=${"ff-label " + label.className || false}>${label.text}</div>`;
        })}</div>
        </div><div class="ff-row">
            <div class="ff-labels ff-bottom-left">${Object.keys(labels[ELocation.BottomLeft]).map(key => {
            const label = labels[ELocation.BottomLeft][key];
            return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<div class=${"ff-label " + label.className || false}>${label.text}</div>`;
        })}</div>
            <div class="ff-labels ff-bottom-center">${Object.keys(labels[ELocation.BottomCenter]).map(key => {
            const label = labels[ELocation.BottomCenter][key];
            return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<div class=${"ff-label " + label.className || false}>${label.text}</div>`;
        })}</div>
            <div class="ff-labels ff-bottom-right">${Object.keys(labels[ELocation.BottomRight]).map(key => {
            const label = labels[ELocation.BottomRight][key];
            return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<div class=${"ff-label " + label.className || false}>${label.text}</div>`;
        })}</div>
        </div>`;
    }
};
ViewportOverlay = __decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["customElement"])("ff-viewport-overlay")
], ViewportOverlay);
/* harmony default export */ __webpack_exports__["default"] = (ViewportOverlay);


/***/ }),

/***/ "../../libs/ff-ui/source/Button.ts":
/*!*********************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-ui/source/Button.ts ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Icon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Icon */ "../../libs/ff-ui/source/Icon.ts");
/* harmony import */ var _CustomElement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


/**
 * Custom element displaying a button with a text and/or an icon.
 * The button emits a [[IButtonClickEvent]] if clicked.
 * Classes assigned: "ff-button", "ff-control".
 */
let Button = class Button extends _CustomElement__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super();
        /** Optional name to identify the button. */
        this.name = "";
        /** Optional index to identify the button. */
        this.index = 0;
        this.selectedIndex = -1;
        /** If true, adds "ff-selected" class to element. */
        this.selected = false;
        /** If true, toggles selected state every time the button is clicked. */
        this.selectable = false;
        this.disabled = false;
        /** Optional name of the icon to be displayed on the button. */
        this.icon = "";
        /** If true, displays a downward facing triangle at the right side. */
        this.caret = false;
        this.inline = false;
        this.transparent = false;
        this.addEventListener("click", (e) => this.onClick(e));
        this.addEventListener("keydown", (e) => this.onKeyDown(e));
    }
    firstConnected() {
        this.tabIndex = 0;
        this.classList.add("ff-button");
    }
    shouldUpdate(changedProperties) {
        if (changedProperties.has("selectedIndex") || changedProperties.has("index")) {
            if (this.selectedIndex >= 0) {
                this.selected = this.index === this.selectedIndex;
            }
        }
        if (changedProperties.has("disabled")) {
            this.setClass("ff-disabled", this.disabled);
        }
        return true;
    }
    update(changedProperties) {
        this.classList.remove("ff-inline", "ff-transparent", "ff-control");
        if (this.inline) {
            this.classList.add("ff-inline");
        }
        else if (this.transparent) {
            this.classList.add("ff-transparent");
        }
        else {
            this.classList.add("ff-control");
        }
        super.update(changedProperties);
    }
    render() {
        return _CustomElement__WEBPACK_IMPORTED_MODULE_1__["html"] `${this.renderIcon()}${this.renderText()}${this.renderCaret()}`;
    }
    renderIcon() {
        return this.icon ? _CustomElement__WEBPACK_IMPORTED_MODULE_1__["html"] `<ff-icon class="ff-off" name=${this.icon}></ff-icon>` : null;
    }
    renderText() {
        return this.text ? _CustomElement__WEBPACK_IMPORTED_MODULE_1__["html"] `<div class="ff-text ff-off">${this.text}</div>` : null;
    }
    renderCaret() {
        return this.caret ? _CustomElement__WEBPACK_IMPORTED_MODULE_1__["html"] `<div class="ff-caret-down ff-off"></div>` : null;
    }
    onClick(event) {
        if (this.selectable) {
            this.selected = !this.selected;
        }
    }
    onKeyDown(event) {
        if (document.activeElement === this && (event.code === "Space" || event.code === "Enter")) {
            this.dispatchEvent(new MouseEvent("click", { bubbles: true }));
        }
    }
};
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])({ type: String })
], Button.prototype, "name", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])({ type: Number })
], Button.prototype, "index", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])({ type: Number })
], Button.prototype, "selectedIndex", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])({ type: Boolean, reflect: true })
], Button.prototype, "selected", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])({ type: Boolean })
], Button.prototype, "selectable", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])({ type: Boolean })
], Button.prototype, "disabled", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])()
], Button.prototype, "text", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])()
], Button.prototype, "icon", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])({ type: Boolean })
], Button.prototype, "caret", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])({ type: Boolean })
], Button.prototype, "inline", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])({ type: Boolean })
], Button.prototype, "transparent", void 0);
Button = __decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["customElement"])("ff-button")
], Button);
/* harmony default export */ __webpack_exports__["default"] = (Button);


/***/ }),

/***/ "../../libs/ff-ui/source/ButtonGroup.ts":
/*!**************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-ui/source/ButtonGroup.ts ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CustomElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/* harmony import */ var _Button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Button */ "../../libs/ff-ui/source/Button.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


let ButtonGroup = class ButtonGroup extends _CustomElement__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
        this.mode = "radio";
        this.selectionIndex = -1;
        this.observer = new MutationObserver(this.onObserver);
        this.selectedButton = null;
        this.addEventListener("click", (e) => this.onClick(e));
    }
    firstConnected() {
        this.classList.add("ff-button-group");
        this.parseChildren();
    }
    connected() {
        this.observer.observe(this, { childList: true });
    }
    disconnected() {
        this.observer.disconnect();
    }
    onObserver(mutations) {
        mutations.forEach(mutation => {
            if (mutation.type === "childList") {
                this.parseChildren();
            }
        });
    }
    onClick(event) {
        let target = event.target;
        while (target && target !== this && !(target instanceof _Button__WEBPACK_IMPORTED_MODULE_1__["default"])) {
            target = target.parentElement;
        }
        if (!(target instanceof _Button__WEBPACK_IMPORTED_MODULE_1__["default"])) {
            return;
        }
        if (target.selected) {
            if (this.mode === "exclusive") {
                target.selected = false;
                this.selectedButton = null;
                this.selectionIndex = -1;
            }
        }
        else {
            if (this.selectedButton) {
                this.selectedButton.selected = false;
            }
            this.selectedButton = target;
            this.selectedButton.selected = true;
            this.selectionIndex = this.getButtons().indexOf(target);
        }
    }
    parseChildren() {
        const buttons = this.getButtons();
        if (this.selectedButton) {
            this.selectionIndex = buttons.indexOf(this.selectedButton);
            if (this.selectionIndex < 0) {
                this.selectedButton.selected = false;
                this.selectedButton = null;
            }
        }
        if (this.selectionIndex < 0 || this.selectionIndex >= buttons.length) {
            this.selectionIndex = this.mode === "radio" ? 0 : -1;
        }
        if (this.selectionIndex >= 0) {
            this.selectedButton = buttons[this.selectionIndex];
            this.selectedButton.selected = true;
        }
    }
    getButtons() {
        return this.getChildrenArray().filter(child => child instanceof _Button__WEBPACK_IMPORTED_MODULE_1__["default"]);
    }
};
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: String })
], ButtonGroup.prototype, "mode", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: Number })
], ButtonGroup.prototype, "selectionIndex", void 0);
ButtonGroup = __decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["customElement"])("ff-button-group")
], ButtonGroup);
/* harmony default export */ __webpack_exports__["default"] = (ButtonGroup);


/***/ }),

/***/ "../../libs/ff-ui/source/ColorEdit.ts":
/*!************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-ui/source/ColorEdit.ts ***!
  \************************************************************/
/*! exports provided: Color, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_core_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/math */ "../../libs/ff-core/source/math.ts");
/* harmony import */ var _ff_core_Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/core/Color */ "../../libs/ff-core/source/Color.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return _ff_core_Color__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _LineEdit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LineEdit */ "../../libs/ff-ui/source/LineEdit.ts");
/* harmony import */ var _LinearSlider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LinearSlider */ "../../libs/ff-ui/source/LinearSlider.ts");
/* harmony import */ var _VectorSlider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./VectorSlider */ "../../libs/ff-ui/source/VectorSlider.ts");
/* harmony import */ var _CustomElement__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






////////////////////////////////////////////////////////////////////////////////
const _hueColor = new _ff_core_Color__WEBPACK_IMPORTED_MODULE_1__["default"]();

let ColorEdit = class ColorEdit extends _CustomElement__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor() {
        super();
        this.color = new _ff_core_Color__WEBPACK_IMPORTED_MODULE_1__["default"]();
        this.alpha = false;
        this.numeric = false;
        this.onLumSatChange = this.onLumSatChange.bind(this);
        this.onHueChange = this.onHueChange.bind(this);
        this.onAlphaChange = this.onAlphaChange.bind(this);
        this.addEventListener("click", e => e.stopPropagation());
        this._hsv = new _ff_core_Color__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
        this._lumSatSlider = new _VectorSlider__WEBPACK_IMPORTED_MODULE_4__["default"]().on("change", this.onLumSatChange);
        this._hueSlider = new _LinearSlider__WEBPACK_IMPORTED_MODULE_3__["default"]().addClass("ff-hue-slider").on("change", this.onHueChange);
        this._hueSlider.direction = "vertical";
    }
    firstConnected() {
        this.classList.add("ff-flex-column", "ff-control", "ff-color-edit");
    }
    update(changedProperties) {
        if (changedProperties.has("color")) {
            this.color.toHSV(this._hsv);
        }
        if (changedProperties.has("alpha")) {
            if (this.alpha && !this._alphaSlider) {
                this._alphaSlider = new _LinearSlider__WEBPACK_IMPORTED_MODULE_3__["default"]().addClass("ff-alpha-slider").on("change", this.onAlphaChange);
                this._alphaSlider.direction = "vertical";
            }
            else if (!this.alpha && this._alphaSlider) {
                this._alphaSlider.remove();
            }
        }
        super.update(changedProperties);
    }
    render() {
        let numericControls = null;
        if (this.numeric) {
            const color = this.color;
            const hex = color.toString(false).substr(1);
            const alphaControl = this.alpha ? _CustomElement__WEBPACK_IMPORTED_MODULE_5__["html"] `
                <div class="ff-text">A</div><ff-line-edit name="alphaByte" text=${color.alphaByte} align="center" @change=${this.onNumericEdit}></ff-line-edit>
            ` : null;
            numericControls = _CustomElement__WEBPACK_IMPORTED_MODULE_5__["html"] `<div class="ff-flex-row ff-numeric-controls">
                <div class="ff-text">R</div><ff-line-edit name="redByte" text=${color.redByte} align="center" @change=${this.onNumericEdit}></ff-line-edit>
                <div class="ff-text">G</div><ff-line-edit name="greenByte" text=${color.greenByte} align="center" @change=${this.onNumericEdit}></ff-line-edit>
                <div class="ff-text">B</div><ff-line-edit name="blueByte" text=${color.blueByte} align="center" @change=${this.onNumericEdit}></ff-line-edit>
                ${alphaControl}
                <div class="ff-text">#</div><ff-line-edit name="string" text=${hex} class="ff-wide" align="center" @change=${this.onNumericEdit}></ff-line-edit>
            </div>`;
        }
        return _CustomElement__WEBPACK_IMPORTED_MODULE_5__["html"] `<div class="ff-flex-row ff-slider-controls">
                ${this._lumSatSlider}${this._hueSlider}${this._alphaSlider}
            </div>${numericControls}`;
    }
    updated() {
        this._hueSlider.value = 1 - this._hsv.x / 360;
        const hue = _hueColor.setHSV(this._hsv.x).toString(false);
        const slGrad = `linear-gradient(to bottom, transparent, black), linear-gradient(to right, white, ${hue})`;
        this._lumSatSlider.style.backgroundImage = slGrad;
        this._lumSatSlider.setXY(this._hsv.y, this._hsv.z);
        if (this.alpha) {
            const color = this.color.toString(/* includeAlpha */ false);
            const fg = getComputedStyle(this._alphaSlider).color;
            const alphaGrad = `linear-gradient(to top, transparent, ${color}), repeating-linear-gradient(-45deg, transparent, transparent 8px, ${fg} 8px, ${fg} 16px)`;
            this._alphaSlider.style.backgroundImage = alphaGrad;
            this._alphaSlider.value = this.color.alpha;
        }
    }
    onLumSatChange(event) {
        event.stopPropagation();
        const value = event.detail.value;
        this._hsv.y = value.x;
        this._hsv.z = value.y;
        this.color.setHSV(this._hsv);
        this.requestUpdate();
        this.emitChangeEvent(event.detail.isDragging);
    }
    onHueChange(event) {
        event.stopPropagation();
        this._hsv.x = (1 - event.target.value) * 360;
        this.color.setHSV(this._hsv);
        this.requestUpdate();
        this.emitChangeEvent(event.detail.isDragging);
    }
    onAlphaChange(event) {
        event.stopPropagation();
        this.color.alpha = event.target.value;
        this.requestUpdate();
        this.emitChangeEvent(event.detail.isDragging);
    }
    onNumericEdit(event) {
        event.stopPropagation();
        const name = event.target.name;
        if (name === "string") {
            this.color.setString(event.detail.text, 1, false);
        }
        else {
            let value = parseInt(event.detail.text);
            if (!isFinite(value)) {
                return;
            }
            this.color[name] = _ff_core_math__WEBPACK_IMPORTED_MODULE_0__["default"].limit(value, 0, 255);
        }
        this.color.toHSV(this._hsv);
        this.requestUpdate();
        this.emitChangeEvent(event.detail.isEditing);
    }
    emitChangeEvent(isDragging) {
        this.dispatchEvent(new CustomEvent("change", {
            detail: {
                color: this.color,
                isDragging
            },
            bubbles: true
        }));
    }
};
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_5__["property"])({ attribute: false })
], ColorEdit.prototype, "color", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_5__["property"])({ type: Boolean })
], ColorEdit.prototype, "alpha", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_5__["property"])({ type: Boolean })
], ColorEdit.prototype, "numeric", void 0);
ColorEdit = __decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_5__["customElement"])("ff-color-edit")
], ColorEdit);
/* harmony default export */ __webpack_exports__["default"] = (ColorEdit);


/***/ }),

/***/ "../../libs/ff-ui/source/CustomElement.ts":
/*!****************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-ui/source/CustomElement.ts ***!
  \****************************************************************/
/*! exports provided: property, html, svg, render, TemplateResult, repeat, default, customElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "customElement", function() { return customElement; });
/* harmony import */ var lit_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-element */ "../../node_modules/lit-element/lit-element.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "property", function() { return lit_element__WEBPACK_IMPORTED_MODULE_0__["property"]; });

/* harmony import */ var lit_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit-html */ "../../node_modules/lit-html/lit-html.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "html", function() { return lit_html__WEBPACK_IMPORTED_MODULE_1__["html"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "svg", function() { return lit_html__WEBPACK_IMPORTED_MODULE_1__["svg"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return lit_html__WEBPACK_IMPORTED_MODULE_1__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TemplateResult", function() { return lit_html__WEBPACK_IMPORTED_MODULE_1__["TemplateResult"]; });

/* harmony import */ var lit_html_directives_repeat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit-html/directives/repeat */ "../../node_modules/lit-html/directives/repeat.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "repeat", function() { return lit_html_directives_repeat__WEBPACK_IMPORTED_MODULE_2__["repeat"]; });

/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CustomElement_1;

////////////////////////////////////////////////////////////////////////////////



let CustomElement = CustomElement_1 = class CustomElement extends lit_element__WEBPACK_IMPORTED_MODULE_0__["LitElement"] {
    constructor() {
        super(...arguments);
        this._isFirstConnected = false;
    }
    static setStyle(element, style) {
        Object.assign(element.style, style);
    }
    static setAttribs(element, attribs) {
        for (let name in attribs) {
            element.setAttribute(name, attribs[name]);
        }
    }
    get shady() {
        return this.constructor.shady;
    }
    appendTo(parent) {
        parent.appendChild(this);
        return this;
    }
    removeChildren() {
        while (this.firstChild) {
            this.removeChild(this.firstChild);
        }
    }
    getChildrenArray() {
        return Array.from(this.children);
    }
    appendElement(tagOrType, style) {
        return this.createElement(tagOrType, style, this);
    }
    createElement(tagOrType, style, parent) {
        let element;
        if (typeof tagOrType === "string") {
            element = document.createElement(tagOrType);
        }
        else if (tagOrType instanceof HTMLElement) {
            element = tagOrType;
        }
        else {
            element = new tagOrType();
        }
        if (style) {
            Object.assign(element.style, style);
        }
        if (parent) {
            parent.appendChild(element);
        }
        return element;
    }
    setStyle(style) {
        CustomElement_1.setStyle(this, style);
        return this;
    }
    setAttribute(name, value) {
        super.setAttribute(name, value);
        return this;
    }
    setAttributes(attribs) {
        CustomElement_1.setAttribs(this, attribs);
        return this;
    }
    addClass(...classes) {
        classes.forEach(klass => this.classList.add(klass));
        return this;
    }
    removeClass(...classes) {
        classes.forEach(klass => this.classList.remove(klass));
        return this;
    }
    setClass(name, state) {
        if (state) {
            this.classList.add(name);
        }
        else {
            this.classList.remove(name);
        }
        return this;
    }
    hasFocus() {
        return document.activeElement === this;
    }
    on(type, listener, options) {
        this.addEventListener(type, listener, options);
        return this;
    }
    off(type, listener, options) {
        this.removeEventListener(type, listener, options);
        return this;
    }
    connectedCallback() {
        if (!this._isFirstConnected) {
            this._isFirstConnected = true;
            this.firstConnected();
        }
        this.connected();
        super.connectedCallback();
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this.disconnected();
    }
    createRenderRoot() {
        return this.shady ? super.createRenderRoot() : this;
    }
    firstConnected() {
    }
    connected() {
    }
    disconnected() {
    }
    onUpdate() {
        this.requestUpdate();
    }
};
CustomElement.tagName = "ff-custom-element";
CustomElement.shady = false;
CustomElement = CustomElement_1 = __decorate([
    customElement("ff-custom-element")
], CustomElement);
/* harmony default export */ __webpack_exports__["default"] = (CustomElement);
function customElement(tagName) {
    return (constructor) => {
        constructor.tagName = tagName;
        customElements.define(constructor.tagName, constructor);
        return constructor;
    };
}


/***/ }),

/***/ "../../libs/ff-ui/source/DragHelper.ts":
/*!*************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-ui/source/DragHelper.ts ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DragHelper; });
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
class DragHelper {
    constructor(target) {
        this.isEnabled = true;
        this._isDragging = false;
        this._startX = 0;
        this._startY = 0;
        this._lastX = 0;
        this._lastY = 0;
        this.target = target;
        this.onPointerDown = this.onPointerDown.bind(this);
        this.onPointerMove = this.onPointerMove.bind(this);
        this.onPointerUp = this.onPointerUp.bind(this);
        target.addEventListener("pointerdown", this.onPointerDown);
        target.addEventListener("pointermove", this.onPointerMove);
        target.addEventListener("pointerup", this.onPointerUp);
        target.addEventListener("pointercancel", this.onPointerUp);
    }
    get isDragging() {
        return this._isDragging;
    }
    get startX() {
        return this._startX;
    }
    get startY() {
        return this._startY;
    }
    onPointerDown(event) {
        if (event.isPrimary && this.isEnabled) {
            this._isDragging = true;
            this._startX = this._lastX = event.clientX;
            this._startY = this._lastY = event.clientY;
            this.target.setPointerCapture(event.pointerId);
            this.target.dragStart(event);
        }
        event.stopPropagation();
        event.preventDefault();
    }
    onPointerMove(event) {
        if (event.isPrimary && this._isDragging) {
            const dx = event.clientX - this._lastX;
            this._lastX = event.clientX;
            const dy = event.clientY - this._lastY;
            this._lastY = event.clientY;
            this.target.dragMove(event, dx, dy);
        }
        event.stopPropagation();
        event.preventDefault();
    }
    onPointerUp(event) {
        if (this._isDragging && event.isPrimary) {
            this.target.dragEnd(event);
            this.target.releasePointerCapture(event.pointerId);
            this._isDragging = false;
        }
        event.stopPropagation();
        event.preventDefault();
    }
}


/***/ }),

/***/ "../../libs/ff-ui/source/Icon.ts":
/*!*******************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-ui/source/Icon.ts ***!
  \*******************************************************/
/*! exports provided: html, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CustomElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "html", function() { return _CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"]; });

/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Icon_1;

////////////////////////////////////////////////////////////////////////////////

let Icon = Icon_1 = class Icon extends _CustomElement__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(name) {
        super();
        this.template = null;
        this.name = name || "";
    }
    static add(name, template) {
        if (Icon_1.templates[name]) {
            throw new Error(`icon already registered: '${name}'`);
        }
        Icon_1.templates[name] = template;
    }
    static getTemplateNames() {
        return Object.keys(Icon_1.templates);
    }
    firstConnected() {
        this.classList.add("ff-icon");
    }
    render() {
        if (this.name) {
            const template = this.constructor.templates[this.name];
            if (!template) {
                console.warn(`icon not found: '${this.name}'`);
            }
            return template;
        }
        if (this.template) {
            return this.template;
        }
        return _CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `[icon undefined]`;
    }
};
Icon.templates = {};
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ attribute: false })
], Icon.prototype, "template", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: String })
], Icon.prototype, "name", void 0);
Icon = Icon_1 = __decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["customElement"])("ff-icon")
], Icon);
/* harmony default export */ __webpack_exports__["default"] = (Icon);
////////////////////////////////////////////////////////////////////////////////
// PREDEFINED ICONS
Icon.add("empty", _CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] ``);
Icon.add("check", _CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"/></svg>`);
Icon.add("close", _CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"/></svg>`);
Icon.add("grip", _CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M149.333 56v80c0 13.255-10.745 24-24 24H24c-13.255 0-24-10.745-24-24V56c0-13.255 10.745-24 24-24h101.333c13.255 0 24 10.745 24 24zm181.334 240v-80c0-13.255-10.745-24-24-24H205.333c-13.255 0-24 10.745-24 24v80c0 13.255 10.745 24 24 24h101.333c13.256 0 24.001-10.745 24.001-24zm32-240v80c0 13.255 10.745 24 24 24H488c13.255 0 24-10.745 24-24V56c0-13.255-10.745-24-24-24H386.667c-13.255 0-24 10.745-24 24zm-32 80V56c0-13.255-10.745-24-24-24H205.333c-13.255 0-24 10.745-24 24v80c0 13.255 10.745 24 24 24h101.333c13.256 0 24.001-10.745 24.001-24zm-205.334 56H24c-13.255 0-24 10.745-24 24v80c0 13.255 10.745 24 24 24h101.333c13.255 0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24zM0 376v80c0 13.255 10.745 24 24 24h101.333c13.255 0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H24c-13.255 0-24 10.745-24 24zm386.667-56H488c13.255 0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H386.667c-13.255 0-24 10.745-24 24v80c0 13.255 10.745 24 24 24zm0 160H488c13.255 0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H386.667c-13.255 0-24 10.745-24 24v80c0 13.255 10.745 24 24 24zM181.333 376v80c0 13.255 10.745 24 24 24h101.333c13.255 0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H205.333c-13.255 0-24 10.745-24 24z"/></svg>`);
Icon.add("up", _CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6 0-33.9L207 39c9.4-9.4 24.6-9.4 33.9 0l194.3 194.3c9.4 9.4 9.4 24.6 0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3 0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg>`);
Icon.add("down", _CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M413.1 222.5l22.2 22.2c9.4 9.4 9.4 24.6 0 33.9L241 473c-9.4 9.4-24.6 9.4-33.9 0L12.7 278.6c-9.4-9.4-9.4-24.6 0-33.9l22.2-22.2c9.5-9.5 25-9.3 34.3.4L184 343.4V56c0-13.3 10.7-24 24-24h32c13.3 0 24 10.7 24 24v287.4l114.8-120.5c9.3-9.8 24.8-10 34.3-.4z"/></svg>`);
Icon.add("caret-up", _CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path d="M288.662 352H31.338c-17.818 0-26.741-21.543-14.142-34.142l128.662-128.662c7.81-7.81 20.474-7.81 28.284 0l128.662 128.662c12.6 12.599 3.676 34.142-14.142 34.142z"/></svg>`);
Icon.add("caret-down", _CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path d="M31.3 192h257.3c17.8 0 26.7 21.5 14.1 34.1L174.1 354.8c-7.8 7.8-20.5 7.8-28.3 0L17.2 226.1C4.6 213.5 13.5 192 31.3 192z"/></svg>`);
Icon.add("folder", _CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M464 128H272l-64-64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V176c0-26.51-21.49-48-48-48z"/></svg>`);
Icon.add("file", _CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path d="M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zM332.1 128H256V51.9l76.1 76.1zM48 464V48h160v104c0 13.3 10.7 24 24 24h104v288H48z"/></svg>`);
Icon.add("info", _CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/></svg>`);
Icon.add("warning", _CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></svg>`);
Icon.add("error", _CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z"/></svg>`);
Icon.add("prompt", _CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zM262.655 90c-54.497 0-89.255 22.957-116.549 63.758-3.536 5.286-2.353 12.415 2.715 16.258l34.699 26.31c5.205 3.947 12.621 3.008 16.665-2.122 17.864-22.658 30.113-35.797 57.303-35.797 20.429 0 45.698 13.148 45.698 32.958 0 14.976-12.363 22.667-32.534 33.976C247.128 238.528 216 254.941 216 296v4c0 6.627 5.373 12 12 12h56c6.627 0 12-5.373 12-12v-1.333c0-28.462 83.186-29.647 83.186-106.667 0-58.002-60.165-102-116.531-102zM256 338c-25.365 0-46 20.635-46 46 0 25.364 20.635 46 46 46s46-20.636 46-46c0-25.365-20.635-46-46-46z"/></svg>`);


/***/ }),

/***/ "../../libs/ff-ui/source/LineEdit.ts":
/*!***********************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-ui/source/LineEdit.ts ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CustomElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * Custom element displaying a single line text edit.
 *
 * ### Events
 * - *"change"* - [[ILineEditChangeEvent]] emitted when the control's text is edited.
 */
let LineEdit = class LineEdit extends _CustomElement__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        /** Optional name to identify the button. */
        this.name = "";
        /** Optional index to identify the button. */
        this.index = 0;
        /** Text to be edited in the control. */
        this.text = "";
        /** Placeholder text to display if no other text is present. */
        this.placeholder = "";
        this.align = "left";
        this.initialValue = "";
        this.requestFocus = false;
    }
    get inputElement() {
        return this.getElementsByTagName("input").item(0);
    }
    focus() {
        this.requestFocus = true;
        this.performUpdate();
    }
    hasFocus() {
        return this.inputElement === document.activeElement;
    }
    firstConnected() {
        this.classList.add("ff-control", "ff-line-edit");
    }
    shouldUpdate(changedProperties) {
        // prevent rendering during editing
        if (this.hasFocus()) {
            return false;
        }
        return super.shouldUpdate(changedProperties);
    }
    render() {
        return _CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<input
            type="text" .value=${this.text} placeholder=${this.placeholder}
            @keydown=${this.onKeyDown} @change=${this.onChange} @input=${this.onInput}
            @focus=${this.onFocus} @blur=${this.onBlur}
            style="box-sizing: border-box; width:100%; text-align: ${this.align};">`;
    }
    updated() {
        if (this.requestFocus) {
            this.requestFocus = false;
            this.inputElement.focus();
        }
    }
    onKeyDown(event) {
        const target = event.target;
        if (event.key === "Enter") {
            this.commit(target);
            target.blur();
        }
        else if (event.key === "Escape") {
            this.revert(target);
            target.blur();
        }
    }
    onChange(event) {
        event.stopPropagation();
        event.preventDefault();
        this.text = event.target.value;
        this.dispatchChangeEvent(this.text, false);
    }
    onInput(event) {
        event.stopPropagation();
        event.preventDefault();
        this.text = event.target.value;
        this.dispatchChangeEvent(this.text, true);
    }
    onFocus(event) {
        this.initialValue = event.target.value;
        event.target.select();
    }
    onBlur(event) {
        this.commit(event.target);
        this.requestUpdate();
    }
    revert(element) {
        element.value = this.initialValue;
        this.dispatchChangeEvent(element.value, false);
    }
    commit(element) {
        this.initialValue = element.value;
        this.dispatchChangeEvent(element.value, false);
    }
    dispatchChangeEvent(text, isEditing) {
        this.dispatchEvent(new CustomEvent("change", {
            detail: {
                text,
                isEditing
            }
        }));
    }
};
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: String })
], LineEdit.prototype, "name", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: Number })
], LineEdit.prototype, "index", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: String })
], LineEdit.prototype, "text", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: String })
], LineEdit.prototype, "placeholder", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: String })
], LineEdit.prototype, "align", void 0);
LineEdit = __decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["customElement"])("ff-line-edit")
], LineEdit);
/* harmony default export */ __webpack_exports__["default"] = (LineEdit);


/***/ }),

/***/ "../../libs/ff-ui/source/LinearSlider.ts":
/*!***************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-ui/source/LinearSlider.ts ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_core_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/math */ "../../libs/ff-core/source/math.ts");
/* harmony import */ var _CustomElement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/* harmony import */ var _DragHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DragHelper */ "../../libs/ff-ui/source/DragHelper.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



let LinearSlider = class LinearSlider extends _CustomElement__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super();
        this.direction = "horizontal";
        this.value = 0;
        this._isVertical = false;
        this._offsetX = 0;
        this._offsetY = 0;
        this._knob = new _CustomElement__WEBPACK_IMPORTED_MODULE_1__["default"]()
            .addClass("ff-knob")
            .setStyle({ display: "block", position: "relative " });
        new _DragHelper__WEBPACK_IMPORTED_MODULE_2__["default"](this);
    }
    dragStart(event) {
        const knob = this._knob;
        const track = this.getBoundingClientRect();
        if (event.target === this._knob) {
            this._offsetX = event.clientX - knob.offsetLeft + (knob.clientWidth - knob.offsetWidth) * 0.5;
            this._offsetY = event.clientY - knob.offsetTop + (knob.clientHeight - knob.offsetHeight) * 0.5;
        }
        else {
            this._offsetX = track.left + knob.clientWidth * 0.8;
            this._offsetY = track.top + knob.clientHeight * 0.8;
        }
        this.dragMove(event);
    }
    dragMove(event) {
        const knob = this._knob;
        const px = event.clientX - this._offsetX;
        const py = event.clientY - this._offsetY;
        let v = this._isVertical
            ? 1 - py / (this.clientHeight - knob.clientHeight)
            : px / (this.clientWidth - knob.clientWidth);
        v = _ff_core_math__WEBPACK_IMPORTED_MODULE_0__["default"].limit(v, 0, 1);
        if (v !== this.value) {
            this.value = v;
            this.emitChangeEvent(true);
        }
    }
    dragEnd() {
        this.emitChangeEvent(false);
    }
    firstConnected() {
        this.setStyle({
            position: "relative",
            touchAction: "none"
        });
        this.setAttribute("touch-action", "none");
        this.setAttribute("tabindex", "0");
        this.classList.add("ff-control", "ff-linear-slider");
        this.appendChild(this._knob);
    }
    update(changedProperties) {
        if (changedProperties.has("direction")) {
            this._isVertical = this.direction === "vertical";
            this.setClass("ff-horizontal", !this._isVertical);
            this.setClass("ff-vertical", this._isVertical);
        }
        if (changedProperties.has("value")) {
            const value = _ff_core_math__WEBPACK_IMPORTED_MODULE_0__["default"].limit(this.value, 0, 1);
            const x = this._isVertical ? 0 : value * 100;
            const y = this._isVertical ? (1 - value) * 100 : 0;
            this._knob.style.left = `${x.toFixed(3)}%`;
            this._knob.style.top = `${y.toFixed(3)}%`;
        }
        super.update(changedProperties);
    }
    emitChangeEvent(isDragging) {
        this.dispatchEvent(new CustomEvent("change", {
            detail: {
                value: this.value,
                isDragging
            },
            bubbles: true
        }));
    }
};
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])({ type: String })
], LinearSlider.prototype, "direction", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])({ type: Number })
], LinearSlider.prototype, "value", void 0);
LinearSlider = __decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["customElement"])("ff-linear-slider")
], LinearSlider);
/* harmony default export */ __webpack_exports__["default"] = (LinearSlider);


/***/ }),

/***/ "../../libs/ff-ui/source/Notification.ts":
/*!***************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-ui/source/Notification.ts ***!
  \***************************************************************/
/*! exports provided: default, info, success, warning, error */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "info", function() { return info; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "success", function() { return success; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "warning", function() { return warning; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "error", function() { return error; });
/* harmony import */ var _Icon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Icon */ "../../libs/ff-ui/source/Icon.ts");
/* harmony import */ var _CustomElement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Notification_1;


const _levelClasses = {
    "info": "ff-info",
    "success": "ff-success",
    "warning": "ff-warning",
    "error": "ff-error"
};
const _levelIcons = {
    "info": "info",
    "success": "check",
    "warning": "warning",
    "error": "error"
};
const _levelTimeouts = {
    "info": 2000,
    "success": 2000,
    "warning": 5000,
    "error": 0
};
let Notification = Notification_1 = class Notification extends _CustomElement__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(message, level, timeout) {
        super();
        this._handler = 0;
        this.on("transitionend", this.remove.bind(this));
        this.message = message || "<messge>";
        this.level = level || "info";
        this.timeout = timeout !== undefined ? timeout : _levelTimeouts[this.level];
        const root = Notification_1.shadowRootNode || document;
        const stack = root.getElementById(Notification_1.stackId);
        if (stack) {
            stack.appendChild(this);
        }
        else {
            console.warn(`element '#${Notification_1.stackId}' not found`);
        }
    }
    static show(message, level, timeout) {
        new Notification_1(message, level, timeout);
    }
    close() {
        if (this._handler > 0) {
            window.clearTimeout(this._handler);
            this._handler = 0;
        }
        this.classList.add("ff-out");
    }
    firstUpdated() {
        this.classList.add("ff-notification", _levelClasses[this.level]);
        if (this.timeout > 0) {
            this._handler = window.setTimeout(() => this.close(), this.timeout);
        }
    }
    render() {
        const icon = _levelIcons[this.level];
        return _CustomElement__WEBPACK_IMPORTED_MODULE_1__["html"] `<ff-icon name=${icon}></ff-icon>
            <div class="ff-text">${this.message}</div>
            <ff-button inline icon="close" @click=${this.onClose}>`;
    }
    onClose(event) {
        event.stopPropagation();
        this.close();
    }
};
Notification.stackId = "ff-notification-stack";
Notification.shadowRootNode = null;
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])({ type: String })
], Notification.prototype, "message", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])({ type: String })
], Notification.prototype, "level", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])({ type: Number })
], Notification.prototype, "timeout", void 0);
Notification = Notification_1 = __decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["customElement"])("ff-notification")
], Notification);
/* harmony default export */ __webpack_exports__["default"] = (Notification);
const info = (message, timeout) => new Notification(message, "info", timeout);
const success = (message, timeout) => new Notification(message, "success", timeout);
const warning = (message, timeout) => new Notification(message, "warning", timeout);
const error = (message, timeout) => new Notification(message, "error", timeout);


/***/ }),

/***/ "../../libs/ff-ui/source/Popup.ts":
/*!********************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-ui/source/Popup.ts ***!
  \********************************************************/
/*! exports provided: customElement, property, html, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CustomElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "customElement", function() { return _CustomElement__WEBPACK_IMPORTED_MODULE_0__["customElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "property", function() { return _CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "html", function() { return _CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"]; });

/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

////////////////////////////////////////////////////////////////////////////////

let Popup = class Popup extends _CustomElement__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
        this.anchor = null;
        this.portal = null;
        this.position = undefined;
        this.align = undefined;
        this.justify = undefined;
        this.positionX = 0;
        this.positionY = 0;
        this.offsetX = 0;
        this.offsetY = 0;
        this.keepVisible = false;
        this.modal = false;
        this._modalPlane = null;
        this.onResize = this.onResize.bind(this);
        this.onCaptureEvent = this.onCaptureEvent.bind(this);
        this.onEatEvent = this.onEatEvent.bind(this);
    }
    close() {
        this.dispatchEvent(new CustomEvent("close"));
    }
    connected() {
        this.calculatePosition();
        window.addEventListener("resize", this.onResize);
        if (this.modal) {
            const modalPlane = this._modalPlane = this.createElement("div");
            modalPlane.classList.add("ff-modal-plane");
            modalPlane.addEventListener("mousedown", this.onEatEvent);
            modalPlane.addEventListener("contextmenu", this.onEatEvent);
            modalPlane.addEventListener("pointerdown", this.onEatEvent);
            this.parentElement.appendChild(modalPlane);
            setTimeout(() => modalPlane.classList.add("ff-transition"));
        }
        else {
            document.addEventListener("mousedown", this.onCaptureEvent, { capture: true, passive: true });
        }
    }
    disconnected() {
        window.removeEventListener("resize", this.onResize);
        if (this._modalPlane) {
            this._modalPlane.remove();
            this._modalPlane = null;
        }
        else {
            document.removeEventListener("mousedown", this.onCaptureEvent);
        }
    }
    firstConnected() {
        super.firstConnected();
        this.setStyle({
            position: "fixed",
            zIndex: "1000"
        });
        this.classList.add("ff-popup");
    }
    updated() {
        if (this.isConnected) {
            this.calculatePosition();
        }
    }
    calculatePosition() {
        let anchorRect, portalRect;
        const thisRect = this.getBoundingClientRect();
        if (this.portal) {
            portalRect = this.portal.getBoundingClientRect();
        }
        else {
            portalRect = {
                left: 0,
                top: 0,
                right: window.innerWidth,
                bottom: window.innerHeight,
                width: window.innerWidth,
                height: window.innerHeight
            };
        }
        let position;
        if (this.position === "center") {
            position = this.center(thisRect, portalRect);
        }
        else if (this.position === "anchor") {
            const anchor = this.anchor || this.parentElement;
            if (anchor) {
                anchorRect = anchor.getBoundingClientRect();
                position = this.positionToAnchor(thisRect, anchorRect, portalRect);
            }
        }
        else {
            position = { x: this.positionX, y: this.positionY };
        }
        if (this.keepVisible && this.position !== "center") {
            position = this.keepElementVisible(position, thisRect, portalRect);
        }
        this.style.left = Math.round(position.x) + "px";
        this.style.top = Math.round(position.y) + "px";
    }
    center(thisRect, portalRect) {
        return {
            x: Math.round((portalRect.width - thisRect.width) * 0.5),
            y: Math.round((portalRect.height - thisRect.height) * 0.5)
        };
    }
    positionToAnchor(thisRect, anchorRect, portalRect) {
        const align = this.align;
        const justify = this.justify;
        const offsetX = this.offsetX;
        const offsetY = this.offsetY;
        const position = { x: 0, y: 0 };
        switch (align) {
            case "start":
                position.x = justify !== "start" && justify !== "end"
                    ? anchorRect.left - thisRect.width - offsetX
                    : anchorRect.left;
                break;
            case "end":
                position.x = justify !== "start" && justify !== "end"
                    ? anchorRect.right + offsetX
                    : anchorRect.right - thisRect.width;
                break;
            case "fixed":
                position.x = this.positionX;
                break;
            default:
                position.x = anchorRect.left + (anchorRect.width - thisRect.width) * 0.5;
                break;
        }
        switch (justify) {
            case "start":
                position.y = anchorRect.top - thisRect.height - offsetY;
                break;
            case "end":
                position.y = anchorRect.bottom + offsetY;
                break;
            case "fixed":
                position.y = this.positionY;
                break;
            default:
                position.y = anchorRect.top + (anchorRect.height - thisRect.height) * 0.5;
                break;
        }
        position.x += this.offsetX;
        position.y += this.offsetY;
        return position;
    }
    keepElementVisible(position, thisRect, portalRect) {
        const offsetX = this.offsetX;
        const offsetY = this.offsetY;
        if (thisRect.width > portalRect.width) {
            position.x = (portalRect.width - thisRect.width) * 0.5;
        }
        else if (position.x < portalRect.left + offsetX) {
            position.x = portalRect.left + offsetX;
        }
        else if (position.x + thisRect.width + offsetX > portalRect.right) {
            position.x = portalRect.right - thisRect.width - offsetX;
        }
        if (thisRect.height > portalRect.height) {
            position.y = (portalRect.height - thisRect.height) * 0.5;
        }
        else if (position.y < portalRect.top + offsetY) {
            position.y = portalRect.top + offsetY;
        }
        else if (position.y + thisRect.height + offsetY > portalRect.bottom) {
            position.y = portalRect.bottom - thisRect.height - offsetY;
        }
        return position;
    }
    onResize() {
        this.calculatePosition();
    }
    onCaptureEvent(event) {
        if (event.target instanceof Node && this.contains(event.target)) {
            return;
        }
        this.close();
    }
    onEatEvent(event) {
        console.log("Popup.onEatEvent");
        event.stopPropagation();
        event.preventDefault();
    }
};
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ attribute: false })
], Popup.prototype, "anchor", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ attribute: false })
], Popup.prototype, "portal", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: String })
], Popup.prototype, "position", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: String })
], Popup.prototype, "align", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: String })
], Popup.prototype, "justify", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: Number })
], Popup.prototype, "positionX", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: Number })
], Popup.prototype, "positionY", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: Number })
], Popup.prototype, "offsetX", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: Number })
], Popup.prototype, "offsetY", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: Boolean })
], Popup.prototype, "keepVisible", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: Boolean })
], Popup.prototype, "modal", void 0);
Popup = __decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["customElement"])("ff-popup")
], Popup);
/* harmony default export */ __webpack_exports__["default"] = (Popup);


/***/ }),

/***/ "../../libs/ff-ui/source/QuadSplitter.ts":
/*!***************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-ui/source/QuadSplitter.ts ***!
  \***************************************************************/
/*! exports provided: EQuadViewLayout, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EQuadViewLayout", function() { return EQuadViewLayout; });
/* harmony import */ var _Splitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Splitter */ "../../libs/ff-ui/source/Splitter.ts");
/* harmony import */ var _CustomElement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


////////////////////////////////////////////////////////////////////////////////
var EQuadViewLayout;
(function (EQuadViewLayout) {
    EQuadViewLayout[EQuadViewLayout["Single"] = 0] = "Single";
    EQuadViewLayout[EQuadViewLayout["HorizontalSplit"] = 1] = "HorizontalSplit";
    EQuadViewLayout[EQuadViewLayout["VerticalSplit"] = 2] = "VerticalSplit";
    EQuadViewLayout[EQuadViewLayout["Quad"] = 3] = "Quad";
})(EQuadViewLayout || (EQuadViewLayout = {}));
let QuadSplitter = class QuadSplitter extends _CustomElement__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(...arguments);
        this.layout = EQuadViewLayout.Single;
        this.horizontalPosition = 0.5;
        this.verticalPosition = 0.5;
    }
    firstConnected() {
        this.classList.add("ff-quad-splitter");
    }
    render() {
        const layout = this.layout;
        if (layout === EQuadViewLayout.Single) {
            return _CustomElement__WEBPACK_IMPORTED_MODULE_1__["html"] ``;
        }
        const elements = [];
        if (layout === EQuadViewLayout.HorizontalSplit || layout === EQuadViewLayout.Quad) {
            elements.push(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["html"] `
                <div class="ff-horizontal" style="position:absolute; top:0; bottom:0; left:0; right:0; display:flex;">
                    <div class="ff-left" style="flex:1 1;"></div>
                    <ff-splitter direction="horizontal" position=${this.horizontalPosition} @ff-splitter-change=${this.onSplitterChange}></ff-splitter>
                    <div style="flex:1 1;"></div>
                </div>
            `);
        }
        if (layout === EQuadViewLayout.VerticalSplit || layout === EQuadViewLayout.Quad) {
            elements.push(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["html"] `
                <div class="ff-vertical" style="position:absolute; top:0; bottom:0; left:0; right:0; display:flex; flex-direction: column">
                    <div class="ff-top" style="flex:1 1;"></div>
                    <ff-splitter direction="vertical" position=${this.verticalPosition} @ff-splitter-change=${this.onSplitterChange}></ff-splitter>
                    <div style="flex:1 1;"></div>
                </div>
            `);
        }
        return _CustomElement__WEBPACK_IMPORTED_MODULE_1__["html"] `${elements}`;
    }
    onSplitterChange(event) {
        if (event.detail.direction === "horizontal") {
            this.horizontalPosition = event.detail.position;
        }
        else {
            this.verticalPosition = event.detail.position;
        }
        if (this.onChange) {
            this.onChange({
                layout: this.layout,
                horizontalSplit: this.horizontalPosition,
                verticalSplit: this.verticalPosition,
                isDragging: event.detail.isDragging
            });
        }
    }
};
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])({ attribute: false })
], QuadSplitter.prototype, "layout", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])({ attribute: false })
], QuadSplitter.prototype, "horizontalPosition", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])({ attribute: false })
], QuadSplitter.prototype, "verticalPosition", void 0);
QuadSplitter = __decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_1__["customElement"])("ff-quad-splitter")
], QuadSplitter);
/* harmony default export */ __webpack_exports__["default"] = (QuadSplitter);


/***/ }),

/***/ "../../libs/ff-ui/source/Splitter.ts":
/*!***********************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-ui/source/Splitter.ts ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CustomElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Splitter_1;

let Splitter = Splitter_1 = class Splitter extends _CustomElement__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
        this.direction = "horizontal";
        this.width = 5;
        this.margin = 20;
        this.detached = false;
        this._isActive = false;
        this._offset = 0;
        this._position = 0;
        this.addEventListener("pointerdown", (e) => this.onPointerDown(e));
        this.addEventListener("pointermove", (e) => this.onPointerMove(e));
        this.addEventListener("pointerup", (e) => this.onPointerUpOrCancel(e));
        this.addEventListener("pointercancel", (e) => this.onPointerUpOrCancel(e));
    }
    get position() {
        return this._position;
    }
    isHorizontal() {
        return this.direction === "horizontal";
    }
    update(changedProperties) {
        super.update(changedProperties);
        const isHorizontal = this.isHorizontal();
        const width = this.width;
        this.setStyle({
            padding: isHorizontal ? `0 ${width}px` : `${width}px 0`,
            margin: isHorizontal ? `0 ${-width}px` : `${-width}px 0`,
            cursor: isHorizontal ? "col-resize" : "row-resize"
        });
    }
    firstUpdated() {
        this.classList.add("ff-splitter");
        this.setAttribute("touch-action", "none");
        this.setStyle({
            position: "relative",
            display: "block",
            zIndex: "1",
            touchAction: "none"
        });
    }
    onPointerDown(event) {
        if (event.isPrimary) {
            event.stopPropagation();
            event.preventDefault();
            this._isActive = true;
            this.setPointerCapture(event.pointerId);
            const rect = this.getBoundingClientRect();
            this._offset = this.isHorizontal()
                ? rect.left + rect.width * 0.5 - event.clientX
                : rect.top + rect.height * 0.5 - event.clientY;
        }
    }
    onPointerMove(event) {
        if (event.isPrimary && this._isActive) {
            event.stopPropagation();
            event.preventDefault();
            const parent = this.parentElement;
            if (!parent) {
                return;
            }
            const rect = parent.getBoundingClientRect();
            const isHorizontal = this.isHorizontal();
            const parentSize = isHorizontal ? rect.width : rect.height;
            let position = this._offset + (isHorizontal ? event.clientX - rect.left : event.clientY - rect.top);
            let relativePosition = position / parentSize;
            if (!this.detached) {
                const prevElement = this.previousElementSibling;
                const nextElement = this.nextElementSibling;
                if (prevElement instanceof HTMLElement && nextElement instanceof HTMLElement) {
                    const children = Array.from(parent.children);
                    let splitAreaStart = 0;
                    let splitAreaSize = parentSize;
                    let visited = false;
                    children.forEach(child => {
                        if (child instanceof Splitter_1) {
                            return;
                        }
                        if (child === prevElement || child === nextElement) {
                            visited = true;
                            return;
                        }
                        const childRect = child.getBoundingClientRect();
                        const childSize = isHorizontal ? childRect.width : childRect.height;
                        splitAreaSize -= childSize;
                        if (!visited) {
                            splitAreaStart += childSize;
                        }
                    });
                    const minSize = this.margin;
                    const maxSize = splitAreaSize - minSize;
                    position = (position - splitAreaStart);
                    position = position < minSize ? minSize : (position > maxSize ? maxSize : position);
                    const nextSize = (splitAreaSize - position) / parentSize;
                    relativePosition = position / parentSize;
                    prevElement.style.flexBasis = (relativePosition * 100).toFixed(3) + "%";
                    nextElement.style.flexBasis = (nextSize * 100).toFixed(3) + "%";
                    // send global resize event so components can adjust to new size
                    setTimeout(() => window.dispatchEvent(new CustomEvent("resize")), 0);
                }
            }
            this._position = relativePosition;
            this.dispatchEvent(new CustomEvent(Splitter_1.changeEvent, {
                detail: {
                    direction: this.direction,
                    position: this._position,
                    isDragging: true
                }
            }));
        }
    }
    onPointerUpOrCancel(event) {
        if (event.isPrimary) {
            event.stopPropagation();
            event.preventDefault();
            this._isActive = false;
            this.dispatchEvent(new CustomEvent(Splitter_1.changeEvent, {
                detail: {
                    direction: this.direction,
                    position: this._position,
                    isDragging: false
                }
            }));
        }
    }
};
Splitter.changeEvent = "ff-splitter-change";
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: String })
], Splitter.prototype, "direction", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: Number })
], Splitter.prototype, "width", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: Number })
], Splitter.prototype, "margin", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: Boolean })
], Splitter.prototype, "detached", void 0);
Splitter = Splitter_1 = __decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["customElement"])("ff-splitter")
], Splitter);
/* harmony default export */ __webpack_exports__["default"] = (Splitter);


/***/ }),

/***/ "../../libs/ff-ui/source/TextEdit.ts":
/*!***********************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-ui/source/TextEdit.ts ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CustomElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

let TextEdit = class TextEdit extends _CustomElement__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        /** Optional name to identify the button. */
        this.name = "";
        /** Optional index to identify the button. */
        this.index = 0;
        /** Text to be edited in the control. */
        this.text = "";
        /** Placeholder text to display if no other text is present. */
        this.placeholder = "";
        this.align = "left";
        this.initialValue = "";
    }
    get textArea() {
        return this.getElementsByTagName("textarea").item(0);
    }
    select() {
        const textArea = this.textArea;
        textArea && textArea.select();
    }
    focus() {
        const textArea = this.textArea;
        textArea && textArea.focus();
    }
    blur() {
        const textArea = this.textArea;
        textArea && textArea.blur();
    }
    hasFocus() {
        return this.textArea === document.activeElement;
    }
    firstConnected() {
        this.classList.add("ff-control", "ff-text-edit");
    }
    shouldUpdate(changedProperties) {
        // prevent rendering during editing
        if (this.hasFocus()) {
            return false;
        }
        return super.shouldUpdate(changedProperties);
    }
    render() {
        return _CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<textarea
            .value=${this.text} placeholder=${this.placeholder}
            @keydown=${this.onKeyDown} @change=${this.onChange} @input=${this.onInput}
            @focus=${this.onFocus} @blur=${this.onBlur}
            style="text-align: ${this.align};"></textarea>`;
    }
    onKeyDown(event) {
        const target = event.target;
        if (event.key === "Escape") {
            this.revert(target);
            target.blur();
        }
    }
    onChange(event) {
        event.stopPropagation();
        event.preventDefault();
        this.text = event.target.value;
        this.dispatchChangeEvent(this.text, false);
    }
    onInput(event) {
        event.stopPropagation();
        event.preventDefault();
        this.text = event.target.value;
        this.dispatchChangeEvent(this.text, true);
    }
    onFocus(event) {
        this.initialValue = event.target.value;
    }
    onBlur(event) {
        this.commit(event.target);
        this.requestUpdate();
    }
    revert(element) {
        element.value = this.initialValue;
        this.dispatchChangeEvent(element.value, false);
    }
    commit(element) {
        this.initialValue = element.value;
        this.dispatchChangeEvent(element.value, false);
    }
    dispatchChangeEvent(text, isEditing) {
        this.dispatchEvent(new CustomEvent("change", {
            detail: {
                text,
                isEditing
            }
        }));
    }
};
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: String })
], TextEdit.prototype, "name", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: Number })
], TextEdit.prototype, "index", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: String })
], TextEdit.prototype, "text", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: String })
], TextEdit.prototype, "placeholder", void 0);
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: String })
], TextEdit.prototype, "align", void 0);
TextEdit = __decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_0__["customElement"])("ff-text-edit")
], TextEdit);
/* harmony default export */ __webpack_exports__["default"] = (TextEdit);


/***/ }),

/***/ "../../libs/ff-ui/source/VectorSlider.ts":
/*!***************************************************************!*\
  !*** /var/node/dpo-voyager/libs/ff-ui/source/VectorSlider.ts ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_core_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/math */ "../../libs/ff-core/source/math.ts");
/* harmony import */ var _ff_core_Vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/core/Vector2 */ "../../libs/ff-core/source/Vector2.ts");
/* harmony import */ var _CustomElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/* harmony import */ var _DragHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DragHelper */ "../../libs/ff-ui/source/DragHelper.ts");
/**
 * FF Typescript Foundation Library
 * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH
 *
 * License: MIT
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




let VectorSlider = class VectorSlider extends _CustomElement__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super();
        this.value = new _ff_core_Vector2__WEBPACK_IMPORTED_MODULE_1__["default"]();
        this._offsetX = 0;
        this._offsetY = 0;
        this._knob = new _CustomElement__WEBPACK_IMPORTED_MODULE_2__["default"]()
            .addClass("ff-knob")
            .setStyle({ display: "block", position: "relative " });
        new _DragHelper__WEBPACK_IMPORTED_MODULE_3__["default"](this);
    }
    setXY(x, y) {
        this.value.set(x, y);
        this.requestUpdate();
    }
    dragStart(event) {
        const knob = this._knob;
        const track = this.getBoundingClientRect();
        if (event.target === this._knob) {
            this._offsetX = event.clientX - knob.offsetLeft + (knob.clientWidth - knob.offsetWidth) * 0.5;
            this._offsetY = event.clientY - knob.offsetTop + (knob.clientHeight - knob.offsetHeight) * 0.5;
        }
        else {
            this._offsetX = track.left + knob.clientWidth * 0.8;
            this._offsetY = track.top + knob.clientHeight * 0.8;
        }
        this.dragMove(event);
    }
    dragMove(event) {
        const knob = this._knob;
        const px = event.clientX - this._offsetX;
        const py = event.clientY - this._offsetY;
        let x = px / (this.clientWidth - knob.clientWidth);
        x = _ff_core_math__WEBPACK_IMPORTED_MODULE_0__["default"].limit(x, 0, 1);
        let y = 1 - py / (this.clientHeight - knob.clientHeight);
        y = _ff_core_math__WEBPACK_IMPORTED_MODULE_0__["default"].limit(y, 0, 1);
        if (x !== this.value.x || y !== this.value.y) {
            this.value = this.value.set(x, y);
            this.emitChangeEvent(true);
        }
    }
    dragEnd() {
        this.emitChangeEvent(false);
    }
    firstConnected() {
        this.setStyle({
            position: "relative",
            touchAction: "none"
        });
        this.setAttribute("touch-action", "none");
        this.setAttribute("tabindex", "0");
        this.classList.add("ff-control", "ff-vector-slider");
        this.appendChild(this._knob);
    }
    update(changedProperties) {
        const x = this.value.x * 100;
        const y = (1 - this.value.y) * 100;
        this._knob.style.left = `${x.toFixed(3)}%`;
        this._knob.style.top = `${y.toFixed(3)}%`;
        super.update(changedProperties);
    }
    emitChangeEvent(isDragging) {
        this.dispatchEvent(new CustomEvent("change", {
            detail: {
                value: this.value,
                isDragging
            },
            bubbles: true
        }));
    }
};
__decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_2__["property"])({ attribute: false })
], VectorSlider.prototype, "value", void 0);
VectorSlider = __decorate([
    Object(_CustomElement__WEBPACK_IMPORTED_MODULE_2__["customElement"])("ff-vector-slider")
], VectorSlider);
/* harmony default export */ __webpack_exports__["default"] = (VectorSlider);


/***/ }),

/***/ "../../node_modules/ajv/dist/ajv.js":
/*!**********************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/ajv.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
const context_1 = __webpack_require__(/*! ./compile/context */ "../../node_modules/ajv/dist/compile/context.js");
exports.KeywordCxt = context_1.default;
var codegen_1 = __webpack_require__(/*! ./compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
const core_1 = __webpack_require__(/*! ./core */ "../../node_modules/ajv/dist/core.js");
const draft7_1 = __webpack_require__(/*! ./vocabularies/draft7 */ "../../node_modules/ajv/dist/vocabularies/draft7.js");
const draft7MetaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ "../../node_modules/ajv/dist/refs/json-schema-draft-07.json");
const META_SUPPORT_DATA = ["/properties"];
const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
class Ajv extends core_1.default {
    _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
    }
    _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
            return;
        const metaSchema = this.opts.$data
            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)
            : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
        return (this.opts.defaultMeta =
            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
    }
}
exports.default = Ajv;


/***/ }),

/***/ "../../node_modules/ajv/dist/compile/codegen/code.js":
/*!***************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/compile/codegen/code.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
class _CodeOrName {
}
exports._CodeOrName = _CodeOrName;
exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
class Name extends _CodeOrName {
    constructor(s) {
        super();
        if (!exports.IDENTIFIER.test(s))
            throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
    }
    toString() {
        return this.str;
    }
    emptyStr() {
        return false;
    }
    get names() {
        return { [this.str]: 1 };
    }
}
exports.Name = Name;
class _Code extends _CodeOrName {
    constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
    }
    toString() {
        return this.str;
    }
    emptyStr() {
        if (this._items.length > 1)
            return false;
        const item = this._items[0];
        return item === "" || item === '""';
    }
    get str() {
        var _a;
        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, "")));
    }
    get names() {
        var _a;
        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {
            if (c instanceof Name)
                names[c.str] = (names[c.str] || 0) + 1;
            return names;
        }, {})));
    }
}
exports._Code = _Code;
exports.nil = new _Code("");
function _(strs, ...args) {
    const code = [strs[0]];
    let i = 0;
    while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
    }
    return new _Code(code);
}
exports._ = _;
const plus = new _Code("+");
function str(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
}
exports.str = str;
function addCodeArg(code, arg) {
    if (arg instanceof _Code)
        code.push(...arg._items);
    else if (arg instanceof Name)
        code.push(arg);
    else
        code.push(interpolate(arg));
}
exports.addCodeArg = addCodeArg;
function optimize(expr) {
    let i = 1;
    while (i < expr.length - 1) {
        if (expr[i] === plus) {
            const res = mergeExprItems(expr[i - 1], expr[i + 1]);
            if (res !== undefined) {
                expr.splice(i - 1, 3, res);
                continue;
            }
            expr[i++] = "+";
        }
        i++;
    }
}
function mergeExprItems(a, b) {
    if (b === '""')
        return a;
    if (a === '""')
        return b;
    if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
            return;
        if (typeof b != "string")
            return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
            return a.slice(0, -1) + b.slice(1);
        return;
    }
    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
    return;
}
function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;
}
exports.strConcat = strConcat;
// TODO do not allow arrays here
function interpolate(x) {
    return typeof x == "number" || typeof x == "boolean" || x === null
        ? x
        : safeStringify(Array.isArray(x) ? x.join(",") : x);
}
function stringify(x) {
    return new _Code(safeStringify(x));
}
exports.stringify = stringify;
function safeStringify(x) {
    return JSON.stringify(x)
        .replace(/\u2028/g, "\\u2028")
        .replace(/\u2029/g, "\\u2029");
}
exports.safeStringify = safeStringify;
function getProperty(key) {
    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;
}
exports.getProperty = getProperty;


/***/ }),

/***/ "../../node_modules/ajv/dist/compile/codegen/index.js":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/compile/codegen/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
const code_1 = __webpack_require__(/*! ./code */ "../../node_modules/ajv/dist/compile/codegen/code.js");
const scope_1 = __webpack_require__(/*! ./scope */ "../../node_modules/ajv/dist/compile/codegen/scope.js");
var code_2 = __webpack_require__(/*! ./code */ "../../node_modules/ajv/dist/compile/codegen/code.js");
Object.defineProperty(exports, "_", { enumerable: true, get: function () { return code_2._; } });
Object.defineProperty(exports, "str", { enumerable: true, get: function () { return code_2.str; } });
Object.defineProperty(exports, "strConcat", { enumerable: true, get: function () { return code_2.strConcat; } });
Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return code_2.nil; } });
Object.defineProperty(exports, "getProperty", { enumerable: true, get: function () { return code_2.getProperty; } });
Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return code_2.stringify; } });
Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return code_2.Name; } });
var scope_2 = __webpack_require__(/*! ./scope */ "../../node_modules/ajv/dist/compile/codegen/scope.js");
Object.defineProperty(exports, "Scope", { enumerable: true, get: function () { return scope_2.Scope; } });
Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function () { return scope_2.ValueScope; } });
Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function () { return scope_2.ValueScopeName; } });
Object.defineProperty(exports, "varKinds", { enumerable: true, get: function () { return scope_2.varKinds; } });
exports.operators = {
    GT: new code_1._Code(">"),
    GTE: new code_1._Code(">="),
    LT: new code_1._Code("<"),
    LTE: new code_1._Code("<="),
    EQ: new code_1._Code("==="),
    NEQ: new code_1._Code("!=="),
    NOT: new code_1._Code("!"),
    OR: new code_1._Code("||"),
    AND: new code_1._Code("&&"),
    ADD: new code_1._Code("+"),
};
class Node {
    optimizeNodes() {
        return this;
    }
    optimizeNames(_names, _constants) {
        return this;
    }
}
class Def extends Node {
    constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
    }
    render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names, constants) {
        if (!names[this.name.str])
            return;
        if (this.rhs)
            this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
    }
    get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
    }
}
class Assign extends Node {
    constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
    }
    render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
            return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
    }
    get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
    }
}
class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
    }
    render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
}
class Label extends Node {
    constructor(label) {
        super();
        this.label = label;
        this.names = {};
    }
    render({ _n }) {
        return `${this.label}:` + _n;
    }
}
class Break extends Node {
    constructor(label) {
        super();
        this.label = label;
        this.names = {};
    }
    render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
    }
}
class Throw extends Node {
    constructor(error) {
        super();
        this.error = error;
    }
    render({ _n }) {
        return `throw ${this.error};` + _n;
    }
    get names() {
        return this.error.names;
    }
}
class AnyCode extends Node {
    constructor(code) {
        super();
        this.code = code;
    }
    render({ _n }) {
        return `${this.code};` + _n;
    }
    optimizeNodes() {
        return `${this.code}` ? this : undefined;
    }
    optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
    }
    get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
    }
}
class ParentNode extends Node {
    constructor(nodes = []) {
        super();
        this.nodes = nodes;
    }
    render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
    }
    optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
            const n = nodes[i].optimizeNodes();
            if (Array.isArray(n))
                nodes.splice(i, 1, ...n);
            else if (n)
                nodes[i] = n;
            else
                nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : undefined;
    }
    optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
            // iterating backwards improves 1-pass optimization
            const n = nodes[i];
            if (n.optimizeNames(names, constants))
                continue;
            subtractNames(names, n.names);
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : undefined;
    }
    get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
    }
}
class BlockNode extends ParentNode {
    render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
    }
}
class Root extends ParentNode {
}
class Else extends BlockNode {
}
Else.kind = "else";
class If extends BlockNode {
    constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
    }
    render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
            code += "else " + this.else.render(opts);
        return code;
    }
    optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
            return this.nodes; // else is ignored here
        let e = this.else;
        if (e) {
            const ns = e.optimizeNodes();
            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
            if (cond === false)
                return e instanceof If ? e : e.nodes;
            if (this.nodes.length)
                return this;
            return new If(not(cond), e instanceof If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
            return undefined;
        return this;
    }
    optimizeNames(names, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
            return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
    }
    get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
            addNames(names, this.else.names);
        return names;
    }
}
If.kind = "if";
class For extends BlockNode {
}
For.kind = "for";
class ForLoop extends For {
    constructor(iteration) {
        super();
        this.iteration = iteration;
    }
    render(opts) {
        return `for(${this.iteration})` + super.render(opts);
    }
    optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
            return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
    }
    get names() {
        return addNames(super.names, this.iteration.names);
    }
}
class ForRange extends For {
    constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
    }
    render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
    }
    get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
    }
}
class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
    }
    render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
    }
    optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
            return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
    }
    get names() {
        return addNames(super.names, this.iterable.names);
    }
}
class Func extends BlockNode {
    constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
    }
    render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
    }
}
Func.kind = "func";
class Return extends ParentNode {
    render(opts) {
        return "return " + super.render(opts);
    }
}
Return.kind = "return";
class Try extends BlockNode {
    render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
            code += this.catch.render(opts);
        if (this.finally)
            code += this.finally.render(opts);
        return code;
    }
    optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
    }
    optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
    }
    get names() {
        const names = super.names;
        if (this.catch)
            addNames(names, this.catch.names);
        if (this.finally)
            addNames(names, this.finally.names);
        return names;
    }
}
class Catch extends BlockNode {
    constructor(error) {
        super();
        this.error = error;
    }
    render(opts) {
        return `catch(${this.error})` + super.render(opts);
    }
}
Catch.kind = "catch";
class Finally extends BlockNode {
    render(opts) {
        return "finally" + super.render(opts);
    }
}
Finally.kind = "finally";
class CodeGen {
    constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
    }
    toString() {
        return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(prefix) {
        return this._scope.name(prefix);
    }
    // reserves unique name in the external scope
    scopeName(prefix) {
        return this._extScope.name(prefix);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
        vs.add(name);
        return name;
    }
    getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
        return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== undefined && constant)
            this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
    }
    // `const` declaration (`var` in es5 mode)
    const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    // `var` declaration with optional assignment
    var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    // assignment code
    assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    // `+=` code
    add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
    }
    // appends passed SafeExpr to code or executes Block
    code(c) {
        if (typeof c == "function")
            c();
        else if (c !== code_1.nil)
            this._leafNode(new AnyCode(c));
        return this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
            if (code.length > 1)
                code.push(",");
            code.push(key);
            if (key !== value || this.opts.es5) {
                code.push(":");
                code_1.addCodeArg(code, value);
            }
        }
        code.push("}");
        return new code_1._Code(code);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
            this.code(thenBody).else().code(elseBody).endIf();
        }
        else if (thenBody) {
            this.code(thenBody).endIf();
        }
        else if (elseBody) {
            throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(condition) {
        return this._elseNode(new If(condition));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
        return this._elseNode(new Else());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
        return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
            this.code(forBody).endFor();
        return this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
    }
    // `for` statement for a range of values
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
            return this.forRange("_i", 0, code_1._ `${arr}.length`, (i) => {
                this.var(name, code_1._ `${arr}[${i}]`);
                forBody(name);
            });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
            return this.forOf(nameOrPrefix, code_1._ `Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    // end `for` loop
    endFor() {
        return this._endBlockNode(For);
    }
    // `label` statement
    label(label) {
        return this._leafNode(new Label(label));
    }
    // `break` statement
    break(label) {
        return this._leafNode(new Break(label));
    }
    // `return` statement
    return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
            throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
    }
    // `try` statement
    try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
            throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
            const error = this.name("e");
            this._currNode = node.catch = new Catch(error);
            catchCode(error);
        }
        if (finallyCode) {
            this._currNode = node.finally = new Finally();
            this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
    }
    // `throw` statement
    throw(error) {
        return this._leafNode(new Throw(error));
    }
    // start self-balancing block
    block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
            this.code(body).endBlock(nodeCount);
        return this;
    }
    // end the current self-balancing block
    endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === undefined)
            throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {
            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
            this.code(funcBody).endFunc();
        return this;
    }
    // end function definition
    endFunc() {
        return this._endBlockNode(Func);
    }
    optimize(n = 1) {
        while (n-- > 0) {
            this._root.optimizeNodes();
            this._root.optimizeNames(this._root.names, this._constants);
        }
    }
    _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
    }
    _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
    }
    _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || (N2 && n instanceof N2)) {
            this._nodes.pop();
            return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
            throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
    }
    get _root() {
        return this._nodes[0];
    }
    get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
    }
    set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
    }
}
exports.CodeGen = CodeGen;
function addNames(names, from) {
    for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
    return names;
}
function addExprNames(names, from) {
    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
}
function optimizeExpr(expr, names, constants) {
    if (expr instanceof code_1.Name)
        return replaceName(expr);
    if (!canOptimize(expr))
        return expr;
    return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
            c = replaceName(c);
        if (c instanceof code_1._Code)
            items.push(...c._items);
        else
            items.push(c);
        return items;
    }, []));
    function replaceName(n) {
        const c = constants[n.str];
        if (c === undefined || names[n.str] !== 1)
            return n;
        delete names[n.str];
        return c;
    }
    function canOptimize(e) {
        return (e instanceof code_1._Code &&
            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));
    }
}
function subtractNames(names, from) {
    for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
}
function not(x) {
    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : code_1._ `!${par(x)}`;
}
exports.not = not;
const andCode = mappend(exports.operators.AND);
// boolean AND (&&) expression with the passed arguments
function and(...args) {
    return args.reduce(andCode);
}
exports.and = and;
const orCode = mappend(exports.operators.OR);
// boolean OR (||) expression with the passed arguments
function or(...args) {
    return args.reduce(orCode);
}
exports.or = or;
function mappend(op) {
    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : code_1._ `${par(x)} ${op} ${par(y)}`);
}
function par(x) {
    return x instanceof code_1.Name ? x : code_1._ `(${x})`;
}


/***/ }),

/***/ "../../node_modules/ajv/dist/compile/codegen/scope.js":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/compile/codegen/scope.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
const code_1 = __webpack_require__(/*! ./code */ "../../node_modules/ajv/dist/compile/codegen/code.js");
class ValueError extends Error {
    constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
    }
}
var UsedValueState;
(function (UsedValueState) {
    UsedValueState[UsedValueState["Started"] = 0] = "Started";
    UsedValueState[UsedValueState["Completed"] = 1] = "Completed";
})(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
exports.varKinds = {
    const: new code_1.Name("const"),
    let: new code_1.Name("let"),
    var: new code_1.Name("var"),
};
class Scope {
    constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
    }
    toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
        return new code_1.Name(this._newName(prefix));
    }
    _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {
            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return (this._names[prefix] = { prefix, index: 0 });
    }
}
exports.Scope = Scope;
class ValueScopeName extends code_1.Name {
    constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = code_1._ `.${new code_1.Name(property)}[${itemIndex}]`;
    }
}
exports.ValueScopeName = ValueScopeName;
const line = code_1._ `\n`;
class ValueScope extends Scope {
    constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
    }
    get() {
        return this._scope;
    }
    name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
        var _a;
        if (value.ref === undefined)
            throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
            const _name = vs.get(valueKey);
            if (_name)
                return _name;
        }
        else {
            vs = this._values[prefix] = new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
    }
    getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
            return;
        return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
            if (name.scopePath === undefined)
                throw new Error(`CodeGen: name "${name}" has no value`);
            return code_1._ `${scopeName}${name.scopePath}`;
        });
    }
    scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
            if (name.value === undefined)
                throw new Error(`CodeGen: name "${name}" has no value`);
            return name.value.code;
        }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
            const vs = values[prefix];
            if (!vs)
                continue;
            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());
            vs.forEach((name) => {
                if (nameSet.has(name))
                    return;
                nameSet.set(name, UsedValueState.Started);
                let c = valueCode(name);
                if (c) {
                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
                    code = code_1._ `${code}${def} ${name} = ${c};${this.opts._n}`;
                }
                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {
                    code = code_1._ `${code}${c}${this.opts._n}`;
                }
                else {
                    throw new ValueError(name);
                }
                nameSet.set(name, UsedValueState.Completed);
            });
        }
        return code;
    }
}
exports.ValueScope = ValueScope;


/***/ }),

/***/ "../../node_modules/ajv/dist/compile/context.js":
/*!**********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/compile/context.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getData = void 0;
const dataType_1 = __webpack_require__(/*! ./validate/dataType */ "../../node_modules/ajv/dist/compile/validate/dataType.js");
const util_1 = __webpack_require__(/*! ./util */ "../../node_modules/ajv/dist/compile/util.js");
const errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/ajv/dist/compile/errors.js");
const codegen_1 = __webpack_require__(/*! ./codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const names_1 = __webpack_require__(/*! ./names */ "../../node_modules/ajv/dist/compile/names.js");
const subschema_1 = __webpack_require__(/*! ./subschema */ "../../node_modules/ajv/dist/compile/subschema.js");
class KeywordCxt {
    constructor(it, def, keyword) {
        validateKeywordUsage(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = util_1.schemaRefOrVal(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
            this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        }
        else {
            this.schemaCode = this.schemaValue;
            if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {
                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
            }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
            this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
    }
    result(condition, successAction, failAction) {
        this.gen.if(codegen_1.not(condition));
        if (failAction)
            failAction();
        else
            this.error();
        if (successAction) {
            this.gen.else();
            successAction();
            if (this.allErrors)
                this.gen.endIf();
        }
        else {
            if (this.allErrors)
                this.gen.endIf();
            else
                this.gen.else();
        }
    }
    pass(condition, failAction) {
        this.result(condition, undefined, failAction);
    }
    fail(condition) {
        if (condition === undefined) {
            this.error();
            if (!this.allErrors)
                this.gen.if(false); // this branch will be removed by gen.optimize
            return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
            this.gen.endIf();
        else
            this.gen.else();
    }
    fail$data(condition) {
        if (!this.$data)
            return this.fail(condition);
        const { schemaCode } = this;
        this.fail(codegen_1._ `${schemaCode} !== undefined && (${codegen_1.or(this.invalid$data(), condition)})`);
    }
    error(append) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error);
    }
    $dataError() {
        errors_1.reportError(this, this.def.$dataError || errors_1.keyword$DataError);
    }
    reset() {
        if (this.errsCount === undefined)
            throw new Error('add "trackErrors" to keyword definition');
        errors_1.resetErrorsCount(this.gen, this.errsCount);
    }
    ok(cond) {
        if (!this.allErrors)
            this.gen.if(cond);
    }
    setParams(obj, assign) {
        if (assign)
            Object.assign(this.params, obj);
        else
            this.params = obj;
    }
    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
            this.check$data(valid, $dataValid);
            codeBlock();
        });
    }
    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
            return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if(codegen_1.or(codegen_1._ `${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
            gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
            gen.elseIf(this.invalid$data());
            this.$dataError();
            if (valid !== codegen_1.nil)
                gen.assign(valid, false);
        }
        gen.else();
    }
    invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return codegen_1.or(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
            if (schemaType.length) {
                /* istanbul ignore if */
                if (!(schemaCode instanceof codegen_1.Name))
                    throw new Error("ajv implementation error");
                const st = Array.isArray(schemaType) ? schemaType : [schemaType];
                return codegen_1._ `${dataType_1.checkDataTypes(st, schemaCode, it.opts.strict, dataType_1.DataType.Wrong)}`;
            }
            return codegen_1.nil;
        }
        function invalid$DataSchema() {
            if (def.validateSchema) {
                const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema }); // TODO value.code for standalone
                return codegen_1._ `!${validateSchemaRef}(${schemaCode})`;
            }
            return codegen_1.nil;
        }
    }
    subschema(appl, valid) {
        return subschema_1.applySubschema(this.it, appl, valid);
    }
    mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
            return;
        if (it.props !== true && schemaCxt.props !== undefined) {
            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== undefined) {
            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
    }
    mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
            return true;
        }
    }
}
exports.default = KeywordCxt;
function validSchemaType(schema, schemaType, allowUndefined = false) {
    // TODO add tests
    return (!schemaType.length ||
        schemaType.some((st) => st === "array"
            ? Array.isArray(schema)
            : st === "object"
                ? schema && typeof schema == "object" && !Array.isArray(schema)
                : typeof schema == st || (allowUndefined && typeof schema == "undefined")));
}
function validateKeywordUsage({ schema, opts, self }, def, keyword) {
    /* istanbul ignore if */
    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
    }
    const deps = def.dependencies;
    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
    }
    if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
            const msg = "keyword value is invalid: " + self.errorsText(def.validateSchema.errors);
            if (opts.validateSchema === "log")
                self.logger.error(msg);
            else
                throw new Error(msg);
        }
    }
}
const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, { dataLevel, dataNames, dataPathArr }) {
    let jsonPointer;
    let data;
    if ($data === "")
        return names_1.default.rootData;
    if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
            throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
    }
    else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
            throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
            if (up >= dataLevel)
                throw new Error(errorMsg("property/index", up));
            return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
            throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
            return data;
    }
    let expr = data;
    const segments = jsonPointer.split("/");
    for (const segment of segments) {
        if (segment) {
            data = codegen_1._ `${data}${codegen_1.getProperty(util_1.unescapeJsonPointer(segment))}`;
            expr = codegen_1._ `${expr} && ${data}`;
        }
    }
    return expr;
    function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
    }
}
exports.getData = getData;


/***/ }),

/***/ "../../node_modules/ajv/dist/compile/error_classes.js":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/compile/error_classes.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MissingRefError = exports.ValidationError = void 0;
const resolve_1 = __webpack_require__(/*! ./resolve */ "../../node_modules/ajv/dist/compile/resolve.js");
class ValidationError extends Error {
    constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
    }
}
exports.ValidationError = ValidationError;
class MissingRefError extends Error {
    constructor(baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = resolve_1.resolveUrl(baseId, ref);
        this.missingSchema = resolve_1.normalizeId(resolve_1.getFullPath(this.missingRef));
    }
}
exports.MissingRefError = MissingRefError;
module.exports = {
    ValidationError,
    MissingRefError,
};


/***/ }),

/***/ "../../node_modules/ajv/dist/compile/errors.js":
/*!*********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/compile/errors.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
const codegen_1 = __webpack_require__(/*! ./codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const names_1 = __webpack_require__(/*! ./names */ "../../node_modules/ajv/dist/compile/names.js");
exports.keywordError = {
    message: ({ keyword }) => codegen_1.str `should pass "${keyword}" keyword validation`,
};
exports.keyword$DataError = {
    message: ({ keyword, schemaType }) => schemaType
        ? codegen_1.str `"${keyword}" keyword must be ${schemaType} ($data)`
        : codegen_1.str `"${keyword}" keyword is invalid ($data)`,
};
function reportError(cxt, error = exports.keywordError, overrideAllErrors) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {
        addError(gen, errObj);
    }
    else {
        returnErrors(it, codegen_1._ `[${errObj}]`);
    }
}
exports.reportError = reportError;
function reportExtraError(cxt, error = exports.keywordError) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
    }
}
exports.reportExtraError = reportExtraError;
function resetErrorsCount(gen, errsCount) {
    gen.assign(names_1.default.errors, errsCount);
    gen.if(codegen_1._ `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign(codegen_1._ `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
}
exports.resetErrorsCount = resetErrorsCount;
function extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {
    /* istanbul ignore if */
    if (errsCount === undefined)
        throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, codegen_1._ `${names_1.default.vErrors}[${i}]`);
        gen.if(codegen_1._ `${err}.dataPath === undefined`, () => gen.assign(codegen_1._ `${err}.dataPath`, codegen_1.strConcat(names_1.default.dataPath, it.errorPath)));
        gen.assign(codegen_1._ `${err}.schemaPath`, codegen_1.str `${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
            gen.assign(codegen_1._ `${err}.schema`, schemaValue);
            gen.assign(codegen_1._ `${err}.data`, data);
        }
    });
}
exports.extendErrors = extendErrors;
function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if(codegen_1._ `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, codegen_1._ `[${err}]`), codegen_1._ `${names_1.default.vErrors}.push(${err})`);
    gen.code(codegen_1._ `${names_1.default.errors}++`);
}
function returnErrors(it, errs) {
    const { gen, validateName, schemaEnv } = it;
    if (schemaEnv.$async) {
        gen.throw(codegen_1._ `new ${it.ValidationError}(${errs})`);
    }
    else {
        gen.assign(codegen_1._ `${validateName}.errors`, errs);
        gen.return(false);
    }
}
const E = {
    keyword: new codegen_1.Name("keyword"),
    schemaPath: new codegen_1.Name("schemaPath"),
    params: new codegen_1.Name("params"),
    propertyName: new codegen_1.Name("propertyName"),
    message: new codegen_1.Name("message"),
    schema: new codegen_1.Name("schema"),
    parentSchema: new codegen_1.Name("parentSchema"),
    // JTD error properties
    instancePath: new codegen_1.Name("instancePath"),
};
function errorObjectCode(cxt, error) {
    const { createErrors, opts } = cxt.it;
    if (createErrors === false)
        return codegen_1._ `{}`;
    return (opts.jtd && !opts.ajvErrors ? jtdErrorObject : ajvErrorObject)(cxt, error);
}
function jtdErrorObject(cxt, { message }) {
    const { gen, keyword, it } = cxt;
    const { errorPath, errSchemaPath, opts } = it;
    const keyValues = [
        [E.instancePath, codegen_1.strConcat(names_1.default.dataPath, errorPath)],
        [E.schemaPath, codegen_1.str `${errSchemaPath}/${keyword}`],
    ];
    if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    return gen.object(...keyValues);
}
function ajvErrorObject(cxt, error) {
    const { gen, keyword, data, schemaValue, it } = cxt;
    const { topSchemaRef, schemaPath, errorPath, errSchemaPath, propertyName, opts } = it;
    const { params, message } = error;
    const keyValues = [
        [E.keyword, keyword],
        [names_1.default.dataPath, codegen_1.strConcat(names_1.default.dataPath, errorPath)],
        [E.schemaPath, codegen_1.str `${errSchemaPath}/${keyword}`],
        [E.params, typeof params == "function" ? params(cxt) : params || codegen_1._ `{}`],
    ];
    if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, codegen_1._ `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
    }
    return gen.object(...keyValues);
}


/***/ }),

/***/ "../../node_modules/ajv/dist/compile/index.js":
/*!********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/compile/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
const codegen_1 = __webpack_require__(/*! ./codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const error_classes_1 = __webpack_require__(/*! ./error_classes */ "../../node_modules/ajv/dist/compile/error_classes.js");
const names_1 = __webpack_require__(/*! ./names */ "../../node_modules/ajv/dist/compile/names.js");
const resolve_1 = __webpack_require__(/*! ./resolve */ "../../node_modules/ajv/dist/compile/resolve.js");
const util_1 = __webpack_require__(/*! ./util */ "../../node_modules/ajv/dist/compile/util.js");
const validate_1 = __webpack_require__(/*! ./validate */ "../../node_modules/ajv/dist/compile/validate/index.js");
const URI = __webpack_require__(/*! uri-js */ "../../node_modules/uri-js/dist/es5/uri.all.js");
class SchemaEnv {
    constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
            schema = env.schema;
        this.schema = env.schema;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : resolve_1.normalizeId(schema === null || schema === void 0 ? void 0 : schema.$id);
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
    }
}
exports.SchemaEnv = SchemaEnv;
// let codeSize = 0
// let nodeCount = 0
// Compiles schema in SchemaEnv
function compileSchema(sch) {
    // TODO refactor - remove compilations
    const _sch = getCompilingSchema.call(this, sch);
    if (_sch)
        return _sch;
    const rootId = resolve_1.getFullPath(sch.root.baseId); // TODO if getFullPath removed 1 tests fails
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    let _ValidationError;
    if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
            ref: error_classes_1.ValidationError,
            code: codegen_1._ `require("ajv/dist/compile/error_classes").ValidationError`,
        });
    }
    const validateName = gen.scopeName("validate");
    sch.validateName = validateName;
    const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        dataLevel: 0,
        dataTypes: [],
        definedProperties: new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true
            ? { ref: sch.schema, code: codegen_1.stringify(sch.schema) }
            : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: this.opts.jtd ? "" : "#",
        errorPath: codegen_1._ `""`,
        opts: this.opts,
        self: this,
    };
    let sourceCode;
    try {
        this._compilations.add(sch);
        validate_1.validateFunctionCode(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        // gen.optimize(1)
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))
        if (this.opts.code.process)
            sourceCode = this.opts.code.process(sourceCode, sch);
        // console.log("\n\n\n *** \n", sourceCode)
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
            validate.$async = true;
        if (this.opts.code.source === true) {
            validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
            const { props, items } = schemaCxt;
            validate.evaluated = {
                props: props instanceof codegen_1.Name ? undefined : props,
                items: items instanceof codegen_1.Name ? undefined : items,
                dynamicProps: props instanceof codegen_1.Name,
                dynamicItems: items instanceof codegen_1.Name,
            };
            if (validate.source)
                validate.source.evaluated = codegen_1.stringify(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
    }
    catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
            this.logger.error("Error compiling schema, function code:", sourceCode);
        // console.log("\n\n\n *** \n", sourceCode, this.opts)
        throw e;
    }
    finally {
        this._compilations.delete(sch);
    }
}
exports.compileSchema = compileSchema;
function resolveRef(root, baseId, ref) {
    var _a;
    ref = resolve_1.resolveUrl(baseId, ref);
    const schOrFunc = root.refs[ref];
    if (schOrFunc)
        return schOrFunc;
    let _sch = resolve.call(this, root, ref);
    if (_sch === undefined) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv
        if (schema)
            _sch = new SchemaEnv({ schema, root, baseId });
    }
    if (_sch === undefined)
        return;
    return (root.refs[ref] = inlineOrCompile.call(this, _sch));
}
exports.resolveRef = resolveRef;
function inlineOrCompile(sch) {
    if (resolve_1.inlineRef(sch.schema, this.opts.inlineRefs))
        return sch.schema;
    return sch.validate ? sch : compileSchema.call(this, sch);
}
// Index of schema compilation in the currently compiled list
function getCompilingSchema(schEnv) {
    for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
            return sch;
    }
}
exports.getCompilingSchema = getCompilingSchema;
function sameSchemaEnv(s1, s2) {
    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
// resolve and compile the references ($ref)
// TODO returns AnySchemaObject (if the schema can be inlined) or validation function
function resolve(root, // information about the root schema for the current schema
ref // reference to resolve
) {
    let sch;
    while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
}
// Resolve schema, its root and baseId
function resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it
ref // reference to resolve
) {
    const p = URI.parse(ref);
    const refPath = resolve_1._getFullPath(p);
    let baseId = resolve_1.getFullPath(root.baseId);
    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests
    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
    }
    const id = resolve_1.normalizeId(refPath);
    const schOrRef = this.refs[id] || this.schemas[id];
    if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
            return;
        return getJsonPointer.call(this, p, sch);
    }
    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
    if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
    if (id === resolve_1.normalizeId(ref)) {
        const { schema } = schOrRef;
        if (schema.$id)
            baseId = resolve_1.resolveUrl(baseId, schema.$id);
        return new SchemaEnv({ schema, root, baseId });
    }
    return getJsonPointer.call(this, p, schOrRef);
}
exports.resolveSchema = resolveSchema;
const PREVENT_SCOPE_CHANGE = new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions",
]);
function getJsonPointer(parsedRef, { baseId, schema, root }) {
    var _a;
    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
    for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema == "boolean")
            return;
        schema = schema[util_1.unescapeFragment(part)];
        if (schema === undefined)
            return;
        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?
        if (!PREVENT_SCOPE_CHANGE.has(part) && typeof schema == "object" && schema.$id) {
            baseId = resolve_1.resolveUrl(baseId, schema.$id);
        }
    }
    let env;
    if (typeof schema != "boolean" && schema.$ref && !util_1.schemaHasRulesButRef(schema, this.RULES)) {
        const $ref = resolve_1.resolveUrl(baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
    }
    // even though resolution failed we need to return SchemaEnv to throw exception
    // so that compileAsync loads missing schema.
    env = env || new SchemaEnv({ schema, root, baseId });
    if (env.schema !== env.root.schema)
        return env;
    return undefined;
}


/***/ }),

/***/ "../../node_modules/ajv/dist/compile/names.js":
/*!********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/compile/names.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = __webpack_require__(/*! ./codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const names = {
    // validation function arguments
    data: new codegen_1.Name("data"),
    // args passed from referencing schema
    valCxt: new codegen_1.Name("valCxt"),
    dataPath: new codegen_1.Name("dataPath"),
    parentData: new codegen_1.Name("parentData"),
    parentDataProperty: new codegen_1.Name("parentDataProperty"),
    rootData: new codegen_1.Name("rootData"),
    dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
    // function scoped variables
    vErrors: new codegen_1.Name("vErrors"),
    errors: new codegen_1.Name("errors"),
    this: new codegen_1.Name("this"),
    // "globals"
    self: new codegen_1.Name("self"),
    scope: new codegen_1.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new codegen_1.Name("json"),
    jsonPos: new codegen_1.Name("jsonPos"),
    jsonLen: new codegen_1.Name("jsonLen"),
    jsonPart: new codegen_1.Name("jsonPart"),
};
exports.default = names;


/***/ }),

/***/ "../../node_modules/ajv/dist/compile/resolve.js":
/*!**********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/compile/resolve.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
const util_1 = __webpack_require__(/*! ./util */ "../../node_modules/ajv/dist/compile/util.js");
const equal = __webpack_require__(/*! fast-deep-equal */ "../../node_modules/fast-deep-equal/index.js");
const traverse = __webpack_require__(/*! json-schema-traverse */ "../../node_modules/json-schema-traverse/index.js");
const URI = __webpack_require__(/*! uri-js */ "../../node_modules/uri-js/dist/es5/uri.all.js");
// TODO refactor to use keyword definitions
const SIMPLE_INLINED = new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const",
]);
function inlineRef(schema, limit = true) {
    if (typeof schema == "boolean")
        return true;
    if (limit === true)
        return !hasRef(schema);
    if (!limit)
        return false;
    return countKeys(schema) <= limit;
}
exports.inlineRef = inlineRef;
const REF_KEYWORDS = new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor",
]);
function hasRef(schema) {
    for (const key in schema) {
        if (REF_KEYWORDS.has(key))
            return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
            return true;
        if (typeof sch == "object" && hasRef(sch))
            return true;
    }
    return false;
}
function countKeys(schema) {
    let count = 0;
    for (const key in schema) {
        if (key === "$ref")
            return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
            continue;
        if (typeof schema[key] == "object") {
            util_1.eachItem(schema[key], (sch) => (count += countKeys(sch)));
        }
        if (count === Infinity)
            return Infinity;
    }
    return count;
}
function getFullPath(id = "", normalize) {
    if (normalize !== false)
        id = normalizeId(id);
    const p = URI.parse(id);
    return _getFullPath(p);
}
exports.getFullPath = getFullPath;
function _getFullPath(p) {
    return URI.serialize(p).split("#")[0] + "#";
}
exports._getFullPath = _getFullPath;
const TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
}
exports.normalizeId = normalizeId;
function resolveUrl(baseId, id) {
    id = normalizeId(id);
    return URI.resolve(baseId, id);
}
exports.resolveUrl = resolveUrl;
const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs(schema) {
    if (typeof schema == "boolean")
        return {};
    const schemaId = normalizeId(schema.$id);
    const baseIds = { "": schemaId };
    const pathPrefix = getFullPath(schemaId, false);
    const localRefs = {};
    const schemaRefs = new Set();
    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === undefined)
            return;
        const fullPath = pathPrefix + jsonPtr;
        let baseId = baseIds[parentJsonPtr];
        if (typeof sch.$id == "string")
            baseId = addRef.call(this, sch.$id);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = baseId;
        function addRef(ref) {
            ref = normalizeId(baseId ? URI.resolve(baseId, ref) : ref);
            if (schemaRefs.has(ref))
                throw ambiguos(ref);
            schemaRefs.add(ref);
            let schOrRef = this.refs[ref];
            if (typeof schOrRef == "string")
                schOrRef = this.refs[schOrRef];
            if (typeof schOrRef == "object") {
                checkAmbiguosRef(sch, schOrRef.schema, ref);
            }
            else if (ref !== normalizeId(fullPath)) {
                if (ref[0] === "#") {
                    checkAmbiguosRef(sch, localRefs[ref], ref);
                    localRefs[ref] = sch;
                }
                else {
                    this.refs[ref] = fullPath;
                }
            }
            return ref;
        }
        function addAnchor(anchor) {
            if (typeof anchor == "string") {
                if (!ANCHOR.test(anchor))
                    throw new Error(`invalid anchor "${anchor}"`);
                addRef.call(this, `#${anchor}`);
            }
        }
    });
    return localRefs;
    function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== undefined && !equal(sch1, sch2))
            throw ambiguos(ref);
    }
    function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
    }
}
exports.getSchemaRefs = getSchemaRefs;


/***/ }),

/***/ "../../node_modules/ajv/dist/compile/rules.js":
/*!********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/compile/rules.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getRules = exports.isJSONType = void 0;
const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes = new Set(_jsonTypes);
function isJSONType(x) {
    return typeof x == "string" && jsonTypes.has(x);
}
exports.isJSONType = isJSONType;
function getRules() {
    const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] },
    };
    return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {},
    };
}
exports.getRules = getRules;


/***/ }),

/***/ "../../node_modules/ajv/dist/compile/subschema.js":
/*!************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/compile/subschema.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.applySubschema = exports.Type = void 0;
const validate_1 = __webpack_require__(/*! ./validate */ "../../node_modules/ajv/dist/compile/validate/index.js");
const util_1 = __webpack_require__(/*! ./util */ "../../node_modules/ajv/dist/compile/util.js");
const codegen_1 = __webpack_require__(/*! ./codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
var Type;
(function (Type) {
    Type[Type["Num"] = 0] = "Num";
    Type[Type["Str"] = 1] = "Str";
})(Type = exports.Type || (exports.Type = {}));
function applySubschema(it, appl, valid) {
    const subschema = getSubschema(it, appl);
    extendSubschemaData(subschema, it, appl);
    extendSubschemaMode(subschema, appl);
    const nextContext = { ...it, ...subschema, items: undefined, props: undefined };
    validate_1.subschemaCode(nextContext, valid);
    return nextContext;
}
exports.applySubschema = applySubschema;
function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
    if (keyword !== undefined && schema !== undefined) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
    }
    if (keyword !== undefined) {
        const sch = it.schema[keyword];
        return schemaProp === undefined
            ? {
                schema: sch,
                schemaPath: codegen_1._ `${it.schemaPath}${codegen_1.getProperty(keyword)}`,
                errSchemaPath: `${it.errSchemaPath}/${keyword}`,
            }
            : {
                schema: sch[schemaProp],
                schemaPath: codegen_1._ `${it.schemaPath}${codegen_1.getProperty(keyword)}${codegen_1.getProperty(schemaProp)}`,
                errSchemaPath: `${it.errSchemaPath}/${keyword}/${util_1.escapeFragment(schemaProp)}`,
            };
    }
    if (schema !== undefined) {
        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
            throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
            schema,
            schemaPath,
            topSchemaRef,
            errSchemaPath,
        };
    }
    throw new Error('either "keyword" or "schema" must be passed');
}
function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
    if (data !== undefined && dataProp !== undefined) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
    }
    const { gen } = it;
    if (dataProp !== undefined) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", codegen_1._ `${it.data}${codegen_1.getProperty(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = codegen_1.str `${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = codegen_1._ `${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
    }
    if (data !== undefined) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true); // replaceable if used once?
        dataContextProps(nextData);
        if (propertyName !== undefined)
            subschema.propertyName = propertyName;
        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
    }
    if (dataTypes)
        subschema.dataTypes = dataTypes;
    function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
    }
}
function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
    if (compositeRule !== undefined)
        subschema.compositeRule = compositeRule;
    if (createErrors !== undefined)
        subschema.createErrors = createErrors;
    if (allErrors !== undefined)
        subschema.allErrors = allErrors;
    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited
    subschema.jtdMetadata = jtdMetadata; // not inherited
}
function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    // let path
    if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax
            ? isNumber
                ? codegen_1._ `"[" + ${dataProp} + "]"`
                : codegen_1._ `"['" + ${dataProp} + "']"`
            : isNumber
                ? codegen_1._ `"/" + ${dataProp}`
                : codegen_1._ `"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`; // TODO maybe use global escapePointer
    }
    return jsPropertySyntax ? codegen_1.getProperty(dataProp).toString() : "/" + util_1.escapeJsonPointer(dataProp);
}


/***/ }),

/***/ "../../node_modules/ajv/dist/compile/ucs2length.js":
/*!*************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/compile/ucs2length.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
function ucs2length(str) {
    const len = str.length;
    let length = 0;
    let pos = 0;
    let value;
    while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 0xd800 && value <= 0xdbff && pos < len) {
            // high surrogate, and there is a next character
            value = str.charCodeAt(pos);
            if ((value & 0xfc00) === 0xdc00)
                pos++; // low surrogate
        }
    }
    return length;
}
exports.default = ucs2length;


/***/ }),

/***/ "../../node_modules/ajv/dist/compile/util.js":
/*!*******************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/compile/util.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.func = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
const codegen_1 = __webpack_require__(/*! ./codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const validate_1 = __webpack_require__(/*! ./validate */ "../../node_modules/ajv/dist/compile/validate/index.js");
// TODO refactor to use Set
function toHash(arr) {
    const hash = {};
    for (const item of arr)
        hash[item] = true;
    return hash;
}
exports.toHash = toHash;
function alwaysValidSchema(it, schema) {
    if (typeof schema == "boolean")
        return schema;
    if (Object.keys(schema).length === 0)
        return true;
    checkUnknownRules(it, schema);
    return !schemaHasRules(schema, it.self.RULES.all);
}
exports.alwaysValidSchema = alwaysValidSchema;
function checkUnknownRules(it, schema = it.schema) {
    const { opts, self } = it;
    if (!opts.strict)
        return;
    if (typeof schema === "boolean")
        return;
    const rules = self.RULES.keywords;
    for (const key in schema) {
        if (!rules[key])
            validate_1.checkStrictMode(it, `unknown keyword: "${key}"`);
    }
}
exports.checkUnknownRules = checkUnknownRules;
function schemaHasRules(schema, rules) {
    if (typeof schema == "boolean")
        return !schema;
    for (const key in schema)
        if (rules[key])
            return true;
    return false;
}
exports.schemaHasRules = schemaHasRules;
function schemaHasRulesButRef(schema, RULES) {
    if (typeof schema == "boolean")
        return !schema;
    for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
            return true;
    return false;
}
exports.schemaHasRulesButRef = schemaHasRulesButRef;
function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
    if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
            return schema;
        if (typeof schema == "string")
            return codegen_1._ `${schema}`;
    }
    return codegen_1._ `${topSchemaRef}${schemaPath}${codegen_1.getProperty(keyword)}`;
}
exports.schemaRefOrVal = schemaRefOrVal;
function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
}
exports.unescapeFragment = unescapeFragment;
function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
}
exports.escapeFragment = escapeFragment;
function escapeJsonPointer(str) {
    if (typeof str == "number")
        return `${str}`;
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
exports.escapeJsonPointer = escapeJsonPointer;
function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
}
exports.unescapeJsonPointer = unescapeJsonPointer;
function eachItem(xs, f) {
    if (Array.isArray(xs)) {
        for (const x of xs)
            f(x);
    }
    else {
        f(xs);
    }
}
exports.eachItem = eachItem;
function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {
    return (gen, from, to, toName) => {
        const res = to === undefined
            ? from
            : to instanceof codegen_1.Name
                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)
                : from instanceof codegen_1.Name
                    ? (mergeToName(gen, to, from), from)
                    : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
    };
}
exports.mergeEvaluated = {
    props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if(codegen_1._ `${to} !== true && ${from} !== undefined`, () => {
            gen.if(codegen_1._ `${from} === true`, () => gen.assign(to, true), () => gen.code(codegen_1._ `Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if(codegen_1._ `${to} !== true`, () => {
            if (from === true) {
                gen.assign(to, true);
            }
            else {
                gen.assign(to, codegen_1._ `${to} || {}`);
                setEvaluated(gen, to, from);
            }
        }),
        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),
        resultToName: evaluatedPropsToName,
    }),
    items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if(codegen_1._ `${to} !== true && ${from} !== undefined`, () => gen.assign(to, codegen_1._ `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if(codegen_1._ `${to} !== true`, () => gen.assign(to, from === true ? true : codegen_1._ `${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),
        resultToName: (gen, items) => gen.var("items", items),
    }),
};
function evaluatedPropsToName(gen, ps) {
    if (ps === true)
        return gen.var("props", true);
    const props = gen.var("props", codegen_1._ `{}`);
    if (ps !== undefined)
        setEvaluated(gen, props, ps);
    return props;
}
exports.evaluatedPropsToName = evaluatedPropsToName;
function setEvaluated(gen, props, ps) {
    Object.keys(ps).forEach((p) => gen.assign(codegen_1._ `${props}${codegen_1.getProperty(p)}`, true));
}
exports.setEvaluated = setEvaluated;
function func(gen, f) {
    return gen.scopeValue("func", {
        ref: f,
        code: f.code,
    });
}
exports.func = func;


/***/ }),

/***/ "../../node_modules/ajv/dist/compile/validate/applicability.js":
/*!*************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/compile/validate/applicability.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
function schemaHasRulesForType({ schema, self }, type) {
    const group = self.RULES.types[type];
    return group && group !== true && shouldUseGroup(schema, group);
}
exports.schemaHasRulesForType = schemaHasRulesForType;
function shouldUseGroup(schema, group) {
    return group.rules.some((rule) => shouldUseRule(schema, rule));
}
exports.shouldUseGroup = shouldUseGroup;
function shouldUseRule(schema, rule) {
    var _a;
    return (schema[rule.keyword] !== undefined ||
        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));
}
exports.shouldUseRule = shouldUseRule;


/***/ }),

/***/ "../../node_modules/ajv/dist/compile/validate/boolSchema.js":
/*!**********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/compile/validate/boolSchema.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
const errors_1 = __webpack_require__(/*! ../errors */ "../../node_modules/ajv/dist/compile/errors.js");
const codegen_1 = __webpack_require__(/*! ../codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const names_1 = __webpack_require__(/*! ../names */ "../../node_modules/ajv/dist/compile/names.js");
const boolError = {
    message: "boolean schema is false",
};
function topBoolOrEmptySchema(it) {
    const { gen, schema, validateName } = it;
    if (schema === false) {
        falseSchemaError(it, false);
    }
    else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
    }
    else {
        gen.assign(codegen_1._ `${validateName}.errors`, null);
        gen.return(true);
    }
}
exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
function boolOrEmptySchema(it, valid) {
    const { gen, schema } = it;
    if (schema === false) {
        gen.var(valid, false); // TODO var
        falseSchemaError(it);
    }
    else {
        gen.var(valid, true); // TODO var
    }
}
exports.boolOrEmptySchema = boolOrEmptySchema;
function falseSchemaError(it, overrideAllErrors) {
    const { gen, data } = it;
    // TODO maybe some other interface should be used for non-keyword validation errors...
    const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it,
    };
    errors_1.reportError(cxt, boolError, overrideAllErrors);
}


/***/ }),

/***/ "../../node_modules/ajv/dist/compile/validate/dataType.js":
/*!********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/compile/validate/dataType.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
const rules_1 = __webpack_require__(/*! ../rules */ "../../node_modules/ajv/dist/compile/rules.js");
const applicability_1 = __webpack_require__(/*! ./applicability */ "../../node_modules/ajv/dist/compile/validate/applicability.js");
const errors_1 = __webpack_require__(/*! ../errors */ "../../node_modules/ajv/dist/compile/errors.js");
const codegen_1 = __webpack_require__(/*! ../codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__(/*! ../util */ "../../node_modules/ajv/dist/compile/util.js");
var DataType;
(function (DataType) {
    DataType[DataType["Correct"] = 0] = "Correct";
    DataType[DataType["Wrong"] = 1] = "Wrong";
})(DataType = exports.DataType || (exports.DataType = {}));
function getSchemaTypes(schema) {
    const types = getJSONTypes(schema.type);
    const hasNull = types.includes("null");
    if (hasNull) {
        if (schema.nullable === false)
            throw new Error("type: null contradicts nullable: false");
    }
    else {
        if (!types.length && schema.nullable !== undefined) {
            throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
            types.push("null");
    }
    return types;
}
exports.getSchemaTypes = getSchemaTypes;
function getJSONTypes(ts) {
    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types.every(rules_1.isJSONType))
        return types;
    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
}
exports.getJSONTypes = getJSONTypes;
function coerceAndCheckDataType(it, types) {
    const { gen, data, opts } = it;
    const coerceTo = coerceToTypes(types, opts.coerceTypes);
    const checkTypes = types.length > 0 &&
        !(coerceTo.length === 0 && types.length === 1 && applicability_1.schemaHasRulesForType(it, types[0]));
    if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strict, DataType.Wrong);
        gen.if(wrongType, () => {
            if (coerceTo.length)
                coerceData(it, types, coerceTo);
            else
                reportTypeError(it);
        });
    }
    return checkTypes;
}
exports.coerceAndCheckDataType = coerceAndCheckDataType;
const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
function coerceToTypes(types, coerceTypes) {
    return coerceTypes
        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === "array" && t === "array"))
        : [];
}
function coerceData(it, types, coerceTo) {
    const { gen, data, opts } = it;
    const dataType = gen.let("dataType", codegen_1._ `typeof ${data}`);
    const coerced = gen.let("coerced", codegen_1._ `undefined`);
    if (opts.coerceTypes === "array") {
        gen.if(codegen_1._ `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen
            .assign(data, codegen_1._ `${data}[0]`)
            .assign(dataType, codegen_1._ `typeof ${data}`)
            .if(checkDataTypes(types, data, opts.strict), () => gen.assign(coerced, data)));
    }
    gen.if(codegen_1._ `${coerced} !== undefined`);
    for (const t of coerceTo) {
        if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {
            coerceSpecificType(t);
        }
    }
    gen.else();
    reportTypeError(it);
    gen.endIf();
    gen.if(codegen_1._ `${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
    });
    function coerceSpecificType(t) {
        switch (t) {
            case "string":
                gen
                    .elseIf(codegen_1._ `${dataType} == "number" || ${dataType} == "boolean"`)
                    .assign(coerced, codegen_1._ `"" + ${data}`)
                    .elseIf(codegen_1._ `${data} === null`)
                    .assign(coerced, codegen_1._ `""`);
                return;
            case "number":
                gen
                    .elseIf(codegen_1._ `${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`)
                    .assign(coerced, codegen_1._ `+${data}`);
                return;
            case "integer":
                gen
                    .elseIf(codegen_1._ `${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`)
                    .assign(coerced, codegen_1._ `+${data}`);
                return;
            case "boolean":
                gen
                    .elseIf(codegen_1._ `${data} === "false" || ${data} === 0 || ${data} === null`)
                    .assign(coerced, false)
                    .elseIf(codegen_1._ `${data} === "true" || ${data} === 1`)
                    .assign(coerced, true);
                return;
            case "null":
                gen.elseIf(codegen_1._ `${data} === "" || ${data} === 0 || ${data} === false`);
                gen.assign(coerced, null);
                return;
            case "array":
                gen
                    .elseIf(codegen_1._ `${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`)
                    .assign(coerced, codegen_1._ `[${data}]`);
        }
    }
}
function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    // TODO use gen.property
    gen.if(codegen_1._ `${parentData} !== undefined`, () => gen.assign(codegen_1._ `${parentData}[${parentDataProperty}]`, expr));
}
function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
    let cond;
    switch (dataType) {
        case "null":
            return codegen_1._ `${data} ${EQ} null`;
        case "array":
            cond = codegen_1._ `Array.isArray(${data})`;
            break;
        case "object":
            cond = codegen_1._ `${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
            break;
        case "integer":
            cond = numCond(codegen_1._ `!(${data} % 1) && !isNaN(${data})`);
            break;
        case "number":
            cond = numCond();
            break;
        default:
            return codegen_1._ `typeof ${data} ${EQ} ${dataType}`;
    }
    return correct === DataType.Correct ? cond : codegen_1.not(cond);
    function numCond(_cond = codegen_1.nil) {
        return codegen_1.and(codegen_1._ `typeof ${data} == "number"`, _cond, strictNums ? codegen_1._ `isFinite(${data})` : codegen_1.nil);
    }
}
exports.checkDataType = checkDataType;
function checkDataTypes(dataTypes, data, strictNums, correct) {
    if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
    }
    let cond;
    const types = util_1.toHash(dataTypes);
    if (types.array && types.object) {
        const notObj = codegen_1._ `typeof ${data} != "object"`;
        cond = types.null ? notObj : codegen_1._ `!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
    }
    else {
        cond = codegen_1.nil;
    }
    if (types.number)
        delete types.integer;
    for (const t in types)
        cond = codegen_1.and(cond, checkDataType(t, data, strictNums, correct));
    return cond;
}
exports.checkDataTypes = checkDataTypes;
const typeError = {
    message: ({ schema }) => codegen_1.str `should be ${schema}`,
    params: ({ schema, schemaValue }) => typeof schema == "string" ? codegen_1._ `{type: ${schema}}` : codegen_1._ `{type: ${schemaValue}}`,
};
function reportTypeError(it) {
    const cxt = getTypeErrorContext(it);
    errors_1.reportError(cxt, typeError);
}
exports.reportTypeError = reportTypeError;
function getTypeErrorContext(it) {
    const { gen, data, schema } = it;
    const schemaCode = util_1.schemaRefOrVal(it, schema, "type");
    return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it,
    };
}


/***/ }),

/***/ "../../node_modules/ajv/dist/compile/validate/defaults.js":
/*!********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/compile/validate/defaults.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.assignDefaults = void 0;
const codegen_1 = __webpack_require__(/*! ../codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const _1 = __webpack_require__(/*! . */ "../../node_modules/ajv/dist/compile/validate/index.js");
function assignDefaults(it, ty) {
    const { properties, items } = it.schema;
    if (ty === "object" && properties) {
        for (const key in properties) {
            assignDefault(it, key, properties[key].default);
        }
    }
    else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
    }
}
exports.assignDefaults = assignDefaults;
function assignDefault(it, prop, defaultValue) {
    const { gen, compositeRule, data, opts } = it;
    if (defaultValue === undefined)
        return;
    const childData = codegen_1._ `${data}${codegen_1.getProperty(prop)}`;
    if (compositeRule) {
        _1.checkStrictMode(it, `default is ignored for: ${childData}`);
        return;
    }
    let condition = codegen_1._ `${childData} === undefined`;
    if (opts.useDefaults === "empty") {
        condition = codegen_1._ `${condition} || ${childData} === null || ${childData} === ""`;
    }
    // `${childData} === undefined` +
    // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
    gen.if(condition, codegen_1._ `${childData} = ${codegen_1.stringify(defaultValue)}`);
}


/***/ }),

/***/ "../../node_modules/ajv/dist/compile/validate/index.js":
/*!*****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/compile/validate/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.checkStrictMode = exports.schemaCxtHasRules = exports.subschemaCode = exports.validateFunctionCode = void 0;
const boolSchema_1 = __webpack_require__(/*! ./boolSchema */ "../../node_modules/ajv/dist/compile/validate/boolSchema.js");
const dataType_1 = __webpack_require__(/*! ./dataType */ "../../node_modules/ajv/dist/compile/validate/dataType.js");
const iterate_1 = __webpack_require__(/*! ./iterate */ "../../node_modules/ajv/dist/compile/validate/iterate.js");
const codegen_1 = __webpack_require__(/*! ../codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const names_1 = __webpack_require__(/*! ../names */ "../../node_modules/ajv/dist/compile/names.js");
const resolve_1 = __webpack_require__(/*! ../resolve */ "../../node_modules/ajv/dist/compile/resolve.js");
const util_1 = __webpack_require__(/*! ../util */ "../../node_modules/ajv/dist/compile/util.js");
// schema compilation - generates validation function, subschemaCode (below) is used for subschemas
function validateFunctionCode(it) {
    if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
            topSchemaObjCode(it);
            return;
        }
    }
    validateFunction(it, () => boolSchema_1.topBoolOrEmptySchema(it));
}
exports.validateFunctionCode = validateFunctionCode;
function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
    if (opts.code.es5) {
        gen.func(validateName, codegen_1._ `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
            gen.code(codegen_1._ `"use strict"; ${funcSourceUrl(schema, opts)}`);
            destructureValCxtES5(gen, opts);
            gen.code(body);
        });
    }
    else {
        gen.func(validateName, codegen_1._ `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
    }
}
function destructureValCxt(opts) {
    return codegen_1._ `{${names_1.default.dataPath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? codegen_1._ `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
}
function destructureValCxtES5(gen, opts) {
    gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.dataPath, codegen_1._ `${names_1.default.valCxt}.${names_1.default.dataPath}`);
        gen.var(names_1.default.parentData, codegen_1._ `${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, codegen_1._ `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, codegen_1._ `${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
            gen.var(names_1.default.dynamicAnchors, codegen_1._ `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
    }, () => {
        gen.var(names_1.default.dataPath, codegen_1._ `""`);
        gen.var(names_1.default.parentData, codegen_1._ `undefined`);
        gen.var(names_1.default.parentDataProperty, codegen_1._ `undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
            gen.var(names_1.default.dynamicAnchors, codegen_1._ `{}`);
    });
}
function topSchemaObjCode(it) {
    const { schema, opts, gen } = it;
    validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
            commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
            resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
    });
    return;
}
function resetEvaluated(it) {
    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
    const { gen, validateName } = it;
    it.evaluated = gen.const("evaluated", codegen_1._ `${validateName}.evaluated`);
    gen.if(codegen_1._ `${it.evaluated}.dynamicProps`, () => gen.assign(codegen_1._ `${it.evaluated}.props`, codegen_1._ `undefined`));
    gen.if(codegen_1._ `${it.evaluated}.dynamicItems`, () => gen.assign(codegen_1._ `${it.evaluated}.items`, codegen_1._ `undefined`));
}
function funcSourceUrl(schema, opts) {
    return typeof schema == "object" && schema.$id && (opts.code.source || opts.code.process)
        ? codegen_1._ `/*# sourceURL=${schema.$id} */`
        : codegen_1.nil;
}
// schema compilation - this function is used recursively to generate code for sub-schemas
function subschemaCode(it, valid) {
    if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
            subSchemaObjCode(it, valid);
            return;
        }
    }
    boolSchema_1.boolOrEmptySchema(it, valid);
}
exports.subschemaCode = subschemaCode;
function schemaCxtHasRules({ schema, self }) {
    if (typeof schema == "boolean")
        return !schema;
    for (const key in schema)
        if (self.RULES.all[key])
            return true;
    return false;
}
exports.schemaCxtHasRules = schemaCxtHasRules;
function isSchemaObj(it) {
    return typeof it.schema != "boolean";
}
function subSchemaObjCode(it, valid) {
    const { schema, gen, opts } = it;
    if (opts.$comment && schema.$comment)
        commentKeyword(it);
    updateContext(it);
    checkAsync(it);
    const errsCount = gen.const("_errs", names_1.default.errors);
    typeAndKeywords(it, errsCount);
    // TODO var
    gen.var(valid, codegen_1._ `${errsCount} === ${names_1.default.errors}`);
}
function checkKeywords(it) {
    util_1.checkUnknownRules(it);
    checkRefsAndKeywords(it);
}
function typeAndKeywords(it, errsCount) {
    if (it.opts.jtd)
        return iterate_1.schemaKeywords(it, [], false, errsCount);
    const types = dataType_1.getSchemaTypes(it.schema);
    const checkedTypes = dataType_1.coerceAndCheckDataType(it, types);
    iterate_1.schemaKeywords(it, types, !checkedTypes, errsCount);
}
function checkRefsAndKeywords(it) {
    const { schema, errSchemaPath, opts, self } = it;
    if (schema.$ref && opts.ignoreKeywordsWithRef && util_1.schemaHasRulesButRef(schema, self.RULES)) {
        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
    }
}
function checkNoDefault(it) {
    const { schema, opts } = it;
    if (schema.default !== undefined && opts.useDefaults && opts.strict) {
        checkStrictMode(it, "default is ignored in the schema root");
    }
}
function updateContext(it) {
    if (it.schema.$id)
        it.baseId = resolve_1.resolveUrl(it.baseId, it.schema.$id);
}
function checkAsync(it) {
    if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
}
function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
    const msg = schema.$comment;
    if (opts.$comment === true) {
        gen.code(codegen_1._ `${names_1.default.self}.logger.log(${msg})`);
    }
    else if (typeof opts.$comment == "function") {
        const schemaPath = codegen_1.str `${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code(codegen_1._ `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
    }
}
function returnResults(it) {
    const { gen, schemaEnv, validateName, ValidationError, opts } = it;
    if (schemaEnv.$async) {
        // TODO assign unevaluated
        gen.if(codegen_1._ `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw(codegen_1._ `new ${ValidationError}(${names_1.default.vErrors})`));
    }
    else {
        gen.assign(codegen_1._ `${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
            assignEvaluated(it);
        gen.return(codegen_1._ `${names_1.default.errors} === 0`);
    }
}
function assignEvaluated({ gen, evaluated, props, items }) {
    if (props instanceof codegen_1.Name)
        gen.assign(codegen_1._ `${evaluated}.props`, props);
    if (items instanceof codegen_1.Name)
        gen.assign(codegen_1._ `${evaluated}.items`, items);
}
function checkStrictMode(it, msg, mode = it.opts.strict) {
    if (!mode)
        return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
        throw new Error(msg);
    it.self.logger.warn(msg);
}
exports.checkStrictMode = checkStrictMode;


/***/ }),

/***/ "../../node_modules/ajv/dist/compile/validate/iterate.js":
/*!*******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/compile/validate/iterate.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.schemaKeywords = void 0;
const applicability_1 = __webpack_require__(/*! ./applicability */ "../../node_modules/ajv/dist/compile/validate/applicability.js");
const dataType_1 = __webpack_require__(/*! ./dataType */ "../../node_modules/ajv/dist/compile/validate/dataType.js");
const defaults_1 = __webpack_require__(/*! ./defaults */ "../../node_modules/ajv/dist/compile/validate/defaults.js");
const keyword_1 = __webpack_require__(/*! ./keyword */ "../../node_modules/ajv/dist/compile/validate/keyword.js");
const util_1 = __webpack_require__(/*! ../util */ "../../node_modules/ajv/dist/compile/util.js");
const _1 = __webpack_require__(/*! . */ "../../node_modules/ajv/dist/compile/validate/index.js");
const codegen_1 = __webpack_require__(/*! ../codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const names_1 = __webpack_require__(/*! ../names */ "../../node_modules/ajv/dist/compile/names.js");
function schemaKeywords(it, types, typeErrors, errsCount) {
    const { gen, schema, data, allErrors, opts, self } = it;
    const { RULES } = self;
    if (schema.$ref && (opts.ignoreKeywordsWithRef || !util_1.schemaHasRulesButRef(schema, RULES))) {
        gen.block(() => keyword_1.keywordCode(it, "$ref", RULES.all.$ref.definition)); // TODO typecast
        return;
    }
    if (!opts.jtd)
        checkStrictTypes(it, types);
    gen.block(() => {
        for (const group of RULES.rules)
            groupKeywords(group);
        groupKeywords(RULES.post);
    });
    function groupKeywords(group) {
        if (!applicability_1.shouldUseGroup(schema, group))
            return;
        if (group.type) {
            gen.if(dataType_1.checkDataType(group.type, data, opts.strict));
            iterateKeywords(it, group);
            if (types.length === 1 && types[0] === group.type && typeErrors) {
                gen.else();
                dataType_1.reportTypeError(it);
            }
            gen.endIf();
        }
        else {
            iterateKeywords(it, group);
        }
        // TODO make it "ok" call?
        if (!allErrors)
            gen.if(codegen_1._ `${names_1.default.errors} === ${errsCount || 0}`);
    }
}
exports.schemaKeywords = schemaKeywords;
function iterateKeywords(it, group) {
    const { gen, schema, opts: { useDefaults }, } = it;
    if (useDefaults)
        defaults_1.assignDefaults(it, group.type);
    gen.block(() => {
        for (const rule of group.rules) {
            if (applicability_1.shouldUseRule(schema, rule)) {
                keyword_1.keywordCode(it, rule.keyword, rule.definition, group.type);
            }
        }
    });
}
function checkStrictTypes(it, types) {
    if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
    checkContextTypes(it, types);
    if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
    checkKeywordTypes(it, it.dataTypes);
}
function checkContextTypes(it, types) {
    if (!types.length)
        return;
    if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
    }
    types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
            strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
    });
    it.dataTypes = it.dataTypes.filter((t) => includesType(types, t));
}
function checkMultipleTypes(it, ts) {
    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
    }
}
function checkKeywordTypes(it, ts) {
    const rules = it.self.RULES.all;
    for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && applicability_1.shouldUseRule(it.schema, rule)) {
            const { type } = rule.definition;
            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
                strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
            }
        }
    }
}
function hasApplicableType(schTs, kwdT) {
    return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"));
}
function includesType(ts, t) {
    return ts.includes(t) || (t === "integer" && ts.includes("number"));
}
function strictTypesError(it, msg) {
    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
    msg += ` at "${schemaPath}" (strictTypes)`;
    _1.checkStrictMode(it, msg, it.opts.strictTypes);
}


/***/ }),

/***/ "../../node_modules/ajv/dist/compile/validate/keyword.js":
/*!*******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/compile/validate/keyword.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.keywordCode = void 0;
const context_1 = __webpack_require__(/*! ../context */ "../../node_modules/ajv/dist/compile/context.js");
const errors_1 = __webpack_require__(/*! ../errors */ "../../node_modules/ajv/dist/compile/errors.js");
const code_1 = __webpack_require__(/*! ../../vocabularies/code */ "../../node_modules/ajv/dist/vocabularies/code.js");
const codegen_1 = __webpack_require__(/*! ../codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const names_1 = __webpack_require__(/*! ../names */ "../../node_modules/ajv/dist/compile/names.js");
function keywordCode(it, keyword, def, ruleType) {
    const cxt = new context_1.default(it, def, keyword);
    if ("code" in def) {
        def.code(cxt, ruleType);
    }
    else if (cxt.$data && def.validate) {
        funcKeywordCode(cxt, def);
    }
    else if ("macro" in def) {
        macroKeywordCode(cxt, def);
    }
    else if (def.compile || def.validate) {
        funcKeywordCode(cxt, def);
    }
}
exports.keywordCode = keywordCode;
function macroKeywordCode(cxt, def) {
    const { gen, keyword, schema, parentSchema, it } = cxt;
    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
    const schemaRef = useKeyword(gen, keyword, macroSchema);
    if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
    const valid = gen.name("valid");
    cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true,
    }, valid);
    cxt.pass(valid, () => cxt.error(true));
}
function funcKeywordCode(cxt, def) {
    var _a;
    const { gen, keyword, schema, parentSchema, $data, it } = cxt;
    checkAsync(it, def);
    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
    const validateRef = useKeyword(gen, keyword, validate);
    const valid = gen.let("valid");
    cxt.block$data(valid, validateKeyword);
    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
    function validateKeyword() {
        if (def.errors === false) {
            assignValid();
            if (def.modifying)
                modifyData(cxt);
            reportErrs(() => cxt.error());
        }
        else {
            const ruleErrs = def.async ? validateAsync() : validateSync();
            if (def.modifying)
                modifyData(cxt);
            reportErrs(() => addErrs(cxt, ruleErrs));
        }
    }
    function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid(codegen_1._ `await `), (e) => gen.assign(valid, false).if(codegen_1._ `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, codegen_1._ `${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
    }
    function validateSync() {
        const validateErrs = codegen_1._ `${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
    }
    function assignValid(_await = def.async ? codegen_1._ `await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !(("compile" in def && !$data) || def.schema === false);
        gen.assign(valid, codegen_1._ `${_await}${code_1.callValidateCode(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
    }
    function reportErrs(errors) {
        var _a;
        gen.if(codegen_1.not((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);
    }
}
function modifyData(cxt) {
    const { gen, data, it } = cxt;
    gen.if(it.parentData, () => gen.assign(data, codegen_1._ `${it.parentData}[${it.parentDataProperty}]`));
}
function addErrs(cxt, errs) {
    const { gen } = cxt;
    gen.if(codegen_1._ `Array.isArray(${errs})`, () => {
        gen
            .assign(names_1.default.vErrors, codegen_1._ `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)
            .assign(names_1.default.errors, codegen_1._ `${names_1.default.vErrors}.length`);
        errors_1.extendErrors(cxt);
    }, () => cxt.error());
}
function checkAsync({ schemaEnv }, def) {
    if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
}
function useKeyword(gen, keyword, result) {
    if (result === undefined)
        throw new Error(`keyword "${keyword}" failed to compile`);
    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: codegen_1.stringify(result) });
}


/***/ }),

/***/ "../../node_modules/ajv/dist/core.js":
/*!***********************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/core.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
const context_1 = __webpack_require__(/*! ./compile/context */ "../../node_modules/ajv/dist/compile/context.js");
exports.KeywordCxt = context_1.default;
var codegen_1 = __webpack_require__(/*! ./compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
const error_classes_1 = __webpack_require__(/*! ./compile/error_classes */ "../../node_modules/ajv/dist/compile/error_classes.js");
const rules_1 = __webpack_require__(/*! ./compile/rules */ "../../node_modules/ajv/dist/compile/rules.js");
const compile_1 = __webpack_require__(/*! ./compile */ "../../node_modules/ajv/dist/compile/index.js");
const codegen_2 = __webpack_require__(/*! ./compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const resolve_1 = __webpack_require__(/*! ./compile/resolve */ "../../node_modules/ajv/dist/compile/resolve.js");
const dataType_1 = __webpack_require__(/*! ./compile/validate/dataType */ "../../node_modules/ajv/dist/compile/validate/dataType.js");
const util_1 = __webpack_require__(/*! ./compile/util */ "../../node_modules/ajv/dist/compile/util.js");
const $dataRefSchema = __webpack_require__(/*! ./refs/data.json */ "../../node_modules/ajv/dist/refs/data.json");
const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
const EXT_SCOPE_NAMES = new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error",
]);
const removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    schemaId: "JSON Schema draft-04 is not supported in Ajv v7.",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    strictNumbers: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
};
const deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.',
};
function requiredOptions(o) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const strict = (_a = o.strict) !== null && _a !== void 0 ? _a : true;
    const strictLog = strict ? "log" : false;
    const _optz = (_b = o.code) === null || _b === void 0 ? void 0 : _b.optimize;
    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
    return {
        strict,
        strictTypes: (_c = o.strictTypes) !== null && _c !== void 0 ? _c : strictLog,
        strictTuples: (_d = o.strictTuples) !== null && _d !== void 0 ? _d : strictLog,
        code: o.code ? { ...o.code, optimize } : { optimize },
        loopRequired: (_e = o.loopRequired) !== null && _e !== void 0 ? _e : Infinity,
        loopEnum: (_f = o.loopEnum) !== null && _f !== void 0 ? _f : Infinity,
        meta: (_g = o.meta) !== null && _g !== void 0 ? _g : true,
        messages: (_h = o.messages) !== null && _h !== void 0 ? _h : true,
        inlineRefs: (_j = o.inlineRefs) !== null && _j !== void 0 ? _j : true,
        addUsedSchema: (_k = o.addUsedSchema) !== null && _k !== void 0 ? _k : true,
        validateSchema: (_l = o.validateSchema) !== null && _l !== void 0 ? _l : true,
        validateFormats: (_m = o.validateFormats) !== null && _m !== void 0 ? _m : true,
    };
}
class Ajv {
    constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = new Set();
        this._loading = {};
        this._cache = new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = rules_1.getRules();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
            addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
            addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
            this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
        this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
        const { $data, meta } = this.opts;
        if (meta && $data)
            this.addMetaSchema($dataRefSchema, $dataRefSchema.$id, false);
    }
    defaultMeta() {
        const { meta } = this.opts;
        return (this.opts.defaultMeta = typeof meta == "object" ? meta.$id || meta : undefined);
    }
    validate(schemaKeyRef, // key, ref or schema object
    data // to be validated
    ) {
        let v;
        if (typeof schemaKeyRef == "string") {
            v = this.getSchema(schemaKeyRef);
            if (!v)
                throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        }
        else {
            v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
            this.errors = v.errors;
        return valid;
    }
    compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return (sch.validate || this._compileSchemaEnv(sch));
    }
    compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
            throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
            await loadMetaSchema.call(this, _schema.$schema);
            const sch = this._addSchema(_schema, _meta);
            return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
            if ($ref && !this.getSchema($ref)) {
                await runCompileAsync.call(this, { $ref }, true);
            }
        }
        async function _compileAsync(sch) {
            try {
                return this._compileSchemaEnv(sch);
            }
            catch (e) {
                if (!(e instanceof error_classes_1.MissingRefError))
                    throw e;
                checkLoaded.call(this, e);
                await loadMissingSchema.call(this, e.missingSchema);
                return _compileAsync.call(this, sch);
            }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
            if (this.refs[ref]) {
                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
            }
        }
        async function loadMissingSchema(ref) {
            const _schema = await _loadSchema.call(this, ref);
            if (!this.refs[ref])
                await loadMetaSchema.call(this, _schema.$schema);
            if (!this.refs[ref])
                this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
            const p = this._loading[ref];
            if (p)
                return p;
            try {
                return await (this._loading[ref] = loadSchema(ref));
            }
            finally {
                delete this._loading[ref];
            }
        }
    }
    // Adds schema to the instance
    addSchema(schema, // If array is passed, `key` will be ignored
    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
    ) {
        if (Array.isArray(schema)) {
            for (const sch of schema)
                this.addSchema(sch, undefined, _meta, _validateSchema);
            return this;
        }
        let id;
        if (typeof schema === "object") {
            id = schema.$id;
            if (id !== undefined && typeof id != "string")
                throw new Error("schema id must be string");
        }
        key = resolve_1.normalizeId(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, _validateSchema, true);
        return this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(schema, key, // schema key
    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
    ) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
    }
    //  Validate schema against its meta-schema
    validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
            return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== undefined && typeof $schema != "string") {
            throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
            this.logger.warn("meta-schema not available");
            this.errors = null;
            return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
            const message = "schema is invalid: " + this.errorsText();
            if (this.opts.validateSchema === "log")
                this.logger.error(message);
            else
                throw new Error(message);
        }
        return valid;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
            keyRef = sch;
        if (sch === undefined) {
            const root = new compile_1.SchemaEnv({ schema: {} });
            sch = compile_1.resolveSchema.call(this, root, keyRef);
            if (!sch)
                return;
            this.refs[keyRef] = sch;
        }
        return (sch.validate || this._compileSchemaEnv(sch));
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
            this._removeAllSchemas(this.schemas, schemaKeyRef);
            this._removeAllSchemas(this.refs, schemaKeyRef);
            return this;
        }
        switch (typeof schemaKeyRef) {
            case "undefined":
                this._removeAllSchemas(this.schemas);
                this._removeAllSchemas(this.refs);
                this._cache.clear();
                return this;
            case "string": {
                const sch = getSchEnv.call(this, schemaKeyRef);
                if (typeof sch == "object")
                    this._cache.delete(sch.schema);
                delete this.schemas[schemaKeyRef];
                delete this.refs[schemaKeyRef];
                return this;
            }
            case "object": {
                const cacheKey = schemaKeyRef;
                this._cache.delete(cacheKey);
                let id = schemaKeyRef.$id;
                if (id) {
                    id = resolve_1.normalizeId(id);
                    delete this.schemas[id];
                    delete this.refs[id];
                }
                return this;
            }
            default:
                throw new Error("ajv.removeSchema: invalid parameter");
        }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(definitions) {
        for (const def of definitions)
            this.addKeyword(def);
        return this;
    }
    addKeyword(kwdOrDef, def // deprecated
    ) {
        let keyword;
        if (typeof kwdOrDef == "string") {
            keyword = kwdOrDef;
            if (typeof def == "object") {
                this.logger.warn("these parameters are deprecated, see docs for addKeyword");
                def.keyword = keyword;
            }
        }
        else if (typeof kwdOrDef == "object" && def === undefined) {
            def = kwdOrDef;
            keyword = def.keyword;
            if (Array.isArray(keyword) && !keyword.length) {
                throw new Error("addKeywords: keyword must be string or non-empty array");
            }
        }
        else {
            throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
            util_1.eachItem(keyword, (kwd) => addRule.call(this, kwd));
            return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
            ...def,
            type: dataType_1.getJSONTypes(def.type),
            schemaType: dataType_1.getJSONTypes(def.schemaType),
        };
        util_1.eachItem(keyword, definition.type.length === 0
            ? (k) => addRule.call(this, k, definition)
            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
    }
    getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
    }
    // Remove keyword
    removeKeyword(keyword) {
        // TODO return type should be Ajv
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
            const i = group.rules.findIndex((rule) => rule.keyword === keyword);
            if (i >= 0)
                group.rules.splice(i, 1);
        }
        return this;
    }
    // Add format
    addFormat(name, format) {
        if (typeof format == "string")
            format = new RegExp(format);
        this.formats[name] = format;
        return this;
    }
    errorsText(errors = this.errors, // optional array of validation errors
    { separator = ", ", dataVar = "data" } = {} // optional options with properties `separator` and `dataVar`
    ) {
        if (!errors || errors.length === 0)
            return "No errors";
        return errors
            .map((e) => `${dataVar}${e.dataPath} ${e.message}`)
            .reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
            const segments = jsonPointer.split("/").slice(1); // first segment is an empty string
            let keywords = metaSchema;
            for (const seg of segments)
                keywords = keywords[seg];
            for (const key in rules) {
                const rule = rules[key];
                if (typeof rule != "object")
                    continue;
                const { $data } = rule.definition;
                const schema = keywords[key];
                if ($data && schema)
                    keywords[key] = schemaOrData(schema);
            }
        }
        return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
            const sch = schemas[keyRef];
            if (!regex || regex.test(keyRef)) {
                if (typeof sch == "string") {
                    delete schemas[keyRef];
                }
                else if (sch && !sch.meta) {
                    this._cache.delete(sch.schema);
                    delete schemas[keyRef];
                }
            }
        }
    }
    _addSchema(schema, meta, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        if (typeof schema != "object") {
            if (this.opts.jtd)
                throw new Error("schema must be object");
            else if (typeof schema != "boolean")
                throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== undefined)
            return sch;
        const localRefs = resolve_1.getSchemaRefs.call(this, schema);
        sch = new compile_1.SchemaEnv({ schema, meta, localRefs });
        this._cache.set(sch.schema, sch);
        const id = sch.baseId;
        if (addSchema && !id.startsWith("#")) {
            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
            if (id)
                this._checkUnique(id);
            this.refs[id] = sch;
        }
        if (validateSchema)
            this.validateSchema(schema, true);
        return sch;
    }
    _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
            throw new Error(`schema with key or id "${id}" already exists`);
        }
    }
    _compileSchemaEnv(sch) {
        if (sch.meta)
            this._compileMetaSchema(sch);
        else
            compile_1.compileSchema.call(this, sch);
        /* istanbul ignore if */
        if (!sch.validate)
            throw new Error("ajv implementation error");
        return sch.validate;
    }
    _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
            compile_1.compileSchema.call(this, sch);
        }
        finally {
            this.opts = currentOpts;
        }
    }
}
exports.default = Ajv;
Ajv.ValidationError = error_classes_1.ValidationError;
Ajv.MissingRefError = error_classes_1.MissingRefError;
function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
}
function getSchEnv(keyRef) {
    keyRef = resolve_1.normalizeId(keyRef); // TODO tests fail without this line
    return this.schemas[keyRef] || this.refs[keyRef];
}
function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
        return;
    if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
    else
        for (const key in optsSchemas)
            this.addSchema(optsSchemas[key], key);
}
function addInitialFormats() {
    for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
            this.addFormat(name, format);
    }
}
function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
            def.keyword = keyword;
        this.addKeyword(def);
    }
}
function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
    return metaOpts;
}
const noLogs = { log() { }, warn() { }, error() { } };
function getLogger(logger) {
    if (logger === false)
        return noLogs;
    if (logger === undefined)
        return console;
    if (logger.log && logger.warn && logger.error)
        return logger;
    throw new Error("logger must implement log, warn and error methods");
}
const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
function checkKeyword(keyword, def) {
    const { RULES } = this;
    util_1.eachItem(keyword, (kwd) => {
        if (RULES.keywords[kwd])
            throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
            throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def)
        return;
    if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
    }
}
function addRule(keyword, definition, dataType) {
    var _a;
    const post = definition === null || definition === void 0 ? void 0 : definition.post;
    if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
    if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword] = true;
    if (!definition)
        return;
    const rule = {
        keyword,
        definition: {
            ...definition,
            type: dataType_1.getJSONTypes(definition.type),
            schemaType: dataType_1.getJSONTypes(definition.schemaType),
        },
    };
    if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
        ruleGroup.rules.push(rule);
    RULES.all[keyword] = rule;
    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
}
function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
    }
    else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
    }
}
function keywordMetaschema(def) {
    let { metaSchema } = def;
    if (metaSchema === undefined)
        return;
    if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
    def.validateSchema = this.compile(metaSchema, true);
}
const $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
};
function schemaOrData(schema) {
    return { anyOf: [schema, $dataRef] };
}


/***/ }),

/***/ "../../node_modules/ajv/dist/refs/data.json":
/*!******************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/refs/data.json ***!
  \******************************************************************/
/*! exports provided: $id, description, type, required, properties, additionalProperties, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"$id\":\"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\"description\":\"Meta-schema for $data reference (JSON AnySchema extension proposal)\",\"type\":\"object\",\"required\":[\"$data\"],\"properties\":{\"$data\":{\"type\":\"string\",\"anyOf\":[{\"format\":\"relative-json-pointer\"},{\"format\":\"json-pointer\"}]}},\"additionalProperties\":false}");

/***/ }),

/***/ "../../node_modules/ajv/dist/refs/json-schema-draft-07.json":
/*!**********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/refs/json-schema-draft-07.json ***!
  \**********************************************************************************/
/*! exports provided: $schema, $id, title, definitions, type, properties, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"$id\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"Core schema meta-schema\",\"definitions\":{\"schemaArray\":{\"type\":\"array\",\"minItems\":1,\"items\":{\"$ref\":\"#\"}},\"nonNegativeInteger\":{\"type\":\"integer\",\"minimum\":0},\"nonNegativeIntegerDefault0\":{\"allOf\":[{\"$ref\":\"#/definitions/nonNegativeInteger\"},{\"default\":0}]},\"simpleTypes\":{\"enum\":[\"array\",\"boolean\",\"integer\",\"null\",\"number\",\"object\",\"string\"]},\"stringArray\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"uniqueItems\":true,\"default\":[]}},\"type\":[\"object\",\"boolean\"],\"properties\":{\"$id\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$schema\":{\"type\":\"string\",\"format\":\"uri\"},\"$ref\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$comment\":{\"type\":\"string\"},\"title\":{\"type\":\"string\"},\"description\":{\"type\":\"string\"},\"default\":true,\"readOnly\":{\"type\":\"boolean\",\"default\":false},\"examples\":{\"type\":\"array\",\"items\":true},\"multipleOf\":{\"type\":\"number\",\"exclusiveMinimum\":0},\"maximum\":{\"type\":\"number\"},\"exclusiveMaximum\":{\"type\":\"number\"},\"minimum\":{\"type\":\"number\"},\"exclusiveMinimum\":{\"type\":\"number\"},\"maxLength\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minLength\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"pattern\":{\"type\":\"string\",\"format\":\"regex\"},\"additionalItems\":{\"$ref\":\"#\"},\"items\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/schemaArray\"}],\"default\":true},\"maxItems\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minItems\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"uniqueItems\":{\"type\":\"boolean\",\"default\":false},\"contains\":{\"$ref\":\"#\"},\"maxProperties\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minProperties\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"required\":{\"$ref\":\"#/definitions/stringArray\"},\"additionalProperties\":{\"$ref\":\"#\"},\"definitions\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"properties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"patternProperties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"propertyNames\":{\"format\":\"regex\"},\"default\":{}},\"dependencies\":{\"type\":\"object\",\"additionalProperties\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/stringArray\"}]}},\"propertyNames\":{\"$ref\":\"#\"},\"const\":true,\"enum\":{\"type\":\"array\",\"items\":true,\"minItems\":1,\"uniqueItems\":true},\"type\":{\"anyOf\":[{\"$ref\":\"#/definitions/simpleTypes\"},{\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/simpleTypes\"},\"minItems\":1,\"uniqueItems\":true}]},\"format\":{\"type\":\"string\"},\"contentMediaType\":{\"type\":\"string\"},\"contentEncoding\":{\"type\":\"string\"},\"if\":{\"$ref\":\"#\"},\"then\":{\"$ref\":\"#\"},\"else\":{\"$ref\":\"#\"},\"allOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"anyOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"oneOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"not\":{\"$ref\":\"#\"}},\"default\":true}");

/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/additionalItems.js":
/*!**********************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = __webpack_require__(/*! ../../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const subschema_1 = __webpack_require__(/*! ../../compile/subschema */ "../../node_modules/ajv/dist/compile/subschema.js");
const util_1 = __webpack_require__(/*! ../../compile/util */ "../../node_modules/ajv/dist/compile/util.js");
const validate_1 = __webpack_require__(/*! ../../compile/validate */ "../../node_modules/ajv/dist/compile/validate/index.js");
const error = {
    message: ({ params: { len } }) => codegen_1.str `should NOT have more than ${len} items`,
    params: ({ params: { len } }) => codegen_1._ `{limit: ${len}}`,
};
const def = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error,
    code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
            validate_1.checkStrictMode(it, '"additionalItems" is ignored when "items" is not an array of schemas');
            return;
        }
        it.items = true;
        const len = gen.const("len", codegen_1._ `${data}.length`);
        if (schema === false) {
            cxt.setParams({ len: items.length });
            cxt.pass(codegen_1._ `${len} <= ${items.length}`);
        }
        else if (typeof schema == "object" && !util_1.alwaysValidSchema(it, schema)) {
            const valid = gen.var("valid", codegen_1._ `${len} <= ${items.length}`); // TODO var
            gen.if(codegen_1.not(valid), () => validateItems(valid));
            cxt.ok(valid);
        }
        function validateItems(valid) {
            gen.forRange("i", items.length, len, (i) => {
                cxt.subschema({ keyword: "additionalItems", dataProp: i, dataPropType: subschema_1.Type.Num }, valid);
                if (!it.allErrors)
                    gen.if(codegen_1.not(valid), () => gen.break());
            });
        }
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js":
/*!***************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const code_1 = __webpack_require__(/*! ../code */ "../../node_modules/ajv/dist/vocabularies/code.js");
const codegen_1 = __webpack_require__(/*! ../../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const names_1 = __webpack_require__(/*! ../../compile/names */ "../../node_modules/ajv/dist/compile/names.js");
const subschema_1 = __webpack_require__(/*! ../../compile/subschema */ "../../node_modules/ajv/dist/compile/subschema.js");
const util_1 = __webpack_require__(/*! ../../compile/util */ "../../node_modules/ajv/dist/compile/util.js");
const error = {
    message: "should NOT have additional properties",
    params: ({ params }) => codegen_1._ `{additionalProperty: ${params.additionalProperty}}`,
};
const def = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: true,
    trackErrors: true,
    error,
    code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        /* istanbul ignore if */
        if (!errsCount)
            throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && util_1.alwaysValidSchema(it, schema))
            return;
        const props = code_1.allSchemaProperties(parentSchema.properties);
        const patProps = code_1.allSchemaProperties(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok(codegen_1._ `${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
            gen.forIn("key", data, (key) => {
                if (!props.length && !patProps.length)
                    additionalPropertyCode(key);
                else
                    gen.if(isAdditional(key), () => additionalPropertyCode(key));
            });
        }
        function isAdditional(key) {
            let definedProp;
            if (props.length > 8) {
                // TODO maybe an option instead of hard-coded 8?
                const propsSchema = util_1.schemaRefOrVal(it, parentSchema.properties, "properties");
                definedProp = code_1.isOwnProperty(gen, propsSchema, key);
            }
            else if (props.length) {
                definedProp = codegen_1.or(...props.map((p) => codegen_1._ `${key} === ${p}`));
            }
            else {
                definedProp = codegen_1.nil;
            }
            if (patProps.length) {
                definedProp = codegen_1.or(definedProp, ...patProps.map((p) => codegen_1._ `${code_1.usePattern(gen, p)}.test(${key})`));
            }
            return codegen_1.not(definedProp);
        }
        function deleteAdditional(key) {
            gen.code(codegen_1._ `delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
            if (opts.removeAdditional === "all" || (opts.removeAdditional && schema === false)) {
                deleteAdditional(key);
                return;
            }
            if (schema === false) {
                cxt.setParams({ additionalProperty: key });
                cxt.error();
                if (!allErrors)
                    gen.break();
                return;
            }
            if (typeof schema == "object" && !util_1.alwaysValidSchema(it, schema)) {
                const valid = gen.name("valid");
                if (opts.removeAdditional === "failing") {
                    applyAdditionalSchema(key, valid, false);
                    gen.if(codegen_1.not(valid), () => {
                        cxt.reset();
                        deleteAdditional(key);
                    });
                }
                else {
                    applyAdditionalSchema(key, valid);
                    if (!allErrors)
                        gen.if(codegen_1.not(valid), () => gen.break());
                }
            }
        }
        function applyAdditionalSchema(key, valid, errors) {
            const subschema = {
                keyword: "additionalProperties",
                dataProp: key,
                dataPropType: subschema_1.Type.Str,
            };
            if (errors === false) {
                Object.assign(subschema, {
                    compositeRule: true,
                    createErrors: false,
                    allErrors: false,
                });
            }
            cxt.subschema(subschema, valid);
        }
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/allOf.js":
/*!************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/applicator/allOf.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = __webpack_require__(/*! ../../compile/util */ "../../node_modules/ajv/dist/compile/util.js");
const def = {
    keyword: "allOf",
    schemaType: "array",
    code(cxt) {
        const { gen, schema, it } = cxt;
        /* istanbul ignore if */
        if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
            if (util_1.alwaysValidSchema(it, sch))
                return;
            const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
            cxt.ok(valid);
            cxt.mergeEvaluated(schCxt);
        });
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/anyOf.js":
/*!************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/applicator/anyOf.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const code_1 = __webpack_require__(/*! ../code */ "../../node_modules/ajv/dist/vocabularies/code.js");
const def = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: true,
    code: code_1.validateUnion,
    error: {
        message: "should match some schema in anyOf",
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/contains.js":
/*!***************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/applicator/contains.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = __webpack_require__(/*! ../../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const subschema_1 = __webpack_require__(/*! ../../compile/subschema */ "../../node_modules/ajv/dist/compile/subschema.js");
const util_1 = __webpack_require__(/*! ../../compile/util */ "../../node_modules/ajv/dist/compile/util.js");
const validate_1 = __webpack_require__(/*! ../../compile/validate */ "../../node_modules/ajv/dist/compile/validate/index.js");
const error = {
    message: ({ params: { min, max } }) => max === undefined
        ? codegen_1.str `should contain at least ${min} valid item(s)`
        : codegen_1.str `should contain at least ${min} and no more than ${max} valid item(s)`,
    params: ({ params: { min, max } }) => max === undefined ? codegen_1._ `{minContains: ${min}}` : codegen_1._ `{minContains: ${min}, maxContains: ${max}}`,
};
const def = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: true,
    error,
    code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
            min = minContains === undefined ? 1 : minContains;
            max = maxContains;
        }
        else {
            min = 1;
        }
        const len = gen.const("len", codegen_1._ `${data}.length`);
        cxt.setParams({ min, max });
        if (max === undefined && min === 0) {
            validate_1.checkStrictMode(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
            return;
        }
        if (max !== undefined && min > max) {
            validate_1.checkStrictMode(it, `"minContains" > "maxContains" is always invalid`);
            cxt.fail();
            return;
        }
        if (util_1.alwaysValidSchema(it, schema)) {
            let cond = codegen_1._ `${len} >= ${min}`;
            if (max !== undefined)
                cond = codegen_1._ `${cond} && ${len} <= ${max}`;
            cxt.pass(cond);
            return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === undefined && min === 1) {
            validateItems(valid, () => gen.if(valid, () => gen.break()));
        }
        else {
            gen.let(valid, false);
            const schValid = gen.name("_valid");
            const count = gen.let("count", 0);
            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        cxt.result(valid, () => cxt.reset());
        function validateItems(_valid, block) {
            gen.forRange("i", 0, len, (i) => {
                cxt.subschema({
                    keyword: "contains",
                    dataProp: i,
                    dataPropType: subschema_1.Type.Num,
                    compositeRule: true,
                }, _valid);
                block();
            });
        }
        function checkLimits(count) {
            gen.code(codegen_1._ `${count}++`);
            if (max === undefined) {
                gen.if(codegen_1._ `${count} >= ${min}`, () => gen.assign(valid, true).break());
            }
            else {
                gen.if(codegen_1._ `${count} > ${max}`, () => gen.assign(valid, false).break());
                if (min === 1)
                    gen.assign(valid, true);
                else
                    gen.if(codegen_1._ `${count} >= ${min}`, () => gen.assign(valid, true));
            }
        }
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/dependencies.js":
/*!*******************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/applicator/dependencies.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
const codegen_1 = __webpack_require__(/*! ../../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__(/*! ../../compile/util */ "../../node_modules/ajv/dist/compile/util.js");
const code_1 = __webpack_require__(/*! ../code */ "../../node_modules/ajv/dist/vocabularies/code.js");
exports.error = {
    message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return codegen_1.str `should have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => codegen_1._ `{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`, // TODO change to reference
};
const def = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports.error,
    code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
    },
};
function splitDependencies({ schema }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema) {
        if (key === "__proto__")
            continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
    }
    return [propertyDeps, schemaDeps];
}
function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it } = cxt;
    if (Object.keys(propertyDeps).length === 0)
        return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
            continue;
        const hasProperty = code_1.propertyInData(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
            property: prop,
            depsCount: deps.length,
            deps: deps.join(", "),
        });
        if (it.allErrors) {
            gen.if(hasProperty, () => {
                for (const depProp of deps) {
                    code_1.checkReportMissingProp(cxt, depProp);
                }
            });
        }
        else {
            gen.if(codegen_1._ `${hasProperty} && (${code_1.checkMissingProp(cxt, deps, missing)})`);
            code_1.reportMissingProp(cxt, missing);
            gen.else();
        }
    }
}
exports.validatePropertyDeps = validatePropertyDeps;
function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword, it } = cxt;
    const valid = gen.name("valid");
    for (const prop in schemaDeps) {
        if (util_1.alwaysValidSchema(it, schemaDeps[prop]))
            continue;
        gen.if(code_1.propertyInData(gen, data, prop, it.opts.ownProperties), () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
        }, () => gen.var(valid, true) // TODO var
        );
        cxt.ok(valid);
    }
}
exports.validateSchemaDeps = validateSchemaDeps;
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/if.js":
/*!*********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/applicator/if.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = __webpack_require__(/*! ../../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__(/*! ../../compile/util */ "../../node_modules/ajv/dist/compile/util.js");
const validate_1 = __webpack_require__(/*! ../../compile/validate */ "../../node_modules/ajv/dist/compile/validate/index.js");
const error = {
    message: ({ params }) => codegen_1.str `should match "${params.ifClause}" schema`,
    params: ({ params }) => codegen_1._ `{failingKeyword: ${params.ifClause}}`,
};
const def = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    error,
    code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === undefined && parentSchema.else === undefined) {
            validate_1.checkStrictMode(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
            return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
            const ifClause = gen.let("ifClause");
            cxt.setParams({ ifClause });
            gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        }
        else if (hasThen) {
            gen.if(schValid, validateClause("then"));
        }
        else {
            gen.if(codegen_1.not(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
            const schCxt = cxt.subschema({
                keyword: "if",
                compositeRule: true,
                createErrors: false,
                allErrors: false,
            }, schValid);
            cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
            return () => {
                const schCxt = cxt.subschema({ keyword }, schValid);
                gen.assign(valid, schValid);
                cxt.mergeValidEvaluated(schCxt, valid);
                if (ifClause)
                    gen.assign(ifClause, codegen_1._ `${keyword}`);
                else
                    cxt.setParams({ ifClause: keyword });
            };
        }
    },
};
function hasSchema(it, keyword) {
    const schema = it.schema[keyword];
    return schema !== undefined && !util_1.alwaysValidSchema(it, schema);
}
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/index.js":
/*!************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/applicator/index.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const additionalItems_1 = __webpack_require__(/*! ./additionalItems */ "../../node_modules/ajv/dist/vocabularies/applicator/additionalItems.js");
const items_1 = __webpack_require__(/*! ./items */ "../../node_modules/ajv/dist/vocabularies/applicator/items.js");
const contains_1 = __webpack_require__(/*! ./contains */ "../../node_modules/ajv/dist/vocabularies/applicator/contains.js");
const dependencies_1 = __webpack_require__(/*! ./dependencies */ "../../node_modules/ajv/dist/vocabularies/applicator/dependencies.js");
const propertyNames_1 = __webpack_require__(/*! ./propertyNames */ "../../node_modules/ajv/dist/vocabularies/applicator/propertyNames.js");
const additionalProperties_1 = __webpack_require__(/*! ./additionalProperties */ "../../node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js");
const properties_1 = __webpack_require__(/*! ./properties */ "../../node_modules/ajv/dist/vocabularies/applicator/properties.js");
const patternProperties_1 = __webpack_require__(/*! ./patternProperties */ "../../node_modules/ajv/dist/vocabularies/applicator/patternProperties.js");
const not_1 = __webpack_require__(/*! ./not */ "../../node_modules/ajv/dist/vocabularies/applicator/not.js");
const anyOf_1 = __webpack_require__(/*! ./anyOf */ "../../node_modules/ajv/dist/vocabularies/applicator/anyOf.js");
const oneOf_1 = __webpack_require__(/*! ./oneOf */ "../../node_modules/ajv/dist/vocabularies/applicator/oneOf.js");
const allOf_1 = __webpack_require__(/*! ./allOf */ "../../node_modules/ajv/dist/vocabularies/applicator/allOf.js");
const if_1 = __webpack_require__(/*! ./if */ "../../node_modules/ajv/dist/vocabularies/applicator/if.js");
const thenElse_1 = __webpack_require__(/*! ./thenElse */ "../../node_modules/ajv/dist/vocabularies/applicator/thenElse.js");
const applicator = [
    // any
    not_1.default,
    anyOf_1.default,
    oneOf_1.default,
    allOf_1.default,
    if_1.default,
    thenElse_1.default,
    // array
    additionalItems_1.default,
    items_1.default,
    contains_1.default,
    // object
    propertyNames_1.default,
    additionalProperties_1.default,
    dependencies_1.default,
    properties_1.default,
    patternProperties_1.default,
];
exports.default = applicator;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/items.js":
/*!************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/applicator/items.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = __webpack_require__(/*! ../../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__(/*! ../../compile/util */ "../../node_modules/ajv/dist/compile/util.js");
const validate_1 = __webpack_require__(/*! ../../compile/validate */ "../../node_modules/ajv/dist/compile/validate/index.js");
const code_1 = __webpack_require__(/*! ../code */ "../../node_modules/ajv/dist/vocabularies/code.js");
const def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(cxt) {
        const { gen, schema, it } = cxt;
        if (Array.isArray(schema)) {
            if (it.opts.unevaluated && schema.length && it.items !== true) {
                it.items = util_1.mergeEvaluated.items(gen, schema.length, it.items);
            }
            validateTuple(schema);
        }
        else {
            it.items = true;
            if (util_1.alwaysValidSchema(it, schema))
                return;
            cxt.ok(code_1.validateArray(cxt));
        }
        function validateTuple(schArr) {
            const { parentSchema, data } = cxt;
            if (it.opts.strictTuples && !fullTupleSchema(schArr.length, parentSchema)) {
                const msg = `"items" is ${schArr.length}-tuple, but minItems or maxItems/additionalItems are not specified or different`;
                validate_1.checkStrictMode(it, msg, it.opts.strictTuples);
            }
            const valid = gen.name("valid");
            const len = gen.const("len", codegen_1._ `${data}.length`);
            schArr.forEach((sch, i) => {
                if (util_1.alwaysValidSchema(it, sch))
                    return;
                gen.if(codegen_1._ `${len} > ${i}`, () => cxt.subschema({
                    keyword: "items",
                    schemaProp: i,
                    dataProp: i,
                }, valid));
                cxt.ok(valid);
            });
        }
    },
};
function fullTupleSchema(len, sch) {
    return len === sch.minItems && (len === sch.maxItems || sch.additionalItems === false);
}
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/not.js":
/*!**********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/applicator/not.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = __webpack_require__(/*! ../../compile/util */ "../../node_modules/ajv/dist/compile/util.js");
const def = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    code(cxt) {
        const { gen, schema, it } = cxt;
        if (util_1.alwaysValidSchema(it, schema)) {
            cxt.fail();
            return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
            keyword: "not",
            compositeRule: true,
            createErrors: false,
            allErrors: false,
        }, valid);
        cxt.result(valid, () => cxt.error(), () => cxt.reset());
    },
    error: {
        message: "should NOT be valid",
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/oneOf.js":
/*!************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/applicator/oneOf.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = __webpack_require__(/*! ../../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__(/*! ../../compile/util */ "../../node_modules/ajv/dist/compile/util.js");
const error = {
    message: "should match exactly one schema in oneOf",
    params: ({ params }) => codegen_1._ `{passingSchemas: ${params.passing}}`,
};
const def = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: true,
    error,
    code(cxt) {
        const { gen, schema, it } = cxt;
        /* istanbul ignore if */
        if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
            schArr.forEach((sch, i) => {
                let schCxt;
                if (util_1.alwaysValidSchema(it, sch)) {
                    gen.var(schValid, true);
                }
                else {
                    schCxt = cxt.subschema({
                        keyword: "oneOf",
                        schemaProp: i,
                        compositeRule: true,
                    }, schValid);
                }
                if (i > 0) {
                    gen
                        .if(codegen_1._ `${schValid} && ${valid}`)
                        .assign(valid, false)
                        .assign(passing, codegen_1._ `[${passing}, ${i}]`)
                        .else();
                }
                gen.if(schValid, () => {
                    gen.assign(valid, true);
                    gen.assign(passing, i);
                    if (schCxt)
                        cxt.mergeEvaluated(schCxt, codegen_1.Name);
                });
            });
        }
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/patternProperties.js":
/*!************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const code_1 = __webpack_require__(/*! ../code */ "../../node_modules/ajv/dist/vocabularies/code.js");
const codegen_1 = __webpack_require__(/*! ../../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const subschema_1 = __webpack_require__(/*! ../../compile/subschema */ "../../node_modules/ajv/dist/compile/subschema.js");
const validate_1 = __webpack_require__(/*! ../../compile/validate */ "../../node_modules/ajv/dist/compile/validate/index.js");
const util_1 = __webpack_require__(/*! ../../compile/util */ "../../node_modules/ajv/dist/compile/util.js");
const def = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = code_1.schemaProperties(it, schema);
        // TODO mark properties matching patterns with always valid schemas as evaluated
        if (patterns.length === 0)
            return;
        const checkProperties = opts.strict && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
            it.props = util_1.evaluatedPropsToName(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
            for (const pat of patterns) {
                if (checkProperties)
                    checkMatchingProperties(pat);
                if (it.allErrors) {
                    validateProperties(pat);
                }
                else {
                    gen.var(valid, true); // TODO var
                    validateProperties(pat);
                    gen.if(valid);
                }
            }
        }
        function checkMatchingProperties(pat) {
            for (const prop in checkProperties) {
                if (new RegExp(pat).test(prop)) {
                    validate_1.checkStrictMode(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
                }
            }
        }
        function validateProperties(pat) {
            gen.forIn("key", data, (key) => {
                gen.if(codegen_1._ `${code_1.usePattern(gen, pat)}.test(${key})`, () => {
                    cxt.subschema({
                        keyword: "patternProperties",
                        schemaProp: pat,
                        dataProp: key,
                        dataPropType: subschema_1.Type.Str,
                    }, valid);
                    if (it.opts.unevaluated && props !== true) {
                        gen.assign(codegen_1._ `${props}[${key}]`, true);
                    }
                    else if (!it.allErrors) {
                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
                        // or if all properties were evaluated (props === true)
                        gen.if(codegen_1.not(valid), () => gen.break());
                    }
                });
            });
        }
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/properties.js":
/*!*****************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/applicator/properties.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const context_1 = __webpack_require__(/*! ../../compile/context */ "../../node_modules/ajv/dist/compile/context.js");
const code_1 = __webpack_require__(/*! ../code */ "../../node_modules/ajv/dist/vocabularies/code.js");
const util_1 = __webpack_require__(/*! ../../compile/util */ "../../node_modules/ajv/dist/compile/util.js");
const additionalProperties_1 = __webpack_require__(/*! ./additionalProperties */ "../../node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js");
const def = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
            additionalProperties_1.default.code(new context_1.default(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = code_1.allSchemaProperties(schema);
        for (const prop of allProps) {
            it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
            it.props = util_1.mergeEvaluated.props(gen, util_1.toHash(allProps), it.props);
        }
        const properties = allProps.filter((p) => !util_1.alwaysValidSchema(it, schema[p]));
        if (properties.length === 0)
            return;
        const valid = gen.name("valid");
        for (const prop of properties) {
            if (hasDefault(prop)) {
                applyPropertySchema(prop);
            }
            else {
                gen.if(code_1.propertyInData(gen, data, prop, it.opts.ownProperties));
                applyPropertySchema(prop);
                if (!it.allErrors)
                    gen.else().var(valid, true);
                gen.endIf();
            }
            cxt.it.definedProperties.add(prop);
            cxt.ok(valid);
        }
        function hasDefault(prop) {
            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;
        }
        function applyPropertySchema(prop) {
            cxt.subschema({
                keyword: "properties",
                schemaProp: prop,
                dataProp: prop,
            }, valid);
        }
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/propertyNames.js":
/*!********************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = __webpack_require__(/*! ../../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__(/*! ../../compile/util */ "../../node_modules/ajv/dist/compile/util.js");
const error = {
    message: ({ params }) => codegen_1.str `property name '${params.propertyName}' is invalid`,
    params: ({ params }) => codegen_1._ `{propertyName: ${params.propertyName}}`,
};
const def = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error,
    code(cxt) {
        const { gen, schema, data, it } = cxt;
        if (util_1.alwaysValidSchema(it, schema))
            return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
            cxt.setParams({ propertyName: key });
            cxt.subschema({
                keyword: "propertyNames",
                data: key,
                dataTypes: ["string"],
                propertyName: key,
                compositeRule: true,
            }, valid);
            gen.if(codegen_1.not(valid), () => {
                cxt.error(true);
                if (!it.allErrors)
                    gen.break();
            });
        });
        cxt.ok(valid);
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/applicator/thenElse.js":
/*!***************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/applicator/thenElse.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const validate_1 = __webpack_require__(/*! ../../compile/validate */ "../../node_modules/ajv/dist/compile/validate/index.js");
const def = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword, parentSchema, it }) {
        if (parentSchema.if === undefined)
            validate_1.checkStrictMode(it, `"${keyword}" without "if" is ignored`);
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/code.js":
/*!************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/code.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
const codegen_1 = __webpack_require__(/*! ../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const util_1 = __webpack_require__(/*! ../compile/util */ "../../node_modules/ajv/dist/compile/util.js");
const subschema_1 = __webpack_require__(/*! ../compile/subschema */ "../../node_modules/ajv/dist/compile/subschema.js");
const names_1 = __webpack_require__(/*! ../compile/names */ "../../node_modules/ajv/dist/compile/names.js");
function checkReportMissingProp(cxt, prop) {
    const { gen, data, it } = cxt;
    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: codegen_1._ `${prop}` }, true);
        cxt.error();
    });
}
exports.checkReportMissingProp = checkReportMissingProp;
function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
    return codegen_1.or(...properties.map((prop) => codegen_1._ `${noPropertyInData(gen, data, prop, opts.ownProperties)} && (${missing} = ${prop})`));
}
exports.checkMissingProp = checkMissingProp;
function reportMissingProp(cxt, missing) {
    cxt.setParams({ missingProperty: missing }, true);
    cxt.error();
}
exports.reportMissingProp = reportMissingProp;
function hasPropFunc(gen) {
    return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: codegen_1._ `Object.prototype.hasOwnProperty`,
    });
}
exports.hasPropFunc = hasPropFunc;
function isOwnProperty(gen, data, property) {
    return codegen_1._ `${hasPropFunc(gen)}.call(${data}, ${property})`;
}
exports.isOwnProperty = isOwnProperty;
function propertyInData(gen, data, property, ownProperties) {
    const cond = codegen_1._ `${data}${codegen_1.getProperty(property)} !== undefined`;
    return ownProperties ? codegen_1._ `${cond} && ${isOwnProperty(gen, data, property)}` : cond;
}
exports.propertyInData = propertyInData;
function noPropertyInData(gen, data, property, ownProperties) {
    const cond = codegen_1._ `${data}${codegen_1.getProperty(property)} === undefined`;
    return ownProperties ? codegen_1._ `${cond} || !${isOwnProperty(gen, data, property)}` : cond;
}
exports.noPropertyInData = noPropertyInData;
function allSchemaProperties(schemaMap) {
    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
}
exports.allSchemaProperties = allSchemaProperties;
function schemaProperties(it, schemaMap) {
    return allSchemaProperties(schemaMap).filter((p) => !util_1.alwaysValidSchema(it, schemaMap[p]));
}
exports.schemaProperties = schemaProperties;
function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
    const dataAndSchema = passSchema ? codegen_1._ `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
    const valCxt = [
        [names_1.default.dataPath, codegen_1.strConcat(names_1.default.dataPath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData],
    ];
    if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
    const args = codegen_1._ `${dataAndSchema}, ${gen.object(...valCxt)}`;
    return context !== codegen_1.nil ? codegen_1._ `${func}.call(${context}, ${args})` : codegen_1._ `${func}(${args})`;
}
exports.callValidateCode = callValidateCode;
function usePattern(gen, pattern) {
    return gen.scopeValue("pattern", {
        key: pattern,
        ref: new RegExp(pattern, "u"),
        code: codegen_1._ `new RegExp(${pattern}, "u")`,
    });
}
exports.usePattern = usePattern;
function validateArray(cxt) {
    const { gen, data, keyword, it } = cxt;
    const valid = gen.name("valid");
    if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
    }
    gen.var(valid, true);
    validateItems(() => gen.break());
    return valid;
    function validateItems(notValid) {
        const len = gen.const("len", codegen_1._ `${data}.length`);
        gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
                keyword,
                dataProp: i,
                dataPropType: subschema_1.Type.Num,
            }, valid);
            gen.if(codegen_1.not(valid), notValid);
        });
    }
}
exports.validateArray = validateArray;
function validateUnion(cxt) {
    const { gen, schema, keyword, it } = cxt;
    /* istanbul ignore if */
    if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
    const alwaysValid = schema.some((sch) => util_1.alwaysValidSchema(it, sch));
    if (alwaysValid && !it.opts.unevaluated)
        return;
    const valid = gen.let("valid", false);
    const schValid = gen.name("_valid");
    gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
            keyword,
            schemaProp: i,
            compositeRule: true,
        }, schValid);
        gen.assign(valid, codegen_1._ `${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
        // or if all properties and items were evaluated (it.props === true && it.items === true)
        if (!merged)
            gen.if(codegen_1.not(valid));
    }));
    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
}
exports.validateUnion = validateUnion;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/core/id.js":
/*!***************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/core/id.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const def = {
    keyword: "id",
    code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/core/index.js":
/*!******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/core/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const id_1 = __webpack_require__(/*! ./id */ "../../node_modules/ajv/dist/vocabularies/core/id.js");
const ref_1 = __webpack_require__(/*! ./ref */ "../../node_modules/ajv/dist/vocabularies/core/ref.js");
const core = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    id_1.default,
    ref_1.default,
];
exports.default = core;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/core/ref.js":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/core/ref.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.callRef = exports.getValidate = void 0;
const error_classes_1 = __webpack_require__(/*! ../../compile/error_classes */ "../../node_modules/ajv/dist/compile/error_classes.js");
const code_1 = __webpack_require__(/*! ../code */ "../../node_modules/ajv/dist/vocabularies/code.js");
const codegen_1 = __webpack_require__(/*! ../../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const names_1 = __webpack_require__(/*! ../../compile/names */ "../../node_modules/ajv/dist/compile/names.js");
const compile_1 = __webpack_require__(/*! ../../compile */ "../../node_modules/ajv/dist/compile/index.js");
const util_1 = __webpack_require__(/*! ../../compile/util */ "../../node_modules/ajv/dist/compile/util.js");
const def = {
    keyword: "$ref",
    schemaType: "string",
    code(cxt) {
        const { gen, schema, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self } = it;
        // TODO See comment in dynamicRef.ts
        // This has to be improved to resolve #815.
        if (schema === "#" || schema === "#/")
            return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self, env.root, baseId, schema);
        if (schOrEnv === undefined)
            throw new error_classes_1.MissingRefError(baseId, schema);
        if (schOrEnv instanceof compile_1.SchemaEnv)
            return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
            if (env === env.root)
                return callRef(cxt, validateName, env, env.$async);
            const rootName = gen.scopeValue("root", { ref: env.root });
            return callRef(cxt, codegen_1._ `${rootName}.validate`, env.root, env.root.$async);
        }
        function callValidate(sch) {
            const v = getValidate(cxt, sch);
            callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
            const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: codegen_1.stringify(sch) } : { ref: sch });
            const valid = gen.name("valid");
            const schCxt = cxt.subschema({
                schema: sch,
                dataTypes: [],
                schemaPath: codegen_1.nil,
                topSchemaRef: schName,
                errSchemaPath: schema,
            }, valid);
            cxt.mergeEvaluated(schCxt);
            cxt.ok(valid);
        }
    },
};
function getValidate(cxt, sch) {
    const { gen } = cxt;
    return sch.validate
        ? gen.scopeValue("validate", { ref: sch.validate })
        : codegen_1._ `${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
exports.getValidate = getValidate;
function callRef(cxt, v, sch, $async) {
    const { gen, it } = cxt;
    const { allErrors, schemaEnv: env, opts } = it;
    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
    if ($async)
        callAsyncRef();
    else
        callSyncRef();
    function callAsyncRef() {
        if (!env.$async)
            throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
            gen.code(codegen_1._ `await ${code_1.callValidateCode(cxt, v, passCxt)}`);
            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result
            if (!allErrors)
                gen.assign(valid, true);
        }, (e) => {
            gen.if(codegen_1._ `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
            addErrorsFrom(e);
            if (!allErrors)
                gen.assign(valid, false);
        });
        cxt.ok(valid);
    }
    function callSyncRef() {
        cxt.result(code_1.callValidateCode(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
    }
    function addErrorsFrom(source) {
        const errs = codegen_1._ `${source}.errors`;
        gen.assign(names_1.default.vErrors, codegen_1._ `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged
        gen.assign(names_1.default.errors, codegen_1._ `${names_1.default.vErrors}.length`);
    }
    function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
            return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        // TODO refactor
        if (it.props !== true) {
            if (schEvaluated && !schEvaluated.dynamicProps) {
                if (schEvaluated.props !== undefined) {
                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
                }
            }
            else {
                const props = gen.var("props", codegen_1._ `${source}.evaluated.props`);
                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
            }
        }
        if (it.items !== true) {
            if (schEvaluated && !schEvaluated.dynamicItems) {
                if (schEvaluated.items !== undefined) {
                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
                }
            }
            else {
                const items = gen.var("items", codegen_1._ `${source}.evaluated.items`);
                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
            }
        }
    }
}
exports.callRef = callRef;
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/draft7.js":
/*!**************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/draft7.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = __webpack_require__(/*! ./core */ "../../node_modules/ajv/dist/vocabularies/core/index.js");
const validation_1 = __webpack_require__(/*! ./validation */ "../../node_modules/ajv/dist/vocabularies/validation/index.js");
const applicator_1 = __webpack_require__(/*! ./applicator */ "../../node_modules/ajv/dist/vocabularies/applicator/index.js");
const format_1 = __webpack_require__(/*! ./format */ "../../node_modules/ajv/dist/vocabularies/format/index.js");
const metadata_1 = __webpack_require__(/*! ./metadata */ "../../node_modules/ajv/dist/vocabularies/metadata.js");
const draft7Vocabularies = [
    core_1.default,
    validation_1.default,
    applicator_1.default,
    format_1.default,
    metadata_1.metadataVocabulary,
    metadata_1.contentVocabulary,
];
exports.default = draft7Vocabularies;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/format/format.js":
/*!*********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/format/format.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = __webpack_require__(/*! ../../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const error = {
    message: ({ schemaCode }) => codegen_1.str `should match format "${schemaCode}"`,
    params: ({ schemaCode }) => codegen_1._ `{format: ${schemaCode}}`,
};
const def = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: true,
    error,
    code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
            return;
        if ($data)
            validate$DataFormat();
        else
            validateFormat();
        function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
                ref: self.formats,
                code: opts.code.formats,
            });
            const fDef = gen.const("fDef", codegen_1._ `${fmts}[${schemaCode}]`);
            const fType = gen.let("fType");
            const format = gen.let("format");
            // TODO simplify
            gen.if(codegen_1._ `typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, codegen_1._ `${fDef}.type || "string"`).assign(format, codegen_1._ `${fDef}.validate`), () => gen.assign(fType, codegen_1._ `"string"`).assign(format, fDef));
            cxt.fail$data(codegen_1.or(unknownFmt(), invalidFmt()));
            function unknownFmt() {
                if (opts.strict === false)
                    return codegen_1.nil;
                return codegen_1._ `${schemaCode} && !${format}`;
            }
            function invalidFmt() {
                const callFormat = schemaEnv.$async
                    ? codegen_1._ `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`
                    : codegen_1._ `${format}(${data})`;
                const validData = codegen_1._ `(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
                return codegen_1._ `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
            }
        }
        function validateFormat() {
            const formatDef = self.formats[schema];
            if (!formatDef) {
                unknownFormat();
                return;
            }
            if (formatDef === true)
                return;
            const [fmtType, format, fmtRef] = getFormat(formatDef);
            if (fmtType === ruleType)
                cxt.pass(validCondition());
            function unknownFormat() {
                if (opts.strict === false) {
                    self.logger.warn(unknownMsg());
                    return;
                }
                throw new Error(unknownMsg());
                function unknownMsg() {
                    return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
                }
            }
            function getFormat(fmtDef) {
                const fmt = gen.scopeValue("formats", {
                    key: schema,
                    ref: fmtDef,
                    code: opts.code.formats ? codegen_1._ `${opts.code.formats}${codegen_1.getProperty(schema)}` : undefined,
                });
                if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
                    return [fmtDef.type || "string", fmtDef.validate, codegen_1._ `${fmt}.validate`];
                }
                return ["string", fmtDef, fmt];
            }
            function validCondition() {
                if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
                    if (!schemaEnv.$async)
                        throw new Error("async format in sync schema");
                    return codegen_1._ `await ${fmtRef}(${data})`;
                }
                return typeof format == "function" ? codegen_1._ `${fmtRef}(${data})` : codegen_1._ `${fmtRef}.test(${data})`;
            }
        }
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/format/index.js":
/*!********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/format/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const format_1 = __webpack_require__(/*! ./format */ "../../node_modules/ajv/dist/vocabularies/format/format.js");
const format = [format_1.default];
exports.default = format;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/metadata.js":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/metadata.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.contentVocabulary = exports.metadataVocabulary = void 0;
exports.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples",
];
exports.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema",
];


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/validation/const.js":
/*!************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/validation/const.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = __webpack_require__(/*! ../../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const equal = __webpack_require__(/*! fast-deep-equal */ "../../node_modules/fast-deep-equal/index.js");
const error = {
    message: "should be equal to constant",
    params: ({ schemaCode }) => codegen_1._ `{allowedValue: ${schemaCode}}`,
};
const def = {
    keyword: "const",
    $data: true,
    error,
    code(cxt) {
        const eql = cxt.gen.scopeValue("func", {
            ref: equal,
            code: codegen_1._ `require("ajv/dist/compile/equal")`,
        });
        // TODO optimize for scalar values in schema
        cxt.fail$data(codegen_1._ `!${eql}(${cxt.data}, ${cxt.schemaCode})`);
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/validation/enum.js":
/*!***********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/validation/enum.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = __webpack_require__(/*! ../../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const equal = __webpack_require__(/*! fast-deep-equal */ "../../node_modules/fast-deep-equal/index.js");
const error = {
    message: "should be equal to one of the allowed values",
    params: ({ schemaCode }) => codegen_1._ `{allowedValues: ${schemaCode}}`,
};
const def = {
    keyword: "enum",
    schemaType: "array",
    $data: true,
    error,
    code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
            throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        const eql = cxt.gen.scopeValue("func", {
            ref: equal,
            code: codegen_1._ `require("ajv/dist/compile/equal")`,
        });
        let valid;
        if (useLoop || $data) {
            valid = gen.let("valid");
            cxt.block$data(valid, loopEnum);
        }
        else {
            /* istanbul ignore if */
            if (!Array.isArray(schema))
                throw new Error("ajv implementation error");
            const vSchema = gen.const("vSchema", schemaCode);
            valid = codegen_1.or(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
            gen.assign(valid, false);
            gen.forOf("v", schemaCode, (v) => gen.if(codegen_1._ `${eql}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
            const sch = schema[i];
            return sch && typeof sch === "object"
                ? codegen_1._ `${eql}(${data}, ${vSchema}[${i}])`
                : codegen_1._ `${data} === ${sch}`;
        }
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/validation/index.js":
/*!************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/validation/index.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const limitNumber_1 = __webpack_require__(/*! ./limitNumber */ "../../node_modules/ajv/dist/vocabularies/validation/limitNumber.js");
const multipleOf_1 = __webpack_require__(/*! ./multipleOf */ "../../node_modules/ajv/dist/vocabularies/validation/multipleOf.js");
const limitLength_1 = __webpack_require__(/*! ./limitLength */ "../../node_modules/ajv/dist/vocabularies/validation/limitLength.js");
const pattern_1 = __webpack_require__(/*! ./pattern */ "../../node_modules/ajv/dist/vocabularies/validation/pattern.js");
const limitProperties_1 = __webpack_require__(/*! ./limitProperties */ "../../node_modules/ajv/dist/vocabularies/validation/limitProperties.js");
const required_1 = __webpack_require__(/*! ./required */ "../../node_modules/ajv/dist/vocabularies/validation/required.js");
const limitItems_1 = __webpack_require__(/*! ./limitItems */ "../../node_modules/ajv/dist/vocabularies/validation/limitItems.js");
const uniqueItems_1 = __webpack_require__(/*! ./uniqueItems */ "../../node_modules/ajv/dist/vocabularies/validation/uniqueItems.js");
const const_1 = __webpack_require__(/*! ./const */ "../../node_modules/ajv/dist/vocabularies/validation/const.js");
const enum_1 = __webpack_require__(/*! ./enum */ "../../node_modules/ajv/dist/vocabularies/validation/enum.js");
const validation = [
    // number
    limitNumber_1.default,
    multipleOf_1.default,
    // string
    limitLength_1.default,
    pattern_1.default,
    // object
    limitProperties_1.default,
    required_1.default,
    // array
    limitItems_1.default,
    uniqueItems_1.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    const_1.default,
    enum_1.default,
];
exports.default = validation;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/validation/limitItems.js":
/*!*****************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/validation/limitItems.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = __webpack_require__(/*! ../../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const error = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return codegen_1.str `should NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => codegen_1._ `{limit: ${schemaCode}}`,
};
const def = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data(codegen_1._ `${data}.length ${op} ${schemaCode}`);
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/validation/limitLength.js":
/*!******************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/validation/limitLength.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = __webpack_require__(/*! ../../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const ucs2length_1 = __webpack_require__(/*! ../../compile/ucs2length */ "../../node_modules/ajv/dist/compile/ucs2length.js");
const error = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return codegen_1.str `should NOT have ${comp} than ${schemaCode} characters`;
    },
    params: ({ schemaCode }) => codegen_1._ `{limit: ${schemaCode}}`,
};
const def = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        let len;
        if (it.opts.unicode === false) {
            len = codegen_1._ `${data}.length`;
        }
        else {
            const u2l = cxt.gen.scopeValue("func", {
                ref: ucs2length_1.default,
                code: codegen_1._ `require("ajv/dist/compile/ucs2length").default`,
            });
            len = codegen_1._ `${u2l}(${data})`;
        }
        cxt.fail$data(codegen_1._ `${len} ${op} ${schemaCode}`);
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/validation/limitNumber.js":
/*!******************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/validation/limitNumber.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = __webpack_require__(/*! ../../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const ops = codegen_1.operators;
const KWDs = {
    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
};
const error = {
    message: ({ keyword, schemaCode }) => codegen_1.str `should be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => codegen_1._ `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
};
const def = {
    keyword: Object.keys(KWDs),
    type: "number",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data(codegen_1._ `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/validation/limitProperties.js":
/*!**********************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/validation/limitProperties.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = __webpack_require__(/*! ../../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const error = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return codegen_1.str `should NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => codegen_1._ `{limit: ${schemaCode}}`,
};
const def = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data(codegen_1._ `Object.keys(${data}).length ${op} ${schemaCode}`);
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/validation/multipleOf.js":
/*!*****************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/validation/multipleOf.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = __webpack_require__(/*! ../../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const error = {
    message: ({ schemaCode }) => codegen_1.str `should be multiple of ${schemaCode}`,
    params: ({ schemaCode }) => codegen_1._ `{multipleOf: ${schemaCode}}`,
};
const def = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec
            ? codegen_1._ `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`
            : codegen_1._ `${res} !== parseInt(${res})`;
        cxt.fail$data(codegen_1._ `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/validation/pattern.js":
/*!**************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/validation/pattern.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const code_1 = __webpack_require__(/*! ../code */ "../../node_modules/ajv/dist/vocabularies/code.js");
const codegen_1 = __webpack_require__(/*! ../../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const error = {
    message: ({ schemaCode }) => codegen_1.str `should match pattern "${schemaCode}"`,
    params: ({ schemaCode }) => codegen_1._ `{pattern: ${schemaCode}}`,
};
const def = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: true,
    error,
    code(cxt) {
        const { gen, data, $data, schema, schemaCode } = cxt;
        const regExp = $data ? codegen_1._ `(new RegExp(${schemaCode}, "u"))` : code_1.usePattern(gen, schema); // TODO regexp should be wrapped in try/catch
        cxt.fail$data(codegen_1._ `!${regExp}.test(${data})`);
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/validation/required.js":
/*!***************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/validation/required.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const code_1 = __webpack_require__(/*! ../code */ "../../node_modules/ajv/dist/vocabularies/code.js");
const codegen_1 = __webpack_require__(/*! ../../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const validate_1 = __webpack_require__(/*! ../../compile/validate */ "../../node_modules/ajv/dist/compile/validate/index.js");
const error = {
    message: ({ params: { missingProperty } }) => codegen_1.str `should have required property '${missingProperty}'`,
    params: ({ params: { missingProperty } }) => codegen_1._ `{missingProperty: ${missingProperty}}`,
};
const def = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: true,
    error,
    code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
            return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
            allErrorsMode();
        else
            exitOnErrorMode();
        if (opts.strictRequired) {
            const props = cxt.parentSchema.properties;
            const { definedProperties } = cxt.it;
            for (const requiredKey of schema) {
                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
                    const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
                    validate_1.checkStrictMode(it, msg, it.opts.strictRequired);
                }
            }
        }
        function allErrorsMode() {
            if (useLoop || $data) {
                cxt.block$data(codegen_1.nil, loopAllRequired);
            }
            else {
                for (const prop of schema) {
                    code_1.checkReportMissingProp(cxt, prop);
                }
            }
        }
        function exitOnErrorMode() {
            const missing = gen.let("missing");
            if (useLoop || $data) {
                const valid = gen.let("valid", true);
                cxt.block$data(valid, () => loopUntilMissing(missing, valid));
                cxt.ok(valid);
            }
            else {
                gen.if(code_1.checkMissingProp(cxt, schema, missing));
                code_1.reportMissingProp(cxt, missing);
                gen.else();
            }
        }
        function loopAllRequired() {
            gen.forOf("prop", schemaCode, (prop) => {
                cxt.setParams({ missingProperty: prop });
                gen.if(code_1.noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error());
            });
        }
        function loopUntilMissing(missing, valid) {
            cxt.setParams({ missingProperty: missing });
            gen.forOf(missing, schemaCode, () => {
                gen.assign(valid, code_1.propertyInData(gen, data, missing, opts.ownProperties));
                gen.if(codegen_1.not(valid), () => {
                    cxt.error();
                    gen.break();
                });
            }, codegen_1.nil);
        }
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/ajv/dist/vocabularies/validation/uniqueItems.js":
/*!******************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const dataType_1 = __webpack_require__(/*! ../../compile/validate/dataType */ "../../node_modules/ajv/dist/compile/validate/dataType.js");
const codegen_1 = __webpack_require__(/*! ../../compile/codegen */ "../../node_modules/ajv/dist/compile/codegen/index.js");
const equal = __webpack_require__(/*! fast-deep-equal */ "../../node_modules/fast-deep-equal/index.js");
const error = {
    message: ({ params: { i, j } }) => codegen_1.str `should NOT have duplicate items (items ## ${j} and ${i} are identical)`,
    params: ({ params: { i, j } }) => codegen_1._ `{i: ${i}, j: ${j}}`,
};
const def = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: true,
    error,
    code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
            return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? dataType_1.getSchemaTypes(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, codegen_1._ `${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
            const i = gen.let("i", codegen_1._ `${data}.length`);
            const j = gen.let("j");
            cxt.setParams({ i, j });
            gen.assign(valid, true);
            gen.if(codegen_1._ `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
            return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
            const item = gen.name("item");
            const wrongType = dataType_1.checkDataTypes(itemTypes, item, it.opts.strict, dataType_1.DataType.Wrong);
            const indices = gen.const("indices", codegen_1._ `{}`);
            gen.for(codegen_1._ `;${i}--;`, () => {
                gen.let(item, codegen_1._ `${data}[${i}]`);
                gen.if(wrongType, codegen_1._ `continue`);
                if (itemTypes.length > 1)
                    gen.if(codegen_1._ `typeof ${item} == "string"`, codegen_1._ `${item} += "_"`);
                gen
                    .if(codegen_1._ `typeof ${indices}[${item}] == "number"`, () => {
                    gen.assign(j, codegen_1._ `${indices}[${item}]`);
                    cxt.error();
                    gen.assign(valid, false).break();
                })
                    .code(codegen_1._ `${indices}[${item}] = ${i}`);
            });
        }
        function loopN2(i, j) {
            const eql = cxt.gen.scopeValue("func", {
                ref: equal,
                code: codegen_1._ `require("ajv/dist/compile/equal")`,
            });
            const outer = gen.name("outer");
            gen.label(outer).for(codegen_1._ `;${i}--;`, () => gen.for(codegen_1._ `${j} = ${i}; ${j}--;`, () => gen.if(codegen_1._ `${eql}(${data}[${i}], ${data}[${j}])`, () => {
                cxt.error();
                gen.assign(valid, false).break(outer);
            })));
        }
    },
};
exports.default = def;


/***/ }),

/***/ "../../node_modules/an-array/index.js":
/*!************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/an-array/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var str = Object.prototype.toString

module.exports = anArray

function anArray(arr) {
  return (
       arr.BYTES_PER_ELEMENT
    && str.call(arr.buffer) === '[object ArrayBuffer]'
    || Array.isArray(arr)
  )
}


/***/ }),

/***/ "../../node_modules/as-number/index.js":
/*!*************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/as-number/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function numtype(num, def) {
	return typeof num === 'number'
		? num 
		: (typeof def === 'number' ? def : 0)
}

/***/ }),

/***/ "../../node_modules/dtype/index.js":
/*!*********************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/dtype/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(dtype) {
  switch (dtype) {
    case 'int8':
      return Int8Array
    case 'int16':
      return Int16Array
    case 'int32':
      return Int32Array
    case 'uint8':
      return Uint8Array
    case 'uint16':
      return Uint16Array
    case 'uint32':
      return Uint32Array
    case 'float32':
      return Float32Array
    case 'float64':
      return Float64Array
    case 'array':
      return Array
    case 'uint8_clamped':
      return Uint8ClampedArray
  }
}


/***/ }),

/***/ "../../node_modules/fast-deep-equal/index.js":
/*!*******************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/fast-deep-equal/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }),

/***/ "../../node_modules/inherits/inherits_browser.js":
/*!***********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/inherits/inherits_browser.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "../../node_modules/is-buffer/index.js":
/*!*************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/is-buffer/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}


/***/ }),

/***/ "../../node_modules/json-schema-traverse/index.js":
/*!************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/json-schema-traverse/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var traverse = module.exports = function (schema, opts, cb) {
  // Legacy support for v0.3.1 and earlier.
  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }

  cb = opts.cb || cb;
  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
  var post = cb.post || function() {};

  _traverse(opts, pre, post, schema, '', schema);
};


traverse.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true
};

traverse.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};

traverse.propsKeywords = {
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};

traverse.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};


function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse.arrayKeywords) {
          for (var i=0; i<sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse.propsKeywords) {
        if (sch && typeof sch == 'object') {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}


function escapeJsonPtr(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}


/***/ }),

/***/ "../../node_modules/layout-bmfont-text/index.js":
/*!**********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/layout-bmfont-text/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wordWrap = __webpack_require__(/*! word-wrapper */ "../../node_modules/word-wrapper/index.js")
var xtend = __webpack_require__(/*! xtend */ "../../node_modules/xtend/immutable.js")
var number = __webpack_require__(/*! as-number */ "../../node_modules/as-number/index.js")

var X_HEIGHTS = ['x', 'e', 'a', 'o', 'n', 's', 'r', 'c', 'u', 'm', 'v', 'w', 'z']
var M_WIDTHS = ['m', 'w']
var CAP_HEIGHTS = ['H', 'I', 'N', 'E', 'F', 'K', 'L', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']


var TAB_ID = '\t'.charCodeAt(0)
var SPACE_ID = ' '.charCodeAt(0)
var ALIGN_LEFT = 0, 
    ALIGN_CENTER = 1, 
    ALIGN_RIGHT = 2

module.exports = function createLayout(opt) {
  return new TextLayout(opt)
}

function TextLayout(opt) {
  this.glyphs = []
  this._measure = this.computeMetrics.bind(this)
  this.update(opt)
}

TextLayout.prototype.update = function(opt) {
  opt = xtend({
    measure: this._measure
  }, opt)
  this._opt = opt
  this._opt.tabSize = number(this._opt.tabSize, 4)

  if (!opt.font)
    throw new Error('must provide a valid bitmap font')

  var glyphs = this.glyphs
  var text = opt.text||'' 
  var font = opt.font
  this._setupSpaceGlyphs(font)
  
  var lines = wordWrap.lines(text, opt)
  var minWidth = opt.width || 0

  //clear glyphs
  glyphs.length = 0

  //get max line width
  var maxLineWidth = lines.reduce(function(prev, line) {
    return Math.max(prev, line.width, minWidth)
  }, 0)

  //the pen position
  var x = 0
  var y = 0
  var lineHeight = number(opt.lineHeight, font.common.lineHeight)
  var baseline = font.common.base
  var descender = lineHeight-baseline
  var letterSpacing = opt.letterSpacing || 0
  var height = lineHeight * lines.length - descender
  var align = getAlignType(this._opt.align)

  //draw text along baseline
  y -= height
  
  //the metrics for this text layout
  this._width = maxLineWidth
  this._height = height
  this._descender = lineHeight - baseline
  this._baseline = baseline
  this._xHeight = getXHeight(font)
  this._capHeight = getCapHeight(font)
  this._lineHeight = lineHeight
  this._ascender = lineHeight - descender - this._xHeight
    
  //layout each glyph
  var self = this
  lines.forEach(function(line, lineIndex) {
    var start = line.start
    var end = line.end
    var lineWidth = line.width
    var lastGlyph
    
    //for each glyph in that line...
    for (var i=start; i<end; i++) {
      var id = text.charCodeAt(i)
      var glyph = self.getGlyph(font, id)
      if (glyph) {
        if (lastGlyph) 
          x += getKerning(font, lastGlyph.id, glyph.id)

        var tx = x
        if (align === ALIGN_CENTER) 
          tx += (maxLineWidth-lineWidth)/2
        else if (align === ALIGN_RIGHT)
          tx += (maxLineWidth-lineWidth)

        glyphs.push({
          position: [tx, y],
          data: glyph,
          index: i,
          line: lineIndex
        })  

        //move pen forward
        x += glyph.xadvance + letterSpacing
        lastGlyph = glyph
      }
    }

    //next line down
    y += lineHeight
    x = 0
  })
  this._linesTotal = lines.length;
}

TextLayout.prototype._setupSpaceGlyphs = function(font) {
  //These are fallbacks, when the font doesn't include
  //' ' or '\t' glyphs
  this._fallbackSpaceGlyph = null
  this._fallbackTabGlyph = null

  if (!font.chars || font.chars.length === 0)
    return

  //try to get space glyph
  //then fall back to the 'm' or 'w' glyphs
  //then fall back to the first glyph available
  var space = getGlyphById(font, SPACE_ID) 
          || getMGlyph(font) 
          || font.chars[0]

  //and create a fallback for tab
  var tabWidth = this._opt.tabSize * space.xadvance
  this._fallbackSpaceGlyph = space
  this._fallbackTabGlyph = xtend(space, {
    x: 0, y: 0, xadvance: tabWidth, id: TAB_ID, 
    xoffset: 0, yoffset: 0, width: 0, height: 0
  })
}

TextLayout.prototype.getGlyph = function(font, id) {
  var glyph = getGlyphById(font, id)
  if (glyph)
    return glyph
  else if (id === TAB_ID) 
    return this._fallbackTabGlyph
  else if (id === SPACE_ID) 
    return this._fallbackSpaceGlyph
  return null
}

TextLayout.prototype.computeMetrics = function(text, start, end, width) {
  var letterSpacing = this._opt.letterSpacing || 0
  var font = this._opt.font
  var curPen = 0
  var curWidth = 0
  var count = 0
  var glyph
  var lastGlyph

  if (!font.chars || font.chars.length === 0) {
    return {
      start: start,
      end: start,
      width: 0
    }
  }

  end = Math.min(text.length, end)
  for (var i=start; i < end; i++) {
    var id = text.charCodeAt(i)
    var glyph = this.getGlyph(font, id)

    if (glyph) {
      //move pen forward
      var xoff = glyph.xoffset
      var kern = lastGlyph ? getKerning(font, lastGlyph.id, glyph.id) : 0
      curPen += kern

      var nextPen = curPen + glyph.xadvance + letterSpacing
      var nextWidth = curPen + glyph.width

      //we've hit our limit; we can't move onto the next glyph
      if (nextWidth >= width || nextPen >= width)
        break

      //otherwise continue along our line
      curPen = nextPen
      curWidth = nextWidth
      lastGlyph = glyph
    }
    count++
  }
  
  //make sure rightmost edge lines up with rendered glyphs
  if (lastGlyph)
    curWidth += lastGlyph.xoffset

  return {
    start: start,
    end: start + count,
    width: curWidth
  }
}

//getters for the private vars
;['width', 'height', 
  'descender', 'ascender',
  'xHeight', 'baseline',
  'capHeight',
  'lineHeight' ].forEach(addGetter)

function addGetter(name) {
  Object.defineProperty(TextLayout.prototype, name, {
    get: wrapper(name),
    configurable: true
  })
}

//create lookups for private vars
function wrapper(name) {
  return (new Function([
    'return function '+name+'() {',
    '  return this._'+name,
    '}'
  ].join('\n')))()
}

function getGlyphById(font, id) {
  if (!font.chars || font.chars.length === 0)
    return null

  var glyphIdx = findChar(font.chars, id)
  if (glyphIdx >= 0)
    return font.chars[glyphIdx]
  return null
}

function getXHeight(font) {
  for (var i=0; i<X_HEIGHTS.length; i++) {
    var id = X_HEIGHTS[i].charCodeAt(0)
    var idx = findChar(font.chars, id)
    if (idx >= 0) 
      return font.chars[idx].height
  }
  return 0
}

function getMGlyph(font) {
  for (var i=0; i<M_WIDTHS.length; i++) {
    var id = M_WIDTHS[i].charCodeAt(0)
    var idx = findChar(font.chars, id)
    if (idx >= 0) 
      return font.chars[idx]
  }
  return 0
}

function getCapHeight(font) {
  for (var i=0; i<CAP_HEIGHTS.length; i++) {
    var id = CAP_HEIGHTS[i].charCodeAt(0)
    var idx = findChar(font.chars, id)
    if (idx >= 0) 
      return font.chars[idx].height
  }
  return 0
}

function getKerning(font, left, right) {
  if (!font.kernings || font.kernings.length === 0)
    return 0

  var table = font.kernings
  for (var i=0; i<table.length; i++) {
    var kern = table[i]
    if (kern.first === left && kern.second === right)
      return kern.amount
  }
  return 0
}

function getAlignType(align) {
  if (align === 'center')
    return ALIGN_CENTER
  else if (align === 'right')
    return ALIGN_RIGHT
  return ALIGN_LEFT
}

function findChar (array, value, start) {
  start = start || 0
  for (var i = start; i < array.length; i++) {
    if (array[i].id === value) {
      return i
    }
  }
  return -1
}

/***/ }),

/***/ "../../node_modules/lit-element/lib/css-tag.js":
/*!*********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/lit-element/lib/css-tag.js ***!
  \*********************************************************************/
/*! exports provided: supportsAdoptingStyleSheets, CSSResult, unsafeCSS, css */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportsAdoptingStyleSheets", function() { return supportsAdoptingStyleSheets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSSResult", function() { return CSSResult; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unsafeCSS", function() { return unsafeCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "css", function() { return css; });
/**
@license
Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
const supportsAdoptingStyleSheets = ('adoptedStyleSheets' in Document.prototype) &&
    ('replace' in CSSStyleSheet.prototype);
const constructionToken = Symbol();
class CSSResult {
    constructor(cssText, safeToken) {
        if (safeToken !== constructionToken) {
            throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');
        }
        this.cssText = cssText;
    }
    // Note, this is a getter so that it's lazy. In practice, this means
    // stylesheets are not created until the first element instance is made.
    get styleSheet() {
        if (this._styleSheet === undefined) {
            // Note, if `adoptedStyleSheets` is supported then we assume CSSStyleSheet
            // is constructable.
            if (supportsAdoptingStyleSheets) {
                this._styleSheet = new CSSStyleSheet();
                this._styleSheet.replaceSync(this.cssText);
            }
            else {
                this._styleSheet = null;
            }
        }
        return this._styleSheet;
    }
    toString() {
        return this.cssText;
    }
}
/**
 * Wrap a value for interpolation in a css tagged template literal.
 *
 * This is unsafe because untrusted CSS text can be used to phone home
 * or exfiltrate data to an attacker controlled site. Take care to only use
 * this with trusted input.
 */
const unsafeCSS = (value) => {
    return new CSSResult(String(value), constructionToken);
};
const textFromCSSResult = (value) => {
    if (value instanceof CSSResult) {
        return value.cssText;
    }
    else if (typeof value === 'number') {
        return value;
    }
    else {
        throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but
            take care to ensure page security.`);
    }
};
/**
 * Template tag which which can be used with LitElement's `style` property to
 * set element styles. For security reasons, only literal string values may be
 * used. To incorporate non-literal values `unsafeCSS` may be used inside a
 * template string part.
 */
const css = (strings, ...values) => {
    const cssText = values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);
    return new CSSResult(cssText, constructionToken);
};


/***/ }),

/***/ "../../node_modules/lit-element/lib/decorators.js":
/*!************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/lit-element/lib/decorators.js ***!
  \************************************************************************/
/*! exports provided: customElement, property, internalProperty, query, queryAsync, queryAll, eventOptions, queryAssignedNodes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "customElement", function() { return customElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "property", function() { return property; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "internalProperty", function() { return internalProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "query", function() { return query; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryAsync", function() { return queryAsync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryAll", function() { return queryAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eventOptions", function() { return eventOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryAssignedNodes", function() { return queryAssignedNodes; });
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const legacyCustomElement = (tagName, clazz) => {
    window.customElements.define(tagName, clazz);
    // Cast as any because TS doesn't recognize the return type as being a
    // subtype of the decorated class when clazz is typed as
    // `Constructor<HTMLElement>` for some reason.
    // `Constructor<HTMLElement>` is helpful to make sure the decorator is
    // applied to elements however.
    // tslint:disable-next-line:no-any
    return clazz;
};
const standardCustomElement = (tagName, descriptor) => {
    const { kind, elements } = descriptor;
    return {
        kind,
        elements,
        // This callback is called once the class is otherwise fully defined
        finisher(clazz) {
            window.customElements.define(tagName, clazz);
        }
    };
};
/**
 * Class decorator factory that defines the decorated class as a custom element.
 *
 * ```
 * @customElement('my-element')
 * class MyElement {
 *   render() {
 *     return html``;
 *   }
 * }
 * ```
 *
 * @param tagName The name of the custom element to define.
 */
const customElement = (tagName) => (classOrDescriptor) => (typeof classOrDescriptor === 'function') ?
    legacyCustomElement(tagName, classOrDescriptor) :
    standardCustomElement(tagName, classOrDescriptor);
const standardProperty = (options, element) => {
    // When decorating an accessor, pass it through and add property metadata.
    // Note, the `hasOwnProperty` check in `createProperty` ensures we don't
    // stomp over the user's accessor.
    if (element.kind === 'method' && element.descriptor &&
        !('value' in element.descriptor)) {
        return Object.assign(Object.assign({}, element), { finisher(clazz) {
                clazz.createProperty(element.key, options);
            } });
    }
    else {
        // createProperty() takes care of defining the property, but we still
        // must return some kind of descriptor, so return a descriptor for an
        // unused prototype field. The finisher calls createProperty().
        return {
            kind: 'field',
            key: Symbol(),
            placement: 'own',
            descriptor: {},
            // When @babel/plugin-proposal-decorators implements initializers,
            // do this instead of the initializer below. See:
            // https://github.com/babel/babel/issues/9260 extras: [
            //   {
            //     kind: 'initializer',
            //     placement: 'own',
            //     initializer: descriptor.initializer,
            //   }
            // ],
            initializer() {
                if (typeof element.initializer === 'function') {
                    this[element.key] = element.initializer.call(this);
                }
            },
            finisher(clazz) {
                clazz.createProperty(element.key, options);
            }
        };
    }
};
const legacyProperty = (options, proto, name) => {
    proto.constructor
        .createProperty(name, options);
};
/**
 * A property decorator which creates a LitElement property which reflects a
 * corresponding attribute value. A `PropertyDeclaration` may optionally be
 * supplied to configure property features.
 *
 * This decorator should only be used for public fields. Private or protected
 * fields should use the internalProperty decorator.
 *
 * @example
 *
 *     class MyElement {
 *       @property({ type: Boolean })
 *       clicked = false;
 *     }
 *
 * @ExportDecoratedItems
 */
function property(options) {
    // tslint:disable-next-line:no-any decorator
    return (protoOrDescriptor, name) => (name !== undefined) ?
        legacyProperty(options, protoOrDescriptor, name) :
        standardProperty(options, protoOrDescriptor);
}
/**
 * Declares a private or protected property that still triggers updates to the
 * element when it changes.
 *
 * Properties declared this way must not be used from HTML or HTML templating
 * systems, they're solely for properties internal to the element. These
 * properties may be renamed by optimization tools like closure compiler.
 */
function internalProperty(options) {
    return property({ attribute: false, hasChanged: options === null || options === void 0 ? void 0 : options.hasChanged });
}
/**
 * A property decorator that converts a class property into a getter that
 * executes a querySelector on the element's renderRoot.
 *
 * @param selector A DOMString containing one or more selectors to match.
 *
 * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector
 *
 * @example
 *
 *     class MyElement {
 *       @query('#first')
 *       first;
 *
 *       render() {
 *         return html`
 *           <div id="first"></div>
 *           <div id="second"></div>
 *         `;
 *       }
 *     }
 *
 */
function query(selector) {
    return (protoOrDescriptor, 
    // tslint:disable-next-line:no-any decorator
    name) => {
        const descriptor = {
            get() {
                return this.renderRoot.querySelector(selector);
            },
            enumerable: true,
            configurable: true,
        };
        return (name !== undefined) ?
            legacyQuery(descriptor, protoOrDescriptor, name) :
            standardQuery(descriptor, protoOrDescriptor);
    };
}
// Note, in the future, we may extend this decorator to support the use case
// where the queried element may need to do work to become ready to interact
// with (e.g. load some implementation code). If so, we might elect to
// add a second argument defining a function that can be run to make the
// queried element loaded/updated/ready.
/**
 * A property decorator that converts a class property into a getter that
 * returns a promise that resolves to the result of a querySelector on the
 * element's renderRoot done after the element's `updateComplete` promise
 * resolves. When the queried property may change with element state, this
 * decorator can be used instead of requiring users to await the
 * `updateComplete` before accessing the property.
 *
 * @param selector A DOMString containing one or more selectors to match.
 *
 * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector
 *
 * @example
 *
 *     class MyElement {
 *       @queryAsync('#first')
 *       first;
 *
 *       render() {
 *         return html`
 *           <div id="first"></div>
 *           <div id="second"></div>
 *         `;
 *       }
 *     }
 *
 *     // external usage
 *     async doSomethingWithFirst() {
 *      (await aMyElement.first).doSomething();
 *     }
 */
function queryAsync(selector) {
    return (protoOrDescriptor, 
    // tslint:disable-next-line:no-any decorator
    name) => {
        const descriptor = {
            async get() {
                await this.updateComplete;
                return this.renderRoot.querySelector(selector);
            },
            enumerable: true,
            configurable: true,
        };
        return (name !== undefined) ?
            legacyQuery(descriptor, protoOrDescriptor, name) :
            standardQuery(descriptor, protoOrDescriptor);
    };
}
/**
 * A property decorator that converts a class property into a getter
 * that executes a querySelectorAll on the element's renderRoot.
 *
 * @param selector A DOMString containing one or more selectors to match.
 *
 * See:
 * https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll
 *
 * @example
 *
 *     class MyElement {
 *       @queryAll('div')
 *       divs;
 *
 *       render() {
 *         return html`
 *           <div id="first"></div>
 *           <div id="second"></div>
 *         `;
 *       }
 *     }
 */
function queryAll(selector) {
    return (protoOrDescriptor, 
    // tslint:disable-next-line:no-any decorator
    name) => {
        const descriptor = {
            get() {
                return this.renderRoot.querySelectorAll(selector);
            },
            enumerable: true,
            configurable: true,
        };
        return (name !== undefined) ?
            legacyQuery(descriptor, protoOrDescriptor, name) :
            standardQuery(descriptor, protoOrDescriptor);
    };
}
const legacyQuery = (descriptor, proto, name) => {
    Object.defineProperty(proto, name, descriptor);
};
const standardQuery = (descriptor, element) => ({
    kind: 'method',
    placement: 'prototype',
    key: element.key,
    descriptor,
});
const standardEventOptions = (options, element) => {
    return Object.assign(Object.assign({}, element), { finisher(clazz) {
            Object.assign(clazz.prototype[element.key], options);
        } });
};
const legacyEventOptions = 
// tslint:disable-next-line:no-any legacy decorator
(options, proto, name) => {
    Object.assign(proto[name], options);
};
/**
 * Adds event listener options to a method used as an event listener in a
 * lit-html template.
 *
 * @param options An object that specifies event listener options as accepted by
 * `EventTarget#addEventListener` and `EventTarget#removeEventListener`.
 *
 * Current browsers support the `capture`, `passive`, and `once` options. See:
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters
 *
 * @example
 *
 *     class MyElement {
 *       clicked = false;
 *
 *       render() {
 *         return html`
 *           <div @click=${this._onClick}`>
 *             <button></button>
 *           </div>
 *         `;
 *       }
 *
 *       @eventOptions({capture: true})
 *       _onClick(e) {
 *         this.clicked = true;
 *       }
 *     }
 */
function eventOptions(options) {
    // Return value typed as any to prevent TypeScript from complaining that
    // standard decorator function signature does not match TypeScript decorator
    // signature
    // TODO(kschaaf): unclear why it was only failing on this decorator and not
    // the others
    return ((protoOrDescriptor, name) => (name !== undefined) ?
        legacyEventOptions(options, protoOrDescriptor, name) :
        standardEventOptions(options, protoOrDescriptor));
}
/**
 * A property decorator that converts a class property into a getter that
 * returns the `assignedNodes` of the given named `slot`. Note, the type of
 * this property should be annotated as `NodeListOf<HTMLElement>`.
 *
 */
function queryAssignedNodes(slotName = '', flatten = false) {
    return (protoOrDescriptor, 
    // tslint:disable-next-line:no-any decorator
    name) => {
        const descriptor = {
            get() {
                const selector = `slot${slotName ? `[name=${slotName}]` : ''}`;
                const slot = this.renderRoot.querySelector(selector);
                return slot && slot.assignedNodes({ flatten });
            },
            enumerable: true,
            configurable: true,
        };
        return (name !== undefined) ?
            legacyQuery(descriptor, protoOrDescriptor, name) :
            standardQuery(descriptor, protoOrDescriptor);
    };
}


/***/ }),

/***/ "../../node_modules/lit-element/lib/updating-element.js":
/*!******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/lit-element/lib/updating-element.js ***!
  \******************************************************************************/
/*! exports provided: defaultConverter, notEqual, UpdatingElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultConverter", function() { return defaultConverter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notEqual", function() { return notEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UpdatingElement", function() { return UpdatingElement; });
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var _a;
/**
 * When using Closure Compiler, JSCompiler_renameProperty(property, object) is
 * replaced at compile time by the munged name for object[property]. We cannot
 * alias this function, so we have to use a small shim that has the same
 * behavior when not compiling.
 */
window.JSCompiler_renameProperty =
    (prop, _obj) => prop;
const defaultConverter = {
    toAttribute(value, type) {
        switch (type) {
            case Boolean:
                return value ? '' : null;
            case Object:
            case Array:
                // if the value is `null` or `undefined` pass this through
                // to allow removing/no change behavior.
                return value == null ? value : JSON.stringify(value);
        }
        return value;
    },
    fromAttribute(value, type) {
        switch (type) {
            case Boolean:
                return value !== null;
            case Number:
                return value === null ? null : Number(value);
            case Object:
            case Array:
                return JSON.parse(value);
        }
        return value;
    }
};
/**
 * Change function that returns true if `value` is different from `oldValue`.
 * This method is used as the default for a property's `hasChanged` function.
 */
const notEqual = (value, old) => {
    // This ensures (old==NaN, value==NaN) always returns false
    return old !== value && (old === old || value === value);
};
const defaultPropertyDeclaration = {
    attribute: true,
    type: String,
    converter: defaultConverter,
    reflect: false,
    hasChanged: notEqual
};
const STATE_HAS_UPDATED = 1;
const STATE_UPDATE_REQUESTED = 1 << 2;
const STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;
const STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;
/**
 * The Closure JS Compiler doesn't currently have good support for static
 * property semantics where "this" is dynamic (e.g.
 * https://github.com/google/closure-compiler/issues/3177 and others) so we use
 * this hack to bypass any rewriting by the compiler.
 */
const finalized = 'finalized';
/**
 * Base element class which manages element properties and attributes. When
 * properties change, the `update` method is asynchronously called. This method
 * should be supplied by subclassers to render updates as desired.
 */
class UpdatingElement extends HTMLElement {
    constructor() {
        super();
        this._updateState = 0;
        this._instanceProperties = undefined;
        // Initialize to an unresolved Promise so we can make sure the element has
        // connected before first update.
        this._updatePromise = new Promise((res) => this._enableUpdatingResolver = res);
        /**
         * Map with keys for any properties that have changed since the last
         * update cycle with previous values.
         */
        this._changedProperties = new Map();
        /**
         * Map with keys of properties that should be reflected when updated.
         */
        this._reflectingProperties = undefined;
        this.initialize();
    }
    /**
     * Returns a list of attributes corresponding to the registered properties.
     * @nocollapse
     */
    static get observedAttributes() {
        // note: piggy backing on this to ensure we're finalized.
        this.finalize();
        const attributes = [];
        // Use forEach so this works even if for/of loops are compiled to for loops
        // expecting arrays
        this._classProperties.forEach((v, p) => {
            const attr = this._attributeNameForProperty(p, v);
            if (attr !== undefined) {
                this._attributeToPropertyMap.set(attr, p);
                attributes.push(attr);
            }
        });
        return attributes;
    }
    /**
     * Ensures the private `_classProperties` property metadata is created.
     * In addition to `finalize` this is also called in `createProperty` to
     * ensure the `@property` decorator can add property metadata.
     */
    /** @nocollapse */
    static _ensureClassProperties() {
        // ensure private storage for property declarations.
        if (!this.hasOwnProperty(JSCompiler_renameProperty('_classProperties', this))) {
            this._classProperties = new Map();
            // NOTE: Workaround IE11 not supporting Map constructor argument.
            const superProperties = Object.getPrototypeOf(this)._classProperties;
            if (superProperties !== undefined) {
                superProperties.forEach((v, k) => this._classProperties.set(k, v));
            }
        }
    }
    /**
     * Creates a property accessor on the element prototype if one does not exist
     * and stores a PropertyDeclaration for the property with the given options.
     * The property setter calls the property's `hasChanged` property option
     * or uses a strict identity check to determine whether or not to request
     * an update.
     *
     * This method may be overridden to customize properties; however,
     * when doing so, it's important to call `super.createProperty` to ensure
     * the property is setup correctly. This method calls
     * `getPropertyDescriptor` internally to get a descriptor to install.
     * To customize what properties do when they are get or set, override
     * `getPropertyDescriptor`. To customize the options for a property,
     * implement `createProperty` like this:
     *
     * static createProperty(name, options) {
     *   options = Object.assign(options, {myOption: true});
     *   super.createProperty(name, options);
     * }
     *
     * @nocollapse
     */
    static createProperty(name, options = defaultPropertyDeclaration) {
        // Note, since this can be called by the `@property` decorator which
        // is called before `finalize`, we ensure storage exists for property
        // metadata.
        this._ensureClassProperties();
        this._classProperties.set(name, options);
        // Do not generate an accessor if the prototype already has one, since
        // it would be lost otherwise and that would never be the user's intention;
        // Instead, we expect users to call `requestUpdate` themselves from
        // user-defined accessors. Note that if the super has an accessor we will
        // still overwrite it
        if (options.noAccessor || this.prototype.hasOwnProperty(name)) {
            return;
        }
        const key = typeof name === 'symbol' ? Symbol() : `__${name}`;
        const descriptor = this.getPropertyDescriptor(name, key, options);
        if (descriptor !== undefined) {
            Object.defineProperty(this.prototype, name, descriptor);
        }
    }
    /**
     * Returns a property descriptor to be defined on the given named property.
     * If no descriptor is returned, the property will not become an accessor.
     * For example,
     *
     *   class MyElement extends LitElement {
     *     static getPropertyDescriptor(name, key, options) {
     *       const defaultDescriptor =
     *           super.getPropertyDescriptor(name, key, options);
     *       const setter = defaultDescriptor.set;
     *       return {
     *         get: defaultDescriptor.get,
     *         set(value) {
     *           setter.call(this, value);
     *           // custom action.
     *         },
     *         configurable: true,
     *         enumerable: true
     *       }
     *     }
     *   }
     *
     * @nocollapse
     */
    static getPropertyDescriptor(name, key, _options) {
        return {
            // tslint:disable-next-line:no-any no symbol in index
            get() {
                return this[key];
            },
            set(value) {
                const oldValue = this[name];
                this[key] = value;
                this._requestUpdate(name, oldValue);
            },
            configurable: true,
            enumerable: true
        };
    }
    /**
     * Returns the property options associated with the given property.
     * These options are defined with a PropertyDeclaration via the `properties`
     * object or the `@property` decorator and are registered in
     * `createProperty(...)`.
     *
     * Note, this method should be considered "final" and not overridden. To
     * customize the options for a given property, override `createProperty`.
     *
     * @nocollapse
     * @final
     */
    static getPropertyOptions(name) {
        return this._classProperties && this._classProperties.get(name) ||
            defaultPropertyDeclaration;
    }
    /**
     * Creates property accessors for registered properties and ensures
     * any superclasses are also finalized.
     * @nocollapse
     */
    static finalize() {
        // finalize any superclasses
        const superCtor = Object.getPrototypeOf(this);
        if (!superCtor.hasOwnProperty(finalized)) {
            superCtor.finalize();
        }
        this[finalized] = true;
        this._ensureClassProperties();
        // initialize Map populated in observedAttributes
        this._attributeToPropertyMap = new Map();
        // make any properties
        // Note, only process "own" properties since this element will inherit
        // any properties defined on the superClass, and finalization ensures
        // the entire prototype chain is finalized.
        if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {
            const props = this.properties;
            // support symbols in properties (IE11 does not support this)
            const propKeys = [
                ...Object.getOwnPropertyNames(props),
                ...(typeof Object.getOwnPropertySymbols === 'function') ?
                    Object.getOwnPropertySymbols(props) :
                    []
            ];
            // This for/of is ok because propKeys is an array
            for (const p of propKeys) {
                // note, use of `any` is due to TypeSript lack of support for symbol in
                // index types
                // tslint:disable-next-line:no-any no symbol in index
                this.createProperty(p, props[p]);
            }
        }
    }
    /**
     * Returns the property name for the given attribute `name`.
     * @nocollapse
     */
    static _attributeNameForProperty(name, options) {
        const attribute = options.attribute;
        return attribute === false ?
            undefined :
            (typeof attribute === 'string' ?
                attribute :
                (typeof name === 'string' ? name.toLowerCase() : undefined));
    }
    /**
     * Returns true if a property should request an update.
     * Called when a property value is set and uses the `hasChanged`
     * option for the property if present or a strict identity check.
     * @nocollapse
     */
    static _valueHasChanged(value, old, hasChanged = notEqual) {
        return hasChanged(value, old);
    }
    /**
     * Returns the property value for the given attribute value.
     * Called via the `attributeChangedCallback` and uses the property's
     * `converter` or `converter.fromAttribute` property option.
     * @nocollapse
     */
    static _propertyValueFromAttribute(value, options) {
        const type = options.type;
        const converter = options.converter || defaultConverter;
        const fromAttribute = (typeof converter === 'function' ? converter : converter.fromAttribute);
        return fromAttribute ? fromAttribute(value, type) : value;
    }
    /**
     * Returns the attribute value for the given property value. If this
     * returns undefined, the property will *not* be reflected to an attribute.
     * If this returns null, the attribute will be removed, otherwise the
     * attribute will be set to the value.
     * This uses the property's `reflect` and `type.toAttribute` property options.
     * @nocollapse
     */
    static _propertyValueToAttribute(value, options) {
        if (options.reflect === undefined) {
            return;
        }
        const type = options.type;
        const converter = options.converter;
        const toAttribute = converter && converter.toAttribute ||
            defaultConverter.toAttribute;
        return toAttribute(value, type);
    }
    /**
     * Performs element initialization. By default captures any pre-set values for
     * registered properties.
     */
    initialize() {
        this._saveInstanceProperties();
        // ensures first update will be caught by an early access of
        // `updateComplete`
        this._requestUpdate();
    }
    /**
     * Fixes any properties set on the instance before upgrade time.
     * Otherwise these would shadow the accessor and break these properties.
     * The properties are stored in a Map which is played back after the
     * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
     * (<=41), properties created for native platform properties like (`id` or
     * `name`) may not have default values set in the element constructor. On
     * these browsers native properties appear on instances and therefore their
     * default value will overwrite any element default (e.g. if the element sets
     * this.id = 'id' in the constructor, the 'id' will become '' since this is
     * the native platform default).
     */
    _saveInstanceProperties() {
        // Use forEach so this works even if for/of loops are compiled to for loops
        // expecting arrays
        this.constructor
            ._classProperties.forEach((_v, p) => {
            if (this.hasOwnProperty(p)) {
                const value = this[p];
                delete this[p];
                if (!this._instanceProperties) {
                    this._instanceProperties = new Map();
                }
                this._instanceProperties.set(p, value);
            }
        });
    }
    /**
     * Applies previously saved instance properties.
     */
    _applyInstanceProperties() {
        // Use forEach so this works even if for/of loops are compiled to for loops
        // expecting arrays
        // tslint:disable-next-line:no-any
        this._instanceProperties.forEach((v, p) => this[p] = v);
        this._instanceProperties = undefined;
    }
    connectedCallback() {
        // Ensure first connection completes an update. Updates cannot complete
        // before connection.
        this.enableUpdating();
    }
    enableUpdating() {
        if (this._enableUpdatingResolver !== undefined) {
            this._enableUpdatingResolver();
            this._enableUpdatingResolver = undefined;
        }
    }
    /**
     * Allows for `super.disconnectedCallback()` in extensions while
     * reserving the possibility of making non-breaking feature additions
     * when disconnecting at some point in the future.
     */
    disconnectedCallback() {
    }
    /**
     * Synchronizes property values when attributes change.
     */
    attributeChangedCallback(name, old, value) {
        if (old !== value) {
            this._attributeToProperty(name, value);
        }
    }
    _propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
        const ctor = this.constructor;
        const attr = ctor._attributeNameForProperty(name, options);
        if (attr !== undefined) {
            const attrValue = ctor._propertyValueToAttribute(value, options);
            // an undefined value does not change the attribute.
            if (attrValue === undefined) {
                return;
            }
            // Track if the property is being reflected to avoid
            // setting the property again via `attributeChangedCallback`. Note:
            // 1. this takes advantage of the fact that the callback is synchronous.
            // 2. will behave incorrectly if multiple attributes are in the reaction
            // stack at time of calling. However, since we process attributes
            // in `update` this should not be possible (or an extreme corner case
            // that we'd like to discover).
            // mark state reflecting
            this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;
            if (attrValue == null) {
                this.removeAttribute(attr);
            }
            else {
                this.setAttribute(attr, attrValue);
            }
            // mark state not reflecting
            this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;
        }
    }
    _attributeToProperty(name, value) {
        // Use tracking info to avoid deserializing attribute value if it was
        // just set from a property setter.
        if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {
            return;
        }
        const ctor = this.constructor;
        // Note, hint this as an `AttributeMap` so closure clearly understands
        // the type; it has issues with tracking types through statics
        // tslint:disable-next-line:no-unnecessary-type-assertion
        const propName = ctor._attributeToPropertyMap.get(name);
        if (propName !== undefined) {
            const options = ctor.getPropertyOptions(propName);
            // mark state reflecting
            this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;
            this[propName] =
                // tslint:disable-next-line:no-any
                ctor._propertyValueFromAttribute(value, options);
            // mark state not reflecting
            this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;
        }
    }
    /**
     * This private version of `requestUpdate` does not access or return the
     * `updateComplete` promise. This promise can be overridden and is therefore
     * not free to access.
     */
    _requestUpdate(name, oldValue) {
        let shouldRequestUpdate = true;
        // If we have a property key, perform property update steps.
        if (name !== undefined) {
            const ctor = this.constructor;
            const options = ctor.getPropertyOptions(name);
            if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {
                if (!this._changedProperties.has(name)) {
                    this._changedProperties.set(name, oldValue);
                }
                // Add to reflecting properties set.
                // Note, it's important that every change has a chance to add the
                // property to `_reflectingProperties`. This ensures setting
                // attribute + property reflects correctly.
                if (options.reflect === true &&
                    !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {
                    if (this._reflectingProperties === undefined) {
                        this._reflectingProperties = new Map();
                    }
                    this._reflectingProperties.set(name, options);
                }
            }
            else {
                // Abort the request if the property should not be considered changed.
                shouldRequestUpdate = false;
            }
        }
        if (!this._hasRequestedUpdate && shouldRequestUpdate) {
            this._updatePromise = this._enqueueUpdate();
        }
    }
    /**
     * Requests an update which is processed asynchronously. This should
     * be called when an element should update based on some state not triggered
     * by setting a property. In this case, pass no arguments. It should also be
     * called when manually implementing a property setter. In this case, pass the
     * property `name` and `oldValue` to ensure that any configured property
     * options are honored. Returns the `updateComplete` Promise which is resolved
     * when the update completes.
     *
     * @param name {PropertyKey} (optional) name of requesting property
     * @param oldValue {any} (optional) old value of requesting property
     * @returns {Promise} A Promise that is resolved when the update completes.
     */
    requestUpdate(name, oldValue) {
        this._requestUpdate(name, oldValue);
        return this.updateComplete;
    }
    /**
     * Sets up the element to asynchronously update.
     */
    async _enqueueUpdate() {
        this._updateState = this._updateState | STATE_UPDATE_REQUESTED;
        try {
            // Ensure any previous update has resolved before updating.
            // This `await` also ensures that property changes are batched.
            await this._updatePromise;
        }
        catch (e) {
            // Ignore any previous errors. We only care that the previous cycle is
            // done. Any error should have been handled in the previous update.
        }
        const result = this.performUpdate();
        // If `performUpdate` returns a Promise, we await it. This is done to
        // enable coordinating updates with a scheduler. Note, the result is
        // checked to avoid delaying an additional microtask unless we need to.
        if (result != null) {
            await result;
        }
        return !this._hasRequestedUpdate;
    }
    get _hasRequestedUpdate() {
        return (this._updateState & STATE_UPDATE_REQUESTED);
    }
    get hasUpdated() {
        return (this._updateState & STATE_HAS_UPDATED);
    }
    /**
     * Performs an element update. Note, if an exception is thrown during the
     * update, `firstUpdated` and `updated` will not be called.
     *
     * You can override this method to change the timing of updates. If this
     * method is overridden, `super.performUpdate()` must be called.
     *
     * For instance, to schedule updates to occur just before the next frame:
     *
     * ```
     * protected async performUpdate(): Promise<unknown> {
     *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
     *   super.performUpdate();
     * }
     * ```
     */
    performUpdate() {
        // Mixin instance properties once, if they exist.
        if (this._instanceProperties) {
            this._applyInstanceProperties();
        }
        let shouldUpdate = false;
        const changedProperties = this._changedProperties;
        try {
            shouldUpdate = this.shouldUpdate(changedProperties);
            if (shouldUpdate) {
                this.update(changedProperties);
            }
            else {
                this._markUpdated();
            }
        }
        catch (e) {
            // Prevent `firstUpdated` and `updated` from running when there's an
            // update exception.
            shouldUpdate = false;
            // Ensure element can accept additional updates after an exception.
            this._markUpdated();
            throw e;
        }
        if (shouldUpdate) {
            if (!(this._updateState & STATE_HAS_UPDATED)) {
                this._updateState = this._updateState | STATE_HAS_UPDATED;
                this.firstUpdated(changedProperties);
            }
            this.updated(changedProperties);
        }
    }
    _markUpdated() {
        this._changedProperties = new Map();
        this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;
    }
    /**
     * Returns a Promise that resolves when the element has completed updating.
     * The Promise value is a boolean that is `true` if the element completed the
     * update without triggering another update. The Promise result is `false` if
     * a property was set inside `updated()`. If the Promise is rejected, an
     * exception was thrown during the update.
     *
     * To await additional asynchronous work, override the `_getUpdateComplete`
     * method. For example, it is sometimes useful to await a rendered element
     * before fulfilling this Promise. To do this, first await
     * `super._getUpdateComplete()`, then any subsequent state.
     *
     * @returns {Promise} The Promise returns a boolean that indicates if the
     * update resolved without triggering another update.
     */
    get updateComplete() {
        return this._getUpdateComplete();
    }
    /**
     * Override point for the `updateComplete` promise.
     *
     * It is not safe to override the `updateComplete` getter directly due to a
     * limitation in TypeScript which means it is not possible to call a
     * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
     * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
     * This method should be overridden instead. For example:
     *
     *   class MyElement extends LitElement {
     *     async _getUpdateComplete() {
     *       await super._getUpdateComplete();
     *       await this._myChild.updateComplete;
     *     }
     *   }
     */
    _getUpdateComplete() {
        return this._updatePromise;
    }
    /**
     * Controls whether or not `update` should be called when the element requests
     * an update. By default, this method always returns `true`, but this can be
     * customized to control when to update.
     *
     * @param _changedProperties Map of changed properties with old values
     */
    shouldUpdate(_changedProperties) {
        return true;
    }
    /**
     * Updates the element. This method reflects property values to attributes.
     * It can be overridden to render and keep updated element DOM.
     * Setting properties inside this method will *not* trigger
     * another update.
     *
     * @param _changedProperties Map of changed properties with old values
     */
    update(_changedProperties) {
        if (this._reflectingProperties !== undefined &&
            this._reflectingProperties.size > 0) {
            // Use forEach so this works even if for/of loops are compiled to for
            // loops expecting arrays
            this._reflectingProperties.forEach((v, k) => this._propertyToAttribute(k, this[k], v));
            this._reflectingProperties = undefined;
        }
        this._markUpdated();
    }
    /**
     * Invoked whenever the element is updated. Implement to perform
     * post-updating tasks via DOM APIs, for example, focusing an element.
     *
     * Setting properties inside this method will trigger the element to update
     * again after this update cycle completes.
     *
     * @param _changedProperties Map of changed properties with old values
     */
    updated(_changedProperties) {
    }
    /**
     * Invoked when the element is first updated. Implement to perform one time
     * work on the element after update.
     *
     * Setting properties inside this method will trigger the element to update
     * again after this update cycle completes.
     *
     * @param _changedProperties Map of changed properties with old values
     */
    firstUpdated(_changedProperties) {
    }
}
_a = finalized;
/**
 * Marks class as having finished creating properties.
 */
UpdatingElement[_a] = true;


/***/ }),

/***/ "../../node_modules/lit-element/lit-element.js":
/*!*********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/lit-element/lit-element.js ***!
  \*********************************************************************/
/*! exports provided: defaultConverter, notEqual, UpdatingElement, customElement, property, internalProperty, query, queryAsync, queryAll, eventOptions, queryAssignedNodes, html, svg, TemplateResult, SVGTemplateResult, supportsAdoptingStyleSheets, CSSResult, unsafeCSS, css, LitElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LitElement", function() { return LitElement; });
/* harmony import */ var lit_html_lib_shady_render_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-html/lib/shady-render.js */ "../../node_modules/lit-html/lib/shady-render.js");
/* harmony import */ var _lib_updating_element_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/updating-element.js */ "../../node_modules/lit-element/lib/updating-element.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaultConverter", function() { return _lib_updating_element_js__WEBPACK_IMPORTED_MODULE_1__["defaultConverter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "notEqual", function() { return _lib_updating_element_js__WEBPACK_IMPORTED_MODULE_1__["notEqual"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UpdatingElement", function() { return _lib_updating_element_js__WEBPACK_IMPORTED_MODULE_1__["UpdatingElement"]; });

/* harmony import */ var _lib_decorators_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/decorators.js */ "../../node_modules/lit-element/lib/decorators.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "customElement", function() { return _lib_decorators_js__WEBPACK_IMPORTED_MODULE_2__["customElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "property", function() { return _lib_decorators_js__WEBPACK_IMPORTED_MODULE_2__["property"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "internalProperty", function() { return _lib_decorators_js__WEBPACK_IMPORTED_MODULE_2__["internalProperty"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "query", function() { return _lib_decorators_js__WEBPACK_IMPORTED_MODULE_2__["query"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "queryAsync", function() { return _lib_decorators_js__WEBPACK_IMPORTED_MODULE_2__["queryAsync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "queryAll", function() { return _lib_decorators_js__WEBPACK_IMPORTED_MODULE_2__["queryAll"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "eventOptions", function() { return _lib_decorators_js__WEBPACK_IMPORTED_MODULE_2__["eventOptions"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "queryAssignedNodes", function() { return _lib_decorators_js__WEBPACK_IMPORTED_MODULE_2__["queryAssignedNodes"]; });

/* harmony import */ var lit_html_lit_html_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lit-html/lit-html.js */ "../../node_modules/lit-html/lit-html.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "html", function() { return lit_html_lit_html_js__WEBPACK_IMPORTED_MODULE_3__["html"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "svg", function() { return lit_html_lit_html_js__WEBPACK_IMPORTED_MODULE_3__["svg"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TemplateResult", function() { return lit_html_lit_html_js__WEBPACK_IMPORTED_MODULE_3__["TemplateResult"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SVGTemplateResult", function() { return lit_html_lit_html_js__WEBPACK_IMPORTED_MODULE_3__["SVGTemplateResult"]; });

/* harmony import */ var _lib_css_tag_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/css-tag.js */ "../../node_modules/lit-element/lib/css-tag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "supportsAdoptingStyleSheets", function() { return _lib_css_tag_js__WEBPACK_IMPORTED_MODULE_4__["supportsAdoptingStyleSheets"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CSSResult", function() { return _lib_css_tag_js__WEBPACK_IMPORTED_MODULE_4__["CSSResult"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unsafeCSS", function() { return _lib_css_tag_js__WEBPACK_IMPORTED_MODULE_4__["unsafeCSS"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "css", function() { return _lib_css_tag_js__WEBPACK_IMPORTED_MODULE_4__["css"]; });

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */







// IMPORTANT: do not change the property name or the assignment expression.
// This line will be used in regexes to search for LitElement usage.
// TODO(justinfagnani): inject version number at build time
(window['litElementVersions'] || (window['litElementVersions'] = []))
    .push('2.3.1');
/**
 * Sentinal value used to avoid calling lit-html's render function when
 * subclasses do not implement `render`
 */
const renderNotImplemented = {};
class LitElement extends _lib_updating_element_js__WEBPACK_IMPORTED_MODULE_1__["UpdatingElement"] {
    /**
     * Return the array of styles to apply to the element.
     * Override this method to integrate into a style management system.
     *
     * @nocollapse
     */
    static getStyles() {
        return this.styles;
    }
    /** @nocollapse */
    static _getUniqueStyles() {
        // Only gather styles once per class
        if (this.hasOwnProperty(JSCompiler_renameProperty('_styles', this))) {
            return;
        }
        // Take care not to call `this.getStyles()` multiple times since this
        // generates new CSSResults each time.
        // TODO(sorvell): Since we do not cache CSSResults by input, any
        // shared styles will generate new stylesheet objects, which is wasteful.
        // This should be addressed when a browser ships constructable
        // stylesheets.
        const userStyles = this.getStyles();
        if (userStyles === undefined) {
            this._styles = [];
        }
        else if (Array.isArray(userStyles)) {
            // De-duplicate styles preserving the _last_ instance in the set.
            // This is a performance optimization to avoid duplicated styles that can
            // occur especially when composing via subclassing.
            // The last item is kept to try to preserve the cascade order with the
            // assumption that it's most important that last added styles override
            // previous styles.
            const addStyles = (styles, set) => styles.reduceRight((set, s) => 
            // Note: On IE set.add() does not return the set
            Array.isArray(s) ? addStyles(s, set) : (set.add(s), set), set);
            // Array.from does not work on Set in IE, otherwise return
            // Array.from(addStyles(userStyles, new Set<CSSResult>())).reverse()
            const set = addStyles(userStyles, new Set());
            const styles = [];
            set.forEach((v) => styles.unshift(v));
            this._styles = styles;
        }
        else {
            this._styles = [userStyles];
        }
    }
    /**
     * Performs element initialization. By default this calls `createRenderRoot`
     * to create the element `renderRoot` node and captures any pre-set values for
     * registered properties.
     */
    initialize() {
        super.initialize();
        this.constructor._getUniqueStyles();
        this.renderRoot =
            this.createRenderRoot();
        // Note, if renderRoot is not a shadowRoot, styles would/could apply to the
        // element's getRootNode(). While this could be done, we're choosing not to
        // support this now since it would require different logic around de-duping.
        if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {
            this.adoptStyles();
        }
    }
    /**
     * Returns the node into which the element should render and by default
     * creates and returns an open shadowRoot. Implement to customize where the
     * element's DOM is rendered. For example, to render into the element's
     * childNodes, return `this`.
     * @returns {Element|DocumentFragment} Returns a node into which to render.
     */
    createRenderRoot() {
        return this.attachShadow({ mode: 'open' });
    }
    /**
     * Applies styling to the element shadowRoot using the `static get styles`
     * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where
     * available and will fallback otherwise. When Shadow DOM is polyfilled,
     * ShadyCSS scopes styles and adds them to the document. When Shadow DOM
     * is available but `adoptedStyleSheets` is not, styles are appended to the
     * end of the `shadowRoot` to [mimic spec
     * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
     */
    adoptStyles() {
        const styles = this.constructor._styles;
        if (styles.length === 0) {
            return;
        }
        // There are three separate cases here based on Shadow DOM support.
        // (1) shadowRoot polyfilled: use ShadyCSS
        // (2) shadowRoot.adoptedStyleSheets available: use it.
        // (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after
        // rendering
        if (window.ShadyCSS !== undefined && !window.ShadyCSS.nativeShadow) {
            window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map((s) => s.cssText), this.localName);
        }
        else if (_lib_css_tag_js__WEBPACK_IMPORTED_MODULE_4__["supportsAdoptingStyleSheets"]) {
            this.renderRoot.adoptedStyleSheets =
                styles.map((s) => s.styleSheet);
        }
        else {
            // This must be done after rendering so the actual style insertion is done
            // in `update`.
            this._needsShimAdoptedStyleSheets = true;
        }
    }
    connectedCallback() {
        super.connectedCallback();
        // Note, first update/render handles styleElement so we only call this if
        // connected after first update.
        if (this.hasUpdated && window.ShadyCSS !== undefined) {
            window.ShadyCSS.styleElement(this);
        }
    }
    /**
     * Updates the element. This method reflects property values to attributes
     * and calls `render` to render DOM via lit-html. Setting properties inside
     * this method will *not* trigger another update.
     * @param _changedProperties Map of changed properties with old values
     */
    update(changedProperties) {
        // Setting properties in `render` should not trigger an update. Since
        // updates are allowed after super.update, it's important to call `render`
        // before that.
        const templateResult = this.render();
        super.update(changedProperties);
        // If render is not implemented by the component, don't call lit-html render
        if (templateResult !== renderNotImplemented) {
            this.constructor
                .render(templateResult, this.renderRoot, { scopeName: this.localName, eventContext: this });
        }
        // When native Shadow DOM is used but adoptedStyles are not supported,
        // insert styling after rendering to ensure adoptedStyles have highest
        // priority.
        if (this._needsShimAdoptedStyleSheets) {
            this._needsShimAdoptedStyleSheets = false;
            this.constructor._styles.forEach((s) => {
                const style = document.createElement('style');
                style.textContent = s.cssText;
                this.renderRoot.appendChild(style);
            });
        }
    }
    /**
     * Invoked on each update to perform rendering tasks. This method may return
     * any value renderable by lit-html's NodePart - typically a TemplateResult.
     * Setting properties inside this method will *not* trigger the element to
     * update.
     */
    render() {
        return renderNotImplemented;
    }
}
/**
 * Ensure this class is marked as `finalized` as an optimization ensuring
 * it will not needlessly try to `finalize`.
 *
 * Note this property name is a string to prevent breaking Closure JS Compiler
 * optimizations. See updating-element.ts for more information.
 */
LitElement['finalized'] = true;
/**
 * Render method used to render the value to the element's DOM.
 * @param result The value to render.
 * @param container Node into which to render.
 * @param options Element name.
 * @nocollapse
 */
LitElement.render = lit_html_lib_shady_render_js__WEBPACK_IMPORTED_MODULE_0__["render"];


/***/ }),

/***/ "../../node_modules/lit-html/directives/repeat.js":
/*!************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/lit-html/directives/repeat.js ***!
  \************************************************************************/
/*! exports provided: repeat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "repeat", function() { return repeat; });
/* harmony import */ var _lit_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lit-html.js */ "../../node_modules/lit-html/lit-html.js");
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

// Helper functions for manipulating parts
// TODO(kschaaf): Refactor into Part API?
const createAndInsertPart = (containerPart, beforePart) => {
    const container = containerPart.startNode.parentNode;
    const beforeNode = beforePart === undefined ? containerPart.endNode :
        beforePart.startNode;
    const startNode = container.insertBefore(Object(_lit_html_js__WEBPACK_IMPORTED_MODULE_0__["createMarker"])(), beforeNode);
    container.insertBefore(Object(_lit_html_js__WEBPACK_IMPORTED_MODULE_0__["createMarker"])(), beforeNode);
    const newPart = new _lit_html_js__WEBPACK_IMPORTED_MODULE_0__["NodePart"](containerPart.options);
    newPart.insertAfterNode(startNode);
    return newPart;
};
const updatePart = (part, value) => {
    part.setValue(value);
    part.commit();
    return part;
};
const insertPartBefore = (containerPart, part, ref) => {
    const container = containerPart.startNode.parentNode;
    const beforeNode = ref ? ref.startNode : containerPart.endNode;
    const endNode = part.endNode.nextSibling;
    if (endNode !== beforeNode) {
        Object(_lit_html_js__WEBPACK_IMPORTED_MODULE_0__["reparentNodes"])(container, part.startNode, endNode, beforeNode);
    }
};
const removePart = (part) => {
    Object(_lit_html_js__WEBPACK_IMPORTED_MODULE_0__["removeNodes"])(part.startNode.parentNode, part.startNode, part.endNode.nextSibling);
};
// Helper for generating a map of array item to its index over a subset
// of an array (used to lazily generate `newKeyToIndexMap` and
// `oldKeyToIndexMap`)
const generateMap = (list, start, end) => {
    const map = new Map();
    for (let i = start; i <= end; i++) {
        map.set(list[i], i);
    }
    return map;
};
// Stores previous ordered list of parts and map of key to index
const partListCache = new WeakMap();
const keyListCache = new WeakMap();
/**
 * A directive that repeats a series of values (usually `TemplateResults`)
 * generated from an iterable, and updates those items efficiently when the
 * iterable changes based on user-provided `keys` associated with each item.
 *
 * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,
 * meaning previous DOM for a given key is moved into the new position if
 * needed, and DOM will never be reused with values for different keys (new DOM
 * will always be created for new keys). This is generally the most efficient
 * way to use `repeat` since it performs minimum unnecessary work for insertions
 * and removals.
 *
 * IMPORTANT: If providing a `keyFn`, keys *must* be unique for all items in a
 * given call to `repeat`. The behavior when two or more items have the same key
 * is undefined.
 *
 * If no `keyFn` is provided, this directive will perform similar to mapping
 * items to values, and DOM will be reused against potentially different items.
 */
const repeat = Object(_lit_html_js__WEBPACK_IMPORTED_MODULE_0__["directive"])((items, keyFnOrTemplate, template) => {
    let keyFn;
    if (template === undefined) {
        template = keyFnOrTemplate;
    }
    else if (keyFnOrTemplate !== undefined) {
        keyFn = keyFnOrTemplate;
    }
    return (containerPart) => {
        if (!(containerPart instanceof _lit_html_js__WEBPACK_IMPORTED_MODULE_0__["NodePart"])) {
            throw new Error('repeat can only be used in text bindings');
        }
        // Old part & key lists are retrieved from the last update
        // (associated with the part for this instance of the directive)
        const oldParts = partListCache.get(containerPart) || [];
        const oldKeys = keyListCache.get(containerPart) || [];
        // New part list will be built up as we go (either reused from
        // old parts or created for new keys in this update). This is
        // saved in the above cache at the end of the update.
        const newParts = [];
        // New value list is eagerly generated from items along with a
        // parallel array indicating its key.
        const newValues = [];
        const newKeys = [];
        let index = 0;
        for (const item of items) {
            newKeys[index] = keyFn ? keyFn(item, index) : index;
            newValues[index] = template(item, index);
            index++;
        }
        // Maps from key to index for current and previous update; these
        // are generated lazily only when needed as a performance
        // optimization, since they are only required for multiple
        // non-contiguous changes in the list, which are less common.
        let newKeyToIndexMap;
        let oldKeyToIndexMap;
        // Head and tail pointers to old parts and new values
        let oldHead = 0;
        let oldTail = oldParts.length - 1;
        let newHead = 0;
        let newTail = newValues.length - 1;
        // Overview of O(n) reconciliation algorithm (general approach
        // based on ideas found in ivi, vue, snabbdom, etc.):
        //
        // * We start with the list of old parts and new values (and
        //   arrays of their respective keys), head/tail pointers into
        //   each, and we build up the new list of parts by updating
        //   (and when needed, moving) old parts or creating new ones.
        //   The initial scenario might look like this (for brevity of
        //   the diagrams, the numbers in the array reflect keys
        //   associated with the old parts or new values, although keys
        //   and parts/values are actually stored in parallel arrays
        //   indexed using the same head/tail pointers):
        //
        //      oldHead v                 v oldTail
        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
        //   newParts: [ ,  ,  ,  ,  ,  ,  ]
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new
        //                                      item order
        //      newHead ^                 ^ newTail
        //
        // * Iterate old & new lists from both sides, updating,
        //   swapping, or removing parts at the head/tail locations
        //   until neither head nor tail can move.
        //
        // * Example below: keys at head pointers match, so update old
        //   part 0 in-place (no need to move it) and record part 0 in
        //   the `newParts` list. The last thing we do is advance the
        //   `oldHead` and `newHead` pointers (will be reflected in the
        //   next diagram).
        //
        //      oldHead v                 v oldTail
        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
        //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead
        //                                      & newHead
        //      newHead ^                 ^ newTail
        //
        // * Example below: head pointers don't match, but tail
        //   pointers do, so update part 6 in place (no need to move
        //   it), and record part 6 in the `newParts` list. Last,
        //   advance the `oldTail` and `oldHead` pointers.
        //
        //         oldHead v              v oldTail
        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
        //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail
        //                                      & newTail
        //         newHead ^              ^ newTail
        //
        // * If neither head nor tail match; next check if one of the
        //   old head/tail items was removed. We first need to generate
        //   the reverse map of new keys to index (`newKeyToIndexMap`),
        //   which is done once lazily as a performance optimization,
        //   since we only hit this case if multiple non-contiguous
        //   changes were made. Note that for contiguous removal
        //   anywhere in the list, the head and tails would advance
        //   from either end and pass each other before we get to this
        //   case and removals would be handled in the final while loop
        //   without needing to generate the map.
        //
        // * Example below: The key at `oldTail` was removed (no longer
        //   in the `newKeyToIndexMap`), so remove that part from the
        //   DOM and advance just the `oldTail` pointer.
        //
        //         oldHead v           v oldTail
        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
        //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail
        //         newHead ^           ^ newTail
        //
        // * Once head and tail cannot move, any mismatches are due to
        //   either new or moved items; if a new key is in the previous
        //   "old key to old index" map, move the old part to the new
        //   location, otherwise create and insert a new part. Note
        //   that when moving an old part we null its position in the
        //   oldParts array if it lies between the head and tail so we
        //   know to skip it when the pointers get there.
        //
        // * Example below: neither head nor tail match, and neither
        //   were removed; so find the `newHead` key in the
        //   `oldKeyToIndexMap`, and move that old part's DOM into the
        //   next head position (before `oldParts[oldHead]`). Last,
        //   null the part in the `oldPart` array since it was
        //   somewhere in the remaining oldParts still to be scanned
        //   (between the head and tail pointers) so that we know to
        //   skip that old part on future iterations.
        //
        //         oldHead v        v oldTail
        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
        //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance
        //                                      newHead
        //         newHead ^           ^ newTail
        //
        // * Note that for moves/insertions like the one above, a part
        //   inserted at the head pointer is inserted before the
        //   current `oldParts[oldHead]`, and a part inserted at the
        //   tail pointer is inserted before `newParts[newTail+1]`. The
        //   seeming asymmetry lies in the fact that new parts are
        //   moved into place outside in, so to the right of the head
        //   pointer are old parts, and to the right of the tail
        //   pointer are new parts.
        //
        // * We always restart back from the top of the algorithm,
        //   allowing matching and simple updates in place to
        //   continue...
        //
        // * Example below: the head pointers once again match, so
        //   simply update part 1 and record it in the `newParts`
        //   array.  Last, advance both head pointers.
        //
        //         oldHead v        v oldTail
        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
        //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead
        //                                      & newHead
        //            newHead ^        ^ newTail
        //
        // * As mentioned above, items that were moved as a result of
        //   being stuck (the final else clause in the code below) are
        //   marked with null, so we always advance old pointers over
        //   these so we're comparing the next actual old value on
        //   either end.
        //
        // * Example below: `oldHead` is null (already placed in
        //   newParts), so advance `oldHead`.
        //
        //            oldHead v     v oldTail
        //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:
        //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]
        //               newHead ^     ^ newTail
        //
        // * Note it's not critical to mark old parts as null when they
        //   are moved from head to tail or tail to head, since they
        //   will be outside the pointer range and never visited again.
        //
        // * Example below: Here the old tail key matches the new head
        //   key, so the part at the `oldTail` position and move its
        //   DOM to the new head position (before `oldParts[oldHead]`).
        //   Last, advance `oldTail` and `newHead` pointers.
        //
        //               oldHead v  v oldTail
        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
        //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,
        //                                     advance oldTail & newHead
        //               newHead ^     ^ newTail
        //
        // * Example below: Old and new head keys match, so update the
        //   old head part in place, and advance the `oldHead` and
        //   `newHead` pointers.
        //
        //               oldHead v oldTail
        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
        //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &
        //                                      newHead
        //                  newHead ^  ^ newTail
        //
        // * Once the new or old pointers move past each other then all
        //   we have left is additions (if old list exhausted) or
        //   removals (if new list exhausted). Those are handled in the
        //   final while loops at the end.
        //
        // * Example below: `oldHead` exceeded `oldTail`, so we're done
        //   with the main loop.  Create the remaining part and insert
        //   it at the new head position, and the update is complete.
        //
        //                   (oldHead > oldTail)
        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
        //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7
        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]
        //                     newHead ^ newTail
        //
        // * Note that the order of the if/else clauses is not
        //   important to the algorithm, as long as the null checks
        //   come first (to ensure we're always working on valid old
        //   parts) and that the final else clause comes last (since
        //   that's where the expensive moves occur). The order of
        //   remaining clauses is is just a simple guess at which cases
        //   will be most common.
        //
        // * TODO(kschaaf) Note, we could calculate the longest
        //   increasing subsequence (LIS) of old items in new position,
        //   and only move those not in the LIS set. However that costs
        //   O(nlogn) time and adds a bit more code, and only helps
        //   make rare types of mutations require fewer moves. The
        //   above handles removes, adds, reversal, swaps, and single
        //   moves of contiguous items in linear time, in the minimum
        //   number of moves. As the number of multiple moves where LIS
        //   might help approaches a random shuffle, the LIS
        //   optimization becomes less helpful, so it seems not worth
        //   the code at this point. Could reconsider if a compelling
        //   case arises.
        while (oldHead <= oldTail && newHead <= newTail) {
            if (oldParts[oldHead] === null) {
                // `null` means old part at head has already been used
                // below; skip
                oldHead++;
            }
            else if (oldParts[oldTail] === null) {
                // `null` means old part at tail has already been used
                // below; skip
                oldTail--;
            }
            else if (oldKeys[oldHead] === newKeys[newHead]) {
                // Old head matches new head; update in place
                newParts[newHead] =
                    updatePart(oldParts[oldHead], newValues[newHead]);
                oldHead++;
                newHead++;
            }
            else if (oldKeys[oldTail] === newKeys[newTail]) {
                // Old tail matches new tail; update in place
                newParts[newTail] =
                    updatePart(oldParts[oldTail], newValues[newTail]);
                oldTail--;
                newTail--;
            }
            else if (oldKeys[oldHead] === newKeys[newTail]) {
                // Old head matches new tail; update and move to new tail
                newParts[newTail] =
                    updatePart(oldParts[oldHead], newValues[newTail]);
                insertPartBefore(containerPart, oldParts[oldHead], newParts[newTail + 1]);
                oldHead++;
                newTail--;
            }
            else if (oldKeys[oldTail] === newKeys[newHead]) {
                // Old tail matches new head; update and move to new head
                newParts[newHead] =
                    updatePart(oldParts[oldTail], newValues[newHead]);
                insertPartBefore(containerPart, oldParts[oldTail], oldParts[oldHead]);
                oldTail--;
                newHead++;
            }
            else {
                if (newKeyToIndexMap === undefined) {
                    // Lazily generate key-to-index maps, used for removals &
                    // moves below
                    newKeyToIndexMap = generateMap(newKeys, newHead, newTail);
                    oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);
                }
                if (!newKeyToIndexMap.has(oldKeys[oldHead])) {
                    // Old head is no longer in new list; remove
                    removePart(oldParts[oldHead]);
                    oldHead++;
                }
                else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {
                    // Old tail is no longer in new list; remove
                    removePart(oldParts[oldTail]);
                    oldTail--;
                }
                else {
                    // Any mismatches at this point are due to additions or
                    // moves; see if we have an old part we can reuse and move
                    // into place
                    const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);
                    const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;
                    if (oldPart === null) {
                        // No old part for this value; create a new one and
                        // insert it
                        const newPart = createAndInsertPart(containerPart, oldParts[oldHead]);
                        updatePart(newPart, newValues[newHead]);
                        newParts[newHead] = newPart;
                    }
                    else {
                        // Reuse old part
                        newParts[newHead] =
                            updatePart(oldPart, newValues[newHead]);
                        insertPartBefore(containerPart, oldPart, oldParts[oldHead]);
                        // This marks the old part as having been used, so that
                        // it will be skipped in the first two checks above
                        oldParts[oldIndex] = null;
                    }
                    newHead++;
                }
            }
        }
        // Add parts for any remaining new values
        while (newHead <= newTail) {
            // For all remaining additions, we insert before last new
            // tail, since old pointers are no longer valid
            const newPart = createAndInsertPart(containerPart, newParts[newTail + 1]);
            updatePart(newPart, newValues[newHead]);
            newParts[newHead++] = newPart;
        }
        // Remove any remaining unused old parts
        while (oldHead <= oldTail) {
            const oldPart = oldParts[oldHead++];
            if (oldPart !== null) {
                removePart(oldPart);
            }
        }
        // Save order of new parts for next round
        partListCache.set(containerPart, newParts);
        keyListCache.set(containerPart, newKeys);
    };
});


/***/ }),

/***/ "../../node_modules/lit-html/lib/default-template-processor.js":
/*!*************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/lit-html/lib/default-template-processor.js ***!
  \*************************************************************************************/
/*! exports provided: DefaultTemplateProcessor, defaultTemplateProcessor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultTemplateProcessor", function() { return DefaultTemplateProcessor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultTemplateProcessor", function() { return defaultTemplateProcessor; });
/* harmony import */ var _parts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parts.js */ "../../node_modules/lit-html/lib/parts.js");
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * Creates Parts when a template is instantiated.
 */
class DefaultTemplateProcessor {
    /**
     * Create parts for an attribute-position binding, given the event, attribute
     * name, and string literals.
     *
     * @param element The element containing the binding
     * @param name  The attribute name
     * @param strings The string literals. There are always at least two strings,
     *   event for fully-controlled bindings with a single expression.
     */
    handleAttributeExpressions(element, name, strings, options) {
        const prefix = name[0];
        if (prefix === '.') {
            const committer = new _parts_js__WEBPACK_IMPORTED_MODULE_0__["PropertyCommitter"](element, name.slice(1), strings);
            return committer.parts;
        }
        if (prefix === '@') {
            return [new _parts_js__WEBPACK_IMPORTED_MODULE_0__["EventPart"](element, name.slice(1), options.eventContext)];
        }
        if (prefix === '?') {
            return [new _parts_js__WEBPACK_IMPORTED_MODULE_0__["BooleanAttributePart"](element, name.slice(1), strings)];
        }
        const committer = new _parts_js__WEBPACK_IMPORTED_MODULE_0__["AttributeCommitter"](element, name, strings);
        return committer.parts;
    }
    /**
     * Create parts for a text-position binding.
     * @param templateFactory
     */
    handleTextExpression(options) {
        return new _parts_js__WEBPACK_IMPORTED_MODULE_0__["NodePart"](options);
    }
}
const defaultTemplateProcessor = new DefaultTemplateProcessor();


/***/ }),

/***/ "../../node_modules/lit-html/lib/directive.js":
/*!********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/lit-html/lib/directive.js ***!
  \********************************************************************/
/*! exports provided: directive, isDirective */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "directive", function() { return directive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDirective", function() { return isDirective; });
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const directives = new WeakMap();
/**
 * Brands a function as a directive factory function so that lit-html will call
 * the function during template rendering, rather than passing as a value.
 *
 * A _directive_ is a function that takes a Part as an argument. It has the
 * signature: `(part: Part) => void`.
 *
 * A directive _factory_ is a function that takes arguments for data and
 * configuration and returns a directive. Users of directive usually refer to
 * the directive factory as the directive. For example, "The repeat directive".
 *
 * Usually a template author will invoke a directive factory in their template
 * with relevant arguments, which will then return a directive function.
 *
 * Here's an example of using the `repeat()` directive factory that takes an
 * array and a function to render an item:
 *
 * ```js
 * html`<ul><${repeat(items, (item) => html`<li>${item}</li>`)}</ul>`
 * ```
 *
 * When `repeat` is invoked, it returns a directive function that closes over
 * `items` and the template function. When the outer template is rendered, the
 * return directive function is called with the Part for the expression.
 * `repeat` then performs it's custom logic to render multiple items.
 *
 * @param f The directive factory function. Must be a function that returns a
 * function of the signature `(part: Part) => void`. The returned function will
 * be called with the part object.
 *
 * @example
 *
 * import {directive, html} from 'lit-html';
 *
 * const immutable = directive((v) => (part) => {
 *   if (part.value !== v) {
 *     part.setValue(v)
 *   }
 * });
 */
const directive = (f) => ((...args) => {
    const d = f(...args);
    directives.set(d, true);
    return d;
});
const isDirective = (o) => {
    return typeof o === 'function' && directives.has(o);
};


/***/ }),

/***/ "../../node_modules/lit-html/lib/dom.js":
/*!**************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/lit-html/lib/dom.js ***!
  \**************************************************************/
/*! exports provided: isCEPolyfill, reparentNodes, removeNodes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCEPolyfill", function() { return isCEPolyfill; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reparentNodes", function() { return reparentNodes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeNodes", function() { return removeNodes; });
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * True if the custom elements polyfill is in use.
 */
const isCEPolyfill = typeof window !== 'undefined' &&
    window.customElements != null &&
    window.customElements.polyfillWrapFlushCallback !==
        undefined;
/**
 * Reparents nodes, starting from `start` (inclusive) to `end` (exclusive),
 * into another container (could be the same container), before `before`. If
 * `before` is null, it appends the nodes to the container.
 */
const reparentNodes = (container, start, end = null, before = null) => {
    while (start !== end) {
        const n = start.nextSibling;
        container.insertBefore(start, before);
        start = n;
    }
};
/**
 * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from
 * `container`.
 */
const removeNodes = (container, start, end = null) => {
    while (start !== end) {
        const n = start.nextSibling;
        container.removeChild(start);
        start = n;
    }
};


/***/ }),

/***/ "../../node_modules/lit-html/lib/modify-template.js":
/*!**************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/lit-html/lib/modify-template.js ***!
  \**************************************************************************/
/*! exports provided: removeNodesFromTemplate, insertNodeIntoTemplate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeNodesFromTemplate", function() { return removeNodesFromTemplate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertNodeIntoTemplate", function() { return insertNodeIntoTemplate; });
/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./template.js */ "../../node_modules/lit-html/lib/template.js");
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

const walkerNodeFilter = 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */;
/**
 * Removes the list of nodes from a Template safely. In addition to removing
 * nodes from the Template, the Template part indices are updated to match
 * the mutated Template DOM.
 *
 * As the template is walked the removal state is tracked and
 * part indices are adjusted as needed.
 *
 * div
 *   div#1 (remove) <-- start removing (removing node is div#1)
 *     div
 *       div#2 (remove)  <-- continue removing (removing node is still div#1)
 *         div
 * div <-- stop removing since previous sibling is the removing node (div#1,
 * removed 4 nodes)
 */
function removeNodesFromTemplate(template, nodesToRemove) {
    const { element: { content }, parts } = template;
    const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
    let partIndex = nextActiveIndexInTemplateParts(parts);
    let part = parts[partIndex];
    let nodeIndex = -1;
    let removeCount = 0;
    const nodesToRemoveInTemplate = [];
    let currentRemovingNode = null;
    while (walker.nextNode()) {
        nodeIndex++;
        const node = walker.currentNode;
        // End removal if stepped past the removing node
        if (node.previousSibling === currentRemovingNode) {
            currentRemovingNode = null;
        }
        // A node to remove was found in the template
        if (nodesToRemove.has(node)) {
            nodesToRemoveInTemplate.push(node);
            // Track node we're removing
            if (currentRemovingNode === null) {
                currentRemovingNode = node;
            }
        }
        // When removing, increment count by which to adjust subsequent part indices
        if (currentRemovingNode !== null) {
            removeCount++;
        }
        while (part !== undefined && part.index === nodeIndex) {
            // If part is in a removed node deactivate it by setting index to -1 or
            // adjust the index as needed.
            part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;
            // go to the next active part.
            partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
            part = parts[partIndex];
        }
    }
    nodesToRemoveInTemplate.forEach((n) => n.parentNode.removeChild(n));
}
const countNodes = (node) => {
    let count = (node.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */) ? 0 : 1;
    const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);
    while (walker.nextNode()) {
        count++;
    }
    return count;
};
const nextActiveIndexInTemplateParts = (parts, startIndex = -1) => {
    for (let i = startIndex + 1; i < parts.length; i++) {
        const part = parts[i];
        if (Object(_template_js__WEBPACK_IMPORTED_MODULE_0__["isTemplatePartActive"])(part)) {
            return i;
        }
    }
    return -1;
};
/**
 * Inserts the given node into the Template, optionally before the given
 * refNode. In addition to inserting the node into the Template, the Template
 * part indices are updated to match the mutated Template DOM.
 */
function insertNodeIntoTemplate(template, node, refNode = null) {
    const { element: { content }, parts } = template;
    // If there's no refNode, then put node at end of template.
    // No part indices need to be shifted in this case.
    if (refNode === null || refNode === undefined) {
        content.appendChild(node);
        return;
    }
    const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
    let partIndex = nextActiveIndexInTemplateParts(parts);
    let insertCount = 0;
    let walkerIndex = -1;
    while (walker.nextNode()) {
        walkerIndex++;
        const walkerNode = walker.currentNode;
        if (walkerNode === refNode) {
            insertCount = countNodes(node);
            refNode.parentNode.insertBefore(node, refNode);
        }
        while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {
            // If we've inserted the node, simply adjust all subsequent parts
            if (insertCount > 0) {
                while (partIndex !== -1) {
                    parts[partIndex].index += insertCount;
                    partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
                }
                return;
            }
            partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
        }
    }
}


/***/ }),

/***/ "../../node_modules/lit-html/lib/part.js":
/*!***************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/lit-html/lib/part.js ***!
  \***************************************************************/
/*! exports provided: noChange, nothing */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "noChange", function() { return noChange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nothing", function() { return nothing; });
/**
 * @license
 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * A sentinel value that signals that a value was handled by a directive and
 * should not be written to the DOM.
 */
const noChange = {};
/**
 * A sentinel value that signals a NodePart to fully clear its content.
 */
const nothing = {};


/***/ }),

/***/ "../../node_modules/lit-html/lib/parts.js":
/*!****************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/lit-html/lib/parts.js ***!
  \****************************************************************/
/*! exports provided: isPrimitive, isIterable, AttributeCommitter, AttributePart, NodePart, BooleanAttributePart, PropertyCommitter, PropertyPart, EventPart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPrimitive", function() { return isPrimitive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIterable", function() { return isIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AttributeCommitter", function() { return AttributeCommitter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AttributePart", function() { return AttributePart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NodePart", function() { return NodePart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BooleanAttributePart", function() { return BooleanAttributePart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyCommitter", function() { return PropertyCommitter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyPart", function() { return PropertyPart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventPart", function() { return EventPart; });
/* harmony import */ var _directive_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./directive.js */ "../../node_modules/lit-html/lib/directive.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom.js */ "../../node_modules/lit-html/lib/dom.js");
/* harmony import */ var _part_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./part.js */ "../../node_modules/lit-html/lib/part.js");
/* harmony import */ var _template_instance_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./template-instance.js */ "../../node_modules/lit-html/lib/template-instance.js");
/* harmony import */ var _template_result_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./template-result.js */ "../../node_modules/lit-html/lib/template-result.js");
/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./template.js */ "../../node_modules/lit-html/lib/template.js");
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */






const isPrimitive = (value) => {
    return (value === null ||
        !(typeof value === 'object' || typeof value === 'function'));
};
const isIterable = (value) => {
    return Array.isArray(value) ||
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        !!(value && value[Symbol.iterator]);
};
/**
 * Writes attribute values to the DOM for a group of AttributeParts bound to a
 * single attribute. The value is only set once even if there are multiple parts
 * for an attribute.
 */
class AttributeCommitter {
    constructor(element, name, strings) {
        this.dirty = true;
        this.element = element;
        this.name = name;
        this.strings = strings;
        this.parts = [];
        for (let i = 0; i < strings.length - 1; i++) {
            this.parts[i] = this._createPart();
        }
    }
    /**
     * Creates a single part. Override this to create a differnt type of part.
     */
    _createPart() {
        return new AttributePart(this);
    }
    _getValue() {
        const strings = this.strings;
        const l = strings.length - 1;
        const parts = this.parts;
        // If we're assigning an attribute via syntax like:
        //    attr="${foo}"  or  attr=${foo}
        // but not
        //    attr="${foo} ${bar}" or attr="${foo} baz"
        // then we don't want to coerce the attribute value into one long
        // string. Instead we want to just return the value itself directly,
        // so that sanitizeDOMValue can get the actual value rather than
        // String(value)
        // The exception is if v is an array, in which case we do want to smash
        // it together into a string without calling String() on the array.
        //
        // This also allows trusted values (when using TrustedTypes) being
        // assigned to DOM sinks without being stringified in the process.
        if (l === 1 && strings[0] === '' && strings[1] === '') {
            const v = parts[0].value;
            if (typeof v === 'symbol') {
                return String(v);
            }
            if (typeof v === 'string' || !isIterable(v)) {
                return v;
            }
        }
        let text = '';
        for (let i = 0; i < l; i++) {
            text += strings[i];
            const part = parts[i];
            if (part !== undefined) {
                const v = part.value;
                if (isPrimitive(v) || !isIterable(v)) {
                    text += typeof v === 'string' ? v : String(v);
                }
                else {
                    for (const t of v) {
                        text += typeof t === 'string' ? t : String(t);
                    }
                }
            }
        }
        text += strings[l];
        return text;
    }
    commit() {
        if (this.dirty) {
            this.dirty = false;
            this.element.setAttribute(this.name, this._getValue());
        }
    }
}
/**
 * A Part that controls all or part of an attribute value.
 */
class AttributePart {
    constructor(committer) {
        this.value = undefined;
        this.committer = committer;
    }
    setValue(value) {
        if (value !== _part_js__WEBPACK_IMPORTED_MODULE_2__["noChange"] && (!isPrimitive(value) || value !== this.value)) {
            this.value = value;
            // If the value is a not a directive, dirty the committer so that it'll
            // call setAttribute. If the value is a directive, it'll dirty the
            // committer if it calls setValue().
            if (!Object(_directive_js__WEBPACK_IMPORTED_MODULE_0__["isDirective"])(value)) {
                this.committer.dirty = true;
            }
        }
    }
    commit() {
        while (Object(_directive_js__WEBPACK_IMPORTED_MODULE_0__["isDirective"])(this.value)) {
            const directive = this.value;
            this.value = _part_js__WEBPACK_IMPORTED_MODULE_2__["noChange"];
            directive(this);
        }
        if (this.value === _part_js__WEBPACK_IMPORTED_MODULE_2__["noChange"]) {
            return;
        }
        this.committer.commit();
    }
}
/**
 * A Part that controls a location within a Node tree. Like a Range, NodePart
 * has start and end locations and can set and update the Nodes between those
 * locations.
 *
 * NodeParts support several value types: primitives, Nodes, TemplateResults,
 * as well as arrays and iterables of those types.
 */
class NodePart {
    constructor(options) {
        this.value = undefined;
        this.__pendingValue = undefined;
        this.options = options;
    }
    /**
     * Appends this part into a container.
     *
     * This part must be empty, as its contents are not automatically moved.
     */
    appendInto(container) {
        this.startNode = container.appendChild(Object(_template_js__WEBPACK_IMPORTED_MODULE_5__["createMarker"])());
        this.endNode = container.appendChild(Object(_template_js__WEBPACK_IMPORTED_MODULE_5__["createMarker"])());
    }
    /**
     * Inserts this part after the `ref` node (between `ref` and `ref`'s next
     * sibling). Both `ref` and its next sibling must be static, unchanging nodes
     * such as those that appear in a literal section of a template.
     *
     * This part must be empty, as its contents are not automatically moved.
     */
    insertAfterNode(ref) {
        this.startNode = ref;
        this.endNode = ref.nextSibling;
    }
    /**
     * Appends this part into a parent part.
     *
     * This part must be empty, as its contents are not automatically moved.
     */
    appendIntoPart(part) {
        part.__insert(this.startNode = Object(_template_js__WEBPACK_IMPORTED_MODULE_5__["createMarker"])());
        part.__insert(this.endNode = Object(_template_js__WEBPACK_IMPORTED_MODULE_5__["createMarker"])());
    }
    /**
     * Inserts this part after the `ref` part.
     *
     * This part must be empty, as its contents are not automatically moved.
     */
    insertAfterPart(ref) {
        ref.__insert(this.startNode = Object(_template_js__WEBPACK_IMPORTED_MODULE_5__["createMarker"])());
        this.endNode = ref.endNode;
        ref.endNode = this.startNode;
    }
    setValue(value) {
        this.__pendingValue = value;
    }
    commit() {
        if (this.startNode.parentNode === null) {
            return;
        }
        while (Object(_directive_js__WEBPACK_IMPORTED_MODULE_0__["isDirective"])(this.__pendingValue)) {
            const directive = this.__pendingValue;
            this.__pendingValue = _part_js__WEBPACK_IMPORTED_MODULE_2__["noChange"];
            directive(this);
        }
        const value = this.__pendingValue;
        if (value === _part_js__WEBPACK_IMPORTED_MODULE_2__["noChange"]) {
            return;
        }
        if (isPrimitive(value)) {
            if (value !== this.value) {
                this.__commitText(value);
            }
        }
        else if (value instanceof _template_result_js__WEBPACK_IMPORTED_MODULE_4__["TemplateResult"]) {
            this.__commitTemplateResult(value);
        }
        else if (value instanceof Node) {
            this.__commitNode(value);
        }
        else if (isIterable(value)) {
            this.__commitIterable(value);
        }
        else if (value === _part_js__WEBPACK_IMPORTED_MODULE_2__["nothing"]) {
            this.value = _part_js__WEBPACK_IMPORTED_MODULE_2__["nothing"];
            this.clear();
        }
        else {
            // Fallback, will render the string representation
            this.__commitText(value);
        }
    }
    __insert(node) {
        this.endNode.parentNode.insertBefore(node, this.endNode);
    }
    __commitNode(value) {
        if (this.value === value) {
            return;
        }
        this.clear();
        this.__insert(value);
        this.value = value;
    }
    __commitText(value) {
        const node = this.startNode.nextSibling;
        value = value == null ? '' : value;
        // If `value` isn't already a string, we explicitly convert it here in case
        // it can't be implicitly converted - i.e. it's a symbol.
        const valueAsString = typeof value === 'string' ? value : String(value);
        if (node === this.endNode.previousSibling &&
            node.nodeType === 3 /* Node.TEXT_NODE */) {
            // If we only have a single text node between the markers, we can just
            // set its value, rather than replacing it.
            // TODO(justinfagnani): Can we just check if this.value is primitive?
            node.data = valueAsString;
        }
        else {
            this.__commitNode(document.createTextNode(valueAsString));
        }
        this.value = value;
    }
    __commitTemplateResult(value) {
        const template = this.options.templateFactory(value);
        if (this.value instanceof _template_instance_js__WEBPACK_IMPORTED_MODULE_3__["TemplateInstance"] &&
            this.value.template === template) {
            this.value.update(value.values);
        }
        else {
            // Make sure we propagate the template processor from the TemplateResult
            // so that we use its syntax extension, etc. The template factory comes
            // from the render function options so that it can control template
            // caching and preprocessing.
            const instance = new _template_instance_js__WEBPACK_IMPORTED_MODULE_3__["TemplateInstance"](template, value.processor, this.options);
            const fragment = instance._clone();
            instance.update(value.values);
            this.__commitNode(fragment);
            this.value = instance;
        }
    }
    __commitIterable(value) {
        // For an Iterable, we create a new InstancePart per item, then set its
        // value to the item. This is a little bit of overhead for every item in
        // an Iterable, but it lets us recurse easily and efficiently update Arrays
        // of TemplateResults that will be commonly returned from expressions like:
        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
        // If _value is an array, then the previous render was of an
        // iterable and _value will contain the NodeParts from the previous
        // render. If _value is not an array, clear this part and make a new
        // array for NodeParts.
        if (!Array.isArray(this.value)) {
            this.value = [];
            this.clear();
        }
        // Lets us keep track of how many items we stamped so we can clear leftover
        // items from a previous render
        const itemParts = this.value;
        let partIndex = 0;
        let itemPart;
        for (const item of value) {
            // Try to reuse an existing part
            itemPart = itemParts[partIndex];
            // If no existing part, create a new one
            if (itemPart === undefined) {
                itemPart = new NodePart(this.options);
                itemParts.push(itemPart);
                if (partIndex === 0) {
                    itemPart.appendIntoPart(this);
                }
                else {
                    itemPart.insertAfterPart(itemParts[partIndex - 1]);
                }
            }
            itemPart.setValue(item);
            itemPart.commit();
            partIndex++;
        }
        if (partIndex < itemParts.length) {
            // Truncate the parts array so _value reflects the current state
            itemParts.length = partIndex;
            this.clear(itemPart && itemPart.endNode);
        }
    }
    clear(startNode = this.startNode) {
        Object(_dom_js__WEBPACK_IMPORTED_MODULE_1__["removeNodes"])(this.startNode.parentNode, startNode.nextSibling, this.endNode);
    }
}
/**
 * Implements a boolean attribute, roughly as defined in the HTML
 * specification.
 *
 * If the value is truthy, then the attribute is present with a value of
 * ''. If the value is falsey, the attribute is removed.
 */
class BooleanAttributePart {
    constructor(element, name, strings) {
        this.value = undefined;
        this.__pendingValue = undefined;
        if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {
            throw new Error('Boolean attributes can only contain a single expression');
        }
        this.element = element;
        this.name = name;
        this.strings = strings;
    }
    setValue(value) {
        this.__pendingValue = value;
    }
    commit() {
        while (Object(_directive_js__WEBPACK_IMPORTED_MODULE_0__["isDirective"])(this.__pendingValue)) {
            const directive = this.__pendingValue;
            this.__pendingValue = _part_js__WEBPACK_IMPORTED_MODULE_2__["noChange"];
            directive(this);
        }
        if (this.__pendingValue === _part_js__WEBPACK_IMPORTED_MODULE_2__["noChange"]) {
            return;
        }
        const value = !!this.__pendingValue;
        if (this.value !== value) {
            if (value) {
                this.element.setAttribute(this.name, '');
            }
            else {
                this.element.removeAttribute(this.name);
            }
            this.value = value;
        }
        this.__pendingValue = _part_js__WEBPACK_IMPORTED_MODULE_2__["noChange"];
    }
}
/**
 * Sets attribute values for PropertyParts, so that the value is only set once
 * even if there are multiple parts for a property.
 *
 * If an expression controls the whole property value, then the value is simply
 * assigned to the property under control. If there are string literals or
 * multiple expressions, then the strings are expressions are interpolated into
 * a string first.
 */
class PropertyCommitter extends AttributeCommitter {
    constructor(element, name, strings) {
        super(element, name, strings);
        this.single =
            (strings.length === 2 && strings[0] === '' && strings[1] === '');
    }
    _createPart() {
        return new PropertyPart(this);
    }
    _getValue() {
        if (this.single) {
            return this.parts[0].value;
        }
        return super._getValue();
    }
    commit() {
        if (this.dirty) {
            this.dirty = false;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.element[this.name] = this._getValue();
        }
    }
}
class PropertyPart extends AttributePart {
}
// Detect event listener options support. If the `capture` property is read
// from the options object, then options are supported. If not, then the third
// argument to add/removeEventListener is interpreted as the boolean capture
// value so we should only pass the `capture` property.
let eventOptionsSupported = false;
// Wrap into an IIFE because MS Edge <= v41 does not support having try/catch
// blocks right into the body of a module
(() => {
    try {
        const options = {
            get capture() {
                eventOptionsSupported = true;
                return false;
            }
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        window.addEventListener('test', options, options);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        window.removeEventListener('test', options, options);
    }
    catch (_e) {
        // event options not supported
    }
})();
class EventPart {
    constructor(element, eventName, eventContext) {
        this.value = undefined;
        this.__pendingValue = undefined;
        this.element = element;
        this.eventName = eventName;
        this.eventContext = eventContext;
        this.__boundHandleEvent = (e) => this.handleEvent(e);
    }
    setValue(value) {
        this.__pendingValue = value;
    }
    commit() {
        while (Object(_directive_js__WEBPACK_IMPORTED_MODULE_0__["isDirective"])(this.__pendingValue)) {
            const directive = this.__pendingValue;
            this.__pendingValue = _part_js__WEBPACK_IMPORTED_MODULE_2__["noChange"];
            directive(this);
        }
        if (this.__pendingValue === _part_js__WEBPACK_IMPORTED_MODULE_2__["noChange"]) {
            return;
        }
        const newListener = this.__pendingValue;
        const oldListener = this.value;
        const shouldRemoveListener = newListener == null ||
            oldListener != null &&
                (newListener.capture !== oldListener.capture ||
                    newListener.once !== oldListener.once ||
                    newListener.passive !== oldListener.passive);
        const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);
        if (shouldRemoveListener) {
            this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
        }
        if (shouldAddListener) {
            this.__options = getOptions(newListener);
            this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
        }
        this.value = newListener;
        this.__pendingValue = _part_js__WEBPACK_IMPORTED_MODULE_2__["noChange"];
    }
    handleEvent(event) {
        if (typeof this.value === 'function') {
            this.value.call(this.eventContext || this.element, event);
        }
        else {
            this.value.handleEvent(event);
        }
    }
}
// We copy options because of the inconsistent behavior of browsers when reading
// the third argument of add/removeEventListener. IE11 doesn't support options
// at all. Chrome 41 only reads `capture` if the argument is an object.
const getOptions = (o) => o &&
    (eventOptionsSupported ?
        { capture: o.capture, passive: o.passive, once: o.once } :
        o.capture);


/***/ }),

/***/ "../../node_modules/lit-html/lib/render.js":
/*!*****************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/lit-html/lib/render.js ***!
  \*****************************************************************/
/*! exports provided: parts, render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parts", function() { return parts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom.js */ "../../node_modules/lit-html/lib/dom.js");
/* harmony import */ var _parts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parts.js */ "../../node_modules/lit-html/lib/parts.js");
/* harmony import */ var _template_factory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./template-factory.js */ "../../node_modules/lit-html/lib/template-factory.js");
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */



const parts = new WeakMap();
/**
 * Renders a template result or other value to a container.
 *
 * To update a container with new values, reevaluate the template literal and
 * call `render` with the new result.
 *
 * @param result Any value renderable by NodePart - typically a TemplateResult
 *     created by evaluating a template tag like `html` or `svg`.
 * @param container A DOM parent to render to. The entire contents are either
 *     replaced, or efficiently updated if the same result type was previous
 *     rendered there.
 * @param options RenderOptions for the entire render tree rendered to this
 *     container. Render options must *not* change between renders to the same
 *     container, as those changes will not effect previously rendered DOM.
 */
const render = (result, container, options) => {
    let part = parts.get(container);
    if (part === undefined) {
        Object(_dom_js__WEBPACK_IMPORTED_MODULE_0__["removeNodes"])(container, container.firstChild);
        parts.set(container, part = new _parts_js__WEBPACK_IMPORTED_MODULE_1__["NodePart"](Object.assign({ templateFactory: _template_factory_js__WEBPACK_IMPORTED_MODULE_2__["templateFactory"] }, options)));
        part.appendInto(container);
    }
    part.setValue(result);
    part.commit();
};


/***/ }),

/***/ "../../node_modules/lit-html/lib/shady-render.js":
/*!***********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/lit-html/lib/shady-render.js ***!
  \***********************************************************************/
/*! exports provided: html, svg, TemplateResult, shadyTemplateFactory, render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shadyTemplateFactory", function() { return shadyTemplateFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom.js */ "../../node_modules/lit-html/lib/dom.js");
/* harmony import */ var _modify_template_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modify-template.js */ "../../node_modules/lit-html/lib/modify-template.js");
/* harmony import */ var _render_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./render.js */ "../../node_modules/lit-html/lib/render.js");
/* harmony import */ var _template_factory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./template-factory.js */ "../../node_modules/lit-html/lib/template-factory.js");
/* harmony import */ var _template_instance_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./template-instance.js */ "../../node_modules/lit-html/lib/template-instance.js");
/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./template.js */ "../../node_modules/lit-html/lib/template.js");
/* harmony import */ var _lit_html_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lit-html.js */ "../../node_modules/lit-html/lit-html.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "html", function() { return _lit_html_js__WEBPACK_IMPORTED_MODULE_6__["html"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "svg", function() { return _lit_html_js__WEBPACK_IMPORTED_MODULE_6__["svg"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TemplateResult", function() { return _lit_html_js__WEBPACK_IMPORTED_MODULE_6__["TemplateResult"]; });

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * Module to add shady DOM/shady CSS polyfill support to lit-html template
 * rendering. See the [[render]] method for details.
 *
 * @packageDocumentation
 */
/**
 * Do not remove this comment; it keeps typedoc from misplacing the module
 * docs.
 */







// Get a key to lookup in `templateCaches`.
const getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;
let compatibleShadyCSSVersion = true;
if (typeof window.ShadyCSS === 'undefined') {
    compatibleShadyCSSVersion = false;
}
else if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {
    console.warn(`Incompatible ShadyCSS version detected. ` +
        `Please update to at least @webcomponents/webcomponentsjs@2.0.2 and ` +
        `@webcomponents/shadycss@1.3.1.`);
    compatibleShadyCSSVersion = false;
}
/**
 * Template factory which scopes template DOM using ShadyCSS.
 * @param scopeName {string}
 */
const shadyTemplateFactory = (scopeName) => (result) => {
    const cacheKey = getTemplateCacheKey(result.type, scopeName);
    let templateCache = _template_factory_js__WEBPACK_IMPORTED_MODULE_3__["templateCaches"].get(cacheKey);
    if (templateCache === undefined) {
        templateCache = {
            stringsArray: new WeakMap(),
            keyString: new Map()
        };
        _template_factory_js__WEBPACK_IMPORTED_MODULE_3__["templateCaches"].set(cacheKey, templateCache);
    }
    let template = templateCache.stringsArray.get(result.strings);
    if (template !== undefined) {
        return template;
    }
    const key = result.strings.join(_template_js__WEBPACK_IMPORTED_MODULE_5__["marker"]);
    template = templateCache.keyString.get(key);
    if (template === undefined) {
        const element = result.getTemplateElement();
        if (compatibleShadyCSSVersion) {
            window.ShadyCSS.prepareTemplateDom(element, scopeName);
        }
        template = new _template_js__WEBPACK_IMPORTED_MODULE_5__["Template"](result, element);
        templateCache.keyString.set(key, template);
    }
    templateCache.stringsArray.set(result.strings, template);
    return template;
};
const TEMPLATE_TYPES = ['html', 'svg'];
/**
 * Removes all style elements from Templates for the given scopeName.
 */
const removeStylesFromLitTemplates = (scopeName) => {
    TEMPLATE_TYPES.forEach((type) => {
        const templates = _template_factory_js__WEBPACK_IMPORTED_MODULE_3__["templateCaches"].get(getTemplateCacheKey(type, scopeName));
        if (templates !== undefined) {
            templates.keyString.forEach((template) => {
                const { element: { content } } = template;
                // IE 11 doesn't support the iterable param Set constructor
                const styles = new Set();
                Array.from(content.querySelectorAll('style')).forEach((s) => {
                    styles.add(s);
                });
                Object(_modify_template_js__WEBPACK_IMPORTED_MODULE_1__["removeNodesFromTemplate"])(template, styles);
            });
        }
    });
};
const shadyRenderSet = new Set();
/**
 * For the given scope name, ensures that ShadyCSS style scoping is performed.
 * This is done just once per scope name so the fragment and template cannot
 * be modified.
 * (1) extracts styles from the rendered fragment and hands them to ShadyCSS
 * to be scoped and appended to the document
 * (2) removes style elements from all lit-html Templates for this scope name.
 *
 * Note, <style> elements can only be placed into templates for the
 * initial rendering of the scope. If <style> elements are included in templates
 * dynamically rendered to the scope (after the first scope render), they will
 * not be scoped and the <style> will be left in the template and rendered
 * output.
 */
const prepareTemplateStyles = (scopeName, renderedDOM, template) => {
    shadyRenderSet.add(scopeName);
    // If `renderedDOM` is stamped from a Template, then we need to edit that
    // Template's underlying template element. Otherwise, we create one here
    // to give to ShadyCSS, which still requires one while scoping.
    const templateElement = !!template ? template.element : document.createElement('template');
    // Move styles out of rendered DOM and store.
    const styles = renderedDOM.querySelectorAll('style');
    const { length } = styles;
    // If there are no styles, skip unnecessary work
    if (length === 0) {
        // Ensure prepareTemplateStyles is called to support adding
        // styles via `prepareAdoptedCssText` since that requires that
        // `prepareTemplateStyles` is called.
        //
        // ShadyCSS will only update styles containing @apply in the template
        // given to `prepareTemplateStyles`. If no lit Template was given,
        // ShadyCSS will not be able to update uses of @apply in any relevant
        // template. However, this is not a problem because we only create the
        // template for the purpose of supporting `prepareAdoptedCssText`,
        // which doesn't support @apply at all.
        window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
        return;
    }
    const condensedStyle = document.createElement('style');
    // Collect styles into a single style. This helps us make sure ShadyCSS
    // manipulations will not prevent us from being able to fix up template
    // part indices.
    // NOTE: collecting styles is inefficient for browsers but ShadyCSS
    // currently does this anyway. When it does not, this should be changed.
    for (let i = 0; i < length; i++) {
        const style = styles[i];
        style.parentNode.removeChild(style);
        condensedStyle.textContent += style.textContent;
    }
    // Remove styles from nested templates in this scope.
    removeStylesFromLitTemplates(scopeName);
    // And then put the condensed style into the "root" template passed in as
    // `template`.
    const content = templateElement.content;
    if (!!template) {
        Object(_modify_template_js__WEBPACK_IMPORTED_MODULE_1__["insertNodeIntoTemplate"])(template, condensedStyle, content.firstChild);
    }
    else {
        content.insertBefore(condensedStyle, content.firstChild);
    }
    // Note, it's important that ShadyCSS gets the template that `lit-html`
    // will actually render so that it can update the style inside when
    // needed (e.g. @apply native Shadow DOM case).
    window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
    const style = content.querySelector('style');
    if (window.ShadyCSS.nativeShadow && style !== null) {
        // When in native Shadow DOM, ensure the style created by ShadyCSS is
        // included in initially rendered output (`renderedDOM`).
        renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);
    }
    else if (!!template) {
        // When no style is left in the template, parts will be broken as a
        // result. To fix this, we put back the style node ShadyCSS removed
        // and then tell lit to remove that node from the template.
        // There can be no style in the template in 2 cases (1) when Shady DOM
        // is in use, ShadyCSS removes all styles, (2) when native Shadow DOM
        // is in use ShadyCSS removes the style if it contains no content.
        // NOTE, ShadyCSS creates its own style so we can safely add/remove
        // `condensedStyle` here.
        content.insertBefore(condensedStyle, content.firstChild);
        const removes = new Set();
        removes.add(condensedStyle);
        Object(_modify_template_js__WEBPACK_IMPORTED_MODULE_1__["removeNodesFromTemplate"])(template, removes);
    }
};
/**
 * Extension to the standard `render` method which supports rendering
 * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)
 * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used
 * or when the webcomponentsjs
 * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.
 *
 * Adds a `scopeName` option which is used to scope element DOM and stylesheets
 * when native ShadowDOM is unavailable. The `scopeName` will be added to
 * the class attribute of all rendered DOM. In addition, any style elements will
 * be automatically re-written with this `scopeName` selector and moved out
 * of the rendered DOM and into the document `<head>`.
 *
 * It is common to use this render method in conjunction with a custom element
 * which renders a shadowRoot. When this is done, typically the element's
 * `localName` should be used as the `scopeName`.
 *
 * In addition to DOM scoping, ShadyCSS also supports a basic shim for css
 * custom properties (needed only on older browsers like IE11) and a shim for
 * a deprecated feature called `@apply` that supports applying a set of css
 * custom properties to a given location.
 *
 * Usage considerations:
 *
 * * Part values in `<style>` elements are only applied the first time a given
 * `scopeName` renders. Subsequent changes to parts in style elements will have
 * no effect. Because of this, parts in style elements should only be used for
 * values that will never change, for example parts that set scope-wide theme
 * values or parts which render shared style elements.
 *
 * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a
 * custom element's `constructor` is not supported. Instead rendering should
 * either done asynchronously, for example at microtask timing (for example
 * `Promise.resolve()`), or be deferred until the first time the element's
 * `connectedCallback` runs.
 *
 * Usage considerations when using shimmed custom properties or `@apply`:
 *
 * * Whenever any dynamic changes are made which affect
 * css custom properties, `ShadyCSS.styleElement(element)` must be called
 * to update the element. There are two cases when this is needed:
 * (1) the element is connected to a new parent, (2) a class is added to the
 * element that causes it to match different custom properties.
 * To address the first case when rendering a custom element, `styleElement`
 * should be called in the element's `connectedCallback`.
 *
 * * Shimmed custom properties may only be defined either for an entire
 * shadowRoot (for example, in a `:host` rule) or via a rule that directly
 * matches an element with a shadowRoot. In other words, instead of flowing from
 * parent to child as do native css custom properties, shimmed custom properties
 * flow only from shadowRoots to nested shadowRoots.
 *
 * * When using `@apply` mixing css shorthand property names with
 * non-shorthand names (for example `border` and `border-width`) is not
 * supported.
 */
const render = (result, container, options) => {
    if (!options || typeof options !== 'object' || !options.scopeName) {
        throw new Error('The `scopeName` option is required.');
    }
    const scopeName = options.scopeName;
    const hasRendered = _render_js__WEBPACK_IMPORTED_MODULE_2__["parts"].has(container);
    const needsScoping = compatibleShadyCSSVersion &&
        container.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */ &&
        !!container.host;
    // Handle first render to a scope specially...
    const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);
    // On first scope render, render into a fragment; this cannot be a single
    // fragment that is reused since nested renders can occur synchronously.
    const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;
    Object(_render_js__WEBPACK_IMPORTED_MODULE_2__["render"])(result, renderContainer, Object.assign({ templateFactory: shadyTemplateFactory(scopeName) }, options));
    // When performing first scope render,
    // (1) We've rendered into a fragment so that there's a chance to
    // `prepareTemplateStyles` before sub-elements hit the DOM
    // (which might cause them to render based on a common pattern of
    // rendering in a custom element's `connectedCallback`);
    // (2) Scope the template with ShadyCSS one time only for this scope.
    // (3) Render the fragment into the container and make sure the
    // container knows its `part` is the one we just rendered. This ensures
    // DOM will be re-used on subsequent renders.
    if (firstScopeRender) {
        const part = _render_js__WEBPACK_IMPORTED_MODULE_2__["parts"].get(renderContainer);
        _render_js__WEBPACK_IMPORTED_MODULE_2__["parts"].delete(renderContainer);
        // ShadyCSS might have style sheets (e.g. from `prepareAdoptedCssText`)
        // that should apply to `renderContainer` even if the rendered value is
        // not a TemplateInstance. However, it will only insert scoped styles
        // into the document if `prepareTemplateStyles` has already been called
        // for the given scope name.
        const template = part.value instanceof _template_instance_js__WEBPACK_IMPORTED_MODULE_4__["TemplateInstance"] ?
            part.value.template :
            undefined;
        prepareTemplateStyles(scopeName, renderContainer, template);
        Object(_dom_js__WEBPACK_IMPORTED_MODULE_0__["removeNodes"])(container, container.firstChild);
        container.appendChild(renderContainer);
        _render_js__WEBPACK_IMPORTED_MODULE_2__["parts"].set(container, part);
    }
    // After elements have hit the DOM, update styling if this is the
    // initial render to this container.
    // This is needed whenever dynamic changes are made so it would be
    // safest to do every render; however, this would regress performance
    // so we leave it up to the user to call `ShadyCSS.styleElement`
    // for dynamic changes.
    if (!hasRendered && needsScoping) {
        window.ShadyCSS.styleElement(container.host);
    }
};


/***/ }),

/***/ "../../node_modules/lit-html/lib/template-factory.js":
/*!***************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/lit-html/lib/template-factory.js ***!
  \***************************************************************************/
/*! exports provided: templateFactory, templateCaches */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "templateFactory", function() { return templateFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "templateCaches", function() { return templateCaches; });
/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./template.js */ "../../node_modules/lit-html/lib/template.js");
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * The default TemplateFactory which caches Templates keyed on
 * result.type and result.strings.
 */
function templateFactory(result) {
    let templateCache = templateCaches.get(result.type);
    if (templateCache === undefined) {
        templateCache = {
            stringsArray: new WeakMap(),
            keyString: new Map()
        };
        templateCaches.set(result.type, templateCache);
    }
    let template = templateCache.stringsArray.get(result.strings);
    if (template !== undefined) {
        return template;
    }
    // If the TemplateStringsArray is new, generate a key from the strings
    // This key is shared between all templates with identical content
    const key = result.strings.join(_template_js__WEBPACK_IMPORTED_MODULE_0__["marker"]);
    // Check if we already have a Template for this key
    template = templateCache.keyString.get(key);
    if (template === undefined) {
        // If we have not seen this key before, create a new Template
        template = new _template_js__WEBPACK_IMPORTED_MODULE_0__["Template"](result, result.getTemplateElement());
        // Cache the Template for this key
        templateCache.keyString.set(key, template);
    }
    // Cache all future queries for this TemplateStringsArray
    templateCache.stringsArray.set(result.strings, template);
    return template;
}
const templateCaches = new Map();


/***/ }),

/***/ "../../node_modules/lit-html/lib/template-instance.js":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/lit-html/lib/template-instance.js ***!
  \****************************************************************************/
/*! exports provided: TemplateInstance */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TemplateInstance", function() { return TemplateInstance; });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom.js */ "../../node_modules/lit-html/lib/dom.js");
/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./template.js */ "../../node_modules/lit-html/lib/template.js");
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


/**
 * An instance of a `Template` that can be attached to the DOM and updated
 * with new values.
 */
class TemplateInstance {
    constructor(template, processor, options) {
        this.__parts = [];
        this.template = template;
        this.processor = processor;
        this.options = options;
    }
    update(values) {
        let i = 0;
        for (const part of this.__parts) {
            if (part !== undefined) {
                part.setValue(values[i]);
            }
            i++;
        }
        for (const part of this.__parts) {
            if (part !== undefined) {
                part.commit();
            }
        }
    }
    _clone() {
        // There are a number of steps in the lifecycle of a template instance's
        // DOM fragment:
        //  1. Clone - create the instance fragment
        //  2. Adopt - adopt into the main document
        //  3. Process - find part markers and create parts
        //  4. Upgrade - upgrade custom elements
        //  5. Update - set node, attribute, property, etc., values
        //  6. Connect - connect to the document. Optional and outside of this
        //     method.
        //
        // We have a few constraints on the ordering of these steps:
        //  * We need to upgrade before updating, so that property values will pass
        //    through any property setters.
        //  * We would like to process before upgrading so that we're sure that the
        //    cloned fragment is inert and not disturbed by self-modifying DOM.
        //  * We want custom elements to upgrade even in disconnected fragments.
        //
        // Given these constraints, with full custom elements support we would
        // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect
        //
        // But Safari does not implement CustomElementRegistry#upgrade, so we
        // can not implement that order and still have upgrade-before-update and
        // upgrade disconnected fragments. So we instead sacrifice the
        // process-before-upgrade constraint, since in Custom Elements v1 elements
        // must not modify their light DOM in the constructor. We still have issues
        // when co-existing with CEv0 elements like Polymer 1, and with polyfills
        // that don't strictly adhere to the no-modification rule because shadow
        // DOM, which may be created in the constructor, is emulated by being placed
        // in the light DOM.
        //
        // The resulting order is on native is: Clone, Adopt, Upgrade, Process,
        // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade
        // in one step.
        //
        // The Custom Elements v1 polyfill supports upgrade(), so the order when
        // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,
        // Connect.
        const fragment = _dom_js__WEBPACK_IMPORTED_MODULE_0__["isCEPolyfill"] ?
            this.template.element.content.cloneNode(true) :
            document.importNode(this.template.element.content, true);
        const stack = [];
        const parts = this.template.parts;
        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
        const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);
        let partIndex = 0;
        let nodeIndex = 0;
        let part;
        let node = walker.nextNode();
        // Loop through all the nodes and parts of a template
        while (partIndex < parts.length) {
            part = parts[partIndex];
            if (!Object(_template_js__WEBPACK_IMPORTED_MODULE_1__["isTemplatePartActive"])(part)) {
                this.__parts.push(undefined);
                partIndex++;
                continue;
            }
            // Progress the tree walker until we find our next part's node.
            // Note that multiple parts may share the same node (attribute parts
            // on a single element), so this loop may not run at all.
            while (nodeIndex < part.index) {
                nodeIndex++;
                if (node.nodeName === 'TEMPLATE') {
                    stack.push(node);
                    walker.currentNode = node.content;
                }
                if ((node = walker.nextNode()) === null) {
                    // We've exhausted the content inside a nested template element.
                    // Because we still have parts (the outer for-loop), we know:
                    // - There is a template in the stack
                    // - The walker will find a nextNode outside the template
                    walker.currentNode = stack.pop();
                    node = walker.nextNode();
                }
            }
            // We've arrived at our part's node.
            if (part.type === 'node') {
                const part = this.processor.handleTextExpression(this.options);
                part.insertAfterNode(node.previousSibling);
                this.__parts.push(part);
            }
            else {
                this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));
            }
            partIndex++;
        }
        if (_dom_js__WEBPACK_IMPORTED_MODULE_0__["isCEPolyfill"]) {
            document.adoptNode(fragment);
            customElements.upgrade(fragment);
        }
        return fragment;
    }
}


/***/ }),

/***/ "../../node_modules/lit-html/lib/template-result.js":
/*!**************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/lit-html/lib/template-result.js ***!
  \**************************************************************************/
/*! exports provided: TemplateResult, SVGTemplateResult */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TemplateResult", function() { return TemplateResult; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SVGTemplateResult", function() { return SVGTemplateResult; });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom.js */ "../../node_modules/lit-html/lib/dom.js");
/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./template.js */ "../../node_modules/lit-html/lib/template.js");
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * @module lit-html
 */


/**
 * Our TrustedTypePolicy for HTML which is declared using the html template
 * tag function.
 *
 * That HTML is a developer-authored constant, and is parsed with innerHTML
 * before any untrusted expressions have been mixed in. Therefor it is
 * considered safe by construction.
 */
const policy = window.trustedTypes &&
    trustedTypes.createPolicy('lit-html', { createHTML: (s) => s });
const commentMarker = ` ${_template_js__WEBPACK_IMPORTED_MODULE_1__["marker"]} `;
/**
 * The return type of `html`, which holds a Template and the values from
 * interpolated expressions.
 */
class TemplateResult {
    constructor(strings, values, type, processor) {
        this.strings = strings;
        this.values = values;
        this.type = type;
        this.processor = processor;
    }
    /**
     * Returns a string of HTML used to create a `<template>` element.
     */
    getHTML() {
        const l = this.strings.length - 1;
        let html = '';
        let isCommentBinding = false;
        for (let i = 0; i < l; i++) {
            const s = this.strings[i];
            // For each binding we want to determine the kind of marker to insert
            // into the template source before it's parsed by the browser's HTML
            // parser. The marker type is based on whether the expression is in an
            // attribute, text, or comment position.
            //   * For node-position bindings we insert a comment with the marker
            //     sentinel as its text content, like <!--{{lit-guid}}-->.
            //   * For attribute bindings we insert just the marker sentinel for the
            //     first binding, so that we support unquoted attribute bindings.
            //     Subsequent bindings can use a comment marker because multi-binding
            //     attributes must be quoted.
            //   * For comment bindings we insert just the marker sentinel so we don't
            //     close the comment.
            //
            // The following code scans the template source, but is *not* an HTML
            // parser. We don't need to track the tree structure of the HTML, only
            // whether a binding is inside a comment, and if not, if it appears to be
            // the first binding in an attribute.
            const commentOpen = s.lastIndexOf('<!--');
            // We're in comment position if we have a comment open with no following
            // comment close. Because <-- can appear in an attribute value there can
            // be false positives.
            isCommentBinding = (commentOpen > -1 || isCommentBinding) &&
                s.indexOf('-->', commentOpen + 1) === -1;
            // Check to see if we have an attribute-like sequence preceding the
            // expression. This can match "name=value" like structures in text,
            // comments, and attribute values, so there can be false-positives.
            const attributeMatch = _template_js__WEBPACK_IMPORTED_MODULE_1__["lastAttributeNameRegex"].exec(s);
            if (attributeMatch === null) {
                // We're only in this branch if we don't have a attribute-like
                // preceding sequence. For comments, this guards against unusual
                // attribute values like <div foo="<!--${'bar'}">. Cases like
                // <!-- foo=${'bar'}--> are handled correctly in the attribute branch
                // below.
                html += s + (isCommentBinding ? commentMarker : _template_js__WEBPACK_IMPORTED_MODULE_1__["nodeMarker"]);
            }
            else {
                // For attributes we use just a marker sentinel, and also append a
                // $lit$ suffix to the name to opt-out of attribute-specific parsing
                // that IE and Edge do for style and certain SVG attributes.
                html += s.substr(0, attributeMatch.index) + attributeMatch[1] +
                    attributeMatch[2] + _template_js__WEBPACK_IMPORTED_MODULE_1__["boundAttributeSuffix"] + attributeMatch[3] +
                    _template_js__WEBPACK_IMPORTED_MODULE_1__["marker"];
            }
        }
        html += this.strings[l];
        return html;
    }
    getTemplateElement() {
        const template = document.createElement('template');
        let value = this.getHTML();
        if (policy !== undefined) {
            // this is secure because `this.strings` is a TemplateStringsArray.
            // TODO: validate this when
            // https://github.com/tc39/proposal-array-is-template-object is
            // implemented.
            value = policy.createHTML(value);
        }
        template.innerHTML = value;
        return template;
    }
}
/**
 * A TemplateResult for SVG fragments.
 *
 * This class wraps HTML in an `<svg>` tag in order to parse its contents in the
 * SVG namespace, then modifies the template to remove the `<svg>` tag so that
 * clones only container the original fragment.
 */
class SVGTemplateResult extends TemplateResult {
    getHTML() {
        return `<svg>${super.getHTML()}</svg>`;
    }
    getTemplateElement() {
        const template = super.getTemplateElement();
        const content = template.content;
        const svgElement = content.firstChild;
        content.removeChild(svgElement);
        Object(_dom_js__WEBPACK_IMPORTED_MODULE_0__["reparentNodes"])(content, svgElement.firstChild);
        return template;
    }
}


/***/ }),

/***/ "../../node_modules/lit-html/lib/template.js":
/*!*******************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/lit-html/lib/template.js ***!
  \*******************************************************************/
/*! exports provided: marker, nodeMarker, markerRegex, boundAttributeSuffix, Template, isTemplatePartActive, createMarker, lastAttributeNameRegex */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "marker", function() { return marker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nodeMarker", function() { return nodeMarker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "markerRegex", function() { return markerRegex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "boundAttributeSuffix", function() { return boundAttributeSuffix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Template", function() { return Template; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTemplatePartActive", function() { return isTemplatePartActive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createMarker", function() { return createMarker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lastAttributeNameRegex", function() { return lastAttributeNameRegex; });
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * An expression marker with embedded unique key to avoid collision with
 * possible text in templates.
 */
const marker = `{{lit-${String(Math.random()).slice(2)}}}`;
/**
 * An expression marker used text-positions, multi-binding attributes, and
 * attributes with markup-like text values.
 */
const nodeMarker = `<!--${marker}-->`;
const markerRegex = new RegExp(`${marker}|${nodeMarker}`);
/**
 * Suffix appended to all bound attribute names.
 */
const boundAttributeSuffix = '$lit$';
/**
 * An updatable Template that tracks the location of dynamic parts.
 */
class Template {
    constructor(result, element) {
        this.parts = [];
        this.element = element;
        const nodesToRemove = [];
        const stack = [];
        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
        const walker = document.createTreeWalker(element.content, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);
        // Keeps track of the last index associated with a part. We try to delete
        // unnecessary nodes, but we never want to associate two different parts
        // to the same index. They must have a constant node between.
        let lastPartIndex = 0;
        let index = -1;
        let partIndex = 0;
        const { strings, values: { length } } = result;
        while (partIndex < length) {
            const node = walker.nextNode();
            if (node === null) {
                // We've exhausted the content inside a nested template element.
                // Because we still have parts (the outer for-loop), we know:
                // - There is a template in the stack
                // - The walker will find a nextNode outside the template
                walker.currentNode = stack.pop();
                continue;
            }
            index++;
            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
                if (node.hasAttributes()) {
                    const attributes = node.attributes;
                    const { length } = attributes;
                    // Per
                    // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
                    // attributes are not guaranteed to be returned in document order.
                    // In particular, Edge/IE can return them out of order, so we cannot
                    // assume a correspondence between part index and attribute index.
                    let count = 0;
                    for (let i = 0; i < length; i++) {
                        if (endsWith(attributes[i].name, boundAttributeSuffix)) {
                            count++;
                        }
                    }
                    while (count-- > 0) {
                        // Get the template literal section leading up to the first
                        // expression in this attribute
                        const stringForPart = strings[partIndex];
                        // Find the attribute name
                        const name = lastAttributeNameRegex.exec(stringForPart)[2];
                        // Find the corresponding attribute
                        // All bound attributes have had a suffix added in
                        // TemplateResult#getHTML to opt out of special attribute
                        // handling. To look up the attribute value we also need to add
                        // the suffix.
                        const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
                        const attributeValue = node.getAttribute(attributeLookupName);
                        node.removeAttribute(attributeLookupName);
                        const statics = attributeValue.split(markerRegex);
                        this.parts.push({ type: 'attribute', index, name, strings: statics });
                        partIndex += statics.length - 1;
                    }
                }
                if (node.tagName === 'TEMPLATE') {
                    stack.push(node);
                    walker.currentNode = node.content;
                }
            }
            else if (node.nodeType === 3 /* Node.TEXT_NODE */) {
                const data = node.data;
                if (data.indexOf(marker) >= 0) {
                    const parent = node.parentNode;
                    const strings = data.split(markerRegex);
                    const lastIndex = strings.length - 1;
                    // Generate a new text node for each literal section
                    // These nodes are also used as the markers for node parts
                    for (let i = 0; i < lastIndex; i++) {
                        let insert;
                        let s = strings[i];
                        if (s === '') {
                            insert = createMarker();
                        }
                        else {
                            const match = lastAttributeNameRegex.exec(s);
                            if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
                                s = s.slice(0, match.index) + match[1] +
                                    match[2].slice(0, -boundAttributeSuffix.length) + match[3];
                            }
                            insert = document.createTextNode(s);
                        }
                        parent.insertBefore(insert, node);
                        this.parts.push({ type: 'node', index: ++index });
                    }
                    // If there's no text, we must insert a comment to mark our place.
                    // Else, we can trust it will stick around after cloning.
                    if (strings[lastIndex] === '') {
                        parent.insertBefore(createMarker(), node);
                        nodesToRemove.push(node);
                    }
                    else {
                        node.data = strings[lastIndex];
                    }
                    // We have a part for each match found
                    partIndex += lastIndex;
                }
            }
            else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {
                if (node.data === marker) {
                    const parent = node.parentNode;
                    // Add a new marker node to be the startNode of the Part if any of
                    // the following are true:
                    //  * We don't have a previousSibling
                    //  * The previousSibling is already the start of a previous part
                    if (node.previousSibling === null || index === lastPartIndex) {
                        index++;
                        parent.insertBefore(createMarker(), node);
                    }
                    lastPartIndex = index;
                    this.parts.push({ type: 'node', index });
                    // If we don't have a nextSibling, keep this node so we have an end.
                    // Else, we can remove it to save future costs.
                    if (node.nextSibling === null) {
                        node.data = '';
                    }
                    else {
                        nodesToRemove.push(node);
                        index--;
                    }
                    partIndex++;
                }
                else {
                    let i = -1;
                    while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
                        // Comment node has a binding marker inside, make an inactive part
                        // The binding won't work, but subsequent bindings will
                        // TODO (justinfagnani): consider whether it's even worth it to
                        // make bindings in comments work
                        this.parts.push({ type: 'node', index: -1 });
                        partIndex++;
                    }
                }
            }
        }
        // Remove text binding nodes after the walk to not disturb the TreeWalker
        for (const n of nodesToRemove) {
            n.parentNode.removeChild(n);
        }
    }
}
const endsWith = (str, suffix) => {
    const index = str.length - suffix.length;
    return index >= 0 && str.slice(index) === suffix;
};
const isTemplatePartActive = (part) => part.index !== -1;
// Allows `document.createComment('')` to be renamed for a
// small manual size-savings.
const createMarker = () => document.createComment('');
/**
 * This regex extracts the attribute name preceding an attribute-position
 * expression. It does this by matching the syntax allowed for attributes
 * against the string literal directly preceding the expression, assuming that
 * the expression is in an attribute-value position.
 *
 * See attributes in the HTML spec:
 * https://www.w3.org/TR/html5/syntax.html#elements-attributes
 *
 * " \x09\x0a\x0c\x0d" are HTML space characters:
 * https://www.w3.org/TR/html5/infrastructure.html#space-characters
 *
 * "\0-\x1F\x7F-\x9F" are Unicode control characters, which includes every
 * space character except " ".
 *
 * So an attribute is:
 *  * The name: any character except a control character, space character, ('),
 *    ("), ">", "=", or "/"
 *  * Followed by zero or more space characters
 *  * Followed by "="
 *  * Followed by zero or more space characters
 *  * Followed by:
 *    * Any character except space, ('), ("), "<", ">", "=", (`), or
 *    * (") then any non-("), or
 *    * (') then any non-(')
 */
const lastAttributeNameRegex = 
// eslint-disable-next-line no-control-regex
/([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;


/***/ }),

/***/ "../../node_modules/lit-html/lit-html.js":
/*!***************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/lit-html/lit-html.js ***!
  \***************************************************************/
/*! exports provided: DefaultTemplateProcessor, defaultTemplateProcessor, directive, isDirective, removeNodes, reparentNodes, noChange, nothing, AttributeCommitter, AttributePart, BooleanAttributePart, EventPart, isIterable, isPrimitive, NodePart, PropertyCommitter, PropertyPart, parts, render, templateCaches, templateFactory, TemplateInstance, SVGTemplateResult, TemplateResult, createMarker, isTemplatePartActive, Template, html, svg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "html", function() { return html; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "svg", function() { return svg; });
/* harmony import */ var _lib_default_template_processor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/default-template-processor.js */ "../../node_modules/lit-html/lib/default-template-processor.js");
/* harmony import */ var _lib_template_result_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/template-result.js */ "../../node_modules/lit-html/lib/template-result.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DefaultTemplateProcessor", function() { return _lib_default_template_processor_js__WEBPACK_IMPORTED_MODULE_0__["DefaultTemplateProcessor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaultTemplateProcessor", function() { return _lib_default_template_processor_js__WEBPACK_IMPORTED_MODULE_0__["defaultTemplateProcessor"]; });

/* harmony import */ var _lib_directive_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/directive.js */ "../../node_modules/lit-html/lib/directive.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "directive", function() { return _lib_directive_js__WEBPACK_IMPORTED_MODULE_2__["directive"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isDirective", function() { return _lib_directive_js__WEBPACK_IMPORTED_MODULE_2__["isDirective"]; });

/* harmony import */ var _lib_dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/dom.js */ "../../node_modules/lit-html/lib/dom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "removeNodes", function() { return _lib_dom_js__WEBPACK_IMPORTED_MODULE_3__["removeNodes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reparentNodes", function() { return _lib_dom_js__WEBPACK_IMPORTED_MODULE_3__["reparentNodes"]; });

/* harmony import */ var _lib_part_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/part.js */ "../../node_modules/lit-html/lib/part.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "noChange", function() { return _lib_part_js__WEBPACK_IMPORTED_MODULE_4__["noChange"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nothing", function() { return _lib_part_js__WEBPACK_IMPORTED_MODULE_4__["nothing"]; });

/* harmony import */ var _lib_parts_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/parts.js */ "../../node_modules/lit-html/lib/parts.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AttributeCommitter", function() { return _lib_parts_js__WEBPACK_IMPORTED_MODULE_5__["AttributeCommitter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AttributePart", function() { return _lib_parts_js__WEBPACK_IMPORTED_MODULE_5__["AttributePart"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BooleanAttributePart", function() { return _lib_parts_js__WEBPACK_IMPORTED_MODULE_5__["BooleanAttributePart"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EventPart", function() { return _lib_parts_js__WEBPACK_IMPORTED_MODULE_5__["EventPart"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isIterable", function() { return _lib_parts_js__WEBPACK_IMPORTED_MODULE_5__["isIterable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isPrimitive", function() { return _lib_parts_js__WEBPACK_IMPORTED_MODULE_5__["isPrimitive"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NodePart", function() { return _lib_parts_js__WEBPACK_IMPORTED_MODULE_5__["NodePart"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PropertyCommitter", function() { return _lib_parts_js__WEBPACK_IMPORTED_MODULE_5__["PropertyCommitter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PropertyPart", function() { return _lib_parts_js__WEBPACK_IMPORTED_MODULE_5__["PropertyPart"]; });

/* harmony import */ var _lib_render_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/render.js */ "../../node_modules/lit-html/lib/render.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parts", function() { return _lib_render_js__WEBPACK_IMPORTED_MODULE_6__["parts"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _lib_render_js__WEBPACK_IMPORTED_MODULE_6__["render"]; });

/* harmony import */ var _lib_template_factory_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/template-factory.js */ "../../node_modules/lit-html/lib/template-factory.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "templateCaches", function() { return _lib_template_factory_js__WEBPACK_IMPORTED_MODULE_7__["templateCaches"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "templateFactory", function() { return _lib_template_factory_js__WEBPACK_IMPORTED_MODULE_7__["templateFactory"]; });

/* harmony import */ var _lib_template_instance_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/template-instance.js */ "../../node_modules/lit-html/lib/template-instance.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TemplateInstance", function() { return _lib_template_instance_js__WEBPACK_IMPORTED_MODULE_8__["TemplateInstance"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SVGTemplateResult", function() { return _lib_template_result_js__WEBPACK_IMPORTED_MODULE_1__["SVGTemplateResult"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TemplateResult", function() { return _lib_template_result_js__WEBPACK_IMPORTED_MODULE_1__["TemplateResult"]; });

/* harmony import */ var _lib_template_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/template.js */ "../../node_modules/lit-html/lib/template.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createMarker", function() { return _lib_template_js__WEBPACK_IMPORTED_MODULE_9__["createMarker"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isTemplatePartActive", function() { return _lib_template_js__WEBPACK_IMPORTED_MODULE_9__["isTemplatePartActive"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Template", function() { return _lib_template_js__WEBPACK_IMPORTED_MODULE_9__["Template"]; });

/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 *
 * Main lit-html module.
 *
 * Main exports:
 *
 * -  [[html]]
 * -  [[svg]]
 * -  [[render]]
 *
 * @packageDocumentation
 */
/**
 * Do not remove this comment; it keeps typedoc from misplacing the module
 * docs.
 */




// TODO(justinfagnani): remove line when we get NodePart moving methods








// IMPORTANT: do not change the property name or the assignment expression.
// This line will be used in regexes to search for lit-html usage.
// TODO(justinfagnani): inject version number at build time
if (typeof window !== 'undefined') {
    (window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.3.0');
}
/**
 * Interprets a template literal as an HTML template that can efficiently
 * render to and update a container.
 */
const html = (strings, ...values) => new _lib_template_result_js__WEBPACK_IMPORTED_MODULE_1__["TemplateResult"](strings, values, 'html', _lib_default_template_processor_js__WEBPACK_IMPORTED_MODULE_0__["defaultTemplateProcessor"]);
/**
 * Interprets a template literal as an SVG template that can efficiently
 * render to and update a container.
 */
const svg = (strings, ...values) => new _lib_template_result_js__WEBPACK_IMPORTED_MODULE_1__["SVGTemplateResult"](strings, values, 'svg', _lib_default_template_processor_js__WEBPACK_IMPORTED_MODULE_0__["defaultTemplateProcessor"]);


/***/ }),

/***/ "../../node_modules/object-assign/index.js":
/*!*****************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/object-assign/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "../../node_modules/quad-indices/index.js":
/*!****************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/quad-indices/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dtype = __webpack_require__(/*! dtype */ "../../node_modules/dtype/index.js")
var anArray = __webpack_require__(/*! an-array */ "../../node_modules/an-array/index.js")
var isBuffer = __webpack_require__(/*! is-buffer */ "../../node_modules/is-buffer/index.js")

var CW = [0, 2, 3]
var CCW = [2, 1, 3]

module.exports = function createQuadElements(array, opt) {
    //if user didn't specify an output array
    if (!array || !(anArray(array) || isBuffer(array))) {
        opt = array || {}
        array = null
    }

    if (typeof opt === 'number') //backwards-compatible
        opt = { count: opt }
    else
        opt = opt || {}

    var type = typeof opt.type === 'string' ? opt.type : 'uint16'
    var count = typeof opt.count === 'number' ? opt.count : 1
    var start = (opt.start || 0) 

    var dir = opt.clockwise !== false ? CW : CCW,
        a = dir[0], 
        b = dir[1],
        c = dir[2]

    var numIndices = count * 6

    var indices = array || new (dtype(type))(numIndices)
    for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {
        var x = i + start
        indices[x + 0] = j + 0
        indices[x + 1] = j + 1
        indices[x + 2] = j + 2
        indices[x + 3] = j + a
        indices[x + 4] = j + b
        indices[x + 5] = j + c
    }
    return indices
}

/***/ }),

/***/ "../../node_modules/three-bmfont-text/index.js":
/*!*********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three-bmfont-text/index.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createTextGeometry; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
var createLayout = __webpack_require__(/*! layout-bmfont-text */ "../../node_modules/layout-bmfont-text/index.js")
var inherits = __webpack_require__(/*! inherits */ "../../node_modules/inherits/inherits_browser.js")
var createIndices = __webpack_require__(/*! quad-indices */ "../../node_modules/quad-indices/index.js")

var vertices = __webpack_require__(/*! ./lib/vertices */ "../../node_modules/three-bmfont-text/lib/vertices.js")
var utils = __webpack_require__(/*! ./lib/utils */ "../../node_modules/three-bmfont-text/lib/utils.js")


//var three = require('three')

var Base = three__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]

function createTextGeometry (opt) {
  return new TextGeometry(opt)
}

function TextGeometry (opt) {
  Base.call(this)

  if (typeof opt === 'string') {
    opt = { text: opt }
  }

  // use these as default values for any subsequent
  // calls to update()
  this._opt = Object.assign({}, opt)

  // also do an initial setup...
  if (opt) this.update(opt)
}

inherits(TextGeometry, Base)

TextGeometry.prototype.update = function (opt) {
  if (typeof opt === 'string') {
    opt = { text: opt }
  }

  // use constructor defaults
  opt = Object.assign({}, this._opt, opt)

  if (!opt.font) {
    throw new TypeError('must specify a { font } in options')
  }

  this.layout = createLayout(opt)

  // get vec2 texcoords
  var flipY = opt.flipY !== false

  // the desired BMFont data
  var font = opt.font

  // determine texture size from font file
  var texWidth = font.common.scaleW
  var texHeight = font.common.scaleH

  // get visible glyphs
  var glyphs = this.layout.glyphs.filter(function (glyph) {
    var bitmap = glyph.data
    return bitmap.width * bitmap.height > 0
  })

  // provide visible glyphs for convenience
  this.visibleGlyphs = glyphs

  // get common vertex data
  var positions = vertices.positions(glyphs)
  var uvs = vertices.uvs(glyphs, texWidth, texHeight, flipY)
  var indices = createIndices([], {
    clockwise: true,
    type: 'uint16',
    count: glyphs.length
  })

  // update vertex data
  this.setIndex(indices)
  this.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_0__["BufferAttribute"](positions, 2))
  this.setAttribute('uv', new three__WEBPACK_IMPORTED_MODULE_0__["BufferAttribute"](uvs, 2))

  // update multipage data
  if (!opt.multipage && 'page' in this.attributes) {
    // disable multipage rendering
    this.removeAttribute('page')
  } else if (opt.multipage) {
    // enable multipage rendering
    var pages = vertices.pages(glyphs)
    this.setAttribute('page', new three__WEBPACK_IMPORTED_MODULE_0__["BufferAttribute"](pages, 1))
  }
}

TextGeometry.prototype.computeBoundingSphere = function () {
  if (this.boundingSphere === null) {
    this.boundingSphere = new three__WEBPACK_IMPORTED_MODULE_0__["Sphere"]()
  }

  var positions = this.attributes.position.array
  var itemSize = this.attributes.position.itemSize
  if (!positions || !itemSize || positions.length < 2) {
    this.boundingSphere.radius = 0
    this.boundingSphere.center.set(0, 0, 0)
    return
  }
  utils.computeSphere(positions, this.boundingSphere)
  if (isNaN(this.boundingSphere.radius)) {
    console.error('THREE.BufferGeometry.computeBoundingSphere(): ' +
      'Computed radius is NaN. The ' +
      '"position" attribute is likely to have NaN values.')
  }
}

TextGeometry.prototype.computeBoundingBox = function () {
  if (this.boundingBox === null) {
    this.boundingBox = new three__WEBPACK_IMPORTED_MODULE_0__["Box3"]()
  }

  var bbox = this.boundingBox
  var positions = this.attributes.position.array
  var itemSize = this.attributes.position.itemSize
  if (!positions || !itemSize || positions.length < 2) {
    bbox.makeEmpty()
    return
  }
  utils.computeBox(positions, bbox)
}


/***/ }),

/***/ "../../node_modules/three-bmfont-text/lib/utils.js":
/*!*************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three-bmfont-text/lib/utils.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var itemSize = 2
var box = { min: [0, 0], max: [0, 0] }

function bounds (positions) {
  var count = positions.length / itemSize
  box.min[0] = positions[0]
  box.min[1] = positions[1]
  box.max[0] = positions[0]
  box.max[1] = positions[1]

  for (var i = 0; i < count; i++) {
    var x = positions[i * itemSize + 0]
    var y = positions[i * itemSize + 1]
    box.min[0] = Math.min(x, box.min[0])
    box.min[1] = Math.min(y, box.min[1])
    box.max[0] = Math.max(x, box.max[0])
    box.max[1] = Math.max(y, box.max[1])
  }
}

module.exports.computeBox = function (positions, output) {
  bounds(positions)
  output.min.set(box.min[0], box.min[1], 0)
  output.max.set(box.max[0], box.max[1], 0)
}

module.exports.computeSphere = function (positions, output) {
  bounds(positions)
  var minX = box.min[0]
  var minY = box.min[1]
  var maxX = box.max[0]
  var maxY = box.max[1]
  var width = maxX - minX
  var height = maxY - minY
  var length = Math.sqrt(width * width + height * height)
  output.center.set(minX + width / 2, minY + height / 2, 0)
  output.radius = length / 2
}


/***/ }),

/***/ "../../node_modules/three-bmfont-text/lib/vertices.js":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three-bmfont-text/lib/vertices.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports.pages = function pages (glyphs) {
  var pages = new Float32Array(glyphs.length * 4 * 1)
  var i = 0
  glyphs.forEach(function (glyph) {
    var id = glyph.data.page || 0
    pages[i++] = id
    pages[i++] = id
    pages[i++] = id
    pages[i++] = id
  })
  return pages
}

module.exports.uvs = function uvs (glyphs, texWidth, texHeight, flipY) {
  var uvs = new Float32Array(glyphs.length * 4 * 2)
  var i = 0
  glyphs.forEach(function (glyph) {
    var bitmap = glyph.data
    var bw = (bitmap.x + bitmap.width)
    var bh = (bitmap.y + bitmap.height)

    // top left position
    var u0 = bitmap.x / texWidth
    var v1 = bitmap.y / texHeight
    var u1 = bw / texWidth
    var v0 = bh / texHeight

    if (flipY) {
      v1 = (texHeight - bitmap.y) / texHeight
      v0 = (texHeight - bh) / texHeight
    }

    // BL
    uvs[i++] = u0
    uvs[i++] = v1
    // TL
    uvs[i++] = u0
    uvs[i++] = v0
    // TR
    uvs[i++] = u1
    uvs[i++] = v0
    // BR
    uvs[i++] = u1
    uvs[i++] = v1
  })
  return uvs
}

module.exports.positions = function positions (glyphs) {
  var positions = new Float32Array(glyphs.length * 4 * 2)
  var i = 0
  glyphs.forEach(function (glyph) {
    var bitmap = glyph.data

    // bottom left position
    var x = glyph.position[0] + bitmap.xoffset
    var y = glyph.position[1] + bitmap.yoffset

    // quad size
    var w = bitmap.width
    var h = bitmap.height

    // BL
    positions[i++] = x
    positions[i++] = y
    // TL
    positions[i++] = x
    positions[i++] = y + h
    // TR
    positions[i++] = x + w
    positions[i++] = y + h
    // BR
    positions[i++] = x + w
    positions[i++] = y
  })
  return positions
}


/***/ }),

/***/ "../../node_modules/three-bmfont-text/shaders/msdf.js":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three-bmfont-text/shaders/msdf.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createMSDFShader; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
var assign = __webpack_require__(/*! object-assign */ "../../node_modules/object-assign/index.js");


function createMSDFShader (opt) {
  opt = opt || {};
  var opacity = typeof opt.opacity === 'number' ? opt.opacity : 1;
  var alphaTest = typeof opt.alphaTest === 'number' ? opt.alphaTest : 0.0001;
  var precision = opt.precision || 'highp';
  var color = opt.color;
  var map = opt.map;
  var negate = typeof opt.negate === 'boolean' ? opt.negate : true;
  var webgl2 = opt.isWebGL2 || false;

  // remove to satisfy r73
  delete opt.map;
  delete opt.color;
  delete opt.precision;
  delete opt.opacity;
  delete opt.negate;
  delete opt.isWebGL2;

  if(webgl2) {
    return assign({
      uniforms: {
        opacity: { type: 'f', value: opacity },
        map: { type: 't', value: map || new three__WEBPACK_IMPORTED_MODULE_0__["Texture"]() },
        color: { type: 'c', value: new three__WEBPACK_IMPORTED_MODULE_0__["Color"](color) }
      },
      vertexShader: [
        '#version 300 es',

        'in vec2 uv;',
        'in vec4 position;',
        'uniform mat4 projectionMatrix;',
        'uniform mat4 modelViewMatrix;',
        'out vec2 vUv;',

        'void main() {',
        '  vUv = uv;',
        '  gl_Position = projectionMatrix * modelViewMatrix * position;',
        '}'
      ].join('\n'),
      fragmentShader: [
        '#version 300 es',

        'precision ' + precision + ' float;',
        'uniform float opacity;',
        'uniform vec3 color;',
        'uniform sampler2D map;',
        'in vec2 vUv;',
        'out vec4 myOutputColor;',

        'float median(float r, float g, float b) {',
        '  return max(min(r, g), min(max(r, g), b));',
        '}',

        'void main() {',
        '  vec3 s = ' + (negate ? '1.0 - ' : '') + 'texture(map, vUv).rgb;',
        '  float sigDist = median(s.r, s.g, s.b) - 0.5;',
        '  float alpha = clamp(sigDist/fwidth(sigDist) + 0.5, 0.0, 1.0);',
        '  myOutputColor = vec4(color.xyz, alpha * opacity);',
        alphaTest === 0
          ? ''
          : '  if (myOutputColor.a < ' + alphaTest + ') discard;',
        '}'
      ].join('\n')
    }, opt);
  }
  else
  {
    return assign({
      uniforms: {
        opacity: { type: 'f', value: opacity },
        map: { type: 't', value: map || new three__WEBPACK_IMPORTED_MODULE_0__["Texture"]() },
        color: { type: 'c', value: new three__WEBPACK_IMPORTED_MODULE_0__["Color"](color) }
      },
      vertexShader: [
        'attribute vec2 uv;',
        'attribute vec4 position;',
        'uniform mat4 projectionMatrix;',
        'uniform mat4 modelViewMatrix;',
        'varying vec2 vUv;',
        'void main() {',
        'vUv = uv;',
        'gl_Position = projectionMatrix * modelViewMatrix * position;',
        '}'
      ].join('\n'),
      fragmentShader: [
        '#ifdef GL_OES_standard_derivatives',
        '#extension GL_OES_standard_derivatives : enable',
        '#endif',
        'precision ' + precision + ' float;',
        'uniform float opacity;',
        'uniform vec3 color;',
        'uniform sampler2D map;',
        'varying vec2 vUv;',

        'float median(float r, float g, float b) {',
        '  return max(min(r, g), min(max(r, g), b));',
        '}',

        'void main() {',
        '  vec3 sample = ' + (negate ? '1.0 - ' : '') + 'texture2D(map, vUv).rgb;',
        '  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;',
        '  float alpha = clamp(sigDist/fwidth(sigDist) + 0.5, 0.0, 1.0);',
        '  gl_FragColor = vec4(color.xyz, alpha * opacity);',
        alphaTest === 0
          ? ''
          : '  if (gl_FragColor.a < ' + alphaTest + ') discard;',
        '}'
      ].join('\n')
    }, opt);
  }
};


/***/ }),

/***/ "../../node_modules/three/examples/jsm/loaders/DRACOLoader.js":
/*!************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/examples/jsm/loaders/DRACOLoader.js ***!
  \************************************************************************************/
/*! exports provided: DRACOLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DRACOLoader", function() { return DRACOLoader; });
/* harmony import */ var _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../build/three.module.js */ "../../node_modules/three/src/Three.js");


var DRACOLoader = function ( manager ) {

	_build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Loader"].call( this, manager );

	this.decoderPath = '';
	this.decoderConfig = {};
	this.decoderBinary = null;
	this.decoderPending = null;

	this.workerLimit = 4;
	this.workerPool = [];
	this.workerNextTaskID = 1;
	this.workerSourceURL = '';

	this.defaultAttributeIDs = {
		position: 'POSITION',
		normal: 'NORMAL',
		color: 'COLOR',
		uv: 'TEX_COORD'
	};
	this.defaultAttributeTypes = {
		position: 'Float32Array',
		normal: 'Float32Array',
		color: 'Float32Array',
		uv: 'Float32Array'
	};

};

DRACOLoader.prototype = Object.assign( Object.create( _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Loader"].prototype ), {

	constructor: DRACOLoader,

	setDecoderPath: function ( path ) {

		this.decoderPath = path;

		return this;

	},

	setDecoderConfig: function ( config ) {

		this.decoderConfig = config;

		return this;

	},

	setWorkerLimit: function ( workerLimit ) {

		this.workerLimit = workerLimit;

		return this;

	},

	/** @deprecated */
	setVerbosity: function () {

		console.warn( 'THREE.DRACOLoader: The .setVerbosity() method has been removed.' );

	},

	/** @deprecated */
	setDrawMode: function () {

		console.warn( 'THREE.DRACOLoader: The .setDrawMode() method has been removed.' );

	},

	/** @deprecated */
	setSkipDequantization: function () {

		console.warn( 'THREE.DRACOLoader: The .setSkipDequantization() method has been removed.' );

	},

	load: function ( url, onLoad, onProgress, onError ) {

		var loader = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["FileLoader"]( this.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, ( buffer ) => {

			var taskConfig = {
				attributeIDs: this.defaultAttributeIDs,
				attributeTypes: this.defaultAttributeTypes,
				useUniqueIDs: false
			};

			this.decodeGeometry( buffer, taskConfig )
				.then( onLoad )
				.catch( onError );

		}, onProgress, onError );

	},

	/** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */
	decodeDracoFile: function ( buffer, callback, attributeIDs, attributeTypes ) {

		var taskConfig = {
			attributeIDs: attributeIDs || this.defaultAttributeIDs,
			attributeTypes: attributeTypes || this.defaultAttributeTypes,
			useUniqueIDs: !! attributeIDs
		};

		this.decodeGeometry( buffer, taskConfig ).then( callback );

	},

	decodeGeometry: function ( buffer, taskConfig ) {

		// TODO: For backward-compatibility, support 'attributeTypes' objects containing
		// references (rather than names) to typed array constructors. These must be
		// serialized before sending them to the worker.
		for ( var attribute in taskConfig.attributeTypes ) {

			var type = taskConfig.attributeTypes[ attribute ];

			if ( type.BYTES_PER_ELEMENT !== undefined ) {

				taskConfig.attributeTypes[ attribute ] = type.name;

			}

		}

		//

		var taskKey = JSON.stringify( taskConfig );

		// Check for an existing task using this buffer. A transferred buffer cannot be transferred
		// again from this thread.
		if ( DRACOLoader.taskCache.has( buffer ) ) {

			var cachedTask = DRACOLoader.taskCache.get( buffer );

			if ( cachedTask.key === taskKey ) {

				return cachedTask.promise;

			} else if ( buffer.byteLength === 0 ) {

				// Technically, it would be possible to wait for the previous task to complete,
				// transfer the buffer back, and decode again with the second configuration. That
				// is complex, and I don't know of any reason to decode a Draco buffer twice in
				// different ways, so this is left unimplemented.
				throw new Error(

					'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +
					'settings. Buffer has already been transferred.'

				);

			}

		}

		//

		var worker;
		var taskID = this.workerNextTaskID ++;
		var taskCost = buffer.byteLength;

		// Obtain a worker and assign a task, and construct a geometry instance
		// when the task completes.
		var geometryPending = this._getWorker( taskID, taskCost )
			.then( ( _worker ) => {

				worker = _worker;

				return new Promise( ( resolve, reject ) => {

					worker._callbacks[ taskID ] = { resolve, reject };

					worker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );

					// this.debug();

				} );

			} )
			.then( ( message ) => this._createGeometry( message.geometry ) );

		// Remove task from the task list.
		// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)
		geometryPending
			.catch( () => true )
			.then( () => {

				if ( worker && taskID ) {

					this._releaseTask( worker, taskID );

					// this.debug();

				}

			} );

		// Cache the task result.
		DRACOLoader.taskCache.set( buffer, {

			key: taskKey,
			promise: geometryPending

		} );

		return geometryPending;

	},

	_createGeometry: function ( geometryData ) {

		var geometry = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]();

		if ( geometryData.index ) {

			geometry.setIndex( new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["BufferAttribute"]( geometryData.index.array, 1 ) );

		}

		for ( var i = 0; i < geometryData.attributes.length; i ++ ) {

			var attribute = geometryData.attributes[ i ];
			var name = attribute.name;
			var array = attribute.array;
			var itemSize = attribute.itemSize;

			geometry.setAttribute( name, new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["BufferAttribute"]( array, itemSize ) );

		}

		return geometry;

	},

	_loadLibrary: function ( url, responseType ) {

		var loader = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["FileLoader"]( this.manager );
		loader.setPath( this.decoderPath );
		loader.setResponseType( responseType );
		loader.setWithCredentials( this.withCredentials );

		return new Promise( ( resolve, reject ) => {

			loader.load( url, resolve, undefined, reject );

		} );

	},

	preload: function () {

		this._initDecoder();

		return this;

	},

	_initDecoder: function () {

		if ( this.decoderPending ) return this.decoderPending;

		var useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';
		var librariesPending = [];

		if ( useJS ) {

			librariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );

		} else {

			librariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );
			librariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );

		}

		this.decoderPending = Promise.all( librariesPending )
			.then( ( libraries ) => {

				var jsContent = libraries[ 0 ];

				if ( ! useJS ) {

					this.decoderConfig.wasmBinary = libraries[ 1 ];

				}

				var fn = DRACOLoader.DRACOWorker.toString();

				var body = [
					'/* draco decoder */',
					jsContent,
					'',
					'/* worker */',
					fn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )
				].join( '\n' );

				this.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );

			} );

		return this.decoderPending;

	},

	_getWorker: function ( taskID, taskCost ) {

		return this._initDecoder().then( () => {

			if ( this.workerPool.length < this.workerLimit ) {

				var worker = new Worker( this.workerSourceURL );

				worker._callbacks = {};
				worker._taskCosts = {};
				worker._taskLoad = 0;

				worker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );

				worker.onmessage = function ( e ) {

					var message = e.data;

					switch ( message.type ) {

						case 'decode':
							worker._callbacks[ message.id ].resolve( message );
							break;

						case 'error':
							worker._callbacks[ message.id ].reject( message );
							break;

						default:
							console.error( 'THREE.DRACOLoader: Unexpected message, "' + message.type + '"' );

					}

				};

				this.workerPool.push( worker );

			} else {

				this.workerPool.sort( function ( a, b ) {

					return a._taskLoad > b._taskLoad ? - 1 : 1;

				} );

			}

			var worker = this.workerPool[ this.workerPool.length - 1 ];
			worker._taskCosts[ taskID ] = taskCost;
			worker._taskLoad += taskCost;
			return worker;

		} );

	},

	_releaseTask: function ( worker, taskID ) {

		worker._taskLoad -= worker._taskCosts[ taskID ];
		delete worker._callbacks[ taskID ];
		delete worker._taskCosts[ taskID ];

	},

	debug: function () {

		console.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );

	},

	dispose: function () {

		for ( var i = 0; i < this.workerPool.length; ++ i ) {

			this.workerPool[ i ].terminate();

		}

		this.workerPool.length = 0;

		return this;

	}

} );

/* WEB WORKER */

DRACOLoader.DRACOWorker = function () {

	var decoderConfig;
	var decoderPending;

	onmessage = function ( e ) {

		var message = e.data;

		switch ( message.type ) {

			case 'init':
				decoderConfig = message.decoderConfig;
				decoderPending = new Promise( function ( resolve/*, reject*/ ) {

					decoderConfig.onModuleLoaded = function ( draco ) {

						// Module is Promise-like. Wrap before resolving to avoid loop.
						resolve( { draco: draco } );

					};

					DracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef

				} );
				break;

			case 'decode':
				var buffer = message.buffer;
				var taskConfig = message.taskConfig;
				decoderPending.then( ( module ) => {

					var draco = module.draco;
					var decoder = new draco.Decoder();
					var decoderBuffer = new draco.DecoderBuffer();
					decoderBuffer.Init( new Int8Array( buffer ), buffer.byteLength );

					try {

						var geometry = decodeGeometry( draco, decoder, decoderBuffer, taskConfig );

						var buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );

						if ( geometry.index ) buffers.push( geometry.index.array.buffer );

						self.postMessage( { type: 'decode', id: message.id, geometry }, buffers );

					} catch ( error ) {

						console.error( error );

						self.postMessage( { type: 'error', id: message.id, error: error.message } );

					} finally {

						draco.destroy( decoderBuffer );
						draco.destroy( decoder );

					}

				} );
				break;

		}

	};

	function decodeGeometry( draco, decoder, decoderBuffer, taskConfig ) {

		var attributeIDs = taskConfig.attributeIDs;
		var attributeTypes = taskConfig.attributeTypes;

		var dracoGeometry;
		var decodingStatus;

		var geometryType = decoder.GetEncodedGeometryType( decoderBuffer );

		if ( geometryType === draco.TRIANGULAR_MESH ) {

			dracoGeometry = new draco.Mesh();
			decodingStatus = decoder.DecodeBufferToMesh( decoderBuffer, dracoGeometry );

		} else if ( geometryType === draco.POINT_CLOUD ) {

			dracoGeometry = new draco.PointCloud();
			decodingStatus = decoder.DecodeBufferToPointCloud( decoderBuffer, dracoGeometry );

		} else {

			throw new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );

		}

		if ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {

			throw new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );

		}

		var geometry = { index: null, attributes: [] };

		// Gather all vertex attributes.
		for ( var attributeName in attributeIDs ) {

			var attributeType = self[ attributeTypes[ attributeName ] ];

			var attribute;
			var attributeID;

			// A Draco file may be created with default vertex attributes, whose attribute IDs
			// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,
			// a Draco file may contain a custom set of attributes, identified by known unique
			// IDs. glTF files always do the latter, and `.drc` files typically do the former.
			if ( taskConfig.useUniqueIDs ) {

				attributeID = attributeIDs[ attributeName ];
				attribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );

			} else {

				attributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );

				if ( attributeID === - 1 ) continue;

				attribute = decoder.GetAttribute( dracoGeometry, attributeID );

			}

			geometry.attributes.push( decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) );

		}

		// Add index.
		if ( geometryType === draco.TRIANGULAR_MESH ) {

			geometry.index = decodeIndex( draco, decoder, dracoGeometry );

		}

		draco.destroy( dracoGeometry );

		return geometry;

	}

	function decodeIndex( draco, decoder, dracoGeometry ) {

		var numFaces = dracoGeometry.num_faces();
		var numIndices = numFaces * 3;
		var byteLength = numIndices * 4;

		var ptr = draco._malloc( byteLength );
		decoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );
		var index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();
		draco._free( ptr );

		return { array: index, itemSize: 1 };

	}

	function decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {

		var numComponents = attribute.num_components();
		var numPoints = dracoGeometry.num_points();
		var numValues = numPoints * numComponents;
		var byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
		var dataType = getDracoDataType( draco, attributeType );

		var ptr = draco._malloc( byteLength );
		decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );
		var array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();
		draco._free( ptr );

		return {
			name: attributeName,
			array: array,
			itemSize: numComponents
		};

	}

	function getDracoDataType( draco, attributeType ) {

		switch ( attributeType ) {

			case Float32Array: return draco.DT_FLOAT32;
			case Int8Array: return draco.DT_INT8;
			case Int16Array: return draco.DT_INT16;
			case Int32Array: return draco.DT_INT32;
			case Uint8Array: return draco.DT_UINT8;
			case Uint16Array: return draco.DT_UINT16;
			case Uint32Array: return draco.DT_UINT32;

		}

	}

};

DRACOLoader.taskCache = new WeakMap();

/** Deprecated static methods */

/** @deprecated */
DRACOLoader.setDecoderPath = function () {

	console.warn( 'THREE.DRACOLoader: The .setDecoderPath() method has been removed. Use instance methods.' );

};

/** @deprecated */
DRACOLoader.setDecoderConfig = function () {

	console.warn( 'THREE.DRACOLoader: The .setDecoderConfig() method has been removed. Use instance methods.' );

};

/** @deprecated */
DRACOLoader.releaseDecoderModule = function () {

	console.warn( 'THREE.DRACOLoader: The .releaseDecoderModule() method has been removed. Use instance methods.' );

};

/** @deprecated */
DRACOLoader.getDecoderModule = function () {

	console.warn( 'THREE.DRACOLoader: The .getDecoderModule() method has been removed. Use instance methods.' );

};




/***/ }),

/***/ "../../node_modules/three/examples/jsm/loaders/GLTFLoader.js":
/*!***********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/examples/jsm/loaders/GLTFLoader.js ***!
  \***********************************************************************************/
/*! exports provided: GLTFLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFLoader", function() { return GLTFLoader; });
/* harmony import */ var _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../build/three.module.js */ "../../node_modules/three/src/Three.js");


var GLTFLoader = ( function () {

	function GLTFLoader( manager ) {

		_build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Loader"].call( this, manager );

		this.dracoLoader = null;
		this.ktx2Loader = null;
		this.meshoptDecoder = null;

		this.pluginCallbacks = [];

		this.register( function ( parser ) {

			return new GLTFMaterialsClearcoatExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureBasisUExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureWebPExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsTransmissionExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFLightsExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMeshoptCompression( parser );

		} );

	}

	GLTFLoader.prototype = Object.assign( Object.create( _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Loader"].prototype ), {

		constructor: GLTFLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var resourcePath;

			if ( this.resourcePath !== '' ) {

				resourcePath = this.resourcePath;

			} else if ( this.path !== '' ) {

				resourcePath = this.path;

			} else {

				resourcePath = _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["LoaderUtils"].extractUrlBase( url );

			}

			// Tells the LoadingManager to track an extra item, which resolves after
			// the model is fully loaded. This means the count of items loaded will
			// be incorrect, but ensures manager.onLoad() does not fire early.
			this.manager.itemStart( url );

			var _onError = function ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			};

			var loader = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["FileLoader"]( this.manager );

			loader.setPath( this.path );
			loader.setResponseType( 'arraybuffer' );
			loader.setRequestHeader( this.requestHeader );
			loader.setWithCredentials( this.withCredentials );

			loader.load( url, function ( data ) {

				try {

					scope.parse( data, resourcePath, function ( gltf ) {

						onLoad( gltf );

						scope.manager.itemEnd( url );

					}, _onError );

				} catch ( e ) {

					_onError( e );

				}

			}, onProgress, _onError );

		},

		setDRACOLoader: function ( dracoLoader ) {

			this.dracoLoader = dracoLoader;
			return this;

		},

		setDDSLoader: function () {

			throw new Error(

				'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'

			);

		},

		setKTX2Loader: function ( ktx2Loader ) {

			this.ktx2Loader = ktx2Loader;
			return this;

		},

		setMeshoptDecoder: function ( meshoptDecoder ) {

			this.meshoptDecoder = meshoptDecoder;
			return this;

		},

		register: function ( callback ) {

			if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

				this.pluginCallbacks.push( callback );

			}

			return this;

		},

		unregister: function ( callback ) {

			if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

				this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

			}

			return this;

		},

		parse: function ( data, path, onLoad, onError ) {

			var content;
			var extensions = {};
			var plugins = {};

			if ( typeof data === 'string' ) {

				content = data;

			} else {

				var magic = _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["LoaderUtils"].decodeText( new Uint8Array( data, 0, 4 ) );

				if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

					try {

						extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

					} catch ( error ) {

						if ( onError ) onError( error );
						return;

					}

					content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;

				} else {

					content = _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["LoaderUtils"].decodeText( new Uint8Array( data ) );

				}

			}

			var json = JSON.parse( content );

			if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

				if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
				return;

			}

			var parser = new GLTFParser( json, {

				path: path || this.resourcePath || '',
				crossOrigin: this.crossOrigin,
				requestHeader: this.requestHeader,
				manager: this.manager,
				ktx2Loader: this.ktx2Loader,
				meshoptDecoder: this.meshoptDecoder

			} );

			parser.fileLoader.setRequestHeader( this.requestHeader );

			for ( var i = 0; i < this.pluginCallbacks.length; i ++ ) {

				var plugin = this.pluginCallbacks[ i ]( parser );
				plugins[ plugin.name ] = plugin;

				// Workaround to avoid determining as unknown extension
				// in addUnknownExtensionsToUserData().
				// Remove this workaround if we move all the existing
				// extension handlers to plugin system
				extensions[ plugin.name ] = true;

			}

			if ( json.extensionsUsed ) {

				for ( var i = 0; i < json.extensionsUsed.length; ++ i ) {

					var extensionName = json.extensionsUsed[ i ];
					var extensionsRequired = json.extensionsRequired || [];

					switch ( extensionName ) {

						case EXTENSIONS.KHR_MATERIALS_UNLIT:
							extensions[ extensionName ] = new GLTFMaterialsUnlitExtension();
							break;

						case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
							extensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();
							break;

						case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
							extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
							break;

						case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
							extensions[ extensionName ] = new GLTFTextureTransformExtension();
							break;

						case EXTENSIONS.KHR_MESH_QUANTIZATION:
							extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
							break;

						default:

							if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {

								console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

							}

					}

				}

			}

			parser.setExtensions( extensions );
			parser.setPlugins( plugins );
			parser.parse( onLoad, onError );

		}

	} );

	/* GLTFREGISTRY */

	function GLTFRegistry() {

		var objects = {};

		return	{

			get: function ( key ) {

				return objects[ key ];

			},

			add: function ( key, object ) {

				objects[ key ] = object;

			},

			remove: function ( key ) {

				delete objects[ key ];

			},

			removeAll: function () {

				objects = {};

			}

		};

	}

	/*********************************/
	/********** EXTENSIONS ***********/
	/*********************************/

	var EXTENSIONS = {
		KHR_BINARY_GLTF: 'KHR_binary_glTF',
		KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
		KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
		KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
		KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
		KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
		KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
		KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
		KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
		KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
		EXT_TEXTURE_WEBP: 'EXT_texture_webp',
		EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
	};

	/**
	 * Punctual Lights Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
	 */
	function GLTFLightsExtension( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

		// Object3D instance caches
		this.cache = { refs: {}, uses: {} };

	}

	GLTFLightsExtension.prototype._markDefs = function () {

		var parser = this.parser;
		var nodeDefs = this.parser.json.nodes || [];

		for ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			var nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.extensions
				&& nodeDef.extensions[ this.name ]
				&& nodeDef.extensions[ this.name ].light !== undefined ) {

				parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );

			}

		}

	};

	GLTFLightsExtension.prototype._loadLight = function ( lightIndex ) {

		var parser = this.parser;
		var cacheKey = 'light:' + lightIndex;
		var dependency = parser.cache.get( cacheKey );

		if ( dependency ) return dependency;

		var json = parser.json;
		var extensions = ( json.extensions && json.extensions[ this.name ] ) || {};
		var lightDefs = extensions.lights || [];
		var lightDef = lightDefs[ lightIndex ];
		var lightNode;

		var color = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Color"]( 0xffffff );

		if ( lightDef.color !== undefined ) color.fromArray( lightDef.color );

		var range = lightDef.range !== undefined ? lightDef.range : 0;

		switch ( lightDef.type ) {

			case 'directional':
				lightNode = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["DirectionalLight"]( color );
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			case 'point':
				lightNode = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["PointLight"]( color );
				lightNode.distance = range;
				break;

			case 'spot':
				lightNode = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["SpotLight"]( color );
				lightNode.distance = range;
				// Handle spotlight properties.
				lightDef.spot = lightDef.spot || {};
				lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
				lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
				lightNode.angle = lightDef.spot.outerConeAngle;
				lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			default:
				throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );

		}

		// Some lights (e.g. spot) default to a position other than the origin. Reset the position
		// here, because node-level parsing will only override position if explicitly specified.
		lightNode.position.set( 0, 0, 0 );

		lightNode.decay = 2;

		if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;

		lightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );

		dependency = Promise.resolve( lightNode );

		parser.cache.add( cacheKey, dependency );

		return dependency;

	};

	GLTFLightsExtension.prototype.createNodeAttachment = function ( nodeIndex ) {

		var self = this;
		var parser = this.parser;
		var json = parser.json;
		var nodeDef = json.nodes[ nodeIndex ];
		var lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};
		var lightIndex = lightDef.light;

		if ( lightIndex === undefined ) return null;

		return this._loadLight( lightIndex ).then( function ( light ) {

			return parser._getNodeRef( self.cache, lightIndex, light );

		} );

	};

	/**
	 * Unlit Materials Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
	 */
	function GLTFMaterialsUnlitExtension() {

		this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

	}

	GLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {

		return _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["MeshBasicMaterial"];

	};

	GLTFMaterialsUnlitExtension.prototype.extendParams = function ( materialParams, materialDef, parser ) {

		var pending = [];

		materialParams.color = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Color"]( 1.0, 1.0, 1.0 );
		materialParams.opacity = 1.0;

		var metallicRoughness = materialDef.pbrMetallicRoughness;

		if ( metallicRoughness ) {

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				var array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

			}

		}

		return Promise.all( pending );

	};

	/**
	 * Clearcoat Materials Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
	 */
	function GLTFMaterialsClearcoatExtension( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

	}

	GLTFMaterialsClearcoatExtension.prototype.getMaterialType = function ( materialIndex ) {

		var parser = this.parser;
		var materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["MeshPhysicalMaterial"];

	};

	GLTFMaterialsClearcoatExtension.prototype.extendMaterialParams = function ( materialIndex, materialParams ) {

		var parser = this.parser;
		var materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		var pending = [];

		var extension = materialDef.extensions[ this.name ];

		if ( extension.clearcoatFactor !== undefined ) {

			materialParams.clearcoat = extension.clearcoatFactor;

		}

		if ( extension.clearcoatTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );

		}

		if ( extension.clearcoatRoughnessFactor !== undefined ) {

			materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

		}

		if ( extension.clearcoatRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );

		}

		if ( extension.clearcoatNormalTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );

			if ( extension.clearcoatNormalTexture.scale !== undefined ) {

				var scale = extension.clearcoatNormalTexture.scale;

				// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
				materialParams.clearcoatNormalScale = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]( scale, - scale );

			}

		}

		return Promise.all( pending );

	};

	/**
	 * Transmission Materials Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
	 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
	 */
	function GLTFMaterialsTransmissionExtension( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;

	}

	GLTFMaterialsTransmissionExtension.prototype.getMaterialType = function ( materialIndex ) {

		var parser = this.parser;
		var materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["MeshPhysicalMaterial"];

	};

	GLTFMaterialsTransmissionExtension.prototype.extendMaterialParams = function ( materialIndex, materialParams ) {

		var parser = this.parser;
		var materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		var pending = [];

		var extension = materialDef.extensions[ this.name ];

		if ( extension.transmissionFactor !== undefined ) {

			materialParams.transmission = extension.transmissionFactor;

		}

		if ( extension.transmissionTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );

		}

		return Promise.all( pending );

	};

	/**
	 * BasisU Texture Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
	 */
	function GLTFTextureBasisUExtension( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_TEXTURE_BASISU;

	}

	GLTFTextureBasisUExtension.prototype.loadTexture = function ( textureIndex ) {

		var parser = this.parser;
		var json = parser.json;

		var textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {

			return null;

		}

		var extension = textureDef.extensions[ this.name ];
		var source = json.images[ extension.source ];
		var loader = parser.options.ktx2Loader;

		if ( ! loader ) {

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );

			} else {

				// Assumes that the extension is optional and that a fallback texture is present
				return null;

			}

		}

		return parser.loadTextureImage( textureIndex, source, loader );

	};

	/**
	 * WebP Texture Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
	 */
	function GLTFTextureWebPExtension( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
		this.isSupported = null;

	}

	GLTFTextureWebPExtension.prototype.loadTexture = function ( textureIndex ) {

		var name = this.name;
		var parser = this.parser;
		var json = parser.json;

		var textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

			return null;

		}

		var extension = textureDef.extensions[ name ];
		var source = json.images[ extension.source ];

		var loader = parser.textureLoader;
		if ( source.uri ) {

			var handler = parser.options.manager.getHandler( source.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.detectSupport().then( function ( isSupported ) {

			if ( isSupported ) return parser.loadTextureImage( textureIndex, source, loader );

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );

			}

			// Fall back to PNG or JPEG.
			return parser.loadTexture( textureIndex );

		} );

	};

	GLTFTextureWebPExtension.prototype.detectSupport = function () {

		if ( ! this.isSupported ) {

			this.isSupported = new Promise( function ( resolve ) {

				var image = new Image();

				// Lossy test image. Support for lossy images doesn't guarantee support for all
				// WebP images, unfortunately.
				image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

				image.onload = image.onerror = function () {

					resolve( image.height === 1 );

				};

			} );

		}

		return this.isSupported;

	};

	/**
	* meshopt BufferView Compression Extension
	*
	* Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
	*/
	function GLTFMeshoptCompression( parser ) {

		this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
		this.parser = parser;

	}

	GLTFMeshoptCompression.prototype.loadBufferView = function ( index ) {

		var json = this.parser.json;
		var bufferView = json.bufferViews[ index ];

		if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {

			var extensionDef = bufferView.extensions[ this.name ];

			var buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );
			var decoder = this.parser.options.meshoptDecoder;

			if ( ! decoder || ! decoder.supported ) {

				if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

					throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );

				} else {

					// Assumes that the extension is optional and that fallback buffer data is present
					return null;

				}

			}

			return Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {

				var byteOffset = extensionDef.byteOffset || 0;
				var byteLength = extensionDef.byteLength || 0;

				var count = extensionDef.count;
				var stride = extensionDef.byteStride;

				var result = new ArrayBuffer( count * stride );
				var source = new Uint8Array( res[ 0 ], byteOffset, byteLength );

				decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );
				return result;

			} );

		} else {

			return null;

		}

	};

	/* BINARY EXTENSION */
	var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
	var BINARY_EXTENSION_HEADER_LENGTH = 12;
	var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

	function GLTFBinaryExtension( data ) {

		this.name = EXTENSIONS.KHR_BINARY_GLTF;
		this.content = null;
		this.body = null;

		var headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );

		this.header = {
			magic: _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["LoaderUtils"].decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),
			version: headerView.getUint32( 4, true ),
			length: headerView.getUint32( 8, true )
		};

		if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

			throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

		} else if ( this.header.version < 2.0 ) {

			throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

		}

		var chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
		var chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
		var chunkIndex = 0;

		while ( chunkIndex < chunkContentsLength ) {

			var chunkLength = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			var chunkType = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

				var contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
				this.content = _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["LoaderUtils"].decodeText( contentArray );

			} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

				var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
				this.body = data.slice( byteOffset, byteOffset + chunkLength );

			}

			// Clients must ignore chunks with unknown types.

			chunkIndex += chunkLength;

		}

		if ( this.content === null ) {

			throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

		}

	}

	/**
	 * DRACO Mesh Compression Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
	 */
	function GLTFDracoMeshCompressionExtension( json, dracoLoader ) {

		if ( ! dracoLoader ) {

			throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

		}

		this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
		this.json = json;
		this.dracoLoader = dracoLoader;
		this.dracoLoader.preload();

	}

	GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function ( primitive, parser ) {

		var json = this.json;
		var dracoLoader = this.dracoLoader;
		var bufferViewIndex = primitive.extensions[ this.name ].bufferView;
		var gltfAttributeMap = primitive.extensions[ this.name ].attributes;
		var threeAttributeMap = {};
		var attributeNormalizedMap = {};
		var attributeTypeMap = {};

		for ( var attributeName in gltfAttributeMap ) {

			var threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

		}

		for ( attributeName in primitive.attributes ) {

			var threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			if ( gltfAttributeMap[ attributeName ] !== undefined ) {

				var accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
				var componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

				attributeTypeMap[ threeAttributeName ] = componentType;
				attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

			}

		}

		return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

			return new Promise( function ( resolve ) {

				dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

					for ( var attributeName in geometry.attributes ) {

						var attribute = geometry.attributes[ attributeName ];
						var normalized = attributeNormalizedMap[ attributeName ];

						if ( normalized !== undefined ) attribute.normalized = normalized;

					}

					resolve( geometry );

				}, threeAttributeMap, attributeTypeMap );

			} );

		} );

	};

	/**
	 * Texture Transform Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
	 */
	function GLTFTextureTransformExtension() {

		this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

	}

	GLTFTextureTransformExtension.prototype.extendTexture = function ( texture, transform ) {

		texture = texture.clone();

		if ( transform.offset !== undefined ) {

			texture.offset.fromArray( transform.offset );

		}

		if ( transform.rotation !== undefined ) {

			texture.rotation = transform.rotation;

		}

		if ( transform.scale !== undefined ) {

			texture.repeat.fromArray( transform.scale );

		}

		if ( transform.texCoord !== undefined ) {

			console.warn( 'THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.' );

		}

		texture.needsUpdate = true;

		return texture;

	};

	/**
	 * Specular-Glossiness Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
	 */

	/**
	 * A sub class of StandardMaterial with some of the functionality
	 * changed via the `onBeforeCompile` callback
	 * @pailhead
	 */

	function GLTFMeshStandardSGMaterial( params ) {

		_build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["MeshStandardMaterial"].call( this );

		this.isGLTFSpecularGlossinessMaterial = true;

		//various chunks that need replacing
		var specularMapParsFragmentChunk = [
			'#ifdef USE_SPECULARMAP',
			'	uniform sampler2D specularMap;',
			'#endif'
		].join( '\n' );

		var glossinessMapParsFragmentChunk = [
			'#ifdef USE_GLOSSINESSMAP',
			'	uniform sampler2D glossinessMap;',
			'#endif'
		].join( '\n' );

		var specularMapFragmentChunk = [
			'vec3 specularFactor = specular;',
			'#ifdef USE_SPECULARMAP',
			'	vec4 texelSpecular = texture2D( specularMap, vUv );',
			'	texelSpecular = sRGBToLinear( texelSpecular );',
			'	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
			'	specularFactor *= texelSpecular.rgb;',
			'#endif'
		].join( '\n' );

		var glossinessMapFragmentChunk = [
			'float glossinessFactor = glossiness;',
			'#ifdef USE_GLOSSINESSMAP',
			'	vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
			'	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
			'	glossinessFactor *= texelGlossiness.a;',
			'#endif'
		].join( '\n' );

		var lightPhysicalFragmentChunk = [
			'PhysicalMaterial material;',
			'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
			'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
			'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
			'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
			'material.specularRoughness += geometryRoughness;',
			'material.specularRoughness = min( material.specularRoughness, 1.0 );',
			'material.specularColor = specularFactor;',
		].join( '\n' );

		var uniforms = {
			specular: { value: new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Color"]().setHex( 0xffffff ) },
			glossiness: { value: 1 },
			specularMap: { value: null },
			glossinessMap: { value: null }
		};

		this._extraUniforms = uniforms;

		this.onBeforeCompile = function ( shader ) {

			for ( var uniformName in uniforms ) {

				shader.uniforms[ uniformName ] = uniforms[ uniformName ];

			}

			shader.fragmentShader = shader.fragmentShader
				.replace( 'uniform float roughness;', 'uniform vec3 specular;' )
				.replace( 'uniform float metalness;', 'uniform float glossiness;' )
				.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )
				.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )
				.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )
				.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )
				.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );

		};

		Object.defineProperties( this, {

			specular: {
				get: function () {

					return uniforms.specular.value;

				},
				set: function ( v ) {

					uniforms.specular.value = v;

				}
			},

			specularMap: {
				get: function () {

					return uniforms.specularMap.value;

				},
				set: function ( v ) {

					uniforms.specularMap.value = v;

					if ( v ) {

						this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps

					} else {

						delete this.defines.USE_SPECULARMAP;

					}

				}
			},

			glossiness: {
				get: function () {

					return uniforms.glossiness.value;

				},
				set: function ( v ) {

					uniforms.glossiness.value = v;

				}
			},

			glossinessMap: {
				get: function () {

					return uniforms.glossinessMap.value;

				},
				set: function ( v ) {

					uniforms.glossinessMap.value = v;

					if ( v ) {

						this.defines.USE_GLOSSINESSMAP = '';
						this.defines.USE_UV = '';

					} else {

						delete this.defines.USE_GLOSSINESSMAP;
						delete this.defines.USE_UV;

					}

				}
			}

		} );

		delete this.metalness;
		delete this.roughness;
		delete this.metalnessMap;
		delete this.roughnessMap;

		this.setValues( params );

	}

	GLTFMeshStandardSGMaterial.prototype = Object.create( _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["MeshStandardMaterial"].prototype );
	GLTFMeshStandardSGMaterial.prototype.constructor = GLTFMeshStandardSGMaterial;

	GLTFMeshStandardSGMaterial.prototype.copy = function ( source ) {

		_build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["MeshStandardMaterial"].prototype.copy.call( this, source );
		this.specularMap = source.specularMap;
		this.specular.copy( source.specular );
		this.glossinessMap = source.glossinessMap;
		this.glossiness = source.glossiness;
		delete this.metalness;
		delete this.roughness;
		delete this.metalnessMap;
		delete this.roughnessMap;
		return this;

	};

	function GLTFMaterialsPbrSpecularGlossinessExtension() {

		return {

			name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,

			specularGlossinessParams: [
				'color',
				'map',
				'lightMap',
				'lightMapIntensity',
				'aoMap',
				'aoMapIntensity',
				'emissive',
				'emissiveIntensity',
				'emissiveMap',
				'bumpMap',
				'bumpScale',
				'normalMap',
				'normalMapType',
				'displacementMap',
				'displacementScale',
				'displacementBias',
				'specularMap',
				'specular',
				'glossinessMap',
				'glossiness',
				'alphaMap',
				'envMap',
				'envMapIntensity',
				'refractionRatio',
			],

			getMaterialType: function () {

				return GLTFMeshStandardSGMaterial;

			},

			extendParams: function ( materialParams, materialDef, parser ) {

				var pbrSpecularGlossiness = materialDef.extensions[ this.name ];

				materialParams.color = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Color"]( 1.0, 1.0, 1.0 );
				materialParams.opacity = 1.0;

				var pending = [];

				if ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {

					var array = pbrSpecularGlossiness.diffuseFactor;

					materialParams.color.fromArray( array );
					materialParams.opacity = array[ 3 ];

				}

				if ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {

					pending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );

				}

				materialParams.emissive = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Color"]( 0.0, 0.0, 0.0 );
				materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
				materialParams.specular = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Color"]( 1.0, 1.0, 1.0 );

				if ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {

					materialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );

				}

				if ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {

					var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
					pending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );
					pending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );

				}

				return Promise.all( pending );

			},

			createMaterial: function ( materialParams ) {

				var material = new GLTFMeshStandardSGMaterial( materialParams );
				material.fog = true;

				material.color = materialParams.color;

				material.map = materialParams.map === undefined ? null : materialParams.map;

				material.lightMap = null;
				material.lightMapIntensity = 1.0;

				material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
				material.aoMapIntensity = 1.0;

				material.emissive = materialParams.emissive;
				material.emissiveIntensity = 1.0;
				material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;

				material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
				material.bumpScale = 1;

				material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
				material.normalMapType = _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["TangentSpaceNormalMap"];

				if ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;

				material.displacementMap = null;
				material.displacementScale = 1;
				material.displacementBias = 0;

				material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
				material.specular = materialParams.specular;

				material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
				material.glossiness = materialParams.glossiness;

				material.alphaMap = null;

				material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
				material.envMapIntensity = 1.0;

				material.refractionRatio = 0.98;

				return material;

			},

		};

	}

	/**
	 * Mesh Quantization Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
	 */
	function GLTFMeshQuantizationExtension() {

		this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

	}

	/*********************************/
	/********** INTERPOLATION ********/
	/*********************************/

	// Spline Interpolation
	// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
	function GLTFCubicSplineInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		_build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Interpolant"].call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	GLTFCubicSplineInterpolant.prototype = Object.create( _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Interpolant"].prototype );
	GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;

	GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function ( index ) {

		// Copies a sample value to the result buffer. See description of glTF
		// CUBICSPLINE values layout in interpolate_() function below.

		var result = this.resultBuffer,
			values = this.sampleValues,
			valueSize = this.valueSize,
			offset = index * valueSize * 3 + valueSize;

		for ( var i = 0; i !== valueSize; i ++ ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	};

	GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

	GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

	GLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {

		var result = this.resultBuffer;
		var values = this.sampleValues;
		var stride = this.valueSize;

		var stride2 = stride * 2;
		var stride3 = stride * 3;

		var td = t1 - t0;

		var p = ( t - t0 ) / td;
		var pp = p * p;
		var ppp = pp * p;

		var offset1 = i1 * stride3;
		var offset0 = offset1 - stride3;

		var s2 = - 2 * ppp + 3 * pp;
		var s3 = ppp - pp;
		var s0 = 1 - s2;
		var s1 = s3 - pp + p;

		// Layout of keyframe output values for CUBICSPLINE animations:
		//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
		for ( var i = 0; i !== stride; i ++ ) {

			var p0 = values[ offset0 + i + stride ]; // splineVertex_k
			var m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
			var p1 = values[ offset1 + i + stride ]; // splineVertex_k+1
			var m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

			result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

		}

		return result;

	};

	/*********************************/
	/********** INTERNALS ************/
	/*********************************/

	/* CONSTANTS */

	var WEBGL_CONSTANTS = {
		FLOAT: 5126,
		//FLOAT_MAT2: 35674,
		FLOAT_MAT3: 35675,
		FLOAT_MAT4: 35676,
		FLOAT_VEC2: 35664,
		FLOAT_VEC3: 35665,
		FLOAT_VEC4: 35666,
		LINEAR: 9729,
		REPEAT: 10497,
		SAMPLER_2D: 35678,
		POINTS: 0,
		LINES: 1,
		LINE_LOOP: 2,
		LINE_STRIP: 3,
		TRIANGLES: 4,
		TRIANGLE_STRIP: 5,
		TRIANGLE_FAN: 6,
		UNSIGNED_BYTE: 5121,
		UNSIGNED_SHORT: 5123
	};

	var WEBGL_COMPONENT_TYPES = {
		5120: Int8Array,
		5121: Uint8Array,
		5122: Int16Array,
		5123: Uint16Array,
		5125: Uint32Array,
		5126: Float32Array
	};

	var WEBGL_FILTERS = {
		9728: _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"],
		9729: _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"],
		9984: _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["NearestMipmapNearestFilter"],
		9985: _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["LinearMipmapNearestFilter"],
		9986: _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["NearestMipmapLinearFilter"],
		9987: _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["LinearMipmapLinearFilter"]
	};

	var WEBGL_WRAPPINGS = {
		33071: _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["ClampToEdgeWrapping"],
		33648: _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["MirroredRepeatWrapping"],
		10497: _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["RepeatWrapping"]
	};

	var WEBGL_TYPE_SIZES = {
		'SCALAR': 1,
		'VEC2': 2,
		'VEC3': 3,
		'VEC4': 4,
		'MAT2': 4,
		'MAT3': 9,
		'MAT4': 16
	};

	var ATTRIBUTES = {
		POSITION: 'position',
		NORMAL: 'normal',
		TANGENT: 'tangent',
		TEXCOORD_0: 'uv',
		TEXCOORD_1: 'uv2',
		COLOR_0: 'color',
		WEIGHTS_0: 'skinWeight',
		JOINTS_0: 'skinIndex',
	};

	var PATH_PROPERTIES = {
		scale: 'scale',
		translation: 'position',
		rotation: 'quaternion',
		weights: 'morphTargetInfluences'
	};

	var INTERPOLATION = {
		CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
		                        // keyframe track will be initialized with a default interpolation type, then modified.
		LINEAR: _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateLinear"],
		STEP: _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateDiscrete"]
	};

	var ALPHA_MODES = {
		OPAQUE: 'OPAQUE',
		MASK: 'MASK',
		BLEND: 'BLEND'
	};

	/* UTILITY FUNCTIONS */

	function resolveURL( url, path ) {

		// Invalid URL
		if ( typeof url !== 'string' || url === '' ) return '';

		// Host Relative URL
		if ( /^https?:\/\//i.test( path ) && /^\//.test( url ) ) {

			path = path.replace( /(^https?:\/\/[^\/]+).*/i, '$1' );

		}

		// Absolute URL http://,https://,//
		if ( /^(https?:)?\/\//i.test( url ) ) return url;

		// Data URI
		if ( /^data:.*,.*$/i.test( url ) ) return url;

		// Blob URL
		if ( /^blob:.*$/i.test( url ) ) return url;

		// Relative URL
		return path + url;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
	 */
	function createDefaultMaterial( cache ) {

		if ( cache[ 'DefaultMaterial' ] === undefined ) {

			cache[ 'DefaultMaterial' ] = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["MeshStandardMaterial"]( {
				color: 0xFFFFFF,
				emissive: 0x000000,
				metalness: 1,
				roughness: 1,
				transparent: false,
				depthTest: true,
				side: _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["FrontSide"]
			} );

		}

		return cache[ 'DefaultMaterial' ];

	}

	function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

		// Add unknown glTF extensions to an object's userData.

		for ( var name in objectDef.extensions ) {

			if ( knownExtensions[ name ] === undefined ) {

				object.userData.gltfExtensions = object.userData.gltfExtensions || {};
				object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

			}

		}

	}

	/**
	 * @param {Object3D|Material|BufferGeometry} object
	 * @param {GLTF.definition} gltfDef
	 */
	function assignExtrasToUserData( object, gltfDef ) {

		if ( gltfDef.extras !== undefined ) {

			if ( typeof gltfDef.extras === 'object' ) {

				Object.assign( object.userData, gltfDef.extras );

			} else {

				console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

			}

		}

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
	 *
	 * @param {BufferGeometry} geometry
	 * @param {Array<GLTF.Target>} targets
	 * @param {GLTFParser} parser
	 * @return {Promise<BufferGeometry>}
	 */
	function addMorphTargets( geometry, targets, parser ) {

		var hasMorphPosition = false;
		var hasMorphNormal = false;

		for ( var i = 0, il = targets.length; i < il; i ++ ) {

			var target = targets[ i ];

			if ( target.POSITION !== undefined ) hasMorphPosition = true;
			if ( target.NORMAL !== undefined ) hasMorphNormal = true;

			if ( hasMorphPosition && hasMorphNormal ) break;

		}

		if ( ! hasMorphPosition && ! hasMorphNormal ) return Promise.resolve( geometry );

		var pendingPositionAccessors = [];
		var pendingNormalAccessors = [];

		for ( var i = 0, il = targets.length; i < il; i ++ ) {

			var target = targets[ i ];

			if ( hasMorphPosition ) {

				var pendingAccessor = target.POSITION !== undefined
					? parser.getDependency( 'accessor', target.POSITION )
					: geometry.attributes.position;

				pendingPositionAccessors.push( pendingAccessor );

			}

			if ( hasMorphNormal ) {

				var pendingAccessor = target.NORMAL !== undefined
					? parser.getDependency( 'accessor', target.NORMAL )
					: geometry.attributes.normal;

				pendingNormalAccessors.push( pendingAccessor );

			}

		}

		return Promise.all( [
			Promise.all( pendingPositionAccessors ),
			Promise.all( pendingNormalAccessors )
		] ).then( function ( accessors ) {

			var morphPositions = accessors[ 0 ];
			var morphNormals = accessors[ 1 ];

			if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
			if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
			geometry.morphTargetsRelative = true;

			return geometry;

		} );

	}

	/**
	 * @param {Mesh} mesh
	 * @param {GLTF.Mesh} meshDef
	 */
	function updateMorphTargets( mesh, meshDef ) {

		mesh.updateMorphTargets();

		if ( meshDef.weights !== undefined ) {

			for ( var i = 0, il = meshDef.weights.length; i < il; i ++ ) {

				mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

			}

		}

		// .extras has user-defined data, so check that .extras.targetNames is an array.
		if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

			var targetNames = meshDef.extras.targetNames;

			if ( mesh.morphTargetInfluences.length === targetNames.length ) {

				mesh.morphTargetDictionary = {};

				for ( var i = 0, il = targetNames.length; i < il; i ++ ) {

					mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

				}

			} else {

				console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

			}

		}

	}

	function createPrimitiveKey( primitiveDef ) {

		var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];
		var geometryKey;

		if ( dracoExtension ) {

			geometryKey = 'draco:' + dracoExtension.bufferView
				+ ':' + dracoExtension.indices
				+ ':' + createAttributesKey( dracoExtension.attributes );

		} else {

			geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

		}

		return geometryKey;

	}

	function createAttributesKey( attributes ) {

		var attributesKey = '';

		var keys = Object.keys( attributes ).sort();

		for ( var i = 0, il = keys.length; i < il; i ++ ) {

			attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

		}

		return attributesKey;

	}

	/* GLTF PARSER */

	function GLTFParser( json, options ) {

		this.json = json || {};
		this.extensions = {};
		this.plugins = {};
		this.options = options || {};

		// loader object cache
		this.cache = new GLTFRegistry();

		// associations between Three.js objects and glTF elements
		this.associations = new Map();

		// BufferGeometry caching
		this.primitiveCache = {};

		// Object3D instance caches
		this.meshCache = { refs: {}, uses: {} };
		this.cameraCache = { refs: {}, uses: {} };
		this.lightCache = { refs: {}, uses: {} };

		// Track node names, to ensure no duplicates
		this.nodeNamesUsed = {};

		// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
		// expensive work of uploading a texture to the GPU off the main thread.
		if ( typeof createImageBitmap !== 'undefined' && /Firefox/.test( navigator.userAgent ) === false ) {

			this.textureLoader = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["ImageBitmapLoader"]( this.options.manager );

		} else {

			this.textureLoader = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["TextureLoader"]( this.options.manager );

		}

		this.textureLoader.setCrossOrigin( this.options.crossOrigin );
		this.textureLoader.setRequestHeader( this.options.requestHeader );

		this.fileLoader = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["FileLoader"]( this.options.manager );
		this.fileLoader.setResponseType( 'arraybuffer' );

		if ( this.options.crossOrigin === 'use-credentials' ) {

			this.fileLoader.setWithCredentials( true );

		}

	}

	GLTFParser.prototype.setExtensions = function ( extensions ) {

		this.extensions = extensions;

	};

	GLTFParser.prototype.setPlugins = function ( plugins ) {

		this.plugins = plugins;

	};

	GLTFParser.prototype.parse = function ( onLoad, onError ) {

		var parser = this;
		var json = this.json;
		var extensions = this.extensions;

		// Clear the loader cache
		this.cache.removeAll();

		// Mark the special nodes/meshes in json for efficient parse
		this._invokeAll( function ( ext ) {

			return ext._markDefs && ext._markDefs();

		} );

		Promise.all( this._invokeAll( function ( ext ) {

			return ext.beforeRoot && ext.beforeRoot();

		} ) ).then( function () {

			return Promise.all( [

				parser.getDependencies( 'scene' ),
				parser.getDependencies( 'animation' ),
				parser.getDependencies( 'camera' ),

			] );

		} ).then( function ( dependencies ) {

			var result = {
				scene: dependencies[ 0 ][ json.scene || 0 ],
				scenes: dependencies[ 0 ],
				animations: dependencies[ 1 ],
				cameras: dependencies[ 2 ],
				asset: json.asset,
				parser: parser,
				userData: {}
			};

			addUnknownExtensionsToUserData( extensions, result, json );

			assignExtrasToUserData( result, json );

			Promise.all( parser._invokeAll( function ( ext ) {

				return ext.afterRoot && ext.afterRoot( result );

			} ) ).then( function () {

				onLoad( result );

			} );

		} ).catch( onError );

	};

	/**
	 * Marks the special nodes/meshes in json for efficient parse.
	 */
	GLTFParser.prototype._markDefs = function () {

		var nodeDefs = this.json.nodes || [];
		var skinDefs = this.json.skins || [];
		var meshDefs = this.json.meshes || [];

		// Nothing in the node definition indicates whether it is a Bone or an
		// Object3D. Use the skins' joint references to mark bones.
		for ( var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

			var joints = skinDefs[ skinIndex ].joints;

			for ( var i = 0, il = joints.length; i < il; i ++ ) {

				nodeDefs[ joints[ i ] ].isBone = true;

			}

		}

		// Iterate over all nodes, marking references to shared resources,
		// as well as skeleton joints.
		for ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			var nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.mesh !== undefined ) {

				this._addNodeRef( this.meshCache, nodeDef.mesh );

				// Nothing in the mesh definition indicates whether it is
				// a SkinnedMesh or Mesh. Use the node's mesh reference
				// to mark SkinnedMesh if node has skin.
				if ( nodeDef.skin !== undefined ) {

					meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

				}

			}

			if ( nodeDef.camera !== undefined ) {

				this._addNodeRef( this.cameraCache, nodeDef.camera );

			}

		}

	};

	/**
	 * Counts references to shared node / Object3D resources. These resources
	 * can be reused, or "instantiated", at multiple nodes in the scene
	 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
	 * be marked. Non-scenegraph resources (like Materials, Geometries, and
	 * Textures) can be reused directly and are not marked here.
	 *
	 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
	 */
	GLTFParser.prototype._addNodeRef = function ( cache, index ) {

		if ( index === undefined ) return;

		if ( cache.refs[ index ] === undefined ) {

			cache.refs[ index ] = cache.uses[ index ] = 0;

		}

		cache.refs[ index ] ++;

	};

	/** Returns a reference to a shared resource, cloning it if necessary. */
	GLTFParser.prototype._getNodeRef = function ( cache, index, object ) {

		if ( cache.refs[ index ] <= 1 ) return object;

		var ref = object.clone();

		ref.name += '_instance_' + ( cache.uses[ index ] ++ );

		return ref;

	};

	GLTFParser.prototype._invokeOne = function ( func ) {

		var extensions = Object.values( this.plugins );
		extensions.push( this );

		for ( var i = 0; i < extensions.length; i ++ ) {

			var result = func( extensions[ i ] );

			if ( result ) return result;

		}

	};

	GLTFParser.prototype._invokeAll = function ( func ) {

		var extensions = Object.values( this.plugins );
		extensions.unshift( this );

		var pending = [];

		for ( var i = 0; i < extensions.length; i ++ ) {

			var result = func( extensions[ i ] );

			if ( result ) pending.push( result );

		}

		return pending;

	};

	/**
	 * Requests the specified dependency asynchronously, with caching.
	 * @param {string} type
	 * @param {number} index
	 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
	 */
	GLTFParser.prototype.getDependency = function ( type, index ) {

		var cacheKey = type + ':' + index;
		var dependency = this.cache.get( cacheKey );

		if ( ! dependency ) {

			switch ( type ) {

				case 'scene':
					dependency = this.loadScene( index );
					break;

				case 'node':
					dependency = this.loadNode( index );
					break;

				case 'mesh':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMesh && ext.loadMesh( index );

					} );
					break;

				case 'accessor':
					dependency = this.loadAccessor( index );
					break;

				case 'bufferView':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadBufferView && ext.loadBufferView( index );

					} );
					break;

				case 'buffer':
					dependency = this.loadBuffer( index );
					break;

				case 'material':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMaterial && ext.loadMaterial( index );

					} );
					break;

				case 'texture':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadTexture && ext.loadTexture( index );

					} );
					break;

				case 'skin':
					dependency = this.loadSkin( index );
					break;

				case 'animation':
					dependency = this.loadAnimation( index );
					break;

				case 'camera':
					dependency = this.loadCamera( index );
					break;

				default:
					throw new Error( 'Unknown type: ' + type );

			}

			this.cache.add( cacheKey, dependency );

		}

		return dependency;

	};

	/**
	 * Requests all dependencies of the specified type asynchronously, with caching.
	 * @param {string} type
	 * @return {Promise<Array<Object>>}
	 */
	GLTFParser.prototype.getDependencies = function ( type ) {

		var dependencies = this.cache.get( type );

		if ( ! dependencies ) {

			var parser = this;
			var defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];

			dependencies = Promise.all( defs.map( function ( def, index ) {

				return parser.getDependency( type, index );

			} ) );

			this.cache.add( type, dependencies );

		}

		return dependencies;

	};

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	GLTFParser.prototype.loadBuffer = function ( bufferIndex ) {

		var bufferDef = this.json.buffers[ bufferIndex ];
		var loader = this.fileLoader;

		if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

			throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

		}

		// If present, GLB container is required to be the first buffer.
		if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

			return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

		}

		var options = this.options;

		return new Promise( function ( resolve, reject ) {

			loader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

				reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

			} );

		} );

	};

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferViewIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	GLTFParser.prototype.loadBufferView = function ( bufferViewIndex ) {

		var bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

		return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

			var byteLength = bufferViewDef.byteLength || 0;
			var byteOffset = bufferViewDef.byteOffset || 0;
			return buffer.slice( byteOffset, byteOffset + byteLength );

		} );

	};

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
	 * @param {number} accessorIndex
	 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
	 */
	GLTFParser.prototype.loadAccessor = function ( accessorIndex ) {

		var parser = this;
		var json = this.json;

		var accessorDef = this.json.accessors[ accessorIndex ];

		if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

			// Ignore empty accessors, which may be used to declare runtime
			// information about attributes coming from another source (e.g. Draco
			// compression extension).
			return Promise.resolve( null );

		}

		var pendingBufferViews = [];

		if ( accessorDef.bufferView !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

		} else {

			pendingBufferViews.push( null );

		}

		if ( accessorDef.sparse !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

		}

		return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

			var bufferView = bufferViews[ 0 ];

			var itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
			var TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

			// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
			var elementBytes = TypedArray.BYTES_PER_ELEMENT;
			var itemBytes = elementBytes * itemSize;
			var byteOffset = accessorDef.byteOffset || 0;
			var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
			var normalized = accessorDef.normalized === true;
			var array, bufferAttribute;

			// The buffer is not interleaved if the stride is the item size in bytes.
			if ( byteStride && byteStride !== itemBytes ) {

				// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
				// This makes sure that IBA.count reflects accessor.count properly
				var ibSlice = Math.floor( byteOffset / byteStride );
				var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
				var ib = parser.cache.get( ibCacheKey );

				if ( ! ib ) {

					array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );

					// Integer parameters to IB/IBA are in array elements, not bytes.
					ib = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["InterleavedBuffer"]( array, byteStride / elementBytes );

					parser.cache.add( ibCacheKey, ib );

				}

				bufferAttribute = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["InterleavedBufferAttribute"]( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );

			} else {

				if ( bufferView === null ) {

					array = new TypedArray( accessorDef.count * itemSize );

				} else {

					array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

				}

				bufferAttribute = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["BufferAttribute"]( array, itemSize, normalized );

			}

			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
			if ( accessorDef.sparse !== undefined ) {

				var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
				var TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];

				var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
				var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

				var sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
				var sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

				if ( bufferView !== null ) {

					// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
					bufferAttribute = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["BufferAttribute"]( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

				}

				for ( var i = 0, il = sparseIndices.length; i < il; i ++ ) {

					var index = sparseIndices[ i ];

					bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
					if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );
					if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );
					if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );
					if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );

				}

			}

			return bufferAttribute;

		} );

	};

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
	 * @param {number} textureIndex
	 * @return {Promise<THREE.Texture>}
	 */
	GLTFParser.prototype.loadTexture = function ( textureIndex ) {

		var json = this.json;
		var options = this.options;
		var textureDef = json.textures[ textureIndex ];
		var source = json.images[ textureDef.source ];

		var loader = this.textureLoader;

		if ( source.uri ) {

			var handler = options.manager.getHandler( source.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.loadTextureImage( textureIndex, source, loader );

	};

	GLTFParser.prototype.loadTextureImage = function ( textureIndex, source, loader ) {

		var parser = this;
		var json = this.json;
		var options = this.options;

		var textureDef = json.textures[ textureIndex ];

		var URL = self.URL || self.webkitURL;

		var sourceURI = source.uri;
		var isObjectURL = false;
		var hasAlpha = true;

		if ( source.mimeType === 'image/jpeg' ) hasAlpha = false;

		if ( source.bufferView !== undefined ) {

			// Load binary image data from bufferView, if provided.

			sourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {

				if ( source.mimeType === 'image/png' ) {

					// Inspect the PNG 'IHDR' chunk to determine whether the image could have an
					// alpha channel. This check is conservative — the image could have an alpha
					// channel with all values == 1, and the indexed type (colorType == 3) only
					// sometimes contains alpha.
					//
					// https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header
					var colorType = new DataView( bufferView, 25, 1 ).getUint8( 0, false );
					hasAlpha = colorType === 6 || colorType === 4 || colorType === 3;

				}

				isObjectURL = true;
				var blob = new Blob( [ bufferView ], { type: source.mimeType } );
				sourceURI = URL.createObjectURL( blob );
				return sourceURI;

			} );

		} else if ( source.uri === undefined ) {

			throw new Error( 'THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView' );

		}

		return Promise.resolve( sourceURI ).then( function ( sourceURI ) {

			return new Promise( function ( resolve, reject ) {

				var onLoad = resolve;

				if ( loader.isImageBitmapLoader === true ) {

					onLoad = function ( imageBitmap ) {

						resolve( new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["CanvasTexture"]( imageBitmap ) );

					};

				}

				loader.load( resolveURL( sourceURI, options.path ), onLoad, undefined, reject );

			} );

		} ).then( function ( texture ) {

			// Clean up resources and configure Texture.

			if ( isObjectURL === true ) {

				URL.revokeObjectURL( sourceURI );

			}

			texture.flipY = false;

			if ( textureDef.name ) texture.name = textureDef.name;

			// When there is definitely no alpha channel in the texture, set RGBFormat to save space.
			if ( ! hasAlpha ) texture.format = _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["RGBFormat"];

			var samplers = json.samplers || {};
			var sampler = samplers[ textureDef.sampler ] || {};

			texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"];
			texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["LinearMipmapLinearFilter"];
			texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["RepeatWrapping"];
			texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["RepeatWrapping"];

			parser.associations.set( texture, {
				type: 'textures',
				index: textureIndex
			} );

			return texture;

		} );

	};

	/**
	 * Asynchronously assigns a texture to the given material parameters.
	 * @param {Object} materialParams
	 * @param {string} mapName
	 * @param {Object} mapDef
	 * @return {Promise}
	 */
	GLTFParser.prototype.assignTexture = function ( materialParams, mapName, mapDef ) {

		var parser = this;

		return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

			// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
			// However, we will copy UV set 0 to UV set 1 on demand for aoMap
			if ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {

				console.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );

			}

			if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

				var transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

				if ( transform ) {

					var gltfReference = parser.associations.get( texture );
					texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
					parser.associations.set( texture, gltfReference );

				}

			}

			materialParams[ mapName ] = texture;

		} );

	};

	/**
	 * Assigns final material to a Mesh, Line, or Points instance. The instance
	 * already has a material (generated from the glTF material options alone)
	 * but reuse of the same glTF material may require multiple threejs materials
	 * to accommodate different primitive types, defines, etc. New materials will
	 * be created if necessary, and reused from a cache.
	 * @param  {Object3D} mesh Mesh, Line, or Points instance.
	 */
	GLTFParser.prototype.assignFinalMaterial = function ( mesh ) {

		var geometry = mesh.geometry;
		var material = mesh.material;

		var useVertexTangents = geometry.attributes.tangent !== undefined;
		var useVertexColors = geometry.attributes.color !== undefined;
		var useFlatShading = geometry.attributes.normal === undefined;
		var useSkinning = mesh.isSkinnedMesh === true;
		var useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0;
		var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;

		if ( mesh.isPoints ) {

			var cacheKey = 'PointsMaterial:' + material.uuid;

			var pointsMaterial = this.cache.get( cacheKey );

			if ( ! pointsMaterial ) {

				pointsMaterial = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["PointsMaterial"]();
				_build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Material"].prototype.copy.call( pointsMaterial, material );
				pointsMaterial.color.copy( material.color );
				pointsMaterial.map = material.map;
				pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

				this.cache.add( cacheKey, pointsMaterial );

			}

			material = pointsMaterial;

		} else if ( mesh.isLine ) {

			var cacheKey = 'LineBasicMaterial:' + material.uuid;

			var lineMaterial = this.cache.get( cacheKey );

			if ( ! lineMaterial ) {

				lineMaterial = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["LineBasicMaterial"]();
				_build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Material"].prototype.copy.call( lineMaterial, material );
				lineMaterial.color.copy( material.color );

				this.cache.add( cacheKey, lineMaterial );

			}

			material = lineMaterial;

		}

		// Clone the material if it will be modified
		if ( useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets ) {

			var cacheKey = 'ClonedMaterial:' + material.uuid + ':';

			if ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';
			if ( useSkinning ) cacheKey += 'skinning:';
			if ( useVertexTangents ) cacheKey += 'vertex-tangents:';
			if ( useVertexColors ) cacheKey += 'vertex-colors:';
			if ( useFlatShading ) cacheKey += 'flat-shading:';
			if ( useMorphTargets ) cacheKey += 'morph-targets:';
			if ( useMorphNormals ) cacheKey += 'morph-normals:';

			var cachedMaterial = this.cache.get( cacheKey );

			if ( ! cachedMaterial ) {

				cachedMaterial = material.clone();

				if ( useSkinning ) cachedMaterial.skinning = true;
				if ( useVertexColors ) cachedMaterial.vertexColors = true;
				if ( useFlatShading ) cachedMaterial.flatShading = true;
				if ( useMorphTargets ) cachedMaterial.morphTargets = true;
				if ( useMorphNormals ) cachedMaterial.morphNormals = true;

				if ( useVertexTangents ) {

					cachedMaterial.vertexTangents = true;

					// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
					if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;
					if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;

				}

				this.cache.add( cacheKey, cachedMaterial );

				this.associations.set( cachedMaterial, this.associations.get( material ) );

			}

			material = cachedMaterial;

		}

		// workarounds for mesh and geometry

		if ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {

			geometry.setAttribute( 'uv2', geometry.attributes.uv );

		}

		mesh.material = material;

	};

	GLTFParser.prototype.getMaterialType = function ( /* materialIndex */ ) {

		return _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["MeshStandardMaterial"];

	};

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
	 * @param {number} materialIndex
	 * @return {Promise<Material>}
	 */
	GLTFParser.prototype.loadMaterial = function ( materialIndex ) {

		var parser = this;
		var json = this.json;
		var extensions = this.extensions;
		var materialDef = json.materials[ materialIndex ];

		var materialType;
		var materialParams = {};
		var materialExtensions = materialDef.extensions || {};

		var pending = [];

		if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {

			var sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];
			materialType = sgExtension.getMaterialType();
			pending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );

		} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

			var kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
			materialType = kmuExtension.getMaterialType();
			pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

		} else {

			// Specification:
			// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

			var metallicRoughness = materialDef.pbrMetallicRoughness || {};

			materialParams.color = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Color"]( 1.0, 1.0, 1.0 );
			materialParams.opacity = 1.0;

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				var array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

			}

			materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
			materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

			if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
				pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

			}

			materialType = this._invokeOne( function ( ext ) {

				return ext.getMaterialType && ext.getMaterialType( materialIndex );

			} );

			pending.push( Promise.all( this._invokeAll( function ( ext ) {

				return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );

			} ) ) );

		}

		if ( materialDef.doubleSided === true ) {

			materialParams.side = _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"];

		}

		var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

		if ( alphaMode === ALPHA_MODES.BLEND ) {

			materialParams.transparent = true;

			// See: https://github.com/mrdoob/three.js/issues/17706
			materialParams.depthWrite = false;

		} else {

			materialParams.transparent = false;

			if ( alphaMode === ALPHA_MODES.MASK ) {

				materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

			}

		}

		if ( materialDef.normalTexture !== undefined && materialType !== _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["MeshBasicMaterial"] ) {

			pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );

			// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
			materialParams.normalScale = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]( 1, - 1 );

			if ( materialDef.normalTexture.scale !== undefined ) {

				materialParams.normalScale.set( materialDef.normalTexture.scale, - materialDef.normalTexture.scale );

			}

		}

		if ( materialDef.occlusionTexture !== undefined && materialType !== _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["MeshBasicMaterial"] ) {

			pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

			if ( materialDef.occlusionTexture.strength !== undefined ) {

				materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

			}

		}

		if ( materialDef.emissiveFactor !== undefined && materialType !== _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["MeshBasicMaterial"] ) {

			materialParams.emissive = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Color"]().fromArray( materialDef.emissiveFactor );

		}

		if ( materialDef.emissiveTexture !== undefined && materialType !== _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["MeshBasicMaterial"] ) {

			pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );

		}

		return Promise.all( pending ).then( function () {

			var material;

			if ( materialType === GLTFMeshStandardSGMaterial ) {

				material = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );

			} else {

				material = new materialType( materialParams );

			}

			if ( materialDef.name ) material.name = materialDef.name;

			// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.
			if ( material.map ) material.map.encoding = _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["sRGBEncoding"];
			if ( material.emissiveMap ) material.emissiveMap.encoding = _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["sRGBEncoding"];

			assignExtrasToUserData( material, materialDef );

			parser.associations.set( material, { type: 'materials', index: materialIndex } );

			if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );

			return material;

		} );

	};

	/** When Object3D instances are targeted by animation, they need unique names. */
	GLTFParser.prototype.createUniqueName = function ( originalName ) {

		var sanitizedName = _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["PropertyBinding"].sanitizeNodeName( originalName || '' );

		var name = sanitizedName;

		for ( var i = 1; this.nodeNamesUsed[ name ]; ++ i ) {

			name = sanitizedName + '_' + i;

		}

		this.nodeNamesUsed[ name ] = true;

		return name;

	};

	/**
	 * @param {BufferGeometry} geometry
	 * @param {GLTF.Primitive} primitiveDef
	 * @param {GLTFParser} parser
	 */
	function computeBounds( geometry, primitiveDef, parser ) {

		var attributes = primitiveDef.attributes;

		var box = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Box3"]();

		if ( attributes.POSITION !== undefined ) {

			var accessor = parser.json.accessors[ attributes.POSITION ];

			var min = accessor.min;
			var max = accessor.max;

			// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

			if ( min !== undefined && max !== undefined ) {

				box.set(
					new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]( min[ 0 ], min[ 1 ], min[ 2 ] ),
					new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]( max[ 0 ], max[ 1 ], max[ 2 ] ) );

			} else {

				console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

				return;

			}

		} else {

			return;

		}

		var targets = primitiveDef.targets;

		if ( targets !== undefined ) {

			var maxDisplacement = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
			var vector = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

			for ( var i = 0, il = targets.length; i < il; i ++ ) {

				var target = targets[ i ];

				if ( target.POSITION !== undefined ) {

					var accessor = parser.json.accessors[ target.POSITION ];
					var min = accessor.min;
					var max = accessor.max;

					// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

					if ( min !== undefined && max !== undefined ) {

						// we need to get max of absolute components because target weight is [-1,1]
						vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
						vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
						vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );

						// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
						// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
						// are used to implement key-frame animations and as such only two are active at a time - this results in very large
						// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
						maxDisplacement.max( vector );

					} else {

						console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

					}

				}

			}

			// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
			box.expandByVector( maxDisplacement );

		}

		geometry.boundingBox = box;

		var sphere = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Sphere"]();

		box.getCenter( sphere.center );
		sphere.radius = box.min.distanceTo( box.max ) / 2;

		geometry.boundingSphere = sphere;

	}

	/**
	 * @param {BufferGeometry} geometry
	 * @param {GLTF.Primitive} primitiveDef
	 * @param {GLTFParser} parser
	 * @return {Promise<BufferGeometry>}
	 */
	function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

		var attributes = primitiveDef.attributes;

		var pending = [];

		function assignAttributeAccessor( accessorIndex, attributeName ) {

			return parser.getDependency( 'accessor', accessorIndex )
				.then( function ( accessor ) {

					geometry.setAttribute( attributeName, accessor );

				} );

		}

		for ( var gltfAttributeName in attributes ) {

			var threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();

			// Skip attributes already provided by e.g. Draco extension.
			if ( threeAttributeName in geometry.attributes ) continue;

			pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

		}

		if ( primitiveDef.indices !== undefined && ! geometry.index ) {

			var accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

				geometry.setIndex( accessor );

			} );

			pending.push( accessor );

		}

		assignExtrasToUserData( geometry, primitiveDef );

		computeBounds( geometry, primitiveDef, parser );

		return Promise.all( pending ).then( function () {

			return primitiveDef.targets !== undefined
				? addMorphTargets( geometry, primitiveDef.targets, parser )
				: geometry;

		} );

	}

	/**
	 * @param {BufferGeometry} geometry
	 * @param {Number} drawMode
	 * @return {BufferGeometry}
	 */
	function toTrianglesDrawMode( geometry, drawMode ) {

		var index = geometry.getIndex();

		// generate index if not present

		if ( index === null ) {

			var indices = [];

			var position = geometry.getAttribute( 'position' );

			if ( position !== undefined ) {

				for ( var i = 0; i < position.count; i ++ ) {

					indices.push( i );

				}

				geometry.setIndex( indices );
				index = geometry.getIndex();

			} else {

				console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
				return geometry;

			}

		}

		//

		var numberOfTriangles = index.count - 2;
		var newIndices = [];

		if ( drawMode === _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["TriangleFanDrawMode"] ) {

			// gl.TRIANGLE_FAN

			for ( var i = 1; i <= numberOfTriangles; i ++ ) {

				newIndices.push( index.getX( 0 ) );
				newIndices.push( index.getX( i ) );
				newIndices.push( index.getX( i + 1 ) );

			}

		} else {

			// gl.TRIANGLE_STRIP

			for ( var i = 0; i < numberOfTriangles; i ++ ) {

				if ( i % 2 === 0 ) {

					newIndices.push( index.getX( i ) );
					newIndices.push( index.getX( i + 1 ) );
					newIndices.push( index.getX( i + 2 ) );


				} else {

					newIndices.push( index.getX( i + 2 ) );
					newIndices.push( index.getX( i + 1 ) );
					newIndices.push( index.getX( i ) );

				}

			}

		}

		if ( ( newIndices.length / 3 ) !== numberOfTriangles ) {

			console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

		}

		// build final geometry

		var newGeometry = geometry.clone();
		newGeometry.setIndex( newIndices );

		return newGeometry;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
	 *
	 * Creates BufferGeometries from primitives.
	 *
	 * @param {Array<GLTF.Primitive>} primitives
	 * @return {Promise<Array<BufferGeometry>>}
	 */
	GLTFParser.prototype.loadGeometries = function ( primitives ) {

		var parser = this;
		var extensions = this.extensions;
		var cache = this.primitiveCache;

		function createDracoPrimitive( primitive ) {

			return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]
				.decodePrimitive( primitive, parser )
				.then( function ( geometry ) {

					return addPrimitiveAttributes( geometry, primitive, parser );

				} );

		}

		var pending = [];

		for ( var i = 0, il = primitives.length; i < il; i ++ ) {

			var primitive = primitives[ i ];
			var cacheKey = createPrimitiveKey( primitive );

			// See if we've already created this geometry
			var cached = cache[ cacheKey ];

			if ( cached ) {

				// Use the cached geometry if it exists
				pending.push( cached.promise );

			} else {

				var geometryPromise;

				if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

					// Use DRACO geometry if available
					geometryPromise = createDracoPrimitive( primitive );

				} else {

					// Otherwise create a new geometry
					geometryPromise = addPrimitiveAttributes( new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"](), primitive, parser );

				}

				// Cache this geometry
				cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };

				pending.push( geometryPromise );

			}

		}

		return Promise.all( pending );

	};

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
	 * @param {number} meshIndex
	 * @return {Promise<Group|Mesh|SkinnedMesh>}
	 */
	GLTFParser.prototype.loadMesh = function ( meshIndex ) {

		var parser = this;
		var json = this.json;
		var extensions = this.extensions;

		var meshDef = json.meshes[ meshIndex ];
		var primitives = meshDef.primitives;

		var pending = [];

		for ( var i = 0, il = primitives.length; i < il; i ++ ) {

			var material = primitives[ i ].material === undefined
				? createDefaultMaterial( this.cache )
				: this.getDependency( 'material', primitives[ i ].material );

			pending.push( material );

		}

		pending.push( parser.loadGeometries( primitives ) );

		return Promise.all( pending ).then( function ( results ) {

			var materials = results.slice( 0, results.length - 1 );
			var geometries = results[ results.length - 1 ];

			var meshes = [];

			for ( var i = 0, il = geometries.length; i < il; i ++ ) {

				var geometry = geometries[ i ];
				var primitive = primitives[ i ];

				// 1. create Mesh

				var mesh;

				var material = materials[ i ];

				if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||
					primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
					primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
					primitive.mode === undefined ) {

					// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
					mesh = meshDef.isSkinnedMesh === true
						? new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["SkinnedMesh"]( geometry, material )
						: new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Mesh"]( geometry, material );

					if ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {

						// we normalize floating point skin weight array to fix malformed assets (see #15319)
						// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
						mesh.normalizeSkinWeights();

					}

					if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["TriangleStripDrawMode"] );

					} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["TriangleFanDrawMode"] );

					}

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

					mesh = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["LineSegments"]( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {

					mesh = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Line"]( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {

					mesh = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["LineLoop"]( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {

					mesh = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Points"]( geometry, material );

				} else {

					throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

				}

				if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

					updateMorphTargets( mesh, meshDef );

				}

				mesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );

				assignExtrasToUserData( mesh, meshDef );

				if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );

				parser.assignFinalMaterial( mesh );

				meshes.push( mesh );

			}

			if ( meshes.length === 1 ) {

				return meshes[ 0 ];

			}

			var group = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Group"]();

			for ( var i = 0, il = meshes.length; i < il; i ++ ) {

				group.add( meshes[ i ] );

			}

			return group;

		} );

	};

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
	 * @param {number} cameraIndex
	 * @return {Promise<THREE.Camera>}
	 */
	GLTFParser.prototype.loadCamera = function ( cameraIndex ) {

		var camera;
		var cameraDef = this.json.cameras[ cameraIndex ];
		var params = cameraDef[ cameraDef.type ];

		if ( ! params ) {

			console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
			return;

		}

		if ( cameraDef.type === 'perspective' ) {

			camera = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["PerspectiveCamera"]( _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

		} else if ( cameraDef.type === 'orthographic' ) {

			camera = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["OrthographicCamera"]( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );

		}

		if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );

		assignExtrasToUserData( camera, cameraDef );

		return Promise.resolve( camera );

	};

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
	 * @param {number} skinIndex
	 * @return {Promise<Object>}
	 */
	GLTFParser.prototype.loadSkin = function ( skinIndex ) {

		var skinDef = this.json.skins[ skinIndex ];

		var skinEntry = { joints: skinDef.joints };

		if ( skinDef.inverseBindMatrices === undefined ) {

			return Promise.resolve( skinEntry );

		}

		return this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {

			skinEntry.inverseBindMatrices = accessor;

			return skinEntry;

		} );

	};

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
	 * @param {number} animationIndex
	 * @return {Promise<AnimationClip>}
	 */
	GLTFParser.prototype.loadAnimation = function ( animationIndex ) {

		var json = this.json;

		var animationDef = json.animations[ animationIndex ];

		var pendingNodes = [];
		var pendingInputAccessors = [];
		var pendingOutputAccessors = [];
		var pendingSamplers = [];
		var pendingTargets = [];

		for ( var i = 0, il = animationDef.channels.length; i < il; i ++ ) {

			var channel = animationDef.channels[ i ];
			var sampler = animationDef.samplers[ channel.sampler ];
			var target = channel.target;
			var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
			var input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
			var output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;

			pendingNodes.push( this.getDependency( 'node', name ) );
			pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
			pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
			pendingSamplers.push( sampler );
			pendingTargets.push( target );

		}

		return Promise.all( [

			Promise.all( pendingNodes ),
			Promise.all( pendingInputAccessors ),
			Promise.all( pendingOutputAccessors ),
			Promise.all( pendingSamplers ),
			Promise.all( pendingTargets )

		] ).then( function ( dependencies ) {

			var nodes = dependencies[ 0 ];
			var inputAccessors = dependencies[ 1 ];
			var outputAccessors = dependencies[ 2 ];
			var samplers = dependencies[ 3 ];
			var targets = dependencies[ 4 ];

			var tracks = [];

			for ( var i = 0, il = nodes.length; i < il; i ++ ) {

				var node = nodes[ i ];
				var inputAccessor = inputAccessors[ i ];
				var outputAccessor = outputAccessors[ i ];
				var sampler = samplers[ i ];
				var target = targets[ i ];

				if ( node === undefined ) continue;

				node.updateMatrix();
				node.matrixAutoUpdate = true;

				var TypedKeyframeTrack;

				switch ( PATH_PROPERTIES[ target.path ] ) {

					case PATH_PROPERTIES.weights:

						TypedKeyframeTrack = _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["NumberKeyframeTrack"];
						break;

					case PATH_PROPERTIES.rotation:

						TypedKeyframeTrack = _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["QuaternionKeyframeTrack"];
						break;

					case PATH_PROPERTIES.position:
					case PATH_PROPERTIES.scale:
					default:

						TypedKeyframeTrack = _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["VectorKeyframeTrack"];
						break;

				}

				var targetName = node.name ? node.name : node.uuid;

				var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateLinear"];

				var targetNames = [];

				if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {

					// Node may be a Group (glTF mesh with several primitives) or a Mesh.
					node.traverse( function ( object ) {

						if ( object.isMesh === true && object.morphTargetInfluences ) {

							targetNames.push( object.name ? object.name : object.uuid );

						}

					} );

				} else {

					targetNames.push( targetName );

				}

				var outputArray = outputAccessor.array;

				if ( outputAccessor.normalized ) {

					var scale;

					if ( outputArray.constructor === Int8Array ) {

						scale = 1 / 127;

					} else if ( outputArray.constructor === Uint8Array ) {

						scale = 1 / 255;

					} else if ( outputArray.constructor == Int16Array ) {

						scale = 1 / 32767;

					} else if ( outputArray.constructor === Uint16Array ) {

						scale = 1 / 65535;

					} else {

						throw new Error( 'THREE.GLTFLoader: Unsupported output accessor component type.' );

					}

					var scaled = new Float32Array( outputArray.length );

					for ( var j = 0, jl = outputArray.length; j < jl; j ++ ) {

						scaled[ j ] = outputArray[ j ] * scale;

					}

					outputArray = scaled;

				}

				for ( var j = 0, jl = targetNames.length; j < jl; j ++ ) {

					var track = new TypedKeyframeTrack(
						targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],
						inputAccessor.array,
						outputArray,
						interpolation
					);

					// Override interpolation with custom factory method.
					if ( sampler.interpolation === 'CUBICSPLINE' ) {

						track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

							// A CUBICSPLINE keyframe in glTF has three output values for each input value,
							// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
							// must be divided by three to get the interpolant's sampleSize argument.

							return new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result );

						};

						// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
						track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

					}

					tracks.push( track );

				}

			}

			var name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

			return new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["AnimationClip"]( name, undefined, tracks );

		} );

	};

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
	 * @param {number} nodeIndex
	 * @return {Promise<Object3D>}
	 */
	GLTFParser.prototype.loadNode = function ( nodeIndex ) {

		var json = this.json;
		var extensions = this.extensions;
		var parser = this;

		var nodeDef = json.nodes[ nodeIndex ];

		// reserve node's name before its dependencies, so the root has the intended name.
		var nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';

		return ( function () {

			var pending = [];

			if ( nodeDef.mesh !== undefined ) {

				pending.push( parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

					var node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );

					// if weights are provided on the node, override weights on the mesh.
					if ( nodeDef.weights !== undefined ) {

						node.traverse( function ( o ) {

							if ( ! o.isMesh ) return;

							for ( var i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

								o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

							}

						} );

					}

					return node;

				} ) );

			}

			if ( nodeDef.camera !== undefined ) {

				pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {

					return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );

				} ) );

			}

			parser._invokeAll( function ( ext ) {

				return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );

			} ).forEach( function ( promise ) {

				pending.push( promise );

			} );

			return Promise.all( pending );

		}() ).then( function ( objects ) {

			var node;

			// .isBone isn't in glTF spec. See ._markDefs
			if ( nodeDef.isBone === true ) {

				node = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Bone"]();

			} else if ( objects.length > 1 ) {

				node = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Group"]();

			} else if ( objects.length === 1 ) {

				node = objects[ 0 ];

			} else {

				node = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Object3D"]();

			}

			if ( node !== objects[ 0 ] ) {

				for ( var i = 0, il = objects.length; i < il; i ++ ) {

					node.add( objects[ i ] );

				}

			}

			if ( nodeDef.name ) {

				node.userData.name = nodeDef.name;
				node.name = nodeName;

			}

			assignExtrasToUserData( node, nodeDef );

			if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );

			if ( nodeDef.matrix !== undefined ) {

				var matrix = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
				matrix.fromArray( nodeDef.matrix );
				node.applyMatrix4( matrix );

			} else {

				if ( nodeDef.translation !== undefined ) {

					node.position.fromArray( nodeDef.translation );

				}

				if ( nodeDef.rotation !== undefined ) {

					node.quaternion.fromArray( nodeDef.rotation );

				}

				if ( nodeDef.scale !== undefined ) {

					node.scale.fromArray( nodeDef.scale );

				}

			}

			parser.associations.set( node, { type: 'nodes', index: nodeIndex } );

			return node;

		} );

	};

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
	 * @param {number} sceneIndex
	 * @return {Promise<Group>}
	 */
	GLTFParser.prototype.loadScene = function () {

		// scene node hierachy builder

		function buildNodeHierachy( nodeId, parentObject, json, parser ) {

			var nodeDef = json.nodes[ nodeId ];

			return parser.getDependency( 'node', nodeId ).then( function ( node ) {

				if ( nodeDef.skin === undefined ) return node;

				// build skeleton here as well

				var skinEntry;

				return parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {

					skinEntry = skin;

					var pendingJoints = [];

					for ( var i = 0, il = skinEntry.joints.length; i < il; i ++ ) {

						pendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );

					}

					return Promise.all( pendingJoints );

				} ).then( function ( jointNodes ) {

					node.traverse( function ( mesh ) {

						if ( ! mesh.isMesh ) return;

						var bones = [];
						var boneInverses = [];

						for ( var j = 0, jl = jointNodes.length; j < jl; j ++ ) {

							var jointNode = jointNodes[ j ];

							if ( jointNode ) {

								bones.push( jointNode );

								var mat = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();

								if ( skinEntry.inverseBindMatrices !== undefined ) {

									mat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );

								}

								boneInverses.push( mat );

							} else {

								console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[ j ] );

							}

						}

						mesh.bind( new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Skeleton"]( bones, boneInverses ), mesh.matrixWorld );

					} );

					return node;

				} );

			} ).then( function ( node ) {

				// build node hierachy

				parentObject.add( node );

				var pending = [];

				if ( nodeDef.children ) {

					var children = nodeDef.children;

					for ( var i = 0, il = children.length; i < il; i ++ ) {

						var child = children[ i ];
						pending.push( buildNodeHierachy( child, node, json, parser ) );

					}

				}

				return Promise.all( pending );

			} );

		}

		return function loadScene( sceneIndex ) {

			var json = this.json;
			var extensions = this.extensions;
			var sceneDef = this.json.scenes[ sceneIndex ];
			var parser = this;

			// Loader returns Group, not Scene.
			// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
			var scene = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Group"]();
			if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );

			assignExtrasToUserData( scene, sceneDef );

			if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );

			var nodeIds = sceneDef.nodes || [];

			var pending = [];

			for ( var i = 0, il = nodeIds.length; i < il; i ++ ) {

				pending.push( buildNodeHierachy( nodeIds[ i ], scene, json, parser ) );

			}

			return Promise.all( pending ).then( function () {

				return scene;

			} );

		};

	}();

	return GLTFLoader;

} )();




/***/ }),

/***/ "../../node_modules/three/examples/jsm/loaders/OBJLoader.js":
/*!**********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/examples/jsm/loaders/OBJLoader.js ***!
  \**********************************************************************************/
/*! exports provided: OBJLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OBJLoader", function() { return OBJLoader; });
/* harmony import */ var _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../build/three.module.js */ "../../node_modules/three/src/Three.js");


var OBJLoader = ( function () {

	// o object_name | g group_name
	var object_pattern = /^[og]\s*(.+)?/;
	// mtllib file_reference
	var material_library_pattern = /^mtllib /;
	// usemtl material_name
	var material_use_pattern = /^usemtl /;
	// usemap map_name
	var map_use_pattern = /^usemap /;

	var vA = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
	var vB = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
	var vC = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

	var ab = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
	var cb = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

	function ParserState() {

		var state = {
			objects: [],
			object: {},

			vertices: [],
			normals: [],
			colors: [],
			uvs: [],

			materials: {},
			materialLibraries: [],

			startObject: function ( name, fromDeclaration ) {

				// If the current object (initial from reset) is not from a g/o declaration in the parsed
				// file. We need to use it for the first parsed g/o to keep things in sync.
				if ( this.object && this.object.fromDeclaration === false ) {

					this.object.name = name;
					this.object.fromDeclaration = ( fromDeclaration !== false );
					return;

				}

				var previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );

				if ( this.object && typeof this.object._finalize === 'function' ) {

					this.object._finalize( true );

				}

				this.object = {
					name: name || '',
					fromDeclaration: ( fromDeclaration !== false ),

					geometry: {
						vertices: [],
						normals: [],
						colors: [],
						uvs: [],
						hasUVIndices: false
					},
					materials: [],
					smooth: true,

					startMaterial: function ( name, libraries ) {

						var previous = this._finalize( false );

						// New usemtl declaration overwrites an inherited material, except if faces were declared
						// after the material, then it must be preserved for proper MultiMaterial continuation.
						if ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {

							this.materials.splice( previous.index, 1 );

						}

						var material = {
							index: this.materials.length,
							name: name || '',
							mtllib: ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),
							smooth: ( previous !== undefined ? previous.smooth : this.smooth ),
							groupStart: ( previous !== undefined ? previous.groupEnd : 0 ),
							groupEnd: - 1,
							groupCount: - 1,
							inherited: false,

							clone: function ( index ) {

								var cloned = {
									index: ( typeof index === 'number' ? index : this.index ),
									name: this.name,
									mtllib: this.mtllib,
									smooth: this.smooth,
									groupStart: 0,
									groupEnd: - 1,
									groupCount: - 1,
									inherited: false
								};
								cloned.clone = this.clone.bind( cloned );
								return cloned;

							}
						};

						this.materials.push( material );

						return material;

					},

					currentMaterial: function () {

						if ( this.materials.length > 0 ) {

							return this.materials[ this.materials.length - 1 ];

						}

						return undefined;

					},

					_finalize: function ( end ) {

						var lastMultiMaterial = this.currentMaterial();
						if ( lastMultiMaterial && lastMultiMaterial.groupEnd === - 1 ) {

							lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
							lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
							lastMultiMaterial.inherited = false;

						}

						// Ignore objects tail materials if no face declarations followed them before a new o/g started.
						if ( end && this.materials.length > 1 ) {

							for ( var mi = this.materials.length - 1; mi >= 0; mi -- ) {

								if ( this.materials[ mi ].groupCount <= 0 ) {

									this.materials.splice( mi, 1 );

								}

							}

						}

						// Guarantee at least one empty material, this makes the creation later more straight forward.
						if ( end && this.materials.length === 0 ) {

							this.materials.push( {
								name: '',
								smooth: this.smooth
							} );

						}

						return lastMultiMaterial;

					}
				};

				// Inherit previous objects material.
				// Spec tells us that a declared material must be set to all objects until a new material is declared.
				// If a usemtl declaration is encountered while this new object is being parsed, it will
				// overwrite the inherited material. Exception being that there was already face declarations
				// to the inherited material, then it will be preserved for proper MultiMaterial continuation.

				if ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {

					var declared = previousMaterial.clone( 0 );
					declared.inherited = true;
					this.object.materials.push( declared );

				}

				this.objects.push( this.object );

			},

			finalize: function () {

				if ( this.object && typeof this.object._finalize === 'function' ) {

					this.object._finalize( true );

				}

			},

			parseVertexIndex: function ( value, len ) {

				var index = parseInt( value, 10 );
				return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

			},

			parseNormalIndex: function ( value, len ) {

				var index = parseInt( value, 10 );
				return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

			},

			parseUVIndex: function ( value, len ) {

				var index = parseInt( value, 10 );
				return ( index >= 0 ? index - 1 : index + len / 2 ) * 2;

			},

			addVertex: function ( a, b, c ) {

				var src = this.vertices;
				var dst = this.object.geometry.vertices;

				dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
				dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
				dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

			},

			addVertexPoint: function ( a ) {

				var src = this.vertices;
				var dst = this.object.geometry.vertices;

				dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );

			},

			addVertexLine: function ( a ) {

				var src = this.vertices;
				var dst = this.object.geometry.vertices;

				dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );

			},

			addNormal: function ( a, b, c ) {

				var src = this.normals;
				var dst = this.object.geometry.normals;

				dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
				dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
				dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

			},

			addFaceNormal: function ( a, b, c ) {

				var src = this.vertices;
				var dst = this.object.geometry.normals;

				vA.fromArray( src, a );
				vB.fromArray( src, b );
				vC.fromArray( src, c );

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				cb.normalize();

				dst.push( cb.x, cb.y, cb.z );
				dst.push( cb.x, cb.y, cb.z );
				dst.push( cb.x, cb.y, cb.z );

			},

			addColor: function ( a, b, c ) {

				var src = this.colors;
				var dst = this.object.geometry.colors;

				if ( src[ a ] !== undefined ) dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
				if ( src[ b ] !== undefined ) dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
				if ( src[ c ] !== undefined ) dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

			},

			addUV: function ( a, b, c ) {

				var src = this.uvs;
				var dst = this.object.geometry.uvs;

				dst.push( src[ a + 0 ], src[ a + 1 ] );
				dst.push( src[ b + 0 ], src[ b + 1 ] );
				dst.push( src[ c + 0 ], src[ c + 1 ] );

			},

			addDefaultUV: function () {

				var dst = this.object.geometry.uvs;

				dst.push( 0, 0 );
				dst.push( 0, 0 );
				dst.push( 0, 0 );

			},

			addUVLine: function ( a ) {

				var src = this.uvs;
				var dst = this.object.geometry.uvs;

				dst.push( src[ a + 0 ], src[ a + 1 ] );

			},

			addFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {

				var vLen = this.vertices.length;

				var ia = this.parseVertexIndex( a, vLen );
				var ib = this.parseVertexIndex( b, vLen );
				var ic = this.parseVertexIndex( c, vLen );

				this.addVertex( ia, ib, ic );
				this.addColor( ia, ib, ic );

				// normals

				if ( na !== undefined && na !== '' ) {

					var nLen = this.normals.length;

					ia = this.parseNormalIndex( na, nLen );
					ib = this.parseNormalIndex( nb, nLen );
					ic = this.parseNormalIndex( nc, nLen );

					this.addNormal( ia, ib, ic );

				} else {

					this.addFaceNormal( ia, ib, ic );

				}

				// uvs

				if ( ua !== undefined && ua !== '' ) {

					var uvLen = this.uvs.length;

					ia = this.parseUVIndex( ua, uvLen );
					ib = this.parseUVIndex( ub, uvLen );
					ic = this.parseUVIndex( uc, uvLen );

					this.addUV( ia, ib, ic );

					this.object.geometry.hasUVIndices = true;

				} else {

					// add placeholder values (for inconsistent face definitions)

					this.addDefaultUV();

				}

			},

			addPointGeometry: function ( vertices ) {

				this.object.geometry.type = 'Points';

				var vLen = this.vertices.length;

				for ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {

					var index = this.parseVertexIndex( vertices[ vi ], vLen );

					this.addVertexPoint( index );
					this.addColor( index );

				}

			},

			addLineGeometry: function ( vertices, uvs ) {

				this.object.geometry.type = 'Line';

				var vLen = this.vertices.length;
				var uvLen = this.uvs.length;

				for ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {

					this.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );

				}

				for ( var uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {

					this.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );

				}

			}

		};

		state.startObject( '', false );

		return state;

	}

	//

	function OBJLoader( manager ) {

		_build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Loader"].call( this, manager );

		this.materials = null;

	}

	OBJLoader.prototype = Object.assign( Object.create( _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Loader"].prototype ), {

		constructor: OBJLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["FileLoader"]( this.manager );
			loader.setPath( this.path );
			loader.setRequestHeader( this.requestHeader );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( text ) {

				try {

					onLoad( scope.parse( text ) );

				} catch ( e ) {

					if ( onError ) {

						onError( e );

					} else {

						console.error( e );

					}

					scope.manager.itemError( url );

				}

			}, onProgress, onError );

		},

		setMaterials: function ( materials ) {

			this.materials = materials;

			return this;

		},

		parse: function ( text ) {

			var state = new ParserState();

			if ( text.indexOf( '\r\n' ) !== - 1 ) {

				// This is faster than String.split with regex that splits on both
				text = text.replace( /\r\n/g, '\n' );

			}

			if ( text.indexOf( '\\\n' ) !== - 1 ) {

				// join lines separated by a line continuation character (\)
				text = text.replace( /\\\n/g, '' );

			}

			var lines = text.split( '\n' );
			var line = '', lineFirstChar = '';
			var lineLength = 0;
			var result = [];

			// Faster to just trim left side of the line. Use if available.
			var trimLeft = ( typeof ''.trimLeft === 'function' );

			for ( var i = 0, l = lines.length; i < l; i ++ ) {

				line = lines[ i ];

				line = trimLeft ? line.trimLeft() : line.trim();

				lineLength = line.length;

				if ( lineLength === 0 ) continue;

				lineFirstChar = line.charAt( 0 );

				// @todo invoke passed in handler if any
				if ( lineFirstChar === '#' ) continue;

				if ( lineFirstChar === 'v' ) {

					var data = line.split( /\s+/ );

					switch ( data[ 0 ] ) {

						case 'v':
							state.vertices.push(
								parseFloat( data[ 1 ] ),
								parseFloat( data[ 2 ] ),
								parseFloat( data[ 3 ] )
							);
							if ( data.length >= 7 ) {

								state.colors.push(
									parseFloat( data[ 4 ] ),
									parseFloat( data[ 5 ] ),
									parseFloat( data[ 6 ] )

								);

							} else {

								// if no colors are defined, add placeholders so color and vertex indices match

								state.colors.push( undefined, undefined, undefined );

							}

							break;
						case 'vn':
							state.normals.push(
								parseFloat( data[ 1 ] ),
								parseFloat( data[ 2 ] ),
								parseFloat( data[ 3 ] )
							);
							break;
						case 'vt':
							state.uvs.push(
								parseFloat( data[ 1 ] ),
								parseFloat( data[ 2 ] )
							);
							break;

					}

				} else if ( lineFirstChar === 'f' ) {

					var lineData = line.substr( 1 ).trim();
					var vertexData = lineData.split( /\s+/ );
					var faceVertices = [];

					// Parse the face vertex data into an easy to work with format

					for ( var j = 0, jl = vertexData.length; j < jl; j ++ ) {

						var vertex = vertexData[ j ];

						if ( vertex.length > 0 ) {

							var vertexParts = vertex.split( '/' );
							faceVertices.push( vertexParts );

						}

					}

					// Draw an edge between the first vertex and all subsequent vertices to form an n-gon

					var v1 = faceVertices[ 0 ];

					for ( var j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {

						var v2 = faceVertices[ j ];
						var v3 = faceVertices[ j + 1 ];

						state.addFace(
							v1[ 0 ], v2[ 0 ], v3[ 0 ],
							v1[ 1 ], v2[ 1 ], v3[ 1 ],
							v1[ 2 ], v2[ 2 ], v3[ 2 ]
						);

					}

				} else if ( lineFirstChar === 'l' ) {

					var lineParts = line.substring( 1 ).trim().split( ' ' );
					var lineVertices = [], lineUVs = [];

					if ( line.indexOf( '/' ) === - 1 ) {

						lineVertices = lineParts;

					} else {

						for ( var li = 0, llen = lineParts.length; li < llen; li ++ ) {

							var parts = lineParts[ li ].split( '/' );

							if ( parts[ 0 ] !== '' ) lineVertices.push( parts[ 0 ] );
							if ( parts[ 1 ] !== '' ) lineUVs.push( parts[ 1 ] );

						}

					}

					state.addLineGeometry( lineVertices, lineUVs );

				} else if ( lineFirstChar === 'p' ) {

					var lineData = line.substr( 1 ).trim();
					var pointData = lineData.split( ' ' );

					state.addPointGeometry( pointData );

				} else if ( ( result = object_pattern.exec( line ) ) !== null ) {

					// o object_name
					// or
					// g group_name

					// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
					// var name = result[ 0 ].substr( 1 ).trim();
					var name = ( ' ' + result[ 0 ].substr( 1 ).trim() ).substr( 1 );

					state.startObject( name );

				} else if ( material_use_pattern.test( line ) ) {

					// material

					state.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );

				} else if ( material_library_pattern.test( line ) ) {

					// mtl file

					state.materialLibraries.push( line.substring( 7 ).trim() );

				} else if ( map_use_pattern.test( line ) ) {

					// the line is parsed but ignored since the loader assumes textures are defined MTL files
					// (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)

					console.warn( 'THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.' );

				} else if ( lineFirstChar === 's' ) {

					result = line.split( ' ' );

					// smooth shading

					// @todo Handle files that have varying smooth values for a set of faces inside one geometry,
					// but does not define a usemtl for each face set.
					// This should be detected and a dummy material created (later MultiMaterial and geometry groups).
					// This requires some care to not create extra material on each smooth value for "normal" obj files.
					// where explicit usemtl defines geometry groups.
					// Example asset: examples/models/obj/cerberus/Cerberus.obj

					/*
					 * http://paulbourke.net/dataformats/obj/
					 * or
					 * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf
					 *
					 * From chapter "Grouping" Syntax explanation "s group_number":
					 * "group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.
					 * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form
					 * surfaces, smoothing groups are either turned on or off; there is no difference between values greater
					 * than 0."
					 */
					if ( result.length > 1 ) {

						var value = result[ 1 ].trim().toLowerCase();
						state.object.smooth = ( value !== '0' && value !== 'off' );

					} else {

						// ZBrush can produce "s" lines #11707
						state.object.smooth = true;

					}

					var material = state.object.currentMaterial();
					if ( material ) material.smooth = state.object.smooth;

				} else {

					// Handle null terminated files without exception
					if ( line === '\0' ) continue;

					console.warn( 'THREE.OBJLoader: Unexpected line: "' + line + '"' );

				}

			}

			state.finalize();

			var container = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Group"]();
			container.materialLibraries = [].concat( state.materialLibraries );

			var hasPrimitives = ! ( state.objects.length === 1 && state.objects[ 0 ].geometry.vertices.length === 0 );

			if ( hasPrimitives === true ) {

				for ( var i = 0, l = state.objects.length; i < l; i ++ ) {

					var object = state.objects[ i ];
					var geometry = object.geometry;
					var materials = object.materials;
					var isLine = ( geometry.type === 'Line' );
					var isPoints = ( geometry.type === 'Points' );
					var hasVertexColors = false;

					// Skip o/g line declarations that did not follow with any faces
					if ( geometry.vertices.length === 0 ) continue;

					var buffergeometry = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]();

					buffergeometry.setAttribute( 'position', new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"]( geometry.vertices, 3 ) );

					if ( geometry.normals.length > 0 ) {

						buffergeometry.setAttribute( 'normal', new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"]( geometry.normals, 3 ) );

					}

					if ( geometry.colors.length > 0 ) {

						hasVertexColors = true;
						buffergeometry.setAttribute( 'color', new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"]( geometry.colors, 3 ) );

					}

					if ( geometry.hasUVIndices === true ) {

						buffergeometry.setAttribute( 'uv', new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"]( geometry.uvs, 2 ) );

					}

					// Create materials

					var createdMaterials = [];

					for ( var mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {

						var sourceMaterial = materials[ mi ];
						var materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;
						var material = state.materials[ materialHash ];

						if ( this.materials !== null ) {

							material = this.materials.create( sourceMaterial.name );

							// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
							if ( isLine && material && ! ( material instanceof _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["LineBasicMaterial"] ) ) {

								var materialLine = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["LineBasicMaterial"]();
								_build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Material"].prototype.copy.call( materialLine, material );
								materialLine.color.copy( material.color );
								material = materialLine;

							} else if ( isPoints && material && ! ( material instanceof _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["PointsMaterial"] ) ) {

								var materialPoints = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["PointsMaterial"]( { size: 10, sizeAttenuation: false } );
								_build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Material"].prototype.copy.call( materialPoints, material );
								materialPoints.color.copy( material.color );
								materialPoints.map = material.map;
								material = materialPoints;

							}

						}

						if ( material === undefined ) {

							if ( isLine ) {

								material = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["LineBasicMaterial"]();

							} else if ( isPoints ) {

								material = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["PointsMaterial"]( { size: 1, sizeAttenuation: false } );

							} else {

								material = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["MeshPhongMaterial"]();

							}

							material.name = sourceMaterial.name;
							material.flatShading = sourceMaterial.smooth ? false : true;
							material.vertexColors = hasVertexColors;

							state.materials[ materialHash ] = material;

						}

						createdMaterials.push( material );

					}

					// Create mesh

					var mesh;

					if ( createdMaterials.length > 1 ) {

						for ( var mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {

							var sourceMaterial = materials[ mi ];
							buffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );

						}

						if ( isLine ) {

							mesh = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["LineSegments"]( buffergeometry, createdMaterials );

						} else if ( isPoints ) {

							mesh = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Points"]( buffergeometry, createdMaterials );

						} else {

							mesh = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Mesh"]( buffergeometry, createdMaterials );

						}

					} else {

						if ( isLine ) {

							mesh = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["LineSegments"]( buffergeometry, createdMaterials[ 0 ] );

						} else if ( isPoints ) {

							mesh = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Points"]( buffergeometry, createdMaterials[ 0 ] );

						} else {

							mesh = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Mesh"]( buffergeometry, createdMaterials[ 0 ] );

						}

					}

					mesh.name = object.name;

					container.add( mesh );

				}

			} else {

				// if there is only the default parser state object with no geometry data, interpret data as point cloud

				if ( state.vertices.length > 0 ) {

					var material = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["PointsMaterial"]( { size: 1, sizeAttenuation: false } );

					var buffergeometry = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]();

					buffergeometry.setAttribute( 'position', new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"]( state.vertices, 3 ) );

					if ( state.colors.length > 0 && state.colors[ 0 ] !== undefined ) {

						buffergeometry.setAttribute( 'color', new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"]( state.colors, 3 ) );
						material.vertexColors = true;

					}

					var points = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Points"]( buffergeometry, material );
					container.add( points );

				}

			}

			return container;

		}

	} );

	return OBJLoader;

} )();




/***/ }),

/***/ "../../node_modules/three/examples/jsm/loaders/PLYLoader.js":
/*!**********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/examples/jsm/loaders/PLYLoader.js ***!
  \**********************************************************************************/
/*! exports provided: PLYLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PLYLoader", function() { return PLYLoader; });
/* harmony import */ var _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../build/three.module.js */ "../../node_modules/three/src/Three.js");


/**
 * Description: A THREE loader for PLY ASCII files (known as the Polygon
 * File Format or the Stanford Triangle Format).
 *
 * Limitations: ASCII decoding assumes file is UTF-8.
 *
 * Usage:
 *	var loader = new PLYLoader();
 *	loader.load('./models/ply/ascii/dolphins.ply', function (geometry) {
 *
 *		scene.add( new THREE.Mesh( geometry ) );
 *
 *	} );
 *
 * If the PLY file uses non standard property names, they can be mapped while
 * loading. For example, the following maps the properties
 * “diffuse_(red|green|blue)” in the file to standard color names.
 *
 * loader.setPropertyNameMapping( {
 *	diffuse_red: 'red',
 *	diffuse_green: 'green',
 *	diffuse_blue: 'blue'
 * } );
 *
 */


var PLYLoader = function ( manager ) {

	_build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Loader"].call( this, manager );

	this.propertyNameMapping = {};

};

PLYLoader.prototype = Object.assign( Object.create( _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Loader"].prototype ), {

	constructor: PLYLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["FileLoader"]( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( text ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	},

	setPropertyNameMapping: function ( mapping ) {

		this.propertyNameMapping = mapping;

	},

	parse: function ( data ) {

		function parseHeader( data ) {

			var patternHeader = /ply([\s\S]*)end_header\r?\n/;
			var headerText = '';
			var headerLength = 0;
			var result = patternHeader.exec( data );

			if ( result !== null ) {

				headerText = result[ 1 ];
				headerLength = new Blob( [ result[ 0 ] ] ).size;

			}

			var header = {
				comments: [],
				elements: [],
				headerLength: headerLength,
				objInfo: ''
			};

			var lines = headerText.split( '\n' );
			var currentElement;
			var lineType, lineValues;

			function make_ply_element_property( propertValues, propertyNameMapping ) {

				var property = { type: propertValues[ 0 ] };

				if ( property.type === 'list' ) {

					property.name = propertValues[ 3 ];
					property.countType = propertValues[ 1 ];
					property.itemType = propertValues[ 2 ];

				} else {

					property.name = propertValues[ 1 ];

				}

				if ( property.name in propertyNameMapping ) {

					property.name = propertyNameMapping[ property.name ];

				}

				return property;

			}

			for ( var i = 0; i < lines.length; i ++ ) {

				var line = lines[ i ];
				line = line.trim();

				if ( line === '' ) continue;

				lineValues = line.split( /\s+/ );
				lineType = lineValues.shift();
				line = lineValues.join( ' ' );

				switch ( lineType ) {

					case 'format':

						header.format = lineValues[ 0 ];
						header.version = lineValues[ 1 ];

						break;

					case 'comment':

						header.comments.push( line );

						break;

					case 'element':

						if ( currentElement !== undefined ) {

							header.elements.push( currentElement );

						}

						currentElement = {};
						currentElement.name = lineValues[ 0 ];
						currentElement.count = parseInt( lineValues[ 1 ] );
						currentElement.properties = [];

						break;

					case 'property':

						currentElement.properties.push( make_ply_element_property( lineValues, scope.propertyNameMapping ) );

						break;

					case 'obj_info':

						header.objInfo = line;

						break;


					default:

						console.log( 'unhandled', lineType, lineValues );

				}

			}

			if ( currentElement !== undefined ) {

				header.elements.push( currentElement );

			}

			return header;

		}

		function parseASCIINumber( n, type ) {

			switch ( type ) {

				case 'char': case 'uchar': case 'short': case 'ushort': case 'int': case 'uint':
				case 'int8': case 'uint8': case 'int16': case 'uint16': case 'int32': case 'uint32':

					return parseInt( n );

				case 'float': case 'double': case 'float32': case 'float64':

					return parseFloat( n );

			}

		}

		function parseASCIIElement( properties, line ) {

			var values = line.split( /\s+/ );

			var element = {};

			for ( var i = 0; i < properties.length; i ++ ) {

				if ( properties[ i ].type === 'list' ) {

					var list = [];
					var n = parseASCIINumber( values.shift(), properties[ i ].countType );

					for ( var j = 0; j < n; j ++ ) {

						list.push( parseASCIINumber( values.shift(), properties[ i ].itemType ) );

					}

					element[ properties[ i ].name ] = list;

				} else {

					element[ properties[ i ].name ] = parseASCIINumber( values.shift(), properties[ i ].type );

				}

			}

			return element;

		}

		function parseASCII( data, header ) {

			// PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)

			var buffer = {
				indices: [],
				vertices: [],
				normals: [],
				uvs: [],
				faceVertexUvs: [],
				colors: []
			};

			var result;

			var patternBody = /end_header\s([\s\S]*)$/;
			var body = '';
			if ( ( result = patternBody.exec( data ) ) !== null ) {

				body = result[ 1 ];

			}

			var lines = body.split( '\n' );
			var currentElement = 0;
			var currentElementCount = 0;

			for ( var i = 0; i < lines.length; i ++ ) {

				var line = lines[ i ];
				line = line.trim();
				if ( line === '' ) {

					continue;

				}

				if ( currentElementCount >= header.elements[ currentElement ].count ) {

					currentElement ++;
					currentElementCount = 0;

				}

				var element = parseASCIIElement( header.elements[ currentElement ].properties, line );

				handleElement( buffer, header.elements[ currentElement ].name, element );

				currentElementCount ++;

			}

			return postProcess( buffer );

		}

		function postProcess( buffer ) {

			var geometry = new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]();

			// mandatory buffer data

			if ( buffer.indices.length > 0 ) {

				geometry.setIndex( buffer.indices );

			}

			geometry.setAttribute( 'position', new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"]( buffer.vertices, 3 ) );

			// optional buffer data

			if ( buffer.normals.length > 0 ) {

				geometry.setAttribute( 'normal', new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"]( buffer.normals, 3 ) );

			}

			if ( buffer.uvs.length > 0 ) {

				geometry.setAttribute( 'uv', new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"]( buffer.uvs, 2 ) );

			}

			if ( buffer.colors.length > 0 ) {

				geometry.setAttribute( 'color', new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"]( buffer.colors, 3 ) );

			}

			if ( buffer.faceVertexUvs.length > 0 ) {

				geometry = geometry.toNonIndexed();
				geometry.setAttribute( 'uv', new _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"]( buffer.faceVertexUvs, 2 ) );

			}

			geometry.computeBoundingSphere();

			return geometry;

		}

		function handleElement( buffer, elementName, element ) {

			if ( elementName === 'vertex' ) {

				buffer.vertices.push( element.x, element.y, element.z );

				if ( 'nx' in element && 'ny' in element && 'nz' in element ) {

					buffer.normals.push( element.nx, element.ny, element.nz );

				}

				if ( 's' in element && 't' in element ) {

					buffer.uvs.push( element.s, element.t );

				}

				if ( 'red' in element && 'green' in element && 'blue' in element ) {

					buffer.colors.push( element.red / 255.0, element.green / 255.0, element.blue / 255.0 );

				}

			} else if ( elementName === 'face' ) {

				var vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338
				var texcoord = element.texcoord;

				if ( vertex_indices.length === 3 ) {

					buffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 2 ] );

					if ( texcoord && texcoord.length === 6 ) {

						buffer.faceVertexUvs.push( texcoord[ 0 ], texcoord[ 1 ] );
						buffer.faceVertexUvs.push( texcoord[ 2 ], texcoord[ 3 ] );
						buffer.faceVertexUvs.push( texcoord[ 4 ], texcoord[ 5 ] );

					}

				} else if ( vertex_indices.length === 4 ) {

					buffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 3 ] );
					buffer.indices.push( vertex_indices[ 1 ], vertex_indices[ 2 ], vertex_indices[ 3 ] );

				}

			}

		}

		function binaryRead( dataview, at, type, little_endian ) {

			switch ( type ) {

				// corespondences for non-specific length types here match rply:
				case 'int8':		case 'char':	 return [ dataview.getInt8( at ), 1 ];
				case 'uint8':		case 'uchar':	 return [ dataview.getUint8( at ), 1 ];
				case 'int16':		case 'short':	 return [ dataview.getInt16( at, little_endian ), 2 ];
				case 'uint16':	case 'ushort': return [ dataview.getUint16( at, little_endian ), 2 ];
				case 'int32':		case 'int':		 return [ dataview.getInt32( at, little_endian ), 4 ];
				case 'uint32':	case 'uint':	 return [ dataview.getUint32( at, little_endian ), 4 ];
				case 'float32': case 'float':	 return [ dataview.getFloat32( at, little_endian ), 4 ];
				case 'float64': case 'double': return [ dataview.getFloat64( at, little_endian ), 8 ];

			}

		}

		function binaryReadElement( dataview, at, properties, little_endian ) {

			var element = {};
			var result, read = 0;

			for ( var i = 0; i < properties.length; i ++ ) {

				if ( properties[ i ].type === 'list' ) {

					var list = [];

					result = binaryRead( dataview, at + read, properties[ i ].countType, little_endian );
					var n = result[ 0 ];
					read += result[ 1 ];

					for ( var j = 0; j < n; j ++ ) {

						result = binaryRead( dataview, at + read, properties[ i ].itemType, little_endian );
						list.push( result[ 0 ] );
						read += result[ 1 ];

					}

					element[ properties[ i ].name ] = list;

				} else {

					result = binaryRead( dataview, at + read, properties[ i ].type, little_endian );
					element[ properties[ i ].name ] = result[ 0 ];
					read += result[ 1 ];

				}

			}

			return [ element, read ];

		}

		function parseBinary( data, header ) {

			var buffer = {
				indices: [],
				vertices: [],
				normals: [],
				uvs: [],
				faceVertexUvs: [],
				colors: []
			};

			var little_endian = ( header.format === 'binary_little_endian' );
			var body = new DataView( data, header.headerLength );
			var result, loc = 0;

			for ( var currentElement = 0; currentElement < header.elements.length; currentElement ++ ) {

				for ( var currentElementCount = 0; currentElementCount < header.elements[ currentElement ].count; currentElementCount ++ ) {

					result = binaryReadElement( body, loc, header.elements[ currentElement ].properties, little_endian );
					loc += result[ 1 ];
					var element = result[ 0 ];

					handleElement( buffer, header.elements[ currentElement ].name, element );

				}

			}

			return postProcess( buffer );

		}

		//

		var geometry;
		var scope = this;

		if ( data instanceof ArrayBuffer ) {

			var text = _build_three_module_js__WEBPACK_IMPORTED_MODULE_0__["LoaderUtils"].decodeText( new Uint8Array( data ) );
			var header = parseHeader( text );

			geometry = header.format === 'ascii' ? parseASCII( text, header ) : parseBinary( data, header );

		} else {

			geometry = parseASCII( data, parseHeader( data ) );

		}

		return geometry;

	}

} );




/***/ }),

/***/ "../../node_modules/three/src/Three.Legacy.js":
/*!********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/Three.Legacy.js ***!
  \********************************************************************/
/*! exports provided: Math, LineStrip, LinePieces, NoColors, FaceColors, VertexColors, MeshFaceMaterial, MultiMaterial, PointCloud, Particle, ParticleSystem, PointCloudMaterial, ParticleBasicMaterial, ParticleSystemMaterial, Vertex, DynamicBufferAttribute, Int8Attribute, Uint8Attribute, Uint8ClampedAttribute, Int16Attribute, Uint16Attribute, Int32Attribute, Uint32Attribute, Float32Attribute, Float64Attribute, AxisHelper, BoundingBoxHelper, EdgesHelper, WireframeHelper, XHRLoader, BinaryTextureLoader, WebGLRenderTargetCube, CanvasRenderer, JSONLoader, SceneUtils, LensFlare */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineStrip", function() { return LineStrip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinePieces", function() { return LinePieces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoColors", function() { return NoColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceColors", function() { return FaceColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexColors", function() { return VertexColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshFaceMaterial", function() { return MeshFaceMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiMaterial", function() { return MultiMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointCloud", function() { return PointCloud; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Particle", function() { return Particle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleSystem", function() { return ParticleSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointCloudMaterial", function() { return PointCloudMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleBasicMaterial", function() { return ParticleBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleSystemMaterial", function() { return ParticleSystemMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vertex", function() { return Vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicBufferAttribute", function() { return DynamicBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8Attribute", function() { return Int8Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8Attribute", function() { return Uint8Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedAttribute", function() { return Uint8ClampedAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16Attribute", function() { return Int16Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16Attribute", function() { return Uint16Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32Attribute", function() { return Int32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32Attribute", function() { return Uint32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32Attribute", function() { return Float32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64Attribute", function() { return Float64Attribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxisHelper", function() { return AxisHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoundingBoxHelper", function() { return BoundingBoxHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgesHelper", function() { return EdgesHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireframeHelper", function() { return WireframeHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XHRLoader", function() { return XHRLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BinaryTextureLoader", function() { return BinaryTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTargetCube", function() { return WebGLRenderTargetCube; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasRenderer", function() { return CanvasRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSONLoader", function() { return JSONLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SceneUtils", function() { return SceneUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LensFlare", function() { return LensFlare; });
/* harmony import */ var _audio_Audio_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audio/Audio.js */ "../../node_modules/three/src/audio/Audio.js");
/* harmony import */ var _audio_AudioAnalyser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./audio/AudioAnalyser.js */ "../../node_modules/three/src/audio/AudioAnalyser.js");
/* harmony import */ var _cameras_PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cameras/PerspectiveCamera.js */ "../../node_modules/three/src/cameras/PerspectiveCamera.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _core_InstancedBufferGeometry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./core/InstancedBufferGeometry.js */ "../../node_modules/three/src/core/InstancedBufferGeometry.js");
/* harmony import */ var _core_InterleavedBuffer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./core/InterleavedBuffer.js */ "../../node_modules/three/src/core/InterleavedBuffer.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");
/* harmony import */ var _core_Uniform_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./core/Uniform.js */ "../../node_modules/three/src/core/Uniform.js");
/* harmony import */ var _core_Raycaster_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./core/Raycaster.js */ "../../node_modules/three/src/core/Raycaster.js");
/* harmony import */ var _extras_core_Curve_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./extras/core/Curve.js */ "../../node_modules/three/src/extras/core/Curve.js");
/* harmony import */ var _extras_core_Path_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./extras/core/Path.js */ "../../node_modules/three/src/extras/core/Path.js");
/* harmony import */ var _helpers_AxesHelper_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./helpers/AxesHelper.js */ "../../node_modules/three/src/helpers/AxesHelper.js");
/* harmony import */ var _helpers_BoxHelper_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./helpers/BoxHelper.js */ "../../node_modules/three/src/helpers/BoxHelper.js");
/* harmony import */ var _helpers_GridHelper_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./helpers/GridHelper.js */ "../../node_modules/three/src/helpers/GridHelper.js");
/* harmony import */ var _helpers_SkeletonHelper_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./helpers/SkeletonHelper.js */ "../../node_modules/three/src/helpers/SkeletonHelper.js");
/* harmony import */ var _geometries_EdgesGeometry_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./geometries/EdgesGeometry.js */ "../../node_modules/three/src/geometries/EdgesGeometry.js");
/* harmony import */ var _geometries_ExtrudeGeometry_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./geometries/ExtrudeGeometry.js */ "../../node_modules/three/src/geometries/ExtrudeGeometry.js");
/* harmony import */ var _geometries_ShapeGeometry_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./geometries/ShapeGeometry.js */ "../../node_modules/three/src/geometries/ShapeGeometry.js");
/* harmony import */ var _geometries_WireframeGeometry_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./geometries/WireframeGeometry.js */ "../../node_modules/three/src/geometries/WireframeGeometry.js");
/* harmony import */ var _lights_Light_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./lights/Light.js */ "../../node_modules/three/src/lights/Light.js");
/* harmony import */ var _loaders_Loader_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./loaders/Loader.js */ "../../node_modules/three/src/loaders/Loader.js");
/* harmony import */ var _loaders_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./loaders/LoaderUtils.js */ "../../node_modules/three/src/loaders/LoaderUtils.js");
/* harmony import */ var _loaders_FileLoader_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./loaders/FileLoader.js */ "../../node_modules/three/src/loaders/FileLoader.js");
/* harmony import */ var _loaders_AudioLoader_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./loaders/AudioLoader.js */ "../../node_modules/three/src/loaders/AudioLoader.js");
/* harmony import */ var _loaders_CubeTextureLoader_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./loaders/CubeTextureLoader.js */ "../../node_modules/three/src/loaders/CubeTextureLoader.js");
/* harmony import */ var _loaders_DataTextureLoader_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./loaders/DataTextureLoader.js */ "../../node_modules/three/src/loaders/DataTextureLoader.js");
/* harmony import */ var _loaders_TextureLoader_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./loaders/TextureLoader.js */ "../../node_modules/three/src/loaders/TextureLoader.js");
/* harmony import */ var _materials_Material_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./materials/Material.js */ "../../node_modules/three/src/materials/Material.js");
/* harmony import */ var _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./materials/LineBasicMaterial.js */ "../../node_modules/three/src/materials/LineBasicMaterial.js");
/* harmony import */ var _materials_MeshPhysicalMaterial_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./materials/MeshPhysicalMaterial.js */ "../../node_modules/three/src/materials/MeshPhysicalMaterial.js");
/* harmony import */ var _materials_PointsMaterial_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./materials/PointsMaterial.js */ "../../node_modules/three/src/materials/PointsMaterial.js");
/* harmony import */ var _materials_ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./materials/ShaderMaterial.js */ "../../node_modules/three/src/materials/ShaderMaterial.js");
/* harmony import */ var _math_Box2_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./math/Box2.js */ "../../node_modules/three/src/math/Box2.js");
/* harmony import */ var _math_Box3_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./math/Box3.js */ "../../node_modules/three/src/math/Box3.js");
/* harmony import */ var _math_Sphere_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./math/Sphere.js */ "../../node_modules/three/src/math/Sphere.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./math/Color.js */ "../../node_modules/three/src/math/Color.js");
/* harmony import */ var _math_Frustum_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./math/Frustum.js */ "../../node_modules/three/src/math/Frustum.js");
/* harmony import */ var _math_Line3_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./math/Line3.js */ "../../node_modules/three/src/math/Line3.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./math/MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Math", function() { return _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_40__["MathUtils"]; });

/* harmony import */ var _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./math/Matrix3.js */ "../../node_modules/three/src/math/Matrix3.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./math/Matrix4.js */ "../../node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _math_Plane_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./math/Plane.js */ "../../node_modules/three/src/math/Plane.js");
/* harmony import */ var _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./math/Quaternion.js */ "../../node_modules/three/src/math/Quaternion.js");
/* harmony import */ var _math_Ray_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./math/Ray.js */ "../../node_modules/three/src/math/Ray.js");
/* harmony import */ var _math_Triangle_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./math/Triangle.js */ "../../node_modules/three/src/math/Triangle.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Vector4_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./math/Vector4.js */ "../../node_modules/three/src/math/Vector4.js");
/* harmony import */ var _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./objects/Mesh.js */ "../../node_modules/three/src/objects/Mesh.js");
/* harmony import */ var _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./objects/LineSegments.js */ "../../node_modules/three/src/objects/LineSegments.js");
/* harmony import */ var _objects_Points_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./objects/Points.js */ "../../node_modules/three/src/objects/Points.js");
/* harmony import */ var _objects_Sprite_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./objects/Sprite.js */ "../../node_modules/three/src/objects/Sprite.js");
/* harmony import */ var _objects_SkinnedMesh_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./objects/SkinnedMesh.js */ "../../node_modules/three/src/objects/SkinnedMesh.js");
/* harmony import */ var _renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./renderers/WebGLRenderer.js */ "../../node_modules/three/src/renderers/WebGLRenderer.js");
/* harmony import */ var _renderers_WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./renderers/WebGLRenderTarget.js */ "../../node_modules/three/src/renderers/WebGLRenderTarget.js");
/* harmony import */ var _renderers_WebGLCubeRenderTarget_js__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./renderers/WebGLCubeRenderTarget.js */ "../../node_modules/three/src/renderers/WebGLCubeRenderTarget.js");
/* harmony import */ var _renderers_webgl_WebGLShadowMap_js__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./renderers/webgl/WebGLShadowMap.js */ "../../node_modules/three/src/renderers/webgl/WebGLShadowMap.js");
/* harmony import */ var _extras_ImageUtils_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./extras/ImageUtils.js */ "../../node_modules/three/src/extras/ImageUtils.js");
/* harmony import */ var _extras_core_Shape_js__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./extras/core/Shape.js */ "../../node_modules/three/src/extras/core/Shape.js");
/* harmony import */ var _cameras_CubeCamera_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./cameras/CubeCamera.js */ "../../node_modules/three/src/cameras/CubeCamera.js");
/* harmony import */ var _scenes_Scene_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./scenes/Scene.js */ "../../node_modules/three/src/scenes/Scene.js");


































































const LineStrip = 0;
const LinePieces = 1;
const NoColors = 0;
const FaceColors = 1;
const VertexColors = 2;

function MeshFaceMaterial( materials ) {

	console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
	return materials;

}

function MultiMaterial( materials = [] ) {

	console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
	materials.isMultiMaterial = true;
	materials.materials = materials;
	materials.clone = function () {

		return materials.slice();

	};

	return materials;

}

function PointCloud( geometry, material ) {

	console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
	return new _objects_Points_js__WEBPACK_IMPORTED_MODULE_52__["Points"]( geometry, material );

}

function Particle( material ) {

	console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
	return new _objects_Sprite_js__WEBPACK_IMPORTED_MODULE_53__["Sprite"]( material );

}

function ParticleSystem( geometry, material ) {

	console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
	return new _objects_Points_js__WEBPACK_IMPORTED_MODULE_52__["Points"]( geometry, material );

}

function PointCloudMaterial( parameters ) {

	console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
	return new _materials_PointsMaterial_js__WEBPACK_IMPORTED_MODULE_32__["PointsMaterial"]( parameters );

}

function ParticleBasicMaterial( parameters ) {

	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
	return new _materials_PointsMaterial_js__WEBPACK_IMPORTED_MODULE_32__["PointsMaterial"]( parameters );

}

function ParticleSystemMaterial( parameters ) {

	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
	return new _materials_PointsMaterial_js__WEBPACK_IMPORTED_MODULE_32__["PointsMaterial"]( parameters );

}

function Vertex( x, y, z ) {

	console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
	return new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_48__["Vector3"]( x, y, z );

}

//

function DynamicBufferAttribute( array, itemSize ) {

	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.' );
	return new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["BufferAttribute"]( array, itemSize ).setUsage( _constants_js__WEBPACK_IMPORTED_MODULE_3__["DynamicDrawUsage"] );

}

function Int8Attribute( array, itemSize ) {

	console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
	return new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["Int8BufferAttribute"]( array, itemSize );

}

function Uint8Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
	return new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["Uint8BufferAttribute"]( array, itemSize );

}

function Uint8ClampedAttribute( array, itemSize ) {

	console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
	return new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["Uint8ClampedBufferAttribute"]( array, itemSize );

}

function Int16Attribute( array, itemSize ) {

	console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
	return new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["Int16BufferAttribute"]( array, itemSize );

}

function Uint16Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
	return new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["Uint16BufferAttribute"]( array, itemSize );

}

function Int32Attribute( array, itemSize ) {

	console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
	return new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["Int32BufferAttribute"]( array, itemSize );

}

function Uint32Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
	return new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["Uint32BufferAttribute"]( array, itemSize );

}

function Float32Attribute( array, itemSize ) {

	console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
	return new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["Float32BufferAttribute"]( array, itemSize );

}

function Float64Attribute( array, itemSize ) {

	console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
	return new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["Float64BufferAttribute"]( array, itemSize );

}

//

_extras_core_Curve_js__WEBPACK_IMPORTED_MODULE_11__["Curve"].create = function ( construct, getPoint ) {

	console.log( 'THREE.Curve.create() has been deprecated' );

	construct.prototype = Object.create( _extras_core_Curve_js__WEBPACK_IMPORTED_MODULE_11__["Curve"].prototype );
	construct.prototype.constructor = construct;
	construct.prototype.getPoint = getPoint;

	return construct;

};

//

_extras_core_Path_js__WEBPACK_IMPORTED_MODULE_12__["Path"].prototype.fromPoints = function ( points ) {

	console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
	return this.setFromPoints( points );

};

//

function AxisHelper( size ) {

	console.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );
	return new _helpers_AxesHelper_js__WEBPACK_IMPORTED_MODULE_13__["AxesHelper"]( size );

}

function BoundingBoxHelper( object, color ) {

	console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
	return new _helpers_BoxHelper_js__WEBPACK_IMPORTED_MODULE_14__["BoxHelper"]( object, color );

}

function EdgesHelper( object, hex ) {

	console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
	return new _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_51__["LineSegments"]( new _geometries_EdgesGeometry_js__WEBPACK_IMPORTED_MODULE_17__["EdgesGeometry"]( object.geometry ), new _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_30__["LineBasicMaterial"]( { color: hex !== undefined ? hex : 0xffffff } ) );

}

_helpers_GridHelper_js__WEBPACK_IMPORTED_MODULE_15__["GridHelper"].prototype.setColors = function () {

	console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

};

_helpers_SkeletonHelper_js__WEBPACK_IMPORTED_MODULE_16__["SkeletonHelper"].prototype.update = function () {

	console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

};

function WireframeHelper( object, hex ) {

	console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
	return new _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_51__["LineSegments"]( new _geometries_WireframeGeometry_js__WEBPACK_IMPORTED_MODULE_20__["WireframeGeometry"]( object.geometry ), new _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_30__["LineBasicMaterial"]( { color: hex !== undefined ? hex : 0xffffff } ) );

}

//

_loaders_Loader_js__WEBPACK_IMPORTED_MODULE_22__["Loader"].prototype.extractUrlBase = function ( url ) {

	console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
	return _loaders_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_23__["LoaderUtils"].extractUrlBase( url );

};

_loaders_Loader_js__WEBPACK_IMPORTED_MODULE_22__["Loader"].Handlers = {

	add: function ( /* regex, loader */ ) {

		console.error( 'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.' );

	},

	get: function ( /* file */ ) {

		console.error( 'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.' );

	}

};

function XHRLoader( manager ) {

	console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
	return new _loaders_FileLoader_js__WEBPACK_IMPORTED_MODULE_24__["FileLoader"]( manager );

}

function BinaryTextureLoader( manager ) {

	console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
	return new _loaders_DataTextureLoader_js__WEBPACK_IMPORTED_MODULE_27__["DataTextureLoader"]( manager );

}

//

_math_Box2_js__WEBPACK_IMPORTED_MODULE_34__["Box2"].prototype.center = function ( optionalTarget ) {

	console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );

};

_math_Box2_js__WEBPACK_IMPORTED_MODULE_34__["Box2"].prototype.empty = function () {

	console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
	return this.isEmpty();

};

_math_Box2_js__WEBPACK_IMPORTED_MODULE_34__["Box2"].prototype.isIntersectionBox = function ( box ) {

	console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
	return this.intersectsBox( box );

};

_math_Box2_js__WEBPACK_IMPORTED_MODULE_34__["Box2"].prototype.size = function ( optionalTarget ) {

	console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
	return this.getSize( optionalTarget );

};

//

_math_Box3_js__WEBPACK_IMPORTED_MODULE_35__["Box3"].prototype.center = function ( optionalTarget ) {

	console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );

};

_math_Box3_js__WEBPACK_IMPORTED_MODULE_35__["Box3"].prototype.empty = function () {

	console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
	return this.isEmpty();

};

_math_Box3_js__WEBPACK_IMPORTED_MODULE_35__["Box3"].prototype.isIntersectionBox = function ( box ) {

	console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
	return this.intersectsBox( box );

};

_math_Box3_js__WEBPACK_IMPORTED_MODULE_35__["Box3"].prototype.isIntersectionSphere = function ( sphere ) {

	console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
	return this.intersectsSphere( sphere );

};

_math_Box3_js__WEBPACK_IMPORTED_MODULE_35__["Box3"].prototype.size = function ( optionalTarget ) {

	console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
	return this.getSize( optionalTarget );

};

//

_math_Sphere_js__WEBPACK_IMPORTED_MODULE_36__["Sphere"].prototype.empty = function () {

	console.warn( 'THREE.Sphere: .empty() has been renamed to .isEmpty().' );
	return this.isEmpty();

};

//

_math_Frustum_js__WEBPACK_IMPORTED_MODULE_38__["Frustum"].prototype.setFromMatrix = function ( m ) {

	console.warn( 'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().' );
	return this.setFromProjectionMatrix( m );

};

//

_math_Line3_js__WEBPACK_IMPORTED_MODULE_39__["Line3"].prototype.center = function ( optionalTarget ) {

	console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );

};

//

_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_40__["MathUtils"].random16 = function () {

	console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
	return Math.random();

};

_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_40__["MathUtils"].nearestPowerOfTwo = function ( value ) {

	console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
	return _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_40__["MathUtils"].floorPowerOfTwo( value );

};

_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_40__["MathUtils"].nextPowerOfTwo = function ( value ) {

	console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
	return _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_40__["MathUtils"].ceilPowerOfTwo( value );

};

//

_math_Matrix3_js__WEBPACK_IMPORTED_MODULE_41__["Matrix3"].prototype.flattenToArrayOffset = function ( array, offset ) {

	console.warn( 'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );
	return this.toArray( array, offset );

};

_math_Matrix3_js__WEBPACK_IMPORTED_MODULE_41__["Matrix3"].prototype.multiplyVector3 = function ( vector ) {

	console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
	return vector.applyMatrix3( this );

};

_math_Matrix3_js__WEBPACK_IMPORTED_MODULE_41__["Matrix3"].prototype.multiplyVector3Array = function ( /* a */ ) {

	console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

};

_math_Matrix3_js__WEBPACK_IMPORTED_MODULE_41__["Matrix3"].prototype.applyToBufferAttribute = function ( attribute ) {

	console.warn( 'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.' );
	return attribute.applyMatrix3( this );

};

_math_Matrix3_js__WEBPACK_IMPORTED_MODULE_41__["Matrix3"].prototype.applyToVector3Array = function ( /* array, offset, length */ ) {

	console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

};

_math_Matrix3_js__WEBPACK_IMPORTED_MODULE_41__["Matrix3"].prototype.getInverse = function ( matrix ) {

	console.warn( 'THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
	return this.copy( matrix ).invert();

};

//

_math_Matrix4_js__WEBPACK_IMPORTED_MODULE_42__["Matrix4"].prototype.extractPosition = function ( m ) {

	console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
	return this.copyPosition( m );

};

_math_Matrix4_js__WEBPACK_IMPORTED_MODULE_42__["Matrix4"].prototype.flattenToArrayOffset = function ( array, offset ) {

	console.warn( 'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );
	return this.toArray( array, offset );

};

_math_Matrix4_js__WEBPACK_IMPORTED_MODULE_42__["Matrix4"].prototype.getPosition = function () {

	console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
	return new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_48__["Vector3"]().setFromMatrixColumn( this, 3 );

};

_math_Matrix4_js__WEBPACK_IMPORTED_MODULE_42__["Matrix4"].prototype.setRotationFromQuaternion = function ( q ) {

	console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
	return this.makeRotationFromQuaternion( q );

};

_math_Matrix4_js__WEBPACK_IMPORTED_MODULE_42__["Matrix4"].prototype.multiplyToArray = function () {

	console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

};

_math_Matrix4_js__WEBPACK_IMPORTED_MODULE_42__["Matrix4"].prototype.multiplyVector3 = function ( vector ) {

	console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
	return vector.applyMatrix4( this );

};

_math_Matrix4_js__WEBPACK_IMPORTED_MODULE_42__["Matrix4"].prototype.multiplyVector4 = function ( vector ) {

	console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
	return vector.applyMatrix4( this );

};

_math_Matrix4_js__WEBPACK_IMPORTED_MODULE_42__["Matrix4"].prototype.multiplyVector3Array = function ( /* a */ ) {

	console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

};

_math_Matrix4_js__WEBPACK_IMPORTED_MODULE_42__["Matrix4"].prototype.rotateAxis = function ( v ) {

	console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
	v.transformDirection( this );

};

_math_Matrix4_js__WEBPACK_IMPORTED_MODULE_42__["Matrix4"].prototype.crossVector = function ( vector ) {

	console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
	return vector.applyMatrix4( this );

};

_math_Matrix4_js__WEBPACK_IMPORTED_MODULE_42__["Matrix4"].prototype.translate = function () {

	console.error( 'THREE.Matrix4: .translate() has been removed.' );

};

_math_Matrix4_js__WEBPACK_IMPORTED_MODULE_42__["Matrix4"].prototype.rotateX = function () {

	console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

};

_math_Matrix4_js__WEBPACK_IMPORTED_MODULE_42__["Matrix4"].prototype.rotateY = function () {

	console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

};

_math_Matrix4_js__WEBPACK_IMPORTED_MODULE_42__["Matrix4"].prototype.rotateZ = function () {

	console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

};

_math_Matrix4_js__WEBPACK_IMPORTED_MODULE_42__["Matrix4"].prototype.rotateByAxis = function () {

	console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

};

_math_Matrix4_js__WEBPACK_IMPORTED_MODULE_42__["Matrix4"].prototype.applyToBufferAttribute = function ( attribute ) {

	console.warn( 'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.' );
	return attribute.applyMatrix4( this );

};

_math_Matrix4_js__WEBPACK_IMPORTED_MODULE_42__["Matrix4"].prototype.applyToVector3Array = function ( /* array, offset, length */ ) {

	console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

};

_math_Matrix4_js__WEBPACK_IMPORTED_MODULE_42__["Matrix4"].prototype.makeFrustum = function ( left, right, bottom, top, near, far ) {

	console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
	return this.makePerspective( left, right, top, bottom, near, far );

};

_math_Matrix4_js__WEBPACK_IMPORTED_MODULE_42__["Matrix4"].prototype.getInverse = function ( matrix ) {

	console.warn( 'THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
	return this.copy( matrix ).invert();

};

//

_math_Plane_js__WEBPACK_IMPORTED_MODULE_43__["Plane"].prototype.isIntersectionLine = function ( line ) {

	console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
	return this.intersectsLine( line );

};

//

_math_Quaternion_js__WEBPACK_IMPORTED_MODULE_44__["Quaternion"].prototype.multiplyVector3 = function ( vector ) {

	console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
	return vector.applyQuaternion( this );

};

_math_Quaternion_js__WEBPACK_IMPORTED_MODULE_44__["Quaternion"].prototype.inverse = function ( ) {

	console.warn( 'THREE.Quaternion: .inverse() has been renamed to invert().' );
	return this.invert();

};

//

_math_Ray_js__WEBPACK_IMPORTED_MODULE_45__["Ray"].prototype.isIntersectionBox = function ( box ) {

	console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
	return this.intersectsBox( box );

};

_math_Ray_js__WEBPACK_IMPORTED_MODULE_45__["Ray"].prototype.isIntersectionPlane = function ( plane ) {

	console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
	return this.intersectsPlane( plane );

};

_math_Ray_js__WEBPACK_IMPORTED_MODULE_45__["Ray"].prototype.isIntersectionSphere = function ( sphere ) {

	console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
	return this.intersectsSphere( sphere );

};

//

_math_Triangle_js__WEBPACK_IMPORTED_MODULE_46__["Triangle"].prototype.area = function () {

	console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
	return this.getArea();

};

_math_Triangle_js__WEBPACK_IMPORTED_MODULE_46__["Triangle"].prototype.barycoordFromPoint = function ( point, target ) {

	console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
	return this.getBarycoord( point, target );

};

_math_Triangle_js__WEBPACK_IMPORTED_MODULE_46__["Triangle"].prototype.midpoint = function ( target ) {

	console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
	return this.getMidpoint( target );

};

_math_Triangle_js__WEBPACK_IMPORTED_MODULE_46__["Triangle"].prototypenormal = function ( target ) {

	console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
	return this.getNormal( target );

};

_math_Triangle_js__WEBPACK_IMPORTED_MODULE_46__["Triangle"].prototype.plane = function ( target ) {

	console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
	return this.getPlane( target );

};

_math_Triangle_js__WEBPACK_IMPORTED_MODULE_46__["Triangle"].barycoordFromPoint = function ( point, a, b, c, target ) {

	console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
	return _math_Triangle_js__WEBPACK_IMPORTED_MODULE_46__["Triangle"].getBarycoord( point, a, b, c, target );

};

_math_Triangle_js__WEBPACK_IMPORTED_MODULE_46__["Triangle"].normal = function ( a, b, c, target ) {

	console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
	return _math_Triangle_js__WEBPACK_IMPORTED_MODULE_46__["Triangle"].getNormal( a, b, c, target );

};

//

_extras_core_Shape_js__WEBPACK_IMPORTED_MODULE_60__["Shape"].prototype.extractAllPoints = function ( divisions ) {

	console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
	return this.extractPoints( divisions );

};

_extras_core_Shape_js__WEBPACK_IMPORTED_MODULE_60__["Shape"].prototype.extrude = function ( options ) {

	console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
	return new _geometries_ExtrudeGeometry_js__WEBPACK_IMPORTED_MODULE_18__["ExtrudeGeometry"]( this, options );

};

_extras_core_Shape_js__WEBPACK_IMPORTED_MODULE_60__["Shape"].prototype.makeGeometry = function ( options ) {

	console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
	return new _geometries_ShapeGeometry_js__WEBPACK_IMPORTED_MODULE_19__["ShapeGeometry"]( this, options );

};

//

_math_Vector2_js__WEBPACK_IMPORTED_MODULE_47__["Vector2"].prototype.fromAttribute = function ( attribute, index, offset ) {

	console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
	return this.fromBufferAttribute( attribute, index, offset );

};

_math_Vector2_js__WEBPACK_IMPORTED_MODULE_47__["Vector2"].prototype.distanceToManhattan = function ( v ) {

	console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
	return this.manhattanDistanceTo( v );

};

_math_Vector2_js__WEBPACK_IMPORTED_MODULE_47__["Vector2"].prototype.lengthManhattan = function () {

	console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
	return this.manhattanLength();

};

//

_math_Vector3_js__WEBPACK_IMPORTED_MODULE_48__["Vector3"].prototype.setEulerFromRotationMatrix = function () {

	console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

};

_math_Vector3_js__WEBPACK_IMPORTED_MODULE_48__["Vector3"].prototype.setEulerFromQuaternion = function () {

	console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

};

_math_Vector3_js__WEBPACK_IMPORTED_MODULE_48__["Vector3"].prototype.getPositionFromMatrix = function ( m ) {

	console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
	return this.setFromMatrixPosition( m );

};

_math_Vector3_js__WEBPACK_IMPORTED_MODULE_48__["Vector3"].prototype.getScaleFromMatrix = function ( m ) {

	console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
	return this.setFromMatrixScale( m );

};

_math_Vector3_js__WEBPACK_IMPORTED_MODULE_48__["Vector3"].prototype.getColumnFromMatrix = function ( index, matrix ) {

	console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
	return this.setFromMatrixColumn( matrix, index );

};

_math_Vector3_js__WEBPACK_IMPORTED_MODULE_48__["Vector3"].prototype.applyProjection = function ( m ) {

	console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
	return this.applyMatrix4( m );

};

_math_Vector3_js__WEBPACK_IMPORTED_MODULE_48__["Vector3"].prototype.fromAttribute = function ( attribute, index, offset ) {

	console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
	return this.fromBufferAttribute( attribute, index, offset );

};

_math_Vector3_js__WEBPACK_IMPORTED_MODULE_48__["Vector3"].prototype.distanceToManhattan = function ( v ) {

	console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
	return this.manhattanDistanceTo( v );

};

_math_Vector3_js__WEBPACK_IMPORTED_MODULE_48__["Vector3"].prototype.lengthManhattan = function () {

	console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
	return this.manhattanLength();

};

//

_math_Vector4_js__WEBPACK_IMPORTED_MODULE_49__["Vector4"].prototype.fromAttribute = function ( attribute, index, offset ) {

	console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
	return this.fromBufferAttribute( attribute, index, offset );

};

_math_Vector4_js__WEBPACK_IMPORTED_MODULE_49__["Vector4"].prototype.lengthManhattan = function () {

	console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
	return this.manhattanLength();

};

//

_core_Object3D_js__WEBPACK_IMPORTED_MODULE_8__["Object3D"].prototype.getChildByName = function ( name ) {

	console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
	return this.getObjectByName( name );

};

_core_Object3D_js__WEBPACK_IMPORTED_MODULE_8__["Object3D"].prototype.renderDepth = function () {

	console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

};

_core_Object3D_js__WEBPACK_IMPORTED_MODULE_8__["Object3D"].prototype.translate = function ( distance, axis ) {

	console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
	return this.translateOnAxis( axis, distance );

};

_core_Object3D_js__WEBPACK_IMPORTED_MODULE_8__["Object3D"].prototype.getWorldRotation = function () {

	console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );

};

_core_Object3D_js__WEBPACK_IMPORTED_MODULE_8__["Object3D"].prototype.applyMatrix = function ( matrix ) {

	console.warn( 'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().' );
	return this.applyMatrix4( matrix );

};

Object.defineProperties( _core_Object3D_js__WEBPACK_IMPORTED_MODULE_8__["Object3D"].prototype, {

	eulerOrder: {
		get: function () {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			return this.rotation.order;

		},
		set: function ( value ) {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			this.rotation.order = value;

		}
	},
	useQuaternion: {
		get: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},
		set: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		}
	}

} );

_objects_Mesh_js__WEBPACK_IMPORTED_MODULE_50__["Mesh"].prototype.setDrawMode = function () {

	console.error( 'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

};

Object.defineProperties( _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_50__["Mesh"].prototype, {

	drawMode: {
		get: function () {

			console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.' );
			return _constants_js__WEBPACK_IMPORTED_MODULE_3__["TrianglesDrawMode"];

		},
		set: function () {

			console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

		}
	}

} );

_objects_SkinnedMesh_js__WEBPACK_IMPORTED_MODULE_54__["SkinnedMesh"].prototype.initBones = function () {

	console.error( 'THREE.SkinnedMesh: initBones() has been removed.' );

};

Object.defineProperty( _extras_core_Curve_js__WEBPACK_IMPORTED_MODULE_11__["Curve"].prototype, '__arcLengthDivisions', {

	get: function () {

		console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
		return this.arcLengthDivisions;

	},
	set: function ( value ) {

		console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
		this.arcLengthDivisions = value;

	}

} );

//

_cameras_PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__["PerspectiveCamera"].prototype.setLens = function ( focalLength, filmGauge ) {

	console.warn( 'THREE.PerspectiveCamera.setLens is deprecated. ' +
			'Use .setFocalLength and .filmGauge for a photographic setup.' );

	if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
	this.setFocalLength( focalLength );

};

//

Object.defineProperties( _lights_Light_js__WEBPACK_IMPORTED_MODULE_21__["Light"].prototype, {
	onlyShadow: {
		set: function () {

			console.warn( 'THREE.Light: .onlyShadow has been removed.' );

		}
	},
	shadowCameraFov: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
			this.shadow.camera.fov = value;

		}
	},
	shadowCameraLeft: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
			this.shadow.camera.left = value;

		}
	},
	shadowCameraRight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
			this.shadow.camera.right = value;

		}
	},
	shadowCameraTop: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
			this.shadow.camera.top = value;

		}
	},
	shadowCameraBottom: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
			this.shadow.camera.bottom = value;

		}
	},
	shadowCameraNear: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
			this.shadow.camera.near = value;

		}
	},
	shadowCameraFar: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
			this.shadow.camera.far = value;

		}
	},
	shadowCameraVisible: {
		set: function () {

			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

		}
	},
	shadowBias: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
			this.shadow.bias = value;

		}
	},
	shadowDarkness: {
		set: function () {

			console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

		}
	},
	shadowMapWidth: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
			this.shadow.mapSize.width = value;

		}
	},
	shadowMapHeight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
			this.shadow.mapSize.height = value;

		}
	}
} );

//

Object.defineProperties( _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["BufferAttribute"].prototype, {

	length: {
		get: function () {

			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
			return this.array.length;

		}
	},
	dynamic: {
		get: function () {

			console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
			return this.usage === _constants_js__WEBPACK_IMPORTED_MODULE_3__["DynamicDrawUsage"];

		},
		set: function ( /* value */ ) {

			console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
			this.setUsage( _constants_js__WEBPACK_IMPORTED_MODULE_3__["DynamicDrawUsage"] );

		}
	}

} );

_core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["BufferAttribute"].prototype.setDynamic = function ( value ) {

	console.warn( 'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.' );
	this.setUsage( value === true ? _constants_js__WEBPACK_IMPORTED_MODULE_3__["DynamicDrawUsage"] : _constants_js__WEBPACK_IMPORTED_MODULE_3__["StaticDrawUsage"] );
	return this;

};

_core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["BufferAttribute"].prototype.copyIndicesArray = function ( /* indices */ ) {

	console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );

},

_core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["BufferAttribute"].prototype.setArray = function ( /* array */ ) {

	console.error( 'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

};

//

_core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__["BufferGeometry"].prototype.addIndex = function ( index ) {

	console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
	this.setIndex( index );

};

_core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__["BufferGeometry"].prototype.addAttribute = function ( name, attribute ) {

	console.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' );

	if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

		console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

		return this.setAttribute( name, new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["BufferAttribute"]( arguments[ 1 ], arguments[ 2 ] ) );

	}

	if ( name === 'index' ) {

		console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
		this.setIndex( attribute );

		return this;

	}

	return this.setAttribute( name, attribute );

};

_core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__["BufferGeometry"].prototype.addDrawCall = function ( start, count, indexOffset ) {

	if ( indexOffset !== undefined ) {

		console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

	}

	console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
	this.addGroup( start, count );

};

_core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__["BufferGeometry"].prototype.clearDrawCalls = function () {

	console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
	this.clearGroups();

};

_core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__["BufferGeometry"].prototype.computeOffsets = function () {

	console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

};

_core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__["BufferGeometry"].prototype.removeAttribute = function ( name ) {

	console.warn( 'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().' );

	return this.deleteAttribute( name );

};

_core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__["BufferGeometry"].prototype.applyMatrix = function ( matrix ) {

	console.warn( 'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().' );
	return this.applyMatrix4( matrix );

};

Object.defineProperties( _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__["BufferGeometry"].prototype, {

	drawcalls: {
		get: function () {

			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
			return this.groups;

		}
	},
	offsets: {
		get: function () {

			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
			return this.groups;

		}
	}

} );

Object.defineProperties( _core_InstancedBufferGeometry_js__WEBPACK_IMPORTED_MODULE_6__["InstancedBufferGeometry"].prototype, {

	maxInstancedCount: {
		get: function () {

			console.warn( 'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.' );
			return this.instanceCount;

		},
		set: function ( value ) {

			console.warn( 'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.' );
			this.instanceCount = value;

		}
	}

} );

Object.defineProperties( _core_Raycaster_js__WEBPACK_IMPORTED_MODULE_10__["Raycaster"].prototype, {

	linePrecision: {
		get: function () {

			console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );
			return this.params.Line.threshold;

		},
		set: function ( value ) {

			console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );
			this.params.Line.threshold = value;

		}
	}

} );

Object.defineProperties( _core_InterleavedBuffer_js__WEBPACK_IMPORTED_MODULE_7__["InterleavedBuffer"].prototype, {

	dynamic: {
		get: function () {

			console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );
			return this.usage === _constants_js__WEBPACK_IMPORTED_MODULE_3__["DynamicDrawUsage"];

		},
		set: function ( value ) {

			console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );
			this.setUsage( value );

		}
	}

} );

_core_InterleavedBuffer_js__WEBPACK_IMPORTED_MODULE_7__["InterleavedBuffer"].prototype.setDynamic = function ( value ) {

	console.warn( 'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.' );
	this.setUsage( value === true ? _constants_js__WEBPACK_IMPORTED_MODULE_3__["DynamicDrawUsage"] : _constants_js__WEBPACK_IMPORTED_MODULE_3__["StaticDrawUsage"] );
	return this;

};

_core_InterleavedBuffer_js__WEBPACK_IMPORTED_MODULE_7__["InterleavedBuffer"].prototype.setArray = function ( /* array */ ) {

	console.error( 'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

};

//

_geometries_ExtrudeGeometry_js__WEBPACK_IMPORTED_MODULE_18__["ExtrudeGeometry"].prototype.getArrays = function () {

	console.error( 'THREE.ExtrudeGeometry: .getArrays() has been removed.' );

};

_geometries_ExtrudeGeometry_js__WEBPACK_IMPORTED_MODULE_18__["ExtrudeGeometry"].prototype.addShapeList = function () {

	console.error( 'THREE.ExtrudeGeometry: .addShapeList() has been removed.' );

};

_geometries_ExtrudeGeometry_js__WEBPACK_IMPORTED_MODULE_18__["ExtrudeGeometry"].prototype.addShape = function () {

	console.error( 'THREE.ExtrudeGeometry: .addShape() has been removed.' );

};

//

_scenes_Scene_js__WEBPACK_IMPORTED_MODULE_62__["Scene"].prototype.dispose = function () {

	console.error( 'THREE.Scene: .dispose() has been removed.' );

};

//

_core_Uniform_js__WEBPACK_IMPORTED_MODULE_9__["Uniform"].prototype.onUpdate = function () {

	console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
	return this;

};

//

Object.defineProperties( _materials_Material_js__WEBPACK_IMPORTED_MODULE_29__["Material"].prototype, {

	wrapAround: {
		get: function () {

			console.warn( 'THREE.Material: .wrapAround has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Material: .wrapAround has been removed.' );

		}
	},

	overdraw: {
		get: function () {

			console.warn( 'THREE.Material: .overdraw has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Material: .overdraw has been removed.' );

		}
	},

	wrapRGB: {
		get: function () {

			console.warn( 'THREE.Material: .wrapRGB has been removed.' );
			return new _math_Color_js__WEBPACK_IMPORTED_MODULE_37__["Color"]();

		}
	},

	shading: {
		get: function () {

			console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

		},
		set: function ( value ) {

			console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
			this.flatShading = ( value === _constants_js__WEBPACK_IMPORTED_MODULE_3__["FlatShading"] );

		}
	},

	stencilMask: {
		get: function () {

			console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
			return this.stencilFuncMask;

		},
		set: function ( value ) {

			console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
			this.stencilFuncMask = value;

		}
	}

} );

Object.defineProperties( _materials_MeshPhysicalMaterial_js__WEBPACK_IMPORTED_MODULE_31__["MeshPhysicalMaterial"].prototype, {

	transparency: {
		get: function () {

			console.warn( 'THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.' );
			return this.transmission;

		},
		set: function ( value ) {

			console.warn( 'THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.' );
			this.transmission = value;

		}
	}

} );

Object.defineProperties( _materials_ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_33__["ShaderMaterial"].prototype, {

	derivatives: {
		get: function () {

			console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			return this.extensions.derivatives;

		},
		set: function ( value ) {

			console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			this.extensions.derivatives = value;

		}
	}

} );

//

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.clearTarget = function ( renderTarget, color, depth, stencil ) {

	console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );
	this.setRenderTarget( renderTarget );
	this.clear( color, depth, stencil );

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.animate = function ( callback ) {

	console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
	this.setAnimationLoop( callback );

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.getCurrentRenderTarget = function () {

	console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
	return this.getRenderTarget();

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.getMaxAnisotropy = function () {

	console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
	return this.capabilities.getMaxAnisotropy();

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.getPrecision = function () {

	console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
	return this.capabilities.precision;

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.resetGLState = function () {

	console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
	return this.state.reset();

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.supportsFloatTextures = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
	return this.extensions.get( 'OES_texture_float' );

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.supportsHalfFloatTextures = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
	return this.extensions.get( 'OES_texture_half_float' );

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.supportsStandardDerivatives = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
	return this.extensions.get( 'OES_standard_derivatives' );

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.supportsCompressedTextureS3TC = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
	return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.supportsCompressedTexturePVRTC = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
	return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.supportsBlendMinMax = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
	return this.extensions.get( 'EXT_blend_minmax' );

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.supportsVertexTextures = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
	return this.capabilities.vertexTextures;

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.supportsInstancedArrays = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
	return this.extensions.get( 'ANGLE_instanced_arrays' );

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.enableScissorTest = function ( boolean ) {

	console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
	this.setScissorTest( boolean );

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.initMaterial = function () {

	console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.addPrePlugin = function () {

	console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.addPostPlugin = function () {

	console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.updateShadowMap = function () {

	console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.setFaceCulling = function () {

	console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.allocTextureUnit = function () {

	console.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.setTexture = function () {

	console.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.setTexture2D = function () {

	console.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.setTextureCube = function () {

	console.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );

};

_renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype.getActiveMipMapLevel = function () {

	console.warn( 'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().' );
	return this.getActiveMipmapLevel();

};

Object.defineProperties( _renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_55__["WebGLRenderer"].prototype, {

	shadowMapEnabled: {
		get: function () {

			return this.shadowMap.enabled;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
			this.shadowMap.enabled = value;

		}
	},
	shadowMapType: {
		get: function () {

			return this.shadowMap.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
			this.shadowMap.type = value;

		}
	},
	shadowMapCullFace: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function ( /* value */ ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

		}
	},
	context: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.' );
			return this.getContext();

		}
	},
	vr: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .vr has been renamed to .xr' );
			return this.xr;

		}
	},
	gammaInput: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );
			return false;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );

		}
	},
	gammaOutput: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
			return false;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
			this.outputEncoding = ( value === true ) ? _constants_js__WEBPACK_IMPORTED_MODULE_3__["sRGBEncoding"] : _constants_js__WEBPACK_IMPORTED_MODULE_3__["LinearEncoding"];

		}
	},
	toneMappingWhitePoint: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );
			return 1.0;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );

		}
	},

} );

Object.defineProperties( _renderers_webgl_WebGLShadowMap_js__WEBPACK_IMPORTED_MODULE_58__["WebGLShadowMap"].prototype, {

	cullFace: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function ( /* cullFace */ ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

		}
	},
	renderReverseSided: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

		}
	},
	renderSingleSided: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

		}
	}

} );

function WebGLRenderTargetCube( width, height, options ) {

	console.warn( 'THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).' );
	return new _renderers_WebGLCubeRenderTarget_js__WEBPACK_IMPORTED_MODULE_57__["WebGLCubeRenderTarget"]( width, options );

}

//

Object.defineProperties( _renderers_WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_56__["WebGLRenderTarget"].prototype, {

	wrapS: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			return this.texture.wrapS;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			this.texture.wrapS = value;

		}
	},
	wrapT: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			return this.texture.wrapT;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			this.texture.wrapT = value;

		}
	},
	magFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			return this.texture.magFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			this.texture.magFilter = value;

		}
	},
	minFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			return this.texture.minFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			this.texture.minFilter = value;

		}
	},
	anisotropy: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			return this.texture.anisotropy;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			this.texture.anisotropy = value;

		}
	},
	offset: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			return this.texture.offset;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			this.texture.offset = value;

		}
	},
	repeat: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			return this.texture.repeat;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			this.texture.repeat = value;

		}
	},
	format: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			return this.texture.format;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			this.texture.format = value;

		}
	},
	type: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			return this.texture.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			this.texture.type = value;

		}
	},
	generateMipmaps: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			return this.texture.generateMipmaps;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			this.texture.generateMipmaps = value;

		}
	}

} );

//

_audio_Audio_js__WEBPACK_IMPORTED_MODULE_0__["Audio"].prototype.load = function ( file ) {

	console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
	const scope = this;
	const audioLoader = new _loaders_AudioLoader_js__WEBPACK_IMPORTED_MODULE_25__["AudioLoader"]();
	audioLoader.load( file, function ( buffer ) {

		scope.setBuffer( buffer );

	} );
	return this;

};


_audio_AudioAnalyser_js__WEBPACK_IMPORTED_MODULE_1__["AudioAnalyser"].prototype.getData = function () {

	console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
	return this.getFrequencyData();

};

//

_cameras_CubeCamera_js__WEBPACK_IMPORTED_MODULE_61__["CubeCamera"].prototype.updateCubeMap = function ( renderer, scene ) {

	console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
	return this.update( renderer, scene );

};

_cameras_CubeCamera_js__WEBPACK_IMPORTED_MODULE_61__["CubeCamera"].prototype.clear = function ( renderer, color, depth, stencil ) {

	console.warn( 'THREE.CubeCamera: .clear() is now .renderTarget.clear().' );
	return this.renderTarget.clear( renderer, color, depth, stencil );

};

_extras_ImageUtils_js__WEBPACK_IMPORTED_MODULE_59__["ImageUtils"].crossOrigin = undefined;

_extras_ImageUtils_js__WEBPACK_IMPORTED_MODULE_59__["ImageUtils"].loadTexture = function ( url, mapping, onLoad, onError ) {

	console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

	const loader = new _loaders_TextureLoader_js__WEBPACK_IMPORTED_MODULE_28__["TextureLoader"]();
	loader.setCrossOrigin( this.crossOrigin );

	const texture = loader.load( url, onLoad, undefined, onError );

	if ( mapping ) texture.mapping = mapping;

	return texture;

};

_extras_ImageUtils_js__WEBPACK_IMPORTED_MODULE_59__["ImageUtils"].loadTextureCube = function ( urls, mapping, onLoad, onError ) {

	console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

	const loader = new _loaders_CubeTextureLoader_js__WEBPACK_IMPORTED_MODULE_26__["CubeTextureLoader"]();
	loader.setCrossOrigin( this.crossOrigin );

	const texture = loader.load( urls, onLoad, undefined, onError );

	if ( mapping ) texture.mapping = mapping;

	return texture;

};

_extras_ImageUtils_js__WEBPACK_IMPORTED_MODULE_59__["ImageUtils"].loadCompressedTexture = function () {

	console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

};

_extras_ImageUtils_js__WEBPACK_IMPORTED_MODULE_59__["ImageUtils"].loadCompressedTextureCube = function () {

	console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

};

//

function CanvasRenderer() {

	console.error( 'THREE.CanvasRenderer has been removed' );

}

//

function JSONLoader() {

	console.error( 'THREE.JSONLoader has been removed.' );

}

//

const SceneUtils = {

	createMultiMaterialObject: function ( /* geometry, materials */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	},

	detach: function ( /* child, parent, scene */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	},

	attach: function ( /* child, scene, parent */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	}

};

//

function LensFlare() {

	console.error( 'THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js' );

}


/***/ }),

/***/ "../../node_modules/three/src/Three.js":
/*!*************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/Three.js ***!
  \*************************************************************/
/*! exports provided: WebGLMultisampleRenderTarget, WebGLCubeRenderTarget, WebGLRenderTarget, WebGLRenderer, WebGL1Renderer, ShaderLib, UniformsLib, UniformsUtils, ShaderChunk, FogExp2, Fog, Scene, Sprite, LOD, SkinnedMesh, Skeleton, Bone, Mesh, InstancedMesh, LineSegments, LineLoop, Line, Points, Group, VideoTexture, DataTexture, DataTexture2DArray, DataTexture3D, CompressedTexture, CubeTexture, CanvasTexture, DepthTexture, Texture, BoxGeometry, BoxBufferGeometry, CircleGeometry, CircleBufferGeometry, ConeGeometry, ConeBufferGeometry, CylinderGeometry, CylinderBufferGeometry, DodecahedronGeometry, DodecahedronBufferGeometry, EdgesGeometry, ExtrudeGeometry, ExtrudeBufferGeometry, IcosahedronGeometry, IcosahedronBufferGeometry, LatheGeometry, LatheBufferGeometry, OctahedronGeometry, OctahedronBufferGeometry, ParametricGeometry, ParametricBufferGeometry, PlaneGeometry, PlaneBufferGeometry, PolyhedronGeometry, PolyhedronBufferGeometry, RingGeometry, RingBufferGeometry, ShapeGeometry, ShapeBufferGeometry, SphereGeometry, SphereBufferGeometry, TetrahedronGeometry, TetrahedronBufferGeometry, TextGeometry, TextBufferGeometry, TorusGeometry, TorusBufferGeometry, TorusKnotGeometry, TorusKnotBufferGeometry, TubeGeometry, TubeBufferGeometry, WireframeGeometry, ShadowMaterial, SpriteMaterial, RawShaderMaterial, ShaderMaterial, PointsMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshPhongMaterial, MeshToonMaterial, MeshNormalMaterial, MeshLambertMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshBasicMaterial, MeshMatcapMaterial, LineDashedMaterial, LineBasicMaterial, Material, AnimationLoader, CompressedTextureLoader, CubeTextureLoader, DataTextureLoader, TextureLoader, ObjectLoader, MaterialLoader, BufferGeometryLoader, DefaultLoadingManager, LoadingManager, ImageLoader, ImageBitmapLoader, FontLoader, FileLoader, Loader, LoaderUtils, Cache, AudioLoader, SpotLight, PointLight, RectAreaLight, HemisphereLight, HemisphereLightProbe, DirectionalLight, AmbientLight, AmbientLightProbe, Light, LightProbe, StereoCamera, PerspectiveCamera, OrthographicCamera, CubeCamera, ArrayCamera, Camera, AudioListener, PositionalAudio, AudioContext, AudioAnalyser, Audio, VectorKeyframeTrack, StringKeyframeTrack, QuaternionKeyframeTrack, NumberKeyframeTrack, ColorKeyframeTrack, BooleanKeyframeTrack, PropertyMixer, PropertyBinding, KeyframeTrack, AnimationUtils, AnimationObjectGroup, AnimationMixer, AnimationClip, Uniform, InstancedBufferGeometry, BufferGeometry, InterleavedBufferAttribute, InstancedInterleavedBuffer, InterleavedBuffer, InstancedBufferAttribute, GLBufferAttribute, Float64BufferAttribute, Float32BufferAttribute, Float16BufferAttribute, Uint32BufferAttribute, Int32BufferAttribute, Uint16BufferAttribute, Int16BufferAttribute, Uint8ClampedBufferAttribute, Uint8BufferAttribute, Int8BufferAttribute, BufferAttribute, Object3D, Raycaster, Layers, EventDispatcher, Clock, QuaternionLinearInterpolant, LinearInterpolant, DiscreteInterpolant, CubicInterpolant, Interpolant, Triangle, MathUtils, Spherical, Cylindrical, Plane, Frustum, Sphere, Ray, Matrix4, Matrix3, Box3, Box2, Line3, Euler, Vector4, Vector3, Vector2, Quaternion, Color, SphericalHarmonics3, ImmediateRenderObject, SpotLightHelper, SkeletonHelper, PointLightHelper, HemisphereLightHelper, GridHelper, PolarGridHelper, DirectionalLightHelper, CameraHelper, BoxHelper, Box3Helper, PlaneHelper, ArrowHelper, AxesHelper, ArcCurve, CatmullRomCurve3, CubicBezierCurve, CubicBezierCurve3, EllipseCurve, LineCurve, LineCurve3, QuadraticBezierCurve, QuadraticBezierCurve3, SplineCurve, Shape, Path, ShapePath, Font, CurvePath, Curve, DataUtils, ImageUtils, ShapeUtils, PMREMGenerator, WebGLUtils, REVISION, MOUSE, TOUCH, CullFaceNone, CullFaceBack, CullFaceFront, CullFaceFrontBack, BasicShadowMap, PCFShadowMap, PCFSoftShadowMap, VSMShadowMap, FrontSide, BackSide, DoubleSide, FlatShading, SmoothShading, NoBlending, NormalBlending, AdditiveBlending, SubtractiveBlending, MultiplyBlending, CustomBlending, AddEquation, SubtractEquation, ReverseSubtractEquation, MinEquation, MaxEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor, DstColorFactor, OneMinusDstColorFactor, SrcAlphaSaturateFactor, NeverDepth, AlwaysDepth, LessDepth, LessEqualDepth, EqualDepth, GreaterEqualDepth, GreaterDepth, NotEqualDepth, MultiplyOperation, MixOperation, AddOperation, NoToneMapping, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, ACESFilmicToneMapping, CustomToneMapping, UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, CubeUVReflectionMapping, CubeUVRefractionMapping, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipMapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipMapLinearFilter, UnsignedByteType, ByteType, ShortType, UnsignedShortType, IntType, UnsignedIntType, FloatType, HalfFloatType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedInt248Type, AlphaFormat, RGBFormat, RGBAFormat, LuminanceFormat, LuminanceAlphaFormat, RGBEFormat, DepthFormat, DepthStencilFormat, RedFormat, RedIntegerFormat, RGFormat, RGIntegerFormat, RGBIntegerFormat, RGBAIntegerFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_BPTC_Format, SRGB8_ALPHA8_ASTC_4x4_Format, SRGB8_ALPHA8_ASTC_5x4_Format, SRGB8_ALPHA8_ASTC_5x5_Format, SRGB8_ALPHA8_ASTC_6x5_Format, SRGB8_ALPHA8_ASTC_6x6_Format, SRGB8_ALPHA8_ASTC_8x5_Format, SRGB8_ALPHA8_ASTC_8x6_Format, SRGB8_ALPHA8_ASTC_8x8_Format, SRGB8_ALPHA8_ASTC_10x5_Format, SRGB8_ALPHA8_ASTC_10x6_Format, SRGB8_ALPHA8_ASTC_10x8_Format, SRGB8_ALPHA8_ASTC_10x10_Format, SRGB8_ALPHA8_ASTC_12x10_Format, SRGB8_ALPHA8_ASTC_12x12_Format, LoopOnce, LoopRepeat, LoopPingPong, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, ZeroCurvatureEnding, ZeroSlopeEnding, WrapAroundEnding, NormalAnimationBlendMode, AdditiveAnimationBlendMode, TrianglesDrawMode, TriangleStripDrawMode, TriangleFanDrawMode, LinearEncoding, sRGBEncoding, GammaEncoding, RGBEEncoding, LogLuvEncoding, RGBM7Encoding, RGBM16Encoding, RGBDEncoding, BasicDepthPacking, RGBADepthPacking, TangentSpaceNormalMap, ObjectSpaceNormalMap, ZeroStencilOp, KeepStencilOp, ReplaceStencilOp, IncrementStencilOp, DecrementStencilOp, IncrementWrapStencilOp, DecrementWrapStencilOp, InvertStencilOp, NeverStencilFunc, LessStencilFunc, EqualStencilFunc, LessEqualStencilFunc, GreaterStencilFunc, NotEqualStencilFunc, GreaterEqualStencilFunc, AlwaysStencilFunc, StaticDrawUsage, DynamicDrawUsage, StreamDrawUsage, StaticReadUsage, DynamicReadUsage, StreamReadUsage, StaticCopyUsage, DynamicCopyUsage, StreamCopyUsage, GLSL1, GLSL3, Math, LineStrip, LinePieces, NoColors, FaceColors, VertexColors, MeshFaceMaterial, MultiMaterial, PointCloud, Particle, ParticleSystem, PointCloudMaterial, ParticleBasicMaterial, ParticleSystemMaterial, Vertex, DynamicBufferAttribute, Int8Attribute, Uint8Attribute, Uint8ClampedAttribute, Int16Attribute, Uint16Attribute, Int32Attribute, Uint32Attribute, Float32Attribute, Float64Attribute, AxisHelper, BoundingBoxHelper, EdgesHelper, WireframeHelper, XHRLoader, BinaryTextureLoader, WebGLRenderTargetCube, CanvasRenderer, JSONLoader, SceneUtils, LensFlare */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _renderers_WebGLMultisampleRenderTarget_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./renderers/WebGLMultisampleRenderTarget.js */ "../../node_modules/three/src/renderers/WebGLMultisampleRenderTarget.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLMultisampleRenderTarget", function() { return _renderers_WebGLMultisampleRenderTarget_js__WEBPACK_IMPORTED_MODULE_1__["WebGLMultisampleRenderTarget"]; });

/* harmony import */ var _renderers_WebGLCubeRenderTarget_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderers/WebGLCubeRenderTarget.js */ "../../node_modules/three/src/renderers/WebGLCubeRenderTarget.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLCubeRenderTarget", function() { return _renderers_WebGLCubeRenderTarget_js__WEBPACK_IMPORTED_MODULE_2__["WebGLCubeRenderTarget"]; });

/* harmony import */ var _renderers_WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./renderers/WebGLRenderTarget.js */ "../../node_modules/three/src/renderers/WebGLRenderTarget.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTarget", function() { return _renderers_WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_3__["WebGLRenderTarget"]; });

/* harmony import */ var _renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./renderers/WebGLRenderer.js */ "../../node_modules/three/src/renderers/WebGLRenderer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderer", function() { return _renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_4__["WebGLRenderer"]; });

/* harmony import */ var _renderers_WebGL1Renderer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./renderers/WebGL1Renderer.js */ "../../node_modules/three/src/renderers/WebGL1Renderer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGL1Renderer", function() { return _renderers_WebGL1Renderer_js__WEBPACK_IMPORTED_MODULE_5__["WebGL1Renderer"]; });

/* harmony import */ var _renderers_shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./renderers/shaders/ShaderLib.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShaderLib", function() { return _renderers_shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_6__["ShaderLib"]; });

/* harmony import */ var _renderers_shaders_UniformsLib_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./renderers/shaders/UniformsLib.js */ "../../node_modules/three/src/renderers/shaders/UniformsLib.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UniformsLib", function() { return _renderers_shaders_UniformsLib_js__WEBPACK_IMPORTED_MODULE_7__["UniformsLib"]; });

/* harmony import */ var _renderers_shaders_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./renderers/shaders/UniformsUtils.js */ "../../node_modules/three/src/renderers/shaders/UniformsUtils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UniformsUtils", function() { return _renderers_shaders_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_8__["UniformsUtils"]; });

/* harmony import */ var _renderers_shaders_ShaderChunk_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./renderers/shaders/ShaderChunk.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShaderChunk", function() { return _renderers_shaders_ShaderChunk_js__WEBPACK_IMPORTED_MODULE_9__["ShaderChunk"]; });

/* harmony import */ var _scenes_FogExp2_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./scenes/FogExp2.js */ "../../node_modules/three/src/scenes/FogExp2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FogExp2", function() { return _scenes_FogExp2_js__WEBPACK_IMPORTED_MODULE_10__["FogExp2"]; });

/* harmony import */ var _scenes_Fog_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./scenes/Fog.js */ "../../node_modules/three/src/scenes/Fog.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Fog", function() { return _scenes_Fog_js__WEBPACK_IMPORTED_MODULE_11__["Fog"]; });

/* harmony import */ var _scenes_Scene_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./scenes/Scene.js */ "../../node_modules/three/src/scenes/Scene.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Scene", function() { return _scenes_Scene_js__WEBPACK_IMPORTED_MODULE_12__["Scene"]; });

/* harmony import */ var _objects_Sprite_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./objects/Sprite.js */ "../../node_modules/three/src/objects/Sprite.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Sprite", function() { return _objects_Sprite_js__WEBPACK_IMPORTED_MODULE_13__["Sprite"]; });

/* harmony import */ var _objects_LOD_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./objects/LOD.js */ "../../node_modules/three/src/objects/LOD.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LOD", function() { return _objects_LOD_js__WEBPACK_IMPORTED_MODULE_14__["LOD"]; });

/* harmony import */ var _objects_SkinnedMesh_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./objects/SkinnedMesh.js */ "../../node_modules/three/src/objects/SkinnedMesh.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SkinnedMesh", function() { return _objects_SkinnedMesh_js__WEBPACK_IMPORTED_MODULE_15__["SkinnedMesh"]; });

/* harmony import */ var _objects_Skeleton_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./objects/Skeleton.js */ "../../node_modules/three/src/objects/Skeleton.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Skeleton", function() { return _objects_Skeleton_js__WEBPACK_IMPORTED_MODULE_16__["Skeleton"]; });

/* harmony import */ var _objects_Bone_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./objects/Bone.js */ "../../node_modules/three/src/objects/Bone.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Bone", function() { return _objects_Bone_js__WEBPACK_IMPORTED_MODULE_17__["Bone"]; });

/* harmony import */ var _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./objects/Mesh.js */ "../../node_modules/three/src/objects/Mesh.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Mesh", function() { return _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_18__["Mesh"]; });

/* harmony import */ var _objects_InstancedMesh_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./objects/InstancedMesh.js */ "../../node_modules/three/src/objects/InstancedMesh.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InstancedMesh", function() { return _objects_InstancedMesh_js__WEBPACK_IMPORTED_MODULE_19__["InstancedMesh"]; });

/* harmony import */ var _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./objects/LineSegments.js */ "../../node_modules/three/src/objects/LineSegments.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LineSegments", function() { return _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_20__["LineSegments"]; });

/* harmony import */ var _objects_LineLoop_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./objects/LineLoop.js */ "../../node_modules/three/src/objects/LineLoop.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LineLoop", function() { return _objects_LineLoop_js__WEBPACK_IMPORTED_MODULE_21__["LineLoop"]; });

/* harmony import */ var _objects_Line_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./objects/Line.js */ "../../node_modules/three/src/objects/Line.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return _objects_Line_js__WEBPACK_IMPORTED_MODULE_22__["Line"]; });

/* harmony import */ var _objects_Points_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./objects/Points.js */ "../../node_modules/three/src/objects/Points.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Points", function() { return _objects_Points_js__WEBPACK_IMPORTED_MODULE_23__["Points"]; });

/* harmony import */ var _objects_Group_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./objects/Group.js */ "../../node_modules/three/src/objects/Group.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Group", function() { return _objects_Group_js__WEBPACK_IMPORTED_MODULE_24__["Group"]; });

/* harmony import */ var _textures_VideoTexture_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./textures/VideoTexture.js */ "../../node_modules/three/src/textures/VideoTexture.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VideoTexture", function() { return _textures_VideoTexture_js__WEBPACK_IMPORTED_MODULE_25__["VideoTexture"]; });

/* harmony import */ var _textures_DataTexture_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./textures/DataTexture.js */ "../../node_modules/three/src/textures/DataTexture.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataTexture", function() { return _textures_DataTexture_js__WEBPACK_IMPORTED_MODULE_26__["DataTexture"]; });

/* harmony import */ var _textures_DataTexture2DArray_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./textures/DataTexture2DArray.js */ "../../node_modules/three/src/textures/DataTexture2DArray.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataTexture2DArray", function() { return _textures_DataTexture2DArray_js__WEBPACK_IMPORTED_MODULE_27__["DataTexture2DArray"]; });

/* harmony import */ var _textures_DataTexture3D_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./textures/DataTexture3D.js */ "../../node_modules/three/src/textures/DataTexture3D.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataTexture3D", function() { return _textures_DataTexture3D_js__WEBPACK_IMPORTED_MODULE_28__["DataTexture3D"]; });

/* harmony import */ var _textures_CompressedTexture_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./textures/CompressedTexture.js */ "../../node_modules/three/src/textures/CompressedTexture.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CompressedTexture", function() { return _textures_CompressedTexture_js__WEBPACK_IMPORTED_MODULE_29__["CompressedTexture"]; });

/* harmony import */ var _textures_CubeTexture_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./textures/CubeTexture.js */ "../../node_modules/three/src/textures/CubeTexture.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CubeTexture", function() { return _textures_CubeTexture_js__WEBPACK_IMPORTED_MODULE_30__["CubeTexture"]; });

/* harmony import */ var _textures_CanvasTexture_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./textures/CanvasTexture.js */ "../../node_modules/three/src/textures/CanvasTexture.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CanvasTexture", function() { return _textures_CanvasTexture_js__WEBPACK_IMPORTED_MODULE_31__["CanvasTexture"]; });

/* harmony import */ var _textures_DepthTexture_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./textures/DepthTexture.js */ "../../node_modules/three/src/textures/DepthTexture.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DepthTexture", function() { return _textures_DepthTexture_js__WEBPACK_IMPORTED_MODULE_32__["DepthTexture"]; });

/* harmony import */ var _textures_Texture_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./textures/Texture.js */ "../../node_modules/three/src/textures/Texture.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Texture", function() { return _textures_Texture_js__WEBPACK_IMPORTED_MODULE_33__["Texture"]; });

/* harmony import */ var _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./geometries/Geometries.js */ "../../node_modules/three/src/geometries/Geometries.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BoxGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["BoxGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BoxBufferGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["BoxBufferGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CircleGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["CircleGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CircleBufferGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["CircleBufferGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ConeGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["ConeGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ConeBufferGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["ConeBufferGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CylinderGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["CylinderGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CylinderBufferGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["CylinderBufferGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DodecahedronGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["DodecahedronGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DodecahedronBufferGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["DodecahedronBufferGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EdgesGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["EdgesGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ExtrudeGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["ExtrudeGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ExtrudeBufferGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["ExtrudeBufferGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IcosahedronGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["IcosahedronGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IcosahedronBufferGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["IcosahedronBufferGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LatheGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["LatheGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LatheBufferGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["LatheBufferGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OctahedronGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["OctahedronGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OctahedronBufferGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["OctahedronBufferGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ParametricGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["ParametricGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ParametricBufferGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["ParametricBufferGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PlaneGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["PlaneGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PlaneBufferGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["PlaneBufferGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PolyhedronGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["PolyhedronGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PolyhedronBufferGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["PolyhedronBufferGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RingGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["RingGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RingBufferGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["RingBufferGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShapeGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["ShapeGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShapeBufferGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["ShapeBufferGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SphereGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["SphereGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SphereBufferGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["SphereBufferGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TetrahedronGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["TetrahedronGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TetrahedronBufferGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["TetrahedronBufferGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["TextGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextBufferGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["TextBufferGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TorusGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["TorusGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TorusBufferGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["TorusBufferGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TorusKnotGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["TorusKnotGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TorusKnotBufferGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["TorusKnotBufferGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TubeGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["TubeGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TubeBufferGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["TubeBufferGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WireframeGeometry", function() { return _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_34__["WireframeGeometry"]; });

/* harmony import */ var _materials_Materials_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./materials/Materials.js */ "../../node_modules/three/src/materials/Materials.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShadowMaterial", function() { return _materials_Materials_js__WEBPACK_IMPORTED_MODULE_35__["ShadowMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SpriteMaterial", function() { return _materials_Materials_js__WEBPACK_IMPORTED_MODULE_35__["SpriteMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RawShaderMaterial", function() { return _materials_Materials_js__WEBPACK_IMPORTED_MODULE_35__["RawShaderMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShaderMaterial", function() { return _materials_Materials_js__WEBPACK_IMPORTED_MODULE_35__["ShaderMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointsMaterial", function() { return _materials_Materials_js__WEBPACK_IMPORTED_MODULE_35__["PointsMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshPhysicalMaterial", function() { return _materials_Materials_js__WEBPACK_IMPORTED_MODULE_35__["MeshPhysicalMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshStandardMaterial", function() { return _materials_Materials_js__WEBPACK_IMPORTED_MODULE_35__["MeshStandardMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshPhongMaterial", function() { return _materials_Materials_js__WEBPACK_IMPORTED_MODULE_35__["MeshPhongMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshToonMaterial", function() { return _materials_Materials_js__WEBPACK_IMPORTED_MODULE_35__["MeshToonMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshNormalMaterial", function() { return _materials_Materials_js__WEBPACK_IMPORTED_MODULE_35__["MeshNormalMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshLambertMaterial", function() { return _materials_Materials_js__WEBPACK_IMPORTED_MODULE_35__["MeshLambertMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshDepthMaterial", function() { return _materials_Materials_js__WEBPACK_IMPORTED_MODULE_35__["MeshDepthMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshDistanceMaterial", function() { return _materials_Materials_js__WEBPACK_IMPORTED_MODULE_35__["MeshDistanceMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshBasicMaterial", function() { return _materials_Materials_js__WEBPACK_IMPORTED_MODULE_35__["MeshBasicMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshMatcapMaterial", function() { return _materials_Materials_js__WEBPACK_IMPORTED_MODULE_35__["MeshMatcapMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LineDashedMaterial", function() { return _materials_Materials_js__WEBPACK_IMPORTED_MODULE_35__["LineDashedMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LineBasicMaterial", function() { return _materials_Materials_js__WEBPACK_IMPORTED_MODULE_35__["LineBasicMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Material", function() { return _materials_Materials_js__WEBPACK_IMPORTED_MODULE_35__["Material"]; });

/* harmony import */ var _loaders_AnimationLoader_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./loaders/AnimationLoader.js */ "../../node_modules/three/src/loaders/AnimationLoader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimationLoader", function() { return _loaders_AnimationLoader_js__WEBPACK_IMPORTED_MODULE_36__["AnimationLoader"]; });

/* harmony import */ var _loaders_CompressedTextureLoader_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./loaders/CompressedTextureLoader.js */ "../../node_modules/three/src/loaders/CompressedTextureLoader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CompressedTextureLoader", function() { return _loaders_CompressedTextureLoader_js__WEBPACK_IMPORTED_MODULE_37__["CompressedTextureLoader"]; });

/* harmony import */ var _loaders_CubeTextureLoader_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./loaders/CubeTextureLoader.js */ "../../node_modules/three/src/loaders/CubeTextureLoader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CubeTextureLoader", function() { return _loaders_CubeTextureLoader_js__WEBPACK_IMPORTED_MODULE_38__["CubeTextureLoader"]; });

/* harmony import */ var _loaders_DataTextureLoader_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./loaders/DataTextureLoader.js */ "../../node_modules/three/src/loaders/DataTextureLoader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataTextureLoader", function() { return _loaders_DataTextureLoader_js__WEBPACK_IMPORTED_MODULE_39__["DataTextureLoader"]; });

/* harmony import */ var _loaders_TextureLoader_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./loaders/TextureLoader.js */ "../../node_modules/three/src/loaders/TextureLoader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextureLoader", function() { return _loaders_TextureLoader_js__WEBPACK_IMPORTED_MODULE_40__["TextureLoader"]; });

/* harmony import */ var _loaders_ObjectLoader_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./loaders/ObjectLoader.js */ "../../node_modules/three/src/loaders/ObjectLoader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ObjectLoader", function() { return _loaders_ObjectLoader_js__WEBPACK_IMPORTED_MODULE_41__["ObjectLoader"]; });

/* harmony import */ var _loaders_MaterialLoader_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./loaders/MaterialLoader.js */ "../../node_modules/three/src/loaders/MaterialLoader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MaterialLoader", function() { return _loaders_MaterialLoader_js__WEBPACK_IMPORTED_MODULE_42__["MaterialLoader"]; });

/* harmony import */ var _loaders_BufferGeometryLoader_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./loaders/BufferGeometryLoader.js */ "../../node_modules/three/src/loaders/BufferGeometryLoader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BufferGeometryLoader", function() { return _loaders_BufferGeometryLoader_js__WEBPACK_IMPORTED_MODULE_43__["BufferGeometryLoader"]; });

/* harmony import */ var _loaders_LoadingManager_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./loaders/LoadingManager.js */ "../../node_modules/three/src/loaders/LoadingManager.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DefaultLoadingManager", function() { return _loaders_LoadingManager_js__WEBPACK_IMPORTED_MODULE_44__["DefaultLoadingManager"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LoadingManager", function() { return _loaders_LoadingManager_js__WEBPACK_IMPORTED_MODULE_44__["LoadingManager"]; });

/* harmony import */ var _loaders_ImageLoader_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./loaders/ImageLoader.js */ "../../node_modules/three/src/loaders/ImageLoader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageLoader", function() { return _loaders_ImageLoader_js__WEBPACK_IMPORTED_MODULE_45__["ImageLoader"]; });

/* harmony import */ var _loaders_ImageBitmapLoader_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./loaders/ImageBitmapLoader.js */ "../../node_modules/three/src/loaders/ImageBitmapLoader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageBitmapLoader", function() { return _loaders_ImageBitmapLoader_js__WEBPACK_IMPORTED_MODULE_46__["ImageBitmapLoader"]; });

/* harmony import */ var _loaders_FontLoader_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./loaders/FontLoader.js */ "../../node_modules/three/src/loaders/FontLoader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FontLoader", function() { return _loaders_FontLoader_js__WEBPACK_IMPORTED_MODULE_47__["FontLoader"]; });

/* harmony import */ var _loaders_FileLoader_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./loaders/FileLoader.js */ "../../node_modules/three/src/loaders/FileLoader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FileLoader", function() { return _loaders_FileLoader_js__WEBPACK_IMPORTED_MODULE_48__["FileLoader"]; });

/* harmony import */ var _loaders_Loader_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./loaders/Loader.js */ "../../node_modules/three/src/loaders/Loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Loader", function() { return _loaders_Loader_js__WEBPACK_IMPORTED_MODULE_49__["Loader"]; });

/* harmony import */ var _loaders_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./loaders/LoaderUtils.js */ "../../node_modules/three/src/loaders/LoaderUtils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LoaderUtils", function() { return _loaders_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_50__["LoaderUtils"]; });

/* harmony import */ var _loaders_Cache_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./loaders/Cache.js */ "../../node_modules/three/src/loaders/Cache.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Cache", function() { return _loaders_Cache_js__WEBPACK_IMPORTED_MODULE_51__["Cache"]; });

/* harmony import */ var _loaders_AudioLoader_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./loaders/AudioLoader.js */ "../../node_modules/three/src/loaders/AudioLoader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AudioLoader", function() { return _loaders_AudioLoader_js__WEBPACK_IMPORTED_MODULE_52__["AudioLoader"]; });

/* harmony import */ var _lights_SpotLight_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./lights/SpotLight.js */ "../../node_modules/three/src/lights/SpotLight.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SpotLight", function() { return _lights_SpotLight_js__WEBPACK_IMPORTED_MODULE_53__["SpotLight"]; });

/* harmony import */ var _lights_PointLight_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./lights/PointLight.js */ "../../node_modules/three/src/lights/PointLight.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointLight", function() { return _lights_PointLight_js__WEBPACK_IMPORTED_MODULE_54__["PointLight"]; });

/* harmony import */ var _lights_RectAreaLight_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./lights/RectAreaLight.js */ "../../node_modules/three/src/lights/RectAreaLight.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RectAreaLight", function() { return _lights_RectAreaLight_js__WEBPACK_IMPORTED_MODULE_55__["RectAreaLight"]; });

/* harmony import */ var _lights_HemisphereLight_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./lights/HemisphereLight.js */ "../../node_modules/three/src/lights/HemisphereLight.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HemisphereLight", function() { return _lights_HemisphereLight_js__WEBPACK_IMPORTED_MODULE_56__["HemisphereLight"]; });

/* harmony import */ var _lights_HemisphereLightProbe_js__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./lights/HemisphereLightProbe.js */ "../../node_modules/three/src/lights/HemisphereLightProbe.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HemisphereLightProbe", function() { return _lights_HemisphereLightProbe_js__WEBPACK_IMPORTED_MODULE_57__["HemisphereLightProbe"]; });

/* harmony import */ var _lights_DirectionalLight_js__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./lights/DirectionalLight.js */ "../../node_modules/three/src/lights/DirectionalLight.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DirectionalLight", function() { return _lights_DirectionalLight_js__WEBPACK_IMPORTED_MODULE_58__["DirectionalLight"]; });

/* harmony import */ var _lights_AmbientLight_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./lights/AmbientLight.js */ "../../node_modules/three/src/lights/AmbientLight.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AmbientLight", function() { return _lights_AmbientLight_js__WEBPACK_IMPORTED_MODULE_59__["AmbientLight"]; });

/* harmony import */ var _lights_AmbientLightProbe_js__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./lights/AmbientLightProbe.js */ "../../node_modules/three/src/lights/AmbientLightProbe.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AmbientLightProbe", function() { return _lights_AmbientLightProbe_js__WEBPACK_IMPORTED_MODULE_60__["AmbientLightProbe"]; });

/* harmony import */ var _lights_Light_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./lights/Light.js */ "../../node_modules/three/src/lights/Light.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Light", function() { return _lights_Light_js__WEBPACK_IMPORTED_MODULE_61__["Light"]; });

/* harmony import */ var _lights_LightProbe_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./lights/LightProbe.js */ "../../node_modules/three/src/lights/LightProbe.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LightProbe", function() { return _lights_LightProbe_js__WEBPACK_IMPORTED_MODULE_62__["LightProbe"]; });

/* harmony import */ var _cameras_StereoCamera_js__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./cameras/StereoCamera.js */ "../../node_modules/three/src/cameras/StereoCamera.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StereoCamera", function() { return _cameras_StereoCamera_js__WEBPACK_IMPORTED_MODULE_63__["StereoCamera"]; });

/* harmony import */ var _cameras_PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./cameras/PerspectiveCamera.js */ "../../node_modules/three/src/cameras/PerspectiveCamera.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PerspectiveCamera", function() { return _cameras_PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_64__["PerspectiveCamera"]; });

/* harmony import */ var _cameras_OrthographicCamera_js__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./cameras/OrthographicCamera.js */ "../../node_modules/three/src/cameras/OrthographicCamera.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OrthographicCamera", function() { return _cameras_OrthographicCamera_js__WEBPACK_IMPORTED_MODULE_65__["OrthographicCamera"]; });

/* harmony import */ var _cameras_CubeCamera_js__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./cameras/CubeCamera.js */ "../../node_modules/three/src/cameras/CubeCamera.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CubeCamera", function() { return _cameras_CubeCamera_js__WEBPACK_IMPORTED_MODULE_66__["CubeCamera"]; });

/* harmony import */ var _cameras_ArrayCamera_js__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./cameras/ArrayCamera.js */ "../../node_modules/three/src/cameras/ArrayCamera.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ArrayCamera", function() { return _cameras_ArrayCamera_js__WEBPACK_IMPORTED_MODULE_67__["ArrayCamera"]; });

/* harmony import */ var _cameras_Camera_js__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./cameras/Camera.js */ "../../node_modules/three/src/cameras/Camera.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Camera", function() { return _cameras_Camera_js__WEBPACK_IMPORTED_MODULE_68__["Camera"]; });

/* harmony import */ var _audio_AudioListener_js__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./audio/AudioListener.js */ "../../node_modules/three/src/audio/AudioListener.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AudioListener", function() { return _audio_AudioListener_js__WEBPACK_IMPORTED_MODULE_69__["AudioListener"]; });

/* harmony import */ var _audio_PositionalAudio_js__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./audio/PositionalAudio.js */ "../../node_modules/three/src/audio/PositionalAudio.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PositionalAudio", function() { return _audio_PositionalAudio_js__WEBPACK_IMPORTED_MODULE_70__["PositionalAudio"]; });

/* harmony import */ var _audio_AudioContext_js__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./audio/AudioContext.js */ "../../node_modules/three/src/audio/AudioContext.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AudioContext", function() { return _audio_AudioContext_js__WEBPACK_IMPORTED_MODULE_71__["AudioContext"]; });

/* harmony import */ var _audio_AudioAnalyser_js__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./audio/AudioAnalyser.js */ "../../node_modules/three/src/audio/AudioAnalyser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AudioAnalyser", function() { return _audio_AudioAnalyser_js__WEBPACK_IMPORTED_MODULE_72__["AudioAnalyser"]; });

/* harmony import */ var _audio_Audio_js__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./audio/Audio.js */ "../../node_modules/three/src/audio/Audio.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Audio", function() { return _audio_Audio_js__WEBPACK_IMPORTED_MODULE_73__["Audio"]; });

/* harmony import */ var _animation_tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./animation/tracks/VectorKeyframeTrack.js */ "../../node_modules/three/src/animation/tracks/VectorKeyframeTrack.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VectorKeyframeTrack", function() { return _animation_tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_74__["VectorKeyframeTrack"]; });

/* harmony import */ var _animation_tracks_StringKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./animation/tracks/StringKeyframeTrack.js */ "../../node_modules/three/src/animation/tracks/StringKeyframeTrack.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StringKeyframeTrack", function() { return _animation_tracks_StringKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_75__["StringKeyframeTrack"]; });

/* harmony import */ var _animation_tracks_QuaternionKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./animation/tracks/QuaternionKeyframeTrack.js */ "../../node_modules/three/src/animation/tracks/QuaternionKeyframeTrack.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "QuaternionKeyframeTrack", function() { return _animation_tracks_QuaternionKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_76__["QuaternionKeyframeTrack"]; });

/* harmony import */ var _animation_tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./animation/tracks/NumberKeyframeTrack.js */ "../../node_modules/three/src/animation/tracks/NumberKeyframeTrack.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NumberKeyframeTrack", function() { return _animation_tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_77__["NumberKeyframeTrack"]; });

/* harmony import */ var _animation_tracks_ColorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./animation/tracks/ColorKeyframeTrack.js */ "../../node_modules/three/src/animation/tracks/ColorKeyframeTrack.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColorKeyframeTrack", function() { return _animation_tracks_ColorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_78__["ColorKeyframeTrack"]; });

/* harmony import */ var _animation_tracks_BooleanKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./animation/tracks/BooleanKeyframeTrack.js */ "../../node_modules/three/src/animation/tracks/BooleanKeyframeTrack.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BooleanKeyframeTrack", function() { return _animation_tracks_BooleanKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_79__["BooleanKeyframeTrack"]; });

/* harmony import */ var _animation_PropertyMixer_js__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./animation/PropertyMixer.js */ "../../node_modules/three/src/animation/PropertyMixer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PropertyMixer", function() { return _animation_PropertyMixer_js__WEBPACK_IMPORTED_MODULE_80__["PropertyMixer"]; });

/* harmony import */ var _animation_PropertyBinding_js__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./animation/PropertyBinding.js */ "../../node_modules/three/src/animation/PropertyBinding.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PropertyBinding", function() { return _animation_PropertyBinding_js__WEBPACK_IMPORTED_MODULE_81__["PropertyBinding"]; });

/* harmony import */ var _animation_KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./animation/KeyframeTrack.js */ "../../node_modules/three/src/animation/KeyframeTrack.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeyframeTrack", function() { return _animation_KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_82__["KeyframeTrack"]; });

/* harmony import */ var _animation_AnimationUtils_js__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./animation/AnimationUtils.js */ "../../node_modules/three/src/animation/AnimationUtils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimationUtils", function() { return _animation_AnimationUtils_js__WEBPACK_IMPORTED_MODULE_83__["AnimationUtils"]; });

/* harmony import */ var _animation_AnimationObjectGroup_js__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./animation/AnimationObjectGroup.js */ "../../node_modules/three/src/animation/AnimationObjectGroup.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimationObjectGroup", function() { return _animation_AnimationObjectGroup_js__WEBPACK_IMPORTED_MODULE_84__["AnimationObjectGroup"]; });

/* harmony import */ var _animation_AnimationMixer_js__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./animation/AnimationMixer.js */ "../../node_modules/three/src/animation/AnimationMixer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimationMixer", function() { return _animation_AnimationMixer_js__WEBPACK_IMPORTED_MODULE_85__["AnimationMixer"]; });

/* harmony import */ var _animation_AnimationClip_js__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./animation/AnimationClip.js */ "../../node_modules/three/src/animation/AnimationClip.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimationClip", function() { return _animation_AnimationClip_js__WEBPACK_IMPORTED_MODULE_86__["AnimationClip"]; });

/* harmony import */ var _core_Uniform_js__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./core/Uniform.js */ "../../node_modules/three/src/core/Uniform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uniform", function() { return _core_Uniform_js__WEBPACK_IMPORTED_MODULE_87__["Uniform"]; });

/* harmony import */ var _core_InstancedBufferGeometry_js__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./core/InstancedBufferGeometry.js */ "../../node_modules/three/src/core/InstancedBufferGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferGeometry", function() { return _core_InstancedBufferGeometry_js__WEBPACK_IMPORTED_MODULE_88__["InstancedBufferGeometry"]; });

/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BufferGeometry", function() { return _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_89__["BufferGeometry"]; });

/* harmony import */ var _core_InterleavedBufferAttribute_js__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./core/InterleavedBufferAttribute.js */ "../../node_modules/three/src/core/InterleavedBufferAttribute.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InterleavedBufferAttribute", function() { return _core_InterleavedBufferAttribute_js__WEBPACK_IMPORTED_MODULE_90__["InterleavedBufferAttribute"]; });

/* harmony import */ var _core_InstancedInterleavedBuffer_js__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./core/InstancedInterleavedBuffer.js */ "../../node_modules/three/src/core/InstancedInterleavedBuffer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InstancedInterleavedBuffer", function() { return _core_InstancedInterleavedBuffer_js__WEBPACK_IMPORTED_MODULE_91__["InstancedInterleavedBuffer"]; });

/* harmony import */ var _core_InterleavedBuffer_js__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./core/InterleavedBuffer.js */ "../../node_modules/three/src/core/InterleavedBuffer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InterleavedBuffer", function() { return _core_InterleavedBuffer_js__WEBPACK_IMPORTED_MODULE_92__["InterleavedBuffer"]; });

/* harmony import */ var _core_InstancedBufferAttribute_js__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./core/InstancedBufferAttribute.js */ "../../node_modules/three/src/core/InstancedBufferAttribute.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferAttribute", function() { return _core_InstancedBufferAttribute_js__WEBPACK_IMPORTED_MODULE_93__["InstancedBufferAttribute"]; });

/* harmony import */ var _core_GLBufferAttribute_js__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./core/GLBufferAttribute.js */ "../../node_modules/three/src/core/GLBufferAttribute.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLBufferAttribute", function() { return _core_GLBufferAttribute_js__WEBPACK_IMPORTED_MODULE_94__["GLBufferAttribute"]; });

/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float64BufferAttribute", function() { return _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_95__["Float64BufferAttribute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float32BufferAttribute", function() { return _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_95__["Float32BufferAttribute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float16BufferAttribute", function() { return _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_95__["Float16BufferAttribute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint32BufferAttribute", function() { return _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_95__["Uint32BufferAttribute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int32BufferAttribute", function() { return _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_95__["Int32BufferAttribute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint16BufferAttribute", function() { return _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_95__["Uint16BufferAttribute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int16BufferAttribute", function() { return _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_95__["Int16BufferAttribute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedBufferAttribute", function() { return _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_95__["Uint8ClampedBufferAttribute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint8BufferAttribute", function() { return _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_95__["Uint8BufferAttribute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int8BufferAttribute", function() { return _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_95__["Int8BufferAttribute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BufferAttribute", function() { return _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_95__["BufferAttribute"]; });

/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Object3D", function() { return _core_Object3D_js__WEBPACK_IMPORTED_MODULE_96__["Object3D"]; });

/* harmony import */ var _core_Raycaster_js__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./core/Raycaster.js */ "../../node_modules/three/src/core/Raycaster.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Raycaster", function() { return _core_Raycaster_js__WEBPACK_IMPORTED_MODULE_97__["Raycaster"]; });

/* harmony import */ var _core_Layers_js__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./core/Layers.js */ "../../node_modules/three/src/core/Layers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Layers", function() { return _core_Layers_js__WEBPACK_IMPORTED_MODULE_98__["Layers"]; });

/* harmony import */ var _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./core/EventDispatcher.js */ "../../node_modules/three/src/core/EventDispatcher.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EventDispatcher", function() { return _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_99__["EventDispatcher"]; });

/* harmony import */ var _core_Clock_js__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./core/Clock.js */ "../../node_modules/three/src/core/Clock.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Clock", function() { return _core_Clock_js__WEBPACK_IMPORTED_MODULE_100__["Clock"]; });

/* harmony import */ var _math_interpolants_QuaternionLinearInterpolant_js__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./math/interpolants/QuaternionLinearInterpolant.js */ "../../node_modules/three/src/math/interpolants/QuaternionLinearInterpolant.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "QuaternionLinearInterpolant", function() { return _math_interpolants_QuaternionLinearInterpolant_js__WEBPACK_IMPORTED_MODULE_101__["QuaternionLinearInterpolant"]; });

/* harmony import */ var _math_interpolants_LinearInterpolant_js__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./math/interpolants/LinearInterpolant.js */ "../../node_modules/three/src/math/interpolants/LinearInterpolant.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LinearInterpolant", function() { return _math_interpolants_LinearInterpolant_js__WEBPACK_IMPORTED_MODULE_102__["LinearInterpolant"]; });

/* harmony import */ var _math_interpolants_DiscreteInterpolant_js__WEBPACK_IMPORTED_MODULE_103__ = __webpack_require__(/*! ./math/interpolants/DiscreteInterpolant.js */ "../../node_modules/three/src/math/interpolants/DiscreteInterpolant.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DiscreteInterpolant", function() { return _math_interpolants_DiscreteInterpolant_js__WEBPACK_IMPORTED_MODULE_103__["DiscreteInterpolant"]; });

/* harmony import */ var _math_interpolants_CubicInterpolant_js__WEBPACK_IMPORTED_MODULE_104__ = __webpack_require__(/*! ./math/interpolants/CubicInterpolant.js */ "../../node_modules/three/src/math/interpolants/CubicInterpolant.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CubicInterpolant", function() { return _math_interpolants_CubicInterpolant_js__WEBPACK_IMPORTED_MODULE_104__["CubicInterpolant"]; });

/* harmony import */ var _math_Interpolant_js__WEBPACK_IMPORTED_MODULE_105__ = __webpack_require__(/*! ./math/Interpolant.js */ "../../node_modules/three/src/math/Interpolant.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Interpolant", function() { return _math_Interpolant_js__WEBPACK_IMPORTED_MODULE_105__["Interpolant"]; });

/* harmony import */ var _math_Triangle_js__WEBPACK_IMPORTED_MODULE_106__ = __webpack_require__(/*! ./math/Triangle.js */ "../../node_modules/three/src/math/Triangle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Triangle", function() { return _math_Triangle_js__WEBPACK_IMPORTED_MODULE_106__["Triangle"]; });

/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_107__ = __webpack_require__(/*! ./math/MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MathUtils", function() { return _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_107__["MathUtils"]; });

/* harmony import */ var _math_Spherical_js__WEBPACK_IMPORTED_MODULE_108__ = __webpack_require__(/*! ./math/Spherical.js */ "../../node_modules/three/src/math/Spherical.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Spherical", function() { return _math_Spherical_js__WEBPACK_IMPORTED_MODULE_108__["Spherical"]; });

/* harmony import */ var _math_Cylindrical_js__WEBPACK_IMPORTED_MODULE_109__ = __webpack_require__(/*! ./math/Cylindrical.js */ "../../node_modules/three/src/math/Cylindrical.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Cylindrical", function() { return _math_Cylindrical_js__WEBPACK_IMPORTED_MODULE_109__["Cylindrical"]; });

/* harmony import */ var _math_Plane_js__WEBPACK_IMPORTED_MODULE_110__ = __webpack_require__(/*! ./math/Plane.js */ "../../node_modules/three/src/math/Plane.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Plane", function() { return _math_Plane_js__WEBPACK_IMPORTED_MODULE_110__["Plane"]; });

/* harmony import */ var _math_Frustum_js__WEBPACK_IMPORTED_MODULE_111__ = __webpack_require__(/*! ./math/Frustum.js */ "../../node_modules/three/src/math/Frustum.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Frustum", function() { return _math_Frustum_js__WEBPACK_IMPORTED_MODULE_111__["Frustum"]; });

/* harmony import */ var _math_Sphere_js__WEBPACK_IMPORTED_MODULE_112__ = __webpack_require__(/*! ./math/Sphere.js */ "../../node_modules/three/src/math/Sphere.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Sphere", function() { return _math_Sphere_js__WEBPACK_IMPORTED_MODULE_112__["Sphere"]; });

/* harmony import */ var _math_Ray_js__WEBPACK_IMPORTED_MODULE_113__ = __webpack_require__(/*! ./math/Ray.js */ "../../node_modules/three/src/math/Ray.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Ray", function() { return _math_Ray_js__WEBPACK_IMPORTED_MODULE_113__["Ray"]; });

/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_114__ = __webpack_require__(/*! ./math/Matrix4.js */ "../../node_modules/three/src/math/Matrix4.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Matrix4", function() { return _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_114__["Matrix4"]; });

/* harmony import */ var _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_115__ = __webpack_require__(/*! ./math/Matrix3.js */ "../../node_modules/three/src/math/Matrix3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Matrix3", function() { return _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_115__["Matrix3"]; });

/* harmony import */ var _math_Box3_js__WEBPACK_IMPORTED_MODULE_116__ = __webpack_require__(/*! ./math/Box3.js */ "../../node_modules/three/src/math/Box3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Box3", function() { return _math_Box3_js__WEBPACK_IMPORTED_MODULE_116__["Box3"]; });

/* harmony import */ var _math_Box2_js__WEBPACK_IMPORTED_MODULE_117__ = __webpack_require__(/*! ./math/Box2.js */ "../../node_modules/three/src/math/Box2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Box2", function() { return _math_Box2_js__WEBPACK_IMPORTED_MODULE_117__["Box2"]; });

/* harmony import */ var _math_Line3_js__WEBPACK_IMPORTED_MODULE_118__ = __webpack_require__(/*! ./math/Line3.js */ "../../node_modules/three/src/math/Line3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Line3", function() { return _math_Line3_js__WEBPACK_IMPORTED_MODULE_118__["Line3"]; });

/* harmony import */ var _math_Euler_js__WEBPACK_IMPORTED_MODULE_119__ = __webpack_require__(/*! ./math/Euler.js */ "../../node_modules/three/src/math/Euler.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Euler", function() { return _math_Euler_js__WEBPACK_IMPORTED_MODULE_119__["Euler"]; });

/* harmony import */ var _math_Vector4_js__WEBPACK_IMPORTED_MODULE_120__ = __webpack_require__(/*! ./math/Vector4.js */ "../../node_modules/three/src/math/Vector4.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Vector4", function() { return _math_Vector4_js__WEBPACK_IMPORTED_MODULE_120__["Vector4"]; });

/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_121__ = __webpack_require__(/*! ./math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Vector3", function() { return _math_Vector3_js__WEBPACK_IMPORTED_MODULE_121__["Vector3"]; });

/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_122__ = __webpack_require__(/*! ./math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Vector2", function() { return _math_Vector2_js__WEBPACK_IMPORTED_MODULE_122__["Vector2"]; });

/* harmony import */ var _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_123__ = __webpack_require__(/*! ./math/Quaternion.js */ "../../node_modules/three/src/math/Quaternion.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Quaternion", function() { return _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_123__["Quaternion"]; });

/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_124__ = __webpack_require__(/*! ./math/Color.js */ "../../node_modules/three/src/math/Color.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return _math_Color_js__WEBPACK_IMPORTED_MODULE_124__["Color"]; });

/* harmony import */ var _math_SphericalHarmonics3_js__WEBPACK_IMPORTED_MODULE_125__ = __webpack_require__(/*! ./math/SphericalHarmonics3.js */ "../../node_modules/three/src/math/SphericalHarmonics3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SphericalHarmonics3", function() { return _math_SphericalHarmonics3_js__WEBPACK_IMPORTED_MODULE_125__["SphericalHarmonics3"]; });

/* harmony import */ var _extras_objects_ImmediateRenderObject_js__WEBPACK_IMPORTED_MODULE_126__ = __webpack_require__(/*! ./extras/objects/ImmediateRenderObject.js */ "../../node_modules/three/src/extras/objects/ImmediateRenderObject.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImmediateRenderObject", function() { return _extras_objects_ImmediateRenderObject_js__WEBPACK_IMPORTED_MODULE_126__["ImmediateRenderObject"]; });

/* harmony import */ var _helpers_SpotLightHelper_js__WEBPACK_IMPORTED_MODULE_127__ = __webpack_require__(/*! ./helpers/SpotLightHelper.js */ "../../node_modules/three/src/helpers/SpotLightHelper.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SpotLightHelper", function() { return _helpers_SpotLightHelper_js__WEBPACK_IMPORTED_MODULE_127__["SpotLightHelper"]; });

/* harmony import */ var _helpers_SkeletonHelper_js__WEBPACK_IMPORTED_MODULE_128__ = __webpack_require__(/*! ./helpers/SkeletonHelper.js */ "../../node_modules/three/src/helpers/SkeletonHelper.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SkeletonHelper", function() { return _helpers_SkeletonHelper_js__WEBPACK_IMPORTED_MODULE_128__["SkeletonHelper"]; });

/* harmony import */ var _helpers_PointLightHelper_js__WEBPACK_IMPORTED_MODULE_129__ = __webpack_require__(/*! ./helpers/PointLightHelper.js */ "../../node_modules/three/src/helpers/PointLightHelper.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointLightHelper", function() { return _helpers_PointLightHelper_js__WEBPACK_IMPORTED_MODULE_129__["PointLightHelper"]; });

/* harmony import */ var _helpers_HemisphereLightHelper_js__WEBPACK_IMPORTED_MODULE_130__ = __webpack_require__(/*! ./helpers/HemisphereLightHelper.js */ "../../node_modules/three/src/helpers/HemisphereLightHelper.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HemisphereLightHelper", function() { return _helpers_HemisphereLightHelper_js__WEBPACK_IMPORTED_MODULE_130__["HemisphereLightHelper"]; });

/* harmony import */ var _helpers_GridHelper_js__WEBPACK_IMPORTED_MODULE_131__ = __webpack_require__(/*! ./helpers/GridHelper.js */ "../../node_modules/three/src/helpers/GridHelper.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GridHelper", function() { return _helpers_GridHelper_js__WEBPACK_IMPORTED_MODULE_131__["GridHelper"]; });

/* harmony import */ var _helpers_PolarGridHelper_js__WEBPACK_IMPORTED_MODULE_132__ = __webpack_require__(/*! ./helpers/PolarGridHelper.js */ "../../node_modules/three/src/helpers/PolarGridHelper.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PolarGridHelper", function() { return _helpers_PolarGridHelper_js__WEBPACK_IMPORTED_MODULE_132__["PolarGridHelper"]; });

/* harmony import */ var _helpers_DirectionalLightHelper_js__WEBPACK_IMPORTED_MODULE_133__ = __webpack_require__(/*! ./helpers/DirectionalLightHelper.js */ "../../node_modules/three/src/helpers/DirectionalLightHelper.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DirectionalLightHelper", function() { return _helpers_DirectionalLightHelper_js__WEBPACK_IMPORTED_MODULE_133__["DirectionalLightHelper"]; });

/* harmony import */ var _helpers_CameraHelper_js__WEBPACK_IMPORTED_MODULE_134__ = __webpack_require__(/*! ./helpers/CameraHelper.js */ "../../node_modules/three/src/helpers/CameraHelper.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CameraHelper", function() { return _helpers_CameraHelper_js__WEBPACK_IMPORTED_MODULE_134__["CameraHelper"]; });

/* harmony import */ var _helpers_BoxHelper_js__WEBPACK_IMPORTED_MODULE_135__ = __webpack_require__(/*! ./helpers/BoxHelper.js */ "../../node_modules/three/src/helpers/BoxHelper.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BoxHelper", function() { return _helpers_BoxHelper_js__WEBPACK_IMPORTED_MODULE_135__["BoxHelper"]; });

/* harmony import */ var _helpers_Box3Helper_js__WEBPACK_IMPORTED_MODULE_136__ = __webpack_require__(/*! ./helpers/Box3Helper.js */ "../../node_modules/three/src/helpers/Box3Helper.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Box3Helper", function() { return _helpers_Box3Helper_js__WEBPACK_IMPORTED_MODULE_136__["Box3Helper"]; });

/* harmony import */ var _helpers_PlaneHelper_js__WEBPACK_IMPORTED_MODULE_137__ = __webpack_require__(/*! ./helpers/PlaneHelper.js */ "../../node_modules/three/src/helpers/PlaneHelper.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PlaneHelper", function() { return _helpers_PlaneHelper_js__WEBPACK_IMPORTED_MODULE_137__["PlaneHelper"]; });

/* harmony import */ var _helpers_ArrowHelper_js__WEBPACK_IMPORTED_MODULE_138__ = __webpack_require__(/*! ./helpers/ArrowHelper.js */ "../../node_modules/three/src/helpers/ArrowHelper.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ArrowHelper", function() { return _helpers_ArrowHelper_js__WEBPACK_IMPORTED_MODULE_138__["ArrowHelper"]; });

/* harmony import */ var _helpers_AxesHelper_js__WEBPACK_IMPORTED_MODULE_139__ = __webpack_require__(/*! ./helpers/AxesHelper.js */ "../../node_modules/three/src/helpers/AxesHelper.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AxesHelper", function() { return _helpers_AxesHelper_js__WEBPACK_IMPORTED_MODULE_139__["AxesHelper"]; });

/* harmony import */ var _extras_curves_Curves_js__WEBPACK_IMPORTED_MODULE_140__ = __webpack_require__(/*! ./extras/curves/Curves.js */ "../../node_modules/three/src/extras/curves/Curves.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ArcCurve", function() { return _extras_curves_Curves_js__WEBPACK_IMPORTED_MODULE_140__["ArcCurve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CatmullRomCurve3", function() { return _extras_curves_Curves_js__WEBPACK_IMPORTED_MODULE_140__["CatmullRomCurve3"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve", function() { return _extras_curves_Curves_js__WEBPACK_IMPORTED_MODULE_140__["CubicBezierCurve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve3", function() { return _extras_curves_Curves_js__WEBPACK_IMPORTED_MODULE_140__["CubicBezierCurve3"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EllipseCurve", function() { return _extras_curves_Curves_js__WEBPACK_IMPORTED_MODULE_140__["EllipseCurve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LineCurve", function() { return _extras_curves_Curves_js__WEBPACK_IMPORTED_MODULE_140__["LineCurve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LineCurve3", function() { return _extras_curves_Curves_js__WEBPACK_IMPORTED_MODULE_140__["LineCurve3"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve", function() { return _extras_curves_Curves_js__WEBPACK_IMPORTED_MODULE_140__["QuadraticBezierCurve"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve3", function() { return _extras_curves_Curves_js__WEBPACK_IMPORTED_MODULE_140__["QuadraticBezierCurve3"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SplineCurve", function() { return _extras_curves_Curves_js__WEBPACK_IMPORTED_MODULE_140__["SplineCurve"]; });

/* harmony import */ var _extras_core_Shape_js__WEBPACK_IMPORTED_MODULE_141__ = __webpack_require__(/*! ./extras/core/Shape.js */ "../../node_modules/three/src/extras/core/Shape.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return _extras_core_Shape_js__WEBPACK_IMPORTED_MODULE_141__["Shape"]; });

/* harmony import */ var _extras_core_Path_js__WEBPACK_IMPORTED_MODULE_142__ = __webpack_require__(/*! ./extras/core/Path.js */ "../../node_modules/three/src/extras/core/Path.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return _extras_core_Path_js__WEBPACK_IMPORTED_MODULE_142__["Path"]; });

/* harmony import */ var _extras_core_ShapePath_js__WEBPACK_IMPORTED_MODULE_143__ = __webpack_require__(/*! ./extras/core/ShapePath.js */ "../../node_modules/three/src/extras/core/ShapePath.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShapePath", function() { return _extras_core_ShapePath_js__WEBPACK_IMPORTED_MODULE_143__["ShapePath"]; });

/* harmony import */ var _extras_core_Font_js__WEBPACK_IMPORTED_MODULE_144__ = __webpack_require__(/*! ./extras/core/Font.js */ "../../node_modules/three/src/extras/core/Font.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Font", function() { return _extras_core_Font_js__WEBPACK_IMPORTED_MODULE_144__["Font"]; });

/* harmony import */ var _extras_core_CurvePath_js__WEBPACK_IMPORTED_MODULE_145__ = __webpack_require__(/*! ./extras/core/CurvePath.js */ "../../node_modules/three/src/extras/core/CurvePath.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CurvePath", function() { return _extras_core_CurvePath_js__WEBPACK_IMPORTED_MODULE_145__["CurvePath"]; });

/* harmony import */ var _extras_core_Curve_js__WEBPACK_IMPORTED_MODULE_146__ = __webpack_require__(/*! ./extras/core/Curve.js */ "../../node_modules/three/src/extras/core/Curve.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Curve", function() { return _extras_core_Curve_js__WEBPACK_IMPORTED_MODULE_146__["Curve"]; });

/* harmony import */ var _extras_DataUtils_js__WEBPACK_IMPORTED_MODULE_147__ = __webpack_require__(/*! ./extras/DataUtils.js */ "../../node_modules/three/src/extras/DataUtils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataUtils", function() { return _extras_DataUtils_js__WEBPACK_IMPORTED_MODULE_147__["DataUtils"]; });

/* harmony import */ var _extras_ImageUtils_js__WEBPACK_IMPORTED_MODULE_148__ = __webpack_require__(/*! ./extras/ImageUtils.js */ "../../node_modules/three/src/extras/ImageUtils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageUtils", function() { return _extras_ImageUtils_js__WEBPACK_IMPORTED_MODULE_148__["ImageUtils"]; });

/* harmony import */ var _extras_ShapeUtils_js__WEBPACK_IMPORTED_MODULE_149__ = __webpack_require__(/*! ./extras/ShapeUtils.js */ "../../node_modules/three/src/extras/ShapeUtils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShapeUtils", function() { return _extras_ShapeUtils_js__WEBPACK_IMPORTED_MODULE_149__["ShapeUtils"]; });

/* harmony import */ var _extras_PMREMGenerator_js__WEBPACK_IMPORTED_MODULE_150__ = __webpack_require__(/*! ./extras/PMREMGenerator.js */ "../../node_modules/three/src/extras/PMREMGenerator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PMREMGenerator", function() { return _extras_PMREMGenerator_js__WEBPACK_IMPORTED_MODULE_150__["PMREMGenerator"]; });

/* harmony import */ var _renderers_webgl_WebGLUtils_js__WEBPACK_IMPORTED_MODULE_151__ = __webpack_require__(/*! ./renderers/webgl/WebGLUtils.js */ "../../node_modules/three/src/renderers/webgl/WebGLUtils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLUtils", function() { return _renderers_webgl_WebGLUtils_js__WEBPACK_IMPORTED_MODULE_151__["WebGLUtils"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "REVISION", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["REVISION"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MOUSE", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["MOUSE"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TOUCH", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["TOUCH"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CullFaceNone", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["CullFaceNone"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CullFaceBack", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["CullFaceBack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CullFaceFront", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["CullFaceFront"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CullFaceFrontBack", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["CullFaceFrontBack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BasicShadowMap", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["BasicShadowMap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PCFShadowMap", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["PCFShadowMap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PCFSoftShadowMap", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["PCFSoftShadowMap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VSMShadowMap", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["VSMShadowMap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FrontSide", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["FrontSide"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BackSide", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DoubleSide", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FlatShading", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["FlatShading"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SmoothShading", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["SmoothShading"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NoBlending", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoBlending"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NormalBlending", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["NormalBlending"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AdditiveBlending", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["AdditiveBlending"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SubtractiveBlending", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["SubtractiveBlending"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MultiplyBlending", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["MultiplyBlending"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CustomBlending", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["CustomBlending"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AddEquation", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["AddEquation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SubtractEquation", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["SubtractEquation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ReverseSubtractEquation", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["ReverseSubtractEquation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MinEquation", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["MinEquation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MaxEquation", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["MaxEquation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ZeroFactor", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroFactor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OneFactor", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["OneFactor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SrcColorFactor", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["SrcColorFactor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcColorFactor", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["OneMinusSrcColorFactor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaFactor", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["SrcAlphaFactor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcAlphaFactor", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["OneMinusSrcAlphaFactor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DstAlphaFactor", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["DstAlphaFactor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstAlphaFactor", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["OneMinusDstAlphaFactor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DstColorFactor", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["DstColorFactor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstColorFactor", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["OneMinusDstColorFactor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaSaturateFactor", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["SrcAlphaSaturateFactor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NeverDepth", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["NeverDepth"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AlwaysDepth", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["AlwaysDepth"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LessDepth", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["LessDepth"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LessEqualDepth", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["LessEqualDepth"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EqualDepth", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["EqualDepth"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualDepth", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["GreaterEqualDepth"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GreaterDepth", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["GreaterDepth"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NotEqualDepth", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["NotEqualDepth"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MultiplyOperation", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["MultiplyOperation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MixOperation", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["MixOperation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AddOperation", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["AddOperation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NoToneMapping", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoToneMapping"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LinearToneMapping", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearToneMapping"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ReinhardToneMapping", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["ReinhardToneMapping"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CineonToneMapping", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["CineonToneMapping"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ACESFilmicToneMapping", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["ACESFilmicToneMapping"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CustomToneMapping", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["CustomToneMapping"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UVMapping", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["UVMapping"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CubeReflectionMapping", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeReflectionMapping"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CubeRefractionMapping", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeRefractionMapping"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EquirectangularReflectionMapping", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["EquirectangularReflectionMapping"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EquirectangularRefractionMapping", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["EquirectangularRefractionMapping"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CubeUVReflectionMapping", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeUVReflectionMapping"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CubeUVRefractionMapping", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeUVRefractionMapping"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RepeatWrapping", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RepeatWrapping"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ClampToEdgeWrapping", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["ClampToEdgeWrapping"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MirroredRepeatWrapping", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["MirroredRepeatWrapping"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NearestFilter", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapNearestFilter", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestMipmapNearestFilter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapNearestFilter", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestMipMapNearestFilter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapLinearFilter", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestMipmapLinearFilter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapLinearFilter", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestMipMapLinearFilter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LinearFilter", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapNearestFilter", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearMipmapNearestFilter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapNearestFilter", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearMipMapNearestFilter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapLinearFilter", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearMipmapLinearFilter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapLinearFilter", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearMipMapLinearFilter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UnsignedByteType", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedByteType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ByteType", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["ByteType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShortType", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["ShortType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UnsignedShortType", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedShortType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IntType", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["IntType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UnsignedIntType", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedIntType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FloatType", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["FloatType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HalfFloatType", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["HalfFloatType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort4444Type", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedShort4444Type"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort5551Type", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedShort5551Type"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort565Type", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedShort565Type"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UnsignedInt248Type", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedInt248Type"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AlphaFormat", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["AlphaFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBFormat", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBAFormat", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LuminanceFormat", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["LuminanceFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LuminanceAlphaFormat", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["LuminanceAlphaFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBEFormat", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBEFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DepthFormat", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["DepthFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DepthStencilFormat", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["DepthStencilFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RedFormat", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RedFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RedIntegerFormat", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RedIntegerFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGFormat", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGIntegerFormat", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGIntegerFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBIntegerFormat", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBIntegerFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBAIntegerFormat", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAIntegerFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGB_S3TC_DXT1_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_S3TC_DXT1_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT1_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_S3TC_DXT1_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT3_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_S3TC_DXT3_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT5_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_S3TC_DXT5_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_4BPPV1_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_PVRTC_4BPPV1_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_2BPPV1_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_PVRTC_2BPPV1_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_4BPPV1_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_PVRTC_4BPPV1_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_2BPPV1_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_PVRTC_2BPPV1_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC1_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_ETC1_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC2_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_ETC2_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBA_ETC2_EAC_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ETC2_EAC_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_4x4_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_4x4_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x4_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_5x4_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x5_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_5x5_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x5_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_6x5_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x6_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_6x6_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x5_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_8x5_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x6_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_8x6_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x8_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_8x8_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x5_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_10x5_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x6_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_10x6_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x8_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_10x8_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x10_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_10x10_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x10_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_12x10_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x12_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_12x12_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBA_BPTC_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_BPTC_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_4x4_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_4x4_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_5x4_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_5x4_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_5x5_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_5x5_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_6x5_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_6x5_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_6x6_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_6x6_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x5_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_8x5_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x6_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_8x6_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x8_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_8x8_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x5_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_10x5_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x6_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_10x6_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x8_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_10x8_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x10_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_10x10_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_12x10_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_12x10_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_12x12_Format", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_12x12_Format"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LoopOnce", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["LoopOnce"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LoopRepeat", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["LoopRepeat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LoopPingPong", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["LoopPingPong"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InterpolateDiscrete", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateDiscrete"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InterpolateLinear", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateLinear"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InterpolateSmooth", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateSmooth"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ZeroCurvatureEnding", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroCurvatureEnding"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ZeroSlopeEnding", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroSlopeEnding"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WrapAroundEnding", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["WrapAroundEnding"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NormalAnimationBlendMode", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["NormalAnimationBlendMode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AdditiveAnimationBlendMode", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["AdditiveAnimationBlendMode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TrianglesDrawMode", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["TrianglesDrawMode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TriangleStripDrawMode", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["TriangleStripDrawMode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TriangleFanDrawMode", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["TriangleFanDrawMode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LinearEncoding", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sRGBEncoding", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["sRGBEncoding"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GammaEncoding", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["GammaEncoding"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBEEncoding", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBEEncoding"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LogLuvEncoding", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["LogLuvEncoding"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBM7Encoding", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBM7Encoding"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBM16Encoding", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBM16Encoding"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBDEncoding", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBDEncoding"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BasicDepthPacking", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["BasicDepthPacking"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RGBADepthPacking", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBADepthPacking"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TangentSpaceNormalMap", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["TangentSpaceNormalMap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ObjectSpaceNormalMap", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["ObjectSpaceNormalMap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ZeroStencilOp", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroStencilOp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeepStencilOp", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["KeepStencilOp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ReplaceStencilOp", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["ReplaceStencilOp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IncrementStencilOp", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["IncrementStencilOp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DecrementStencilOp", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["DecrementStencilOp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IncrementWrapStencilOp", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["IncrementWrapStencilOp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DecrementWrapStencilOp", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["DecrementWrapStencilOp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InvertStencilOp", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["InvertStencilOp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NeverStencilFunc", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["NeverStencilFunc"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LessStencilFunc", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["LessStencilFunc"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EqualStencilFunc", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["EqualStencilFunc"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LessEqualStencilFunc", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["LessEqualStencilFunc"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GreaterStencilFunc", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["GreaterStencilFunc"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NotEqualStencilFunc", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["NotEqualStencilFunc"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualStencilFunc", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["GreaterEqualStencilFunc"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AlwaysStencilFunc", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["AlwaysStencilFunc"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StaticDrawUsage", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["StaticDrawUsage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DynamicDrawUsage", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["DynamicDrawUsage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StreamDrawUsage", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["StreamDrawUsage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StaticReadUsage", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["StaticReadUsage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DynamicReadUsage", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["DynamicReadUsage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StreamReadUsage", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["StreamReadUsage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StaticCopyUsage", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["StaticCopyUsage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DynamicCopyUsage", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["DynamicCopyUsage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StreamCopyUsage", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["StreamCopyUsage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLSL1", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["GLSL1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLSL3", function() { return _constants_js__WEBPACK_IMPORTED_MODULE_0__["GLSL3"]; });

/* harmony import */ var _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__ = __webpack_require__(/*! ./Three.Legacy.js */ "../../node_modules/three/src/Three.Legacy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Math", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["Math"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LineStrip", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["LineStrip"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LinePieces", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["LinePieces"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NoColors", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["NoColors"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FaceColors", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["FaceColors"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VertexColors", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["VertexColors"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshFaceMaterial", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["MeshFaceMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MultiMaterial", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["MultiMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointCloud", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["PointCloud"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Particle", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["Particle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ParticleSystem", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["ParticleSystem"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointCloudMaterial", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["PointCloudMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ParticleBasicMaterial", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["ParticleBasicMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ParticleSystemMaterial", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["ParticleSystemMaterial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Vertex", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["Vertex"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DynamicBufferAttribute", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["DynamicBufferAttribute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int8Attribute", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["Int8Attribute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint8Attribute", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["Uint8Attribute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedAttribute", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["Uint8ClampedAttribute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int16Attribute", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["Int16Attribute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint16Attribute", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["Uint16Attribute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Int32Attribute", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["Int32Attribute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Uint32Attribute", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["Uint32Attribute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float32Attribute", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["Float32Attribute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Float64Attribute", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["Float64Attribute"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AxisHelper", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["AxisHelper"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BoundingBoxHelper", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["BoundingBoxHelper"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EdgesHelper", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["EdgesHelper"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WireframeHelper", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["WireframeHelper"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "XHRLoader", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["XHRLoader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BinaryTextureLoader", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["BinaryTextureLoader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTargetCube", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["WebGLRenderTargetCube"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CanvasRenderer", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["CanvasRenderer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "JSONLoader", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["JSONLoader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SceneUtils", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["SceneUtils"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LensFlare", function() { return _Three_Legacy_js__WEBPACK_IMPORTED_MODULE_152__["LensFlare"]; });





























































































































































if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

	/* eslint-disable no-undef */
	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
		revision: _constants_js__WEBPACK_IMPORTED_MODULE_0__["REVISION"],
	} } ) );
	/* eslint-enable no-undef */

}

if ( typeof window !== 'undefined' ) {

	if ( window.__THREE__ ) {

		console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

	} else {

		window.__THREE__ = _constants_js__WEBPACK_IMPORTED_MODULE_0__["REVISION"];

	}

}


/***/ }),

/***/ "../../node_modules/three/src/animation/AnimationAction.js":
/*!*********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/animation/AnimationAction.js ***!
  \*********************************************************************************/
/*! exports provided: AnimationAction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationAction", function() { return AnimationAction; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");



class AnimationAction {

	constructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {

		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot;
		this.blendMode = blendMode;

		const tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array( nTracks );

		const interpolantSettings = {
			endingStart: _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroCurvatureEnding"],
			endingEnd: _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroCurvatureEnding"]
		};

		for ( let i = 0; i !== nTracks; ++ i ) {

			const interpolant = tracks[ i ].createInterpolant( null );
			interpolants[ i ] = interpolant;
			interpolant.settings = interpolantSettings;

		}

		this._interpolantSettings = interpolantSettings;

		this._interpolants = interpolants; // bound by the mixer

		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array( nTracks );

		this._cacheIndex = null; // for the memory manager
		this._byClipCacheIndex = null; // for the memory manager

		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;

		this.loop = _constants_js__WEBPACK_IMPORTED_MODULE_0__["LoopRepeat"];
		this._loopCount = - 1;

		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;

		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;

		this.timeScale = 1;
		this._effectiveTimeScale = 1;

		this.weight = 1;
		this._effectiveWeight = 1;

		this.repetitions = Infinity; // no. of repetitions when looping

		this.paused = false; // true -> zero effective time scale
		this.enabled = true; // false -> zero effective weight

		this.clampWhenFinished = false;// keep feeding the last frame?

		this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
		this.zeroSlopeAtEnd = true;// clips for start, loop and end

	}

	// State & Scheduling

	play() {

		this._mixer._activateAction( this );

		return this;

	}

	stop() {

		this._mixer._deactivateAction( this );

		return this.reset();

	}

	reset() {

		this.paused = false;
		this.enabled = true;

		this.time = 0; // restart clip
		this._loopCount = - 1;// forget previous loops
		this._startTime = null;// forget scheduling

		return this.stopFading().stopWarping();

	}

	isRunning() {

		return this.enabled && ! this.paused && this.timeScale !== 0 &&
			this._startTime === null && this._mixer._isActiveAction( this );

	}

	// return true when play has been called
	isScheduled() {

		return this._mixer._isActiveAction( this );

	}

	startAt( time ) {

		this._startTime = time;

		return this;

	}

	setLoop( mode, repetitions ) {

		this.loop = mode;
		this.repetitions = repetitions;

		return this;

	}

	// Weight

	// set the weight stopping any scheduled fading
	// although .enabled = false yields an effective weight of zero, this
	// method does *not* change .enabled, because it would be confusing
	setEffectiveWeight( weight ) {

		this.weight = weight;

		// note: same logic as when updated at runtime
		this._effectiveWeight = this.enabled ? weight : 0;

		return this.stopFading();

	}

	// return the weight considering fading and .enabled
	getEffectiveWeight() {

		return this._effectiveWeight;

	}

	fadeIn( duration ) {

		return this._scheduleFading( duration, 0, 1 );

	}

	fadeOut( duration ) {

		return this._scheduleFading( duration, 1, 0 );

	}

	crossFadeFrom( fadeOutAction, duration, warp ) {

		fadeOutAction.fadeOut( duration );
		this.fadeIn( duration );

		if ( warp ) {

			const fadeInDuration = this._clip.duration,
				fadeOutDuration = fadeOutAction._clip.duration,

				startEndRatio = fadeOutDuration / fadeInDuration,
				endStartRatio = fadeInDuration / fadeOutDuration;

			fadeOutAction.warp( 1.0, startEndRatio, duration );
			this.warp( endStartRatio, 1.0, duration );

		}

		return this;

	}

	crossFadeTo( fadeInAction, duration, warp ) {

		return fadeInAction.crossFadeFrom( this, duration, warp );

	}

	stopFading() {

		const weightInterpolant = this._weightInterpolant;

		if ( weightInterpolant !== null ) {

			this._weightInterpolant = null;
			this._mixer._takeBackControlInterpolant( weightInterpolant );

		}

		return this;

	}

	// Time Scale Control

	// set the time scale stopping any scheduled warping
	// although .paused = true yields an effective time scale of zero, this
	// method does *not* change .paused, because it would be confusing
	setEffectiveTimeScale( timeScale ) {

		this.timeScale = timeScale;
		this._effectiveTimeScale = this.paused ? 0 : timeScale;

		return this.stopWarping();

	}

	// return the time scale considering warping and .paused
	getEffectiveTimeScale() {

		return this._effectiveTimeScale;

	}

	setDuration( duration ) {

		this.timeScale = this._clip.duration / duration;

		return this.stopWarping();

	}

	syncWith( action ) {

		this.time = action.time;
		this.timeScale = action.timeScale;

		return this.stopWarping();

	}

	halt( duration ) {

		return this.warp( this._effectiveTimeScale, 0, duration );

	}

	warp( startTimeScale, endTimeScale, duration ) {

		const mixer = this._mixer,
			now = mixer.time,
			timeScale = this.timeScale;

		let interpolant = this._timeScaleInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._timeScaleInterpolant = interpolant;

		}

		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		times[ 1 ] = now + duration;

		values[ 0 ] = startTimeScale / timeScale;
		values[ 1 ] = endTimeScale / timeScale;

		return this;

	}

	stopWarping() {

		const timeScaleInterpolant = this._timeScaleInterpolant;

		if ( timeScaleInterpolant !== null ) {

			this._timeScaleInterpolant = null;
			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

		}

		return this;

	}

	// Object Accessors

	getMixer() {

		return this._mixer;

	}

	getClip() {

		return this._clip;

	}

	getRoot() {

		return this._localRoot || this._mixer._root;

	}

	// Interna

	_update( time, deltaTime, timeDirection, accuIndex ) {

		// called by the mixer

		if ( ! this.enabled ) {

			// call ._updateWeight() to update ._effectiveWeight

			this._updateWeight( time );
			return;

		}

		const startTime = this._startTime;

		if ( startTime !== null ) {

			// check for scheduled start of action

			const timeRunning = ( time - startTime ) * timeDirection;
			if ( timeRunning < 0 || timeDirection === 0 ) {

				return; // yet to come / don't decide when delta = 0

			}

			// start

			this._startTime = null; // unschedule
			deltaTime = timeDirection * timeRunning;

		}

		// apply time scale and advance time

		deltaTime *= this._updateTimeScale( time );
		const clipTime = this._updateTime( deltaTime );

		// note: _updateTime may disable the action resulting in
		// an effective weight of 0

		const weight = this._updateWeight( time );

		if ( weight > 0 ) {

			const interpolants = this._interpolants;
			const propertyMixers = this._propertyBindings;

			switch ( this.blendMode ) {

				case _constants_js__WEBPACK_IMPORTED_MODULE_0__["AdditiveAnimationBlendMode"]:

					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulateAdditive( weight );

					}

					break;

				case _constants_js__WEBPACK_IMPORTED_MODULE_0__["NormalAnimationBlendMode"]:
				default:

					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulate( accuIndex, weight );

					}

			}

		}

	}

	_updateWeight( time ) {

		let weight = 0;

		if ( this.enabled ) {

			weight = this.weight;
			const interpolant = this._weightInterpolant;

			if ( interpolant !== null ) {

				const interpolantValue = interpolant.evaluate( time )[ 0 ];

				weight *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopFading();

					if ( interpolantValue === 0 ) {

						// faded out, disable
						this.enabled = false;

					}

				}

			}

		}

		this._effectiveWeight = weight;
		return weight;

	}

	_updateTimeScale( time ) {

		let timeScale = 0;

		if ( ! this.paused ) {

			timeScale = this.timeScale;

			const interpolant = this._timeScaleInterpolant;

			if ( interpolant !== null ) {

				const interpolantValue = interpolant.evaluate( time )[ 0 ];

				timeScale *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopWarping();

					if ( timeScale === 0 ) {

						// motion has halted, pause
						this.paused = true;

					} else {

						// warp done - apply final time scale
						this.timeScale = timeScale;

					}

				}

			}

		}

		this._effectiveTimeScale = timeScale;
		return timeScale;

	}

	_updateTime( deltaTime ) {

		const duration = this._clip.duration;
		const loop = this.loop;

		let time = this.time + deltaTime;
		let loopCount = this._loopCount;

		const pingPong = ( loop === _constants_js__WEBPACK_IMPORTED_MODULE_0__["LoopPingPong"] );

		if ( deltaTime === 0 ) {

			if ( loopCount === - 1 ) return time;

			return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

		}

		if ( loop === _constants_js__WEBPACK_IMPORTED_MODULE_0__["LoopOnce"] ) {

			if ( loopCount === - 1 ) {

				// just started

				this._loopCount = 0;
				this._setEndings( true, true, false );

			}

			handle_stop: {

				if ( time >= duration ) {

					time = duration;

				} else if ( time < 0 ) {

					time = 0;

				} else {

					this.time = time;

					break handle_stop;

				}

				if ( this.clampWhenFinished ) this.paused = true;
				else this.enabled = false;

				this.time = time;

				this._mixer.dispatchEvent( {
					type: 'finished', action: this,
					direction: deltaTime < 0 ? - 1 : 1
				} );

			}

		} else { // repetitive Repeat or PingPong

			if ( loopCount === - 1 ) {

				// just started

				if ( deltaTime >= 0 ) {

					loopCount = 0;

					this._setEndings( true, this.repetitions === 0, pingPong );

				} else {

					// when looping in reverse direction, the initial
					// transition through zero counts as a repetition,
					// so leave loopCount at -1

					this._setEndings( this.repetitions === 0, true, pingPong );

				}

			}

			if ( time >= duration || time < 0 ) {

				// wrap around

				const loopDelta = Math.floor( time / duration ); // signed
				time -= duration * loopDelta;

				loopCount += Math.abs( loopDelta );

				const pending = this.repetitions - loopCount;

				if ( pending <= 0 ) {

					// have to stop (switch state, clamp time, fire event)

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					time = deltaTime > 0 ? duration : 0;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime > 0 ? 1 : - 1
					} );

				} else {

					// keep running

					if ( pending === 1 ) {

						// entering the last round

						const atStart = deltaTime < 0;
						this._setEndings( atStart, ! atStart, pingPong );

					} else {

						this._setEndings( false, false, pingPong );

					}

					this._loopCount = loopCount;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'loop', action: this, loopDelta: loopDelta
					} );

				}

			} else {

				this.time = time;

			}

			if ( pingPong && ( loopCount & 1 ) === 1 ) {

				// invert time for the "pong round"

				return duration - time;

			}

		}

		return time;

	}

	_setEndings( atStart, atEnd, pingPong ) {

		const settings = this._interpolantSettings;

		if ( pingPong ) {

			settings.endingStart = _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroSlopeEnding"];
			settings.endingEnd = _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroSlopeEnding"];

		} else {

			// assuming for LoopOnce atStart == atEnd == true

			if ( atStart ) {

				settings.endingStart = this.zeroSlopeAtStart ? _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroSlopeEnding"] : _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroCurvatureEnding"];

			} else {

				settings.endingStart = _constants_js__WEBPACK_IMPORTED_MODULE_0__["WrapAroundEnding"];

			}

			if ( atEnd ) {

				settings.endingEnd = this.zeroSlopeAtEnd ? _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroSlopeEnding"] : _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroCurvatureEnding"];

			} else {

				settings.endingEnd 	 = _constants_js__WEBPACK_IMPORTED_MODULE_0__["WrapAroundEnding"];

			}

		}

	}

	_scheduleFading( duration, weightNow, weightThen ) {

		const mixer = this._mixer, now = mixer.time;
		let interpolant = this._weightInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._weightInterpolant = interpolant;

		}

		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		values[ 0 ] = weightNow;
		times[ 1 ] = now + duration;
		values[ 1 ] = weightThen;

		return this;

	}

}





/***/ }),

/***/ "../../node_modules/three/src/animation/AnimationClip.js":
/*!*******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/animation/AnimationClip.js ***!
  \*******************************************************************************/
/*! exports provided: AnimationClip */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationClip", function() { return AnimationClip; });
/* harmony import */ var _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimationUtils.js */ "../../node_modules/three/src/animation/AnimationUtils.js");
/* harmony import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KeyframeTrack.js */ "../../node_modules/three/src/animation/KeyframeTrack.js");
/* harmony import */ var _tracks_BooleanKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tracks/BooleanKeyframeTrack.js */ "../../node_modules/three/src/animation/tracks/BooleanKeyframeTrack.js");
/* harmony import */ var _tracks_ColorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tracks/ColorKeyframeTrack.js */ "../../node_modules/three/src/animation/tracks/ColorKeyframeTrack.js");
/* harmony import */ var _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tracks/NumberKeyframeTrack.js */ "../../node_modules/three/src/animation/tracks/NumberKeyframeTrack.js");
/* harmony import */ var _tracks_QuaternionKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tracks/QuaternionKeyframeTrack.js */ "../../node_modules/three/src/animation/tracks/QuaternionKeyframeTrack.js");
/* harmony import */ var _tracks_StringKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tracks/StringKeyframeTrack.js */ "../../node_modules/three/src/animation/tracks/StringKeyframeTrack.js");
/* harmony import */ var _tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tracks/VectorKeyframeTrack.js */ "../../node_modules/three/src/animation/tracks/VectorKeyframeTrack.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../math/MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");











class AnimationClip {

	constructor( name, duration = - 1, tracks, blendMode = _constants_js__WEBPACK_IMPORTED_MODULE_9__["NormalAnimationBlendMode"] ) {

		this.name = name;
		this.tracks = tracks;
		this.duration = duration;
		this.blendMode = blendMode;

		this.uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_8__["MathUtils"].generateUUID();

		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {

			this.resetDuration();

		}

	}


	static parse( json ) {

		const tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );

		for ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

		}

		const clip = new this( json.name, json.duration, tracks, json.blendMode );
		clip.uuid = json.uuid;

		return clip;

	}

	static toJSON( clip ) {

		const tracks = [],
			clipTracks = clip.tracks;

		const json = {

			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks,
			'uuid': clip.uuid,
			'blendMode': clip.blendMode

		};

		for ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {

			tracks.push( _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__["KeyframeTrack"].toJSON( clipTracks[ i ] ) );

		}

		return json;

	}

	static CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {

		const numMorphTargets = morphTargetSequence.length;
		const tracks = [];

		for ( let i = 0; i < numMorphTargets; i ++ ) {

			let times = [];
			let values = [];

			times.push(
				( i + numMorphTargets - 1 ) % numMorphTargets,
				i,
				( i + 1 ) % numMorphTargets );

			values.push( 0, 1, 0 );

			const order = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__["AnimationUtils"].getKeyframeOrder( times );
			times = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__["AnimationUtils"].sortedArray( times, 1, order );
			values = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__["AnimationUtils"].sortedArray( values, 1, order );

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if ( ! noLoop && times[ 0 ] === 0 ) {

				times.push( numMorphTargets );
				values.push( values[ 0 ] );

			}

			tracks.push(
				new _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_4__["NumberKeyframeTrack"](
					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
					times, values
				).scale( 1.0 / fps ) );

		}

		return new this( name, - 1, tracks );

	}

	static findByName( objectOrClipArray, name ) {

		let clipArray = objectOrClipArray;

		if ( ! Array.isArray( objectOrClipArray ) ) {

			const o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;

		}

		for ( let i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[ i ].name === name ) {

				return clipArray[ i ];

			}

		}

		return null;

	}

	static CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {

		const animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		const pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

			const morphTarget = morphTargets[ i ];
			const parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				const name = parts[ 1 ];

				let animationMorphTargets = animationToMorphTargets[ name ];

				if ( ! animationMorphTargets ) {

					animationToMorphTargets[ name ] = animationMorphTargets = [];

				}

				animationMorphTargets.push( morphTarget );

			}

		}

		const clips = [];

		for ( const name in animationToMorphTargets ) {

			clips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		}

		return clips;

	}

	// parse the animation.hierarchy format
	static parseAnimation( animation, bones ) {

		if ( ! animation ) {

			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
			return null;

		}

		const addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

			// only return track if there are actually keys.
			if ( animationKeys.length !== 0 ) {

				const times = [];
				const values = [];

				_AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__["AnimationUtils"].flattenJSON( animationKeys, times, values, propertyName );

				// empty keys are filtered out, so check again
				if ( times.length !== 0 ) {

					destTracks.push( new trackType( trackName, times, values ) );

				}

			}

		};

		const tracks = [];

		const clipName = animation.name || 'default';
		const fps = animation.fps || 30;
		const blendMode = animation.blendMode;

		// automatic length determination in AnimationClip.
		let duration = animation.length || - 1;

		const hierarchyTracks = animation.hierarchy || [];

		for ( let h = 0; h < hierarchyTracks.length; h ++ ) {

			const animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length === 0 ) continue;

			// process morph targets
			if ( animationKeys[ 0 ].morphTargets ) {

				// figure out all morph targets used in this track
				const morphTargetNames = {};

				let k;

				for ( k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[ k ].morphTargets ) {

						for ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

						}

					}

				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for ( const morphTargetName in morphTargetNames ) {

					const times = [];
					const values = [];

					for ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

						const animationKey = animationKeys[ k ];

						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					}

					tracks.push( new _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_4__["NumberKeyframeTrack"]( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				}

				duration = morphTargetNames.length * ( fps || 1.0 );

			} else {

				// ...assume skeletal animation

				const boneName = '.bones[' + bones[ h ].name + ']';

				addNonemptyTrack(
					_tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_7__["VectorKeyframeTrack"], boneName + '.position',
					animationKeys, 'pos', tracks );

				addNonemptyTrack(
					_tracks_QuaternionKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_5__["QuaternionKeyframeTrack"], boneName + '.quaternion',
					animationKeys, 'rot', tracks );

				addNonemptyTrack(
					_tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_7__["VectorKeyframeTrack"], boneName + '.scale',
					animationKeys, 'scl', tracks );

			}

		}

		if ( tracks.length === 0 ) {

			return null;

		}

		const clip = new this( clipName, duration, tracks, blendMode );

		return clip;

	}

	resetDuration() {

		const tracks = this.tracks;
		let duration = 0;

		for ( let i = 0, n = tracks.length; i !== n; ++ i ) {

			const track = this.tracks[ i ];

			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

		}

		this.duration = duration;

		return this;

	}

	trim() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	}

	validate() {

		let valid = true;

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			valid = valid && this.tracks[ i ].validate();

		}

		return valid;

	}

	optimize() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	}

	clone() {

		const tracks = [];

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			tracks.push( this.tracks[ i ].clone() );

		}

		return new this.constructor( this.name, this.duration, tracks, this.blendMode );

	}

	toJSON() {

		return this.constructor.toJSON( this );

	}

}

function getTrackTypeForValueTypeName( typeName ) {

	switch ( typeName.toLowerCase() ) {

		case 'scalar':
		case 'double':
		case 'float':
		case 'number':
		case 'integer':

			return _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_4__["NumberKeyframeTrack"];

		case 'vector':
		case 'vector2':
		case 'vector3':
		case 'vector4':

			return _tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_7__["VectorKeyframeTrack"];

		case 'color':

			return _tracks_ColorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_3__["ColorKeyframeTrack"];

		case 'quaternion':

			return _tracks_QuaternionKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_5__["QuaternionKeyframeTrack"];

		case 'bool':
		case 'boolean':

			return _tracks_BooleanKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_2__["BooleanKeyframeTrack"];

		case 'string':

			return _tracks_StringKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_6__["StringKeyframeTrack"];

	}

	throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

}

function parseKeyframeTrack( json ) {

	if ( json.type === undefined ) {

		throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

	}

	const trackType = getTrackTypeForValueTypeName( json.type );

	if ( json.times === undefined ) {

		const times = [], values = [];

		_AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__["AnimationUtils"].flattenJSON( json.keys, times, values, 'value' );

		json.times = times;
		json.values = values;

	}

	// derived classes can define a static parse method
	if ( trackType.parse !== undefined ) {

		return trackType.parse( json );

	} else {

		// by default, we assume a constructor compatible with the base
		return new trackType( json.name, json.times, json.values, json.interpolation );

	}

}




/***/ }),

/***/ "../../node_modules/three/src/animation/AnimationMixer.js":
/*!********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/animation/AnimationMixer.js ***!
  \********************************************************************************/
/*! exports provided: AnimationMixer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationMixer", function() { return AnimationMixer; });
/* harmony import */ var _AnimationAction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimationAction.js */ "../../node_modules/three/src/animation/AnimationAction.js");
/* harmony import */ var _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/EventDispatcher.js */ "../../node_modules/three/src/core/EventDispatcher.js");
/* harmony import */ var _math_interpolants_LinearInterpolant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/interpolants/LinearInterpolant.js */ "../../node_modules/three/src/math/interpolants/LinearInterpolant.js");
/* harmony import */ var _PropertyBinding_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PropertyBinding.js */ "../../node_modules/three/src/animation/PropertyBinding.js");
/* harmony import */ var _PropertyMixer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PropertyMixer.js */ "../../node_modules/three/src/animation/PropertyMixer.js");
/* harmony import */ var _AnimationClip_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AnimationClip.js */ "../../node_modules/three/src/animation/AnimationClip.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");








class AnimationMixer extends _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_1__["EventDispatcher"] {

	constructor( root ) {

		super();

		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;
		this.time = 0;
		this.timeScale = 1.0;

	}

	_bindAction( action, prototypeAction ) {

		const root = action._localRoot || this._root,
			tracks = action._clip.tracks,
			nTracks = tracks.length,
			bindings = action._propertyBindings,
			interpolants = action._interpolants,
			rootUuid = root.uuid,
			bindingsByRoot = this._bindingsByRootAndName;

		let bindingsByName = bindingsByRoot[ rootUuid ];

		if ( bindingsByName === undefined ) {

			bindingsByName = {};
			bindingsByRoot[ rootUuid ] = bindingsByName;

		}

		for ( let i = 0; i !== nTracks; ++ i ) {

			const track = tracks[ i ],
				trackName = track.name;

			let binding = bindingsByName[ trackName ];

			if ( binding !== undefined ) {

				bindings[ i ] = binding;

			} else {

				binding = bindings[ i ];

				if ( binding !== undefined ) {

					// existing binding, make sure the cache knows

					if ( binding._cacheIndex === null ) {

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

					}

					continue;

				}

				const path = prototypeAction && prototypeAction.
					_propertyBindings[ i ].binding.parsedPath;

				binding = new _PropertyMixer_js__WEBPACK_IMPORTED_MODULE_4__["PropertyMixer"](
					_PropertyBinding_js__WEBPACK_IMPORTED_MODULE_3__["PropertyBinding"].create( root, trackName, path ),
					track.ValueTypeName, track.getValueSize() );

				++ binding.referenceCount;
				this._addInactiveBinding( binding, rootUuid, trackName );

				bindings[ i ] = binding;

			}

			interpolants[ i ].resultBuffer = binding.buffer;

		}

	}

	_activateAction( action ) {

		if ( ! this._isActiveAction( action ) ) {

			if ( action._cacheIndex === null ) {

				// this action has been forgotten by the cache, but the user
				// appears to be still using it -> rebind

				const rootUuid = ( action._localRoot || this._root ).uuid,
					clipUuid = action._clip.uuid,
					actionsForClip = this._actionsByClip[ clipUuid ];

				this._bindAction( action,
					actionsForClip && actionsForClip.knownActions[ 0 ] );

				this._addInactiveAction( action, clipUuid, rootUuid );

			}

			const bindings = action._propertyBindings;

			// increment reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( binding.useCount ++ === 0 ) {

					this._lendBinding( binding );
					binding.saveOriginalState();

				}

			}

			this._lendAction( action );

		}

	}

	_deactivateAction( action ) {

		if ( this._isActiveAction( action ) ) {

			const bindings = action._propertyBindings;

			// decrement reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( -- binding.useCount === 0 ) {

					binding.restoreOriginalState();
					this._takeBackBinding( binding );

				}

			}

			this._takeBackAction( action );

		}

	}

	// Memory manager

	_initMemoryManager() {

		this._actions = []; // 'nActiveActions' followed by inactive ones
		this._nActiveActions = 0;

		this._actionsByClip = {};
		// inside:
		// {
		// 	knownActions: Array< AnimationAction > - used as prototypes
		// 	actionByRoot: AnimationAction - lookup
		// }


		this._bindings = []; // 'nActiveBindings' followed by inactive ones
		this._nActiveBindings = 0;

		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


		this._controlInterpolants = []; // same game as above
		this._nActiveControlInterpolants = 0;

		const scope = this;

		this.stats = {

			actions: {
				get total() {

					return scope._actions.length;

				},
				get inUse() {

					return scope._nActiveActions;

				}
			},
			bindings: {
				get total() {

					return scope._bindings.length;

				},
				get inUse() {

					return scope._nActiveBindings;

				}
			},
			controlInterpolants: {
				get total() {

					return scope._controlInterpolants.length;

				},
				get inUse() {

					return scope._nActiveControlInterpolants;

				}
			}

		};

	}

	// Memory management for AnimationAction objects

	_isActiveAction( action ) {

		const index = action._cacheIndex;
		return index !== null && index < this._nActiveActions;

	}

	_addInactiveAction( action, clipUuid, rootUuid ) {

		const actions = this._actions,
			actionsByClip = this._actionsByClip;

		let actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip === undefined ) {

			actionsForClip = {

				knownActions: [ action ],
				actionByRoot: {}

			};

			action._byClipCacheIndex = 0;

			actionsByClip[ clipUuid ] = actionsForClip;

		} else {

			const knownActions = actionsForClip.knownActions;

			action._byClipCacheIndex = knownActions.length;
			knownActions.push( action );

		}

		action._cacheIndex = actions.length;
		actions.push( action );

		actionsForClip.actionByRoot[ rootUuid ] = action;

	}

	_removeInactiveAction( action ) {

		const actions = this._actions,
			lastInactiveAction = actions[ actions.length - 1 ],
			cacheIndex = action._cacheIndex;

		lastInactiveAction._cacheIndex = cacheIndex;
		actions[ cacheIndex ] = lastInactiveAction;
		actions.pop();

		action._cacheIndex = null;


		const clipUuid = action._clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ],
			knownActionsForClip = actionsForClip.knownActions,

			lastKnownAction =
				knownActionsForClip[ knownActionsForClip.length - 1 ],

			byClipCacheIndex = action._byClipCacheIndex;

		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
		knownActionsForClip.pop();

		action._byClipCacheIndex = null;


		const actionByRoot = actionsForClip.actionByRoot,
			rootUuid = ( action._localRoot || this._root ).uuid;

		delete actionByRoot[ rootUuid ];

		if ( knownActionsForClip.length === 0 ) {

			delete actionsByClip[ clipUuid ];

		}

		this._removeInactiveBindingsForAction( action );

	}

	_removeInactiveBindingsForAction( action ) {

		const bindings = action._propertyBindings;

		for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

			const binding = bindings[ i ];

			if ( -- binding.referenceCount === 0 ) {

				this._removeInactiveBinding( binding );

			}

		}

	}

	_lendAction( action ) {

		// [ active actions |  inactive actions  ]
		// [  active actions >| inactive actions ]
		//                 s        a
		//                  <-swap->
		//                 a        s

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			lastActiveIndex = this._nActiveActions ++,

			firstInactiveAction = actions[ lastActiveIndex ];

		action._cacheIndex = lastActiveIndex;
		actions[ lastActiveIndex ] = action;

		firstInactiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = firstInactiveAction;

	}

	_takeBackAction( action ) {

		// [  active actions  | inactive actions ]
		// [ active actions |< inactive actions  ]
		//        a        s
		//         <-swap->
		//        s        a

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			firstInactiveIndex = -- this._nActiveActions,

			lastActiveAction = actions[ firstInactiveIndex ];

		action._cacheIndex = firstInactiveIndex;
		actions[ firstInactiveIndex ] = action;

		lastActiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = lastActiveAction;

	}

	// Memory management for PropertyMixer objects

	_addInactiveBinding( binding, rootUuid, trackName ) {

		const bindingsByRoot = this._bindingsByRootAndName,
			bindings = this._bindings;

		let bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName === undefined ) {

			bindingByName = {};
			bindingsByRoot[ rootUuid ] = bindingByName;

		}

		bindingByName[ trackName ] = binding;

		binding._cacheIndex = bindings.length;
		bindings.push( binding );

	}

	_removeInactiveBinding( binding ) {

		const bindings = this._bindings,
			propBinding = binding.binding,
			rootUuid = propBinding.rootNode.uuid,
			trackName = propBinding.path,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			lastInactiveBinding = bindings[ bindings.length - 1 ],
			cacheIndex = binding._cacheIndex;

		lastInactiveBinding._cacheIndex = cacheIndex;
		bindings[ cacheIndex ] = lastInactiveBinding;
		bindings.pop();

		delete bindingByName[ trackName ];

		if ( Object.keys( bindingByName ).length === 0 ) {

			delete bindingsByRoot[ rootUuid ];

		}

	}

	_lendBinding( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			lastActiveIndex = this._nActiveBindings ++,

			firstInactiveBinding = bindings[ lastActiveIndex ];

		binding._cacheIndex = lastActiveIndex;
		bindings[ lastActiveIndex ] = binding;

		firstInactiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = firstInactiveBinding;

	}

	_takeBackBinding( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			firstInactiveIndex = -- this._nActiveBindings,

			lastActiveBinding = bindings[ firstInactiveIndex ];

		binding._cacheIndex = firstInactiveIndex;
		bindings[ firstInactiveIndex ] = binding;

		lastActiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = lastActiveBinding;

	}


	// Memory management of Interpolants for weight and time scale

	_lendControlInterpolant() {

		const interpolants = this._controlInterpolants,
			lastActiveIndex = this._nActiveControlInterpolants ++;

		let interpolant = interpolants[ lastActiveIndex ];

		if ( interpolant === undefined ) {

			interpolant = new _math_interpolants_LinearInterpolant_js__WEBPACK_IMPORTED_MODULE_2__["LinearInterpolant"](
				new Float32Array( 2 ), new Float32Array( 2 ),
				1, this._controlInterpolantsResultBuffer );

			interpolant.__cacheIndex = lastActiveIndex;
			interpolants[ lastActiveIndex ] = interpolant;

		}

		return interpolant;

	}

	_takeBackControlInterpolant( interpolant ) {

		const interpolants = this._controlInterpolants,
			prevIndex = interpolant.__cacheIndex,

			firstInactiveIndex = -- this._nActiveControlInterpolants,

			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

		interpolant.__cacheIndex = firstInactiveIndex;
		interpolants[ firstInactiveIndex ] = interpolant;

		lastActiveInterpolant.__cacheIndex = prevIndex;
		interpolants[ prevIndex ] = lastActiveInterpolant;

	}

	// return an action for a clip optionally using a custom root target
	// object (this method allocates a lot of dynamic memory in case a
	// previously unknown clip/root combination is specified)
	clipAction( clip, optionalRoot, blendMode ) {

		const root = optionalRoot || this._root,
			rootUuid = root.uuid;

		let clipObject = typeof clip === 'string' ? _AnimationClip_js__WEBPACK_IMPORTED_MODULE_5__["AnimationClip"].findByName( root, clip ) : clip;

		const clipUuid = clipObject !== null ? clipObject.uuid : clip;

		const actionsForClip = this._actionsByClip[ clipUuid ];
		let prototypeAction = null;

		if ( blendMode === undefined ) {

			if ( clipObject !== null ) {

				blendMode = clipObject.blendMode;

			} else {

				blendMode = _constants_js__WEBPACK_IMPORTED_MODULE_6__["NormalAnimationBlendMode"];

			}

		}

		if ( actionsForClip !== undefined ) {

			const existingAction = actionsForClip.actionByRoot[ rootUuid ];

			if ( existingAction !== undefined && existingAction.blendMode === blendMode ) {

				return existingAction;

			}

			// we know the clip, so we don't have to parse all
			// the bindings again but can just copy
			prototypeAction = actionsForClip.knownActions[ 0 ];

			// also, take the clip from the prototype action
			if ( clipObject === null )
				clipObject = prototypeAction._clip;

		}

		// clip must be known when specified via string
		if ( clipObject === null ) return null;

		// allocate all resources required to run it
		const newAction = new _AnimationAction_js__WEBPACK_IMPORTED_MODULE_0__["AnimationAction"]( this, clipObject, optionalRoot, blendMode );

		this._bindAction( newAction, prototypeAction );

		// and make the action known to the memory manager
		this._addInactiveAction( newAction, clipUuid, rootUuid );

		return newAction;

	}

	// get an existing action
	existingAction( clip, optionalRoot ) {

		const root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
				_AnimationClip_js__WEBPACK_IMPORTED_MODULE_5__["AnimationClip"].findByName( root, clip ) : clip,

			clipUuid = clipObject ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			return actionsForClip.actionByRoot[ rootUuid ] || null;

		}

		return null;

	}

	// deactivates all previously scheduled actions
	stopAllAction() {

		const actions = this._actions,
			nActions = this._nActiveActions;

		for ( let i = nActions - 1; i >= 0; -- i ) {

			actions[ i ].stop();

		}

		return this;

	}

	// advance the time and update apply the animation
	update( deltaTime ) {

		deltaTime *= this.timeScale;

		const actions = this._actions,
			nActions = this._nActiveActions,

			time = this.time += deltaTime,
			timeDirection = Math.sign( deltaTime ),

			accuIndex = this._accuIndex ^= 1;

		// run active actions

		for ( let i = 0; i !== nActions; ++ i ) {

			const action = actions[ i ];

			action._update( time, deltaTime, timeDirection, accuIndex );

		}

		// update scene graph

		const bindings = this._bindings,
			nBindings = this._nActiveBindings;

		for ( let i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].apply( accuIndex );

		}

		return this;

	}

	// Allows you to seek to a specific time in an animation.
	setTime( timeInSeconds ) {

		this.time = 0; // Zero out time attribute for AnimationMixer object;
		for ( let i = 0; i < this._actions.length; i ++ ) {

			this._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.

		}

		return this.update( timeInSeconds ); // Update used to set exact time. Returns "this" AnimationMixer object.

	}

	// return this mixer's root target object
	getRoot() {

		return this._root;

	}

	// free all resources specific to a particular clip
	uncacheClip( clip ) {

		const actions = this._actions,
			clipUuid = clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			// note: just calling _removeInactiveAction would mess up the
			// iteration state and also require updating the state we can
			// just throw away

			const actionsToRemove = actionsForClip.knownActions;

			for ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

				const action = actionsToRemove[ i ];

				this._deactivateAction( action );

				const cacheIndex = action._cacheIndex,
					lastInactiveAction = actions[ actions.length - 1 ];

				action._cacheIndex = null;
				action._byClipCacheIndex = null;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				this._removeInactiveBindingsForAction( action );

			}

			delete actionsByClip[ clipUuid ];

		}

	}

	// free all resources specific to a particular root target object
	uncacheRoot( root ) {

		const rootUuid = root.uuid,
			actionsByClip = this._actionsByClip;

		for ( const clipUuid in actionsByClip ) {

			const actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
				action = actionByRoot[ rootUuid ];

			if ( action !== undefined ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

		const bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName !== undefined ) {

			for ( const trackName in bindingByName ) {

				const binding = bindingByName[ trackName ];
				binding.restoreOriginalState();
				this._removeInactiveBinding( binding );

			}

		}

	}

	// remove a targeted clip from the cache
	uncacheAction( clip, optionalRoot ) {

		const action = this.existingAction( clip, optionalRoot );

		if ( action !== null ) {

			this._deactivateAction( action );
			this._removeInactiveAction( action );

		}

	}

}

AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array( 1 );




/***/ }),

/***/ "../../node_modules/three/src/animation/AnimationObjectGroup.js":
/*!**************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/animation/AnimationObjectGroup.js ***!
  \**************************************************************************************/
/*! exports provided: AnimationObjectGroup */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationObjectGroup", function() { return AnimationObjectGroup; });
/* harmony import */ var _PropertyBinding_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PropertyBinding.js */ "../../node_modules/three/src/animation/PropertyBinding.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");



/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */

class AnimationObjectGroup {

	constructor() {

		this.uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__["MathUtils"].generateUUID();

		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call( arguments );

		this.nCachedObjects_ = 0; // threshold
		// note: read by PropertyBinding.Composite

		const indices = {};
		this._indicesByUUID = indices; // for bookkeeping

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			indices[ arguments[ i ].uuid ] = i;

		}

		this._paths = []; // inside: string
		this._parsedPaths = []; // inside: { we don't care, here }
		this._bindings = []; // inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; // inside: indices in these arrays

		const scope = this;

		this.stats = {

			objects: {
				get total() {

					return scope._objects.length;

				},
				get inUse() {

					return this.total - scope.nCachedObjects_;

				}
			},
			get bindingsPerObject() {

				return scope._bindings.length;

			}

		};

	}

	add() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			paths = this._paths,
			parsedPaths = this._parsedPaths,
			bindings = this._bindings,
			nBindings = bindings.length;

		let knownObject = undefined,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid;
			let index = indicesByUUID[ uuid ];

			if ( index === undefined ) {

				// unknown object -> add it to the ACTIVE region

				index = nObjects ++;
				indicesByUUID[ uuid ] = index;
				objects.push( object );

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					bindings[ j ].push( new _PropertyBinding_js__WEBPACK_IMPORTED_MODULE_0__["PropertyBinding"]( object, paths[ j ], parsedPaths[ j ] ) );

				}

			} else if ( index < nCachedObjects ) {

				knownObject = objects[ index ];

				// move existing object to the ACTIVE region

				const firstActiveIndex = -- nCachedObjects,
					lastCachedObject = objects[ firstActiveIndex ];

				indicesByUUID[ lastCachedObject.uuid ] = index;
				objects[ index ] = lastCachedObject;

				indicesByUUID[ uuid ] = firstActiveIndex;
				objects[ firstActiveIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					const bindingsForPath = bindings[ j ],
						lastCached = bindingsForPath[ firstActiveIndex ];

					let binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = lastCached;

					if ( binding === undefined ) {

						// since we do not bother to create new bindings
						// for objects that are cached, the binding may
						// or may not exist

						binding = new _PropertyBinding_js__WEBPACK_IMPORTED_MODULE_0__["PropertyBinding"]( object, paths[ j ], parsedPaths[ j ] );

					}

					bindingsForPath[ firstActiveIndex ] = binding;

				}

			} else if ( objects[ index ] !== knownObject ) {

				console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
					'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

			} // else the object is already where we want it to be

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	remove() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		let nCachedObjects = this.nCachedObjects_;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined && index >= nCachedObjects ) {

				// move existing object into the CACHED region

				const lastCachedIndex = nCachedObjects ++,
					firstActiveObject = objects[ lastCachedIndex ];

				indicesByUUID[ firstActiveObject.uuid ] = index;
				objects[ index ] = firstActiveObject;

				indicesByUUID[ uuid ] = lastCachedIndex;
				objects[ lastCachedIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					const bindingsForPath = bindings[ j ],
						firstActive = bindingsForPath[ lastCachedIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = firstActive;
					bindingsForPath[ lastCachedIndex ] = binding;

				}

			}

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	// remove & forget
	uncache() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		let nCachedObjects = this.nCachedObjects_,
			nObjects = objects.length;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined ) {

				delete indicesByUUID[ uuid ];

				if ( index < nCachedObjects ) {

					// object is cached, shrink the CACHED region

					const firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ],
						lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					// last cached object takes this object's place
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					// last object goes to the activated slot and pop
					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							last = bindingsForPath[ lastIndex ];

						bindingsForPath[ index ] = lastCached;
						bindingsForPath[ firstActiveIndex ] = last;
						bindingsForPath.pop();

					}

				} else {

					// object is active, just swap with the last and pop

					const lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					if ( lastIndex > 0 ) {

						indicesByUUID[ lastObject.uuid ] = index;

					}

					objects[ index ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ];

						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
						bindingsForPath.pop();

					}

				} // cached or active

			} // if object is known

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	// Internal interface used by befriended PropertyBinding.Composite:

	subscribe_( path, parsedPath ) {

		// returns an array of bindings for the given path that is changed
		// according to the contained objects in the group

		const indicesByPath = this._bindingsIndicesByPath;
		let index = indicesByPath[ path ];
		const bindings = this._bindings;

		if ( index !== undefined ) return bindings[ index ];

		const paths = this._paths,
			parsedPaths = this._parsedPaths,
			objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			bindingsForPath = new Array( nObjects );

		index = bindings.length;

		indicesByPath[ path ] = index;

		paths.push( path );
		parsedPaths.push( parsedPath );
		bindings.push( bindingsForPath );

		for ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

			const object = objects[ i ];
			bindingsForPath[ i ] = new _PropertyBinding_js__WEBPACK_IMPORTED_MODULE_0__["PropertyBinding"]( object, path, parsedPath );

		}

		return bindingsForPath;

	}

	unsubscribe_( path ) {

		// tells the group to forget about a property path and no longer
		// update the array previously obtained with 'subscribe_'

		const indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ];

		if ( index !== undefined ) {

			const paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				lastBindingsIndex = bindings.length - 1,
				lastBindings = bindings[ lastBindingsIndex ],
				lastBindingsPath = path[ lastBindingsIndex ];

			indicesByPath[ lastBindingsPath ] = index;

			bindings[ index ] = lastBindings;
			bindings.pop();

			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
			parsedPaths.pop();

			paths[ index ] = paths[ lastBindingsIndex ];
			paths.pop();

		}

	}

}

AnimationObjectGroup.prototype.isAnimationObjectGroup = true;




/***/ }),

/***/ "../../node_modules/three/src/animation/AnimationUtils.js":
/*!********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/animation/AnimationUtils.js ***!
  \********************************************************************************/
/*! exports provided: AnimationUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationUtils", function() { return AnimationUtils; });
/* harmony import */ var _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Quaternion.js */ "../../node_modules/three/src/math/Quaternion.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");



const AnimationUtils = {

	// same as Array.prototype.slice, but also works on typed arrays
	arraySlice: function ( array, from, to ) {

		if ( AnimationUtils.isTypedArray( array ) ) {

			// in ios9 array.subarray(from, undefined) will return empty array
			// but array.subarray(from) or array.subarray(from, len) is correct
			return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

		}

		return array.slice( from, to );

	},

	// converts an array to a specific type
	convertArray: function ( array, type, forceClone ) {

		if ( ! array || // let 'undefined' and 'null' pass
			! forceClone && array.constructor === type ) return array;

		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

			return new type( array ); // create typed array

		}

		return Array.prototype.slice.call( array ); // create Array

	},

	isTypedArray: function ( object ) {

		return ArrayBuffer.isView( object ) &&
			! ( object instanceof DataView );

	},

	// returns an array by which times and values can be sorted
	getKeyframeOrder: function ( times ) {

		function compareTime( i, j ) {

			return times[ i ] - times[ j ];

		}

		const n = times.length;
		const result = new Array( n );
		for ( let i = 0; i !== n; ++ i ) result[ i ] = i;

		result.sort( compareTime );

		return result;

	},

	// uses the array previously returned by 'getKeyframeOrder' to sort data
	sortedArray: function ( values, stride, order ) {

		const nValues = values.length;
		const result = new values.constructor( nValues );

		for ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

			const srcOffset = order[ i ] * stride;

			for ( let j = 0; j !== stride; ++ j ) {

				result[ dstOffset ++ ] = values[ srcOffset + j ];

			}

		}

		return result;

	},

	// function for parsing AOS keyframe formats
	flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

		let i = 1, key = jsonKeys[ 0 ];

		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

			key = jsonKeys[ i ++ ];

		}

		if ( key === undefined ) return; // no data

		let value = key[ valuePropertyName ];
		if ( value === undefined ) return; // no data

		if ( Array.isArray( value ) ) {

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push.apply( values, value ); // push all elements

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else if ( value.toArray !== undefined ) {

			// ...assume THREE.Math-ish

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					value.toArray( values, values.length );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else {

			// otherwise push as-is

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push( value );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		}

	},

	subclip: function ( sourceClip, name, startFrame, endFrame, fps = 30 ) {

		const clip = sourceClip.clone();

		clip.name = name;

		const tracks = [];

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			const track = clip.tracks[ i ];
			const valueSize = track.getValueSize();

			const times = [];
			const values = [];

			for ( let j = 0; j < track.times.length; ++ j ) {

				const frame = track.times[ j ] * fps;

				if ( frame < startFrame || frame >= endFrame ) continue;

				times.push( track.times[ j ] );

				for ( let k = 0; k < valueSize; ++ k ) {

					values.push( track.values[ j * valueSize + k ] );

				}

			}

			if ( times.length === 0 ) continue;

			track.times = AnimationUtils.convertArray( times, track.times.constructor );
			track.values = AnimationUtils.convertArray( values, track.values.constructor );

			tracks.push( track );

		}

		clip.tracks = tracks;

		// find minimum .times value across all tracks in the trimmed clip

		let minStartTime = Infinity;

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

				minStartTime = clip.tracks[ i ].times[ 0 ];

			}

		}

		// shift all tracks such that clip begins at t=0

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			clip.tracks[ i ].shift( - 1 * minStartTime );

		}

		clip.resetDuration();

		return clip;

	},

	makeClipAdditive: function ( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {

		if ( fps <= 0 ) fps = 30;

		const numTracks = referenceClip.tracks.length;
		const referenceTime = referenceFrame / fps;

		// Make each track's values relative to the values at the reference frame
		for ( let i = 0; i < numTracks; ++ i ) {

			const referenceTrack = referenceClip.tracks[ i ];
			const referenceTrackType = referenceTrack.ValueTypeName;

			// Skip this track if it's non-numeric
			if ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;

			// Find the track in the target clip whose name and type matches the reference track
			const targetTrack = targetClip.tracks.find( function ( track ) {

				return track.name === referenceTrack.name
					&& track.ValueTypeName === referenceTrackType;

			} );

			if ( targetTrack === undefined ) continue;

			let referenceOffset = 0;
			const referenceValueSize = referenceTrack.getValueSize();

			if ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

				referenceOffset = referenceValueSize / 3;

			}

			let targetOffset = 0;
			const targetValueSize = targetTrack.getValueSize();

			if ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

				targetOffset = targetValueSize / 3;

			}

			const lastIndex = referenceTrack.times.length - 1;
			let referenceValue;

			// Find the value to subtract out of the track
			if ( referenceTime <= referenceTrack.times[ 0 ] ) {

				// Reference frame is earlier than the first keyframe, so just use the first keyframe
				const startIndex = referenceOffset;
				const endIndex = referenceValueSize - referenceOffset;
				referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

			} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {

				// Reference frame is after the last keyframe, so just use the last keyframe
				const startIndex = lastIndex * referenceValueSize + referenceOffset;
				const endIndex = startIndex + referenceValueSize - referenceOffset;
				referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

			} else {

				// Interpolate to the reference value
				const interpolant = referenceTrack.createInterpolant();
				const startIndex = referenceOffset;
				const endIndex = referenceValueSize - referenceOffset;
				interpolant.evaluate( referenceTime );
				referenceValue = AnimationUtils.arraySlice( interpolant.resultBuffer, startIndex, endIndex );

			}

			// Conjugate the quaternion
			if ( referenceTrackType === 'quaternion' ) {

				const referenceQuat = new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]().fromArray( referenceValue ).normalize().conjugate();
				referenceQuat.toArray( referenceValue );

			}

			// Subtract the reference value from all of the track values

			const numTimes = targetTrack.times.length;
			for ( let j = 0; j < numTimes; ++ j ) {

				const valueStart = j * targetValueSize + targetOffset;

				if ( referenceTrackType === 'quaternion' ) {

					// Multiply the conjugate for quaternion track types
					_math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"].multiplyQuaternionsFlat(
						targetTrack.values,
						valueStart,
						referenceValue,
						0,
						targetTrack.values,
						valueStart
					);

				} else {

					const valueEnd = targetValueSize - targetOffset * 2;

					// Subtract each value for all other numeric track types
					for ( let k = 0; k < valueEnd; ++ k ) {

						targetTrack.values[ valueStart + k ] -= referenceValue[ k ];

					}

				}

			}

		}

		targetClip.blendMode = _constants_js__WEBPACK_IMPORTED_MODULE_1__["AdditiveAnimationBlendMode"];

		return targetClip;

	}

};




/***/ }),

/***/ "../../node_modules/three/src/animation/KeyframeTrack.js":
/*!*******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/animation/KeyframeTrack.js ***!
  \*******************************************************************************/
/*! exports provided: KeyframeTrack */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyframeTrack", function() { return KeyframeTrack; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _math_interpolants_CubicInterpolant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/interpolants/CubicInterpolant.js */ "../../node_modules/three/src/math/interpolants/CubicInterpolant.js");
/* harmony import */ var _math_interpolants_LinearInterpolant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/interpolants/LinearInterpolant.js */ "../../node_modules/three/src/math/interpolants/LinearInterpolant.js");
/* harmony import */ var _math_interpolants_DiscreteInterpolant_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/interpolants/DiscreteInterpolant.js */ "../../node_modules/three/src/math/interpolants/DiscreteInterpolant.js");
/* harmony import */ var _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AnimationUtils.js */ "../../node_modules/three/src/animation/AnimationUtils.js");






class KeyframeTrack {

	constructor( name, times, values, interpolation ) {

		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

		this.name = name;

		this.times = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].convertArray( times, this.TimeBufferType );
		this.values = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].convertArray( values, this.ValueBufferType );

		this.setInterpolation( interpolation || this.DefaultInterpolation );

	}

	// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):

	static toJSON( track ) {

		const trackType = track.constructor;

		let json;

		// derived classes can define a static toJSON method
		if ( trackType.toJSON !== this.toJSON ) {

			json = trackType.toJSON( track );

		} else {

			// by default, we assume the data can be serialized as-is
			json = {

				'name': track.name,
				'times': _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].convertArray( track.times, Array ),
				'values': _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].convertArray( track.values, Array )

			};

			const interpolation = track.getInterpolation();

			if ( interpolation !== track.DefaultInterpolation ) {

				json.interpolation = interpolation;

			}

		}

		json.type = track.ValueTypeName; // mandatory

		return json;

	}

	InterpolantFactoryMethodDiscrete( result ) {

		return new _math_interpolants_DiscreteInterpolant_js__WEBPACK_IMPORTED_MODULE_3__["DiscreteInterpolant"]( this.times, this.values, this.getValueSize(), result );

	}

	InterpolantFactoryMethodLinear( result ) {

		return new _math_interpolants_LinearInterpolant_js__WEBPACK_IMPORTED_MODULE_2__["LinearInterpolant"]( this.times, this.values, this.getValueSize(), result );

	}

	InterpolantFactoryMethodSmooth( result ) {

		return new _math_interpolants_CubicInterpolant_js__WEBPACK_IMPORTED_MODULE_1__["CubicInterpolant"]( this.times, this.values, this.getValueSize(), result );

	}

	setInterpolation( interpolation ) {

		let factoryMethod;

		switch ( interpolation ) {

			case _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateDiscrete"]:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateLinear"]:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateSmooth"]:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;

		}

		if ( factoryMethod === undefined ) {

			const message = 'unsupported interpolation for ' +
				this.ValueTypeName + ' keyframe track named ' + this.name;

			if ( this.createInterpolant === undefined ) {

				// fall back to default, unless the default itself is messed up
				if ( interpolation !== this.DefaultInterpolation ) {

					this.setInterpolation( this.DefaultInterpolation );

				} else {

					throw new Error( message ); // fatal, in this case

				}

			}

			console.warn( 'THREE.KeyframeTrack:', message );
			return this;

		}

		this.createInterpolant = factoryMethod;

		return this;

	}

	getInterpolation() {

		switch ( this.createInterpolant ) {

			case this.InterpolantFactoryMethodDiscrete:

				return _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateDiscrete"];

			case this.InterpolantFactoryMethodLinear:

				return _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateLinear"];

			case this.InterpolantFactoryMethodSmooth:

				return _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateSmooth"];

		}

	}

	getValueSize() {

		return this.values.length / this.times.length;

	}

	// move all keyframes either forwards or backwards in time
	shift( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] += timeOffset;

			}

		}

		return this;

	}

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale( timeScale ) {

		if ( timeScale !== 1.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] *= timeScale;

			}

		}

		return this;

	}

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	trim( startTime, endTime ) {

		const times = this.times,
			nKeys = times.length;

		let from = 0,
			to = nKeys - 1;

		while ( from !== nKeys && times[ from ] < startTime ) {

			++ from;

		}

		while ( to !== - 1 && times[ to ] > endTime ) {

			-- to;

		}

		++ to; // inclusive -> exclusive bound

		if ( from !== 0 || to !== nKeys ) {

			// empty tracks are forbidden, so keep at least one keyframe
			if ( from >= to ) {

				to = Math.max( to, 1 );
				from = to - 1;

			}

			const stride = this.getValueSize();
			this.times = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].arraySlice( times, from, to );
			this.values = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].arraySlice( this.values, from * stride, to * stride );

		}

		return this;

	}

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	validate() {

		let valid = true;

		const valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
			valid = false;

		}

		const times = this.times,
			values = this.values,

			nKeys = times.length;

		if ( nKeys === 0 ) {

			console.error( 'THREE.KeyframeTrack: Track is empty.', this );
			valid = false;

		}

		let prevTime = null;

		for ( let i = 0; i !== nKeys; i ++ ) {

			const currTime = times[ i ];

			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
				valid = false;
				break;

			}

			if ( prevTime !== null && prevTime > currTime ) {

				console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
				valid = false;
				break;

			}

			prevTime = currTime;

		}

		if ( values !== undefined ) {

			if ( _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].isTypedArray( values ) ) {

				for ( let i = 0, n = values.length; i !== n; ++ i ) {

					const value = values[ i ];

					if ( isNaN( value ) ) {

						console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
						valid = false;
						break;

					}

				}

			}

		}

		return valid;

	}

	// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	optimize() {

		// times or values may be shared with other tracks, so overwriting is unsafe
		const times = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].arraySlice( this.times ),
			values = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].arraySlice( this.values ),
			stride = this.getValueSize(),

			smoothInterpolation = this.getInterpolation() === _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateSmooth"],

			lastIndex = times.length - 1;

		let writeIndex = 1;

		for ( let i = 1; i < lastIndex; ++ i ) {

			let keep = false;

			const time = times[ i ];
			const timeNext = times[ i + 1 ];

			// remove adjacent keyframes scheduled at the same time

			if ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {

				if ( ! smoothInterpolation ) {

					// remove unnecessary keyframes same as their neighbors

					const offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;

					for ( let j = 0; j !== stride; ++ j ) {

						const value = values[ offset + j ];

						if ( value !== values[ offsetP + j ] ||
							value !== values[ offsetN + j ] ) {

							keep = true;
							break;

						}

					}

				} else {

					keep = true;

				}

			}

			// in-place compaction

			if ( keep ) {

				if ( i !== writeIndex ) {

					times[ writeIndex ] = times[ i ];

					const readOffset = i * stride,
						writeOffset = writeIndex * stride;

					for ( let j = 0; j !== stride; ++ j ) {

						values[ writeOffset + j ] = values[ readOffset + j ];

					}

				}

				++ writeIndex;

			}

		}

		// flush last keyframe (compaction looks ahead)

		if ( lastIndex > 0 ) {

			times[ writeIndex ] = times[ lastIndex ];

			for ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

				values[ writeOffset + j ] = values[ readOffset + j ];

			}

			++ writeIndex;

		}

		if ( writeIndex !== times.length ) {

			this.times = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].arraySlice( times, 0, writeIndex );
			this.values = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].arraySlice( values, 0, writeIndex * stride );

		} else {

			this.times = times;
			this.values = values;

		}

		return this;

	}

	clone() {

		const times = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].arraySlice( this.times, 0 );
		const values = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].arraySlice( this.values, 0 );

		const TypedKeyframeTrack = this.constructor;
		const track = new TypedKeyframeTrack( this.name, times, values );

		// Interpolant argument to constructor is not saved, so copy the factory method directly.
		track.createInterpolant = this.createInterpolant;

		return track;

	}

}

KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateLinear"];




/***/ }),

/***/ "../../node_modules/three/src/animation/PropertyBinding.js":
/*!*********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/animation/PropertyBinding.js ***!
  \*********************************************************************************/
/*! exports provided: PropertyBinding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyBinding", function() { return PropertyBinding; });
// Characters [].:/ are reserved for track binding syntax.
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
const _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const _directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

const _trackRe = new RegExp( ''
	+ '^'
	+ _directoryRe
	+ _nodeRe
	+ _objectRe
	+ _propertyRe
	+ '$'
);

const _supportedObjectNames = [ 'material', 'materials', 'bones' ];

function Composite( targetGroup, path, optionalParsedPath ) {

	const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

	this._targetGroup = targetGroup;
	this._bindings = targetGroup.subscribe_( path, parsedPath );

}

Object.assign( Composite.prototype, {

	getValue: function ( array, offset ) {

		this.bind(); // bind all binding

		const firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[ firstValidIndex ];

		// and only call .getValue on the first
		if ( binding !== undefined ) binding.getValue( array, offset );

	},

	setValue: function ( array, offset ) {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].setValue( array, offset );

		}

	},

	bind: function () {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].bind();

		}

	},

	unbind: function () {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].unbind();

		}

	}

} );


function PropertyBinding( rootNode, path, parsedPath ) {

	this.path = path;
	this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

	this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

	this.rootNode = rootNode;

}

Object.assign( PropertyBinding, {

	Composite: Composite,

	create: function ( root, path, parsedPath ) {

		if ( ! ( root && root.isAnimationObjectGroup ) ) {

			return new PropertyBinding( root, path, parsedPath );

		} else {

			return new PropertyBinding.Composite( root, path, parsedPath );

		}

	},

	/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */
	sanitizeNodeName: function ( name ) {

		return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

	},

	parseTrackName: function ( trackName ) {

		const matches = _trackRe.exec( trackName );

		if ( ! matches ) {

			throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

		}

		const results = {
			// directoryName: matches[ 1 ], // (tschw) currently unused
			nodeName: matches[ 2 ],
			objectName: matches[ 3 ],
			objectIndex: matches[ 4 ],
			propertyName: matches[ 5 ], // required
			propertyIndex: matches[ 6 ]
		};

		const lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

		if ( lastDot !== undefined && lastDot !== - 1 ) {

			const objectName = results.nodeName.substring( lastDot + 1 );

			// Object names must be checked against an allowlist. Otherwise, there
			// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
			// 'bar' could be the objectName, or part of a nodeName (which can
			// include '.' characters).
			if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

				results.nodeName = results.nodeName.substring( 0, lastDot );
				results.objectName = objectName;

			}

		}

		if ( results.propertyName === null || results.propertyName.length === 0 ) {

			throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

		}

		return results;

	},

	findNode: function ( root, nodeName ) {

		if ( ! nodeName || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

			return root;

		}

		// search into skeleton bones.
		if ( root.skeleton ) {

			const bone = root.skeleton.getBoneByName( nodeName );

			if ( bone !== undefined ) {

				return bone;

			}

		}

		// search into node subtree.
		if ( root.children ) {

			const searchNodeSubtree = function ( children ) {

				for ( let i = 0; i < children.length; i ++ ) {

					const childNode = children[ i ];

					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

						return childNode;

					}

					const result = searchNodeSubtree( childNode.children );

					if ( result ) return result;

				}

				return null;

			};

			const subTreeNode = searchNodeSubtree( root.children );

			if ( subTreeNode ) {

				return subTreeNode;

			}

		}

		return null;

	}

} );

Object.assign( PropertyBinding.prototype, { // prototype, continued

	// these are used to "bind" a nonexistent property
	_getValue_unavailable: function () {},
	_setValue_unavailable: function () {},

	BindingType: {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	},

	Versioning: {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	},

	GetterByBindingType: [

		function getValue_direct( buffer, offset ) {

			buffer[ offset ] = this.node[ this.propertyName ];

		},

		function getValue_array( buffer, offset ) {

			const source = this.resolvedProperty;

			for ( let i = 0, n = source.length; i !== n; ++ i ) {

				buffer[ offset ++ ] = source[ i ];

			}

		},

		function getValue_arrayElement( buffer, offset ) {

			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

		},

		function getValue_toArray( buffer, offset ) {

			this.resolvedProperty.toArray( buffer, offset );

		}

	],

	SetterByBindingTypeAndVersioning: [

		[
			// Direct

			function setValue_direct( buffer, offset ) {

				this.targetObject[ this.propertyName ] = buffer[ offset ];

			},

			function setValue_direct_setNeedsUpdate( buffer, offset ) {

				this.targetObject[ this.propertyName ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.targetObject[ this.propertyName ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// EntireArray

			function setValue_array( buffer, offset ) {

				const dest = this.resolvedProperty;

				for ( let i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

			},

			function setValue_array_setNeedsUpdate( buffer, offset ) {

				const dest = this.resolvedProperty;

				for ( let i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.needsUpdate = true;

			},

			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

				const dest = this.resolvedProperty;

				for ( let i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// ArrayElement

			function setValue_arrayElement( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

			},

			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// HasToFromArray

			function setValue_fromArray( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );

			},

			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.needsUpdate = true;

			},

			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		]

	],

	getValue: function getValue_unbound( targetArray, offset ) {

		this.bind();
		this.getValue( targetArray, offset );

		// Note: This class uses a State pattern on a per-method basis:
		// 'bind' sets 'this.getValue' / 'setValue' and shadows the
		// prototype version of these methods with one that represents
		// the bound state. When the property is not found, the methods
		// become no-ops.

	},

	setValue: function getValue_unbound( sourceArray, offset ) {

		this.bind();
		this.setValue( sourceArray, offset );

	},

	// create getter / setter pair for a property in the scene graph
	bind: function () {

		let targetObject = this.node;
		const parsedPath = this.parsedPath;

		const objectName = parsedPath.objectName;
		const propertyName = parsedPath.propertyName;
		let propertyIndex = parsedPath.propertyIndex;

		if ( ! targetObject ) {

			targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

			this.node = targetObject;

		}

		// set fail state so we can just 'return' on error
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;

		// ensure there is a value node
		if ( ! targetObject ) {

			console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
			return;

		}

		if ( objectName ) {

			let objectIndex = parsedPath.objectIndex;

			// special cases were we need to reach deeper into the hierarchy to get the face materials....
			switch ( objectName ) {

				case 'materials':

					if ( ! targetObject.material ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						return;

					}

					if ( ! targetObject.material.materials ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
						return;

					}

					targetObject = targetObject.material.materials;

					break;

				case 'bones':

					if ( ! targetObject.skeleton ) {

						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
						return;

					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for ( let i = 0; i < targetObject.length; i ++ ) {

						if ( targetObject[ i ].name === objectIndex ) {

							objectIndex = i;
							break;

						}

					}

					break;

				default:

					if ( targetObject[ objectName ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
						return;

					}

					targetObject = targetObject[ objectName ];

			}


			if ( objectIndex !== undefined ) {

				if ( targetObject[ objectIndex ] === undefined ) {

					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
					return;

				}

				targetObject = targetObject[ objectIndex ];

			}

		}

		// resolve property
		const nodeProperty = targetObject[ propertyName ];

		if ( nodeProperty === undefined ) {

			const nodeName = parsedPath.nodeName;

			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
				'.' + propertyName + ' but it wasn\'t found.', targetObject );
			return;

		}

		// determine versioning scheme
		let versioning = this.Versioning.None;

		this.targetObject = targetObject;

		if ( targetObject.needsUpdate !== undefined ) { // material

			versioning = this.Versioning.NeedsUpdate;

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			versioning = this.Versioning.MatrixWorldNeedsUpdate;

		}

		// determine how the property gets bound
		let bindingType = this.BindingType.Direct;

		if ( propertyIndex !== undefined ) {

			// access a sub element of the property array (only primitives are supported right now)

			if ( propertyName === 'morphTargetInfluences' ) {

				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
					return;

				}

				if ( targetObject.geometry.isBufferGeometry ) {

					if ( ! targetObject.geometry.morphAttributes ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
						return;

					}

					if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

						propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

					}


				} else {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this );
					return;

				}

			}

			bindingType = this.BindingType.ArrayElement;

			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;

		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

			// must use copy for Object3D.Euler/Quaternion

			bindingType = this.BindingType.HasFromToArray;

			this.resolvedProperty = nodeProperty;

		} else if ( Array.isArray( nodeProperty ) ) {

			bindingType = this.BindingType.EntireArray;

			this.resolvedProperty = nodeProperty;

		} else {

			this.propertyName = propertyName;

		}

		// select getter / setter
		this.getValue = this.GetterByBindingType[ bindingType ];
		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	},

	unbind: function () {

		this.node = null;

		// back to the prototype version of getValue / setValue
		// note: avoiding to mutate the shape of 'this' via 'delete'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}

} );

// DECLARE ALIAS AFTER assign prototype
Object.assign( PropertyBinding.prototype, {

	// initial state of these methods that calls 'bind'
	_getValue_unbound: PropertyBinding.prototype.getValue,
	_setValue_unbound: PropertyBinding.prototype.setValue,

} );




/***/ }),

/***/ "../../node_modules/three/src/animation/PropertyMixer.js":
/*!*******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/animation/PropertyMixer.js ***!
  \*******************************************************************************/
/*! exports provided: PropertyMixer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyMixer", function() { return PropertyMixer; });
/* harmony import */ var _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Quaternion.js */ "../../node_modules/three/src/math/Quaternion.js");


class PropertyMixer {

	constructor( binding, typeName, valueSize ) {

		this.binding = binding;
		this.valueSize = valueSize;

		let mixFunction,
			mixFunctionAdditive,
			setIdentity;

		// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property
		//
		// 'add' is used for additive cumulative results
		//
		// 'work' is optional and is only present for quaternion types. It is used
		// to store intermediate quaternion multiplication results

		switch ( typeName ) {

			case 'quaternion':
				mixFunction = this._slerp;
				mixFunctionAdditive = this._slerpAdditive;
				setIdentity = this._setAdditiveIdentityQuaternion;

				this.buffer = new Float64Array( valueSize * 6 );
				this._workIndex = 5;
				break;

			case 'string':
			case 'bool':
				mixFunction = this._select;

				// Use the regular mix function and for additive on these types,
				// additive is not relevant for non-numeric types
				mixFunctionAdditive = this._select;

				setIdentity = this._setAdditiveIdentityOther;

				this.buffer = new Array( valueSize * 5 );
				break;

			default:
				mixFunction = this._lerp;
				mixFunctionAdditive = this._lerpAdditive;
				setIdentity = this._setAdditiveIdentityNumeric;

				this.buffer = new Float64Array( valueSize * 5 );

		}

		this._mixBufferRegion = mixFunction;
		this._mixBufferRegionAdditive = mixFunctionAdditive;
		this._setIdentity = setIdentity;
		this._origIndex = 3;
		this._addIndex = 4;

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

		this.useCount = 0;
		this.referenceCount = 0;

	}

	// accumulate data in the 'incoming' region into 'accu<i>'
	accumulate( accuIndex, weight ) {

		// note: happily accumulating nothing when weight = 0, the caller knows
		// the weight and shouldn't have made the call in the first place

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = accuIndex * stride + stride;

		let currentWeight = this.cumulativeWeight;

		if ( currentWeight === 0 ) {

			// accuN := incoming * weight

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ offset + i ] = buffer[ i ];

			}

			currentWeight = weight;

		} else {

			// accuN := accuN + incoming * weight

			currentWeight += weight;
			const mix = weight / currentWeight;
			this._mixBufferRegion( buffer, offset, 0, mix, stride );

		}

		this.cumulativeWeight = currentWeight;

	}

	// accumulate data in the 'incoming' region into 'add'
	accumulateAdditive( weight ) {

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = stride * this._addIndex;

		if ( this.cumulativeWeightAdditive === 0 ) {

			// add = identity

			this._setIdentity();

		}

		// add := add + incoming * weight

		this._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );
		this.cumulativeWeightAdditive += weight;

	}

	// apply the state of 'accu<i>' to the binding when accus differ
	apply( accuIndex ) {

		const stride = this.valueSize,
			buffer = this.buffer,
			offset = accuIndex * stride + stride,

			weight = this.cumulativeWeight,
			weightAdditive = this.cumulativeWeightAdditive,

			binding = this.binding;

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

		if ( weight < 1 ) {

			// accuN := accuN + original * ( 1 - cumulativeWeight )

			const originalValueOffset = stride * this._origIndex;

			this._mixBufferRegion(
				buffer, offset, originalValueOffset, 1 - weight, stride );

		}

		if ( weightAdditive > 0 ) {

			// accuN := accuN + additive accuN

			this._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );

		}

		for ( let i = stride, e = stride + stride; i !== e; ++ i ) {

			if ( buffer[ i ] !== buffer[ i + stride ] ) {

				// value has changed -> update scene graph

				binding.setValue( buffer, offset );
				break;

			}

		}

	}

	// remember the state of the bound property and copy it to both accus
	saveOriginalState() {

		const binding = this.binding;

		const buffer = this.buffer,
			stride = this.valueSize,

			originalValueOffset = stride * this._origIndex;

		binding.getValue( buffer, originalValueOffset );

		// accu[0..1] := orig -- initially detect changes against the original
		for ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {

			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

		}

		// Add to identity for additive
		this._setIdentity();

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

	}

	// apply the state previously taken via 'saveOriginalState' to the binding
	restoreOriginalState() {

		const originalValueOffset = this.valueSize * 3;
		this.binding.setValue( this.buffer, originalValueOffset );

	}

	_setAdditiveIdentityNumeric() {

		const startIndex = this._addIndex * this.valueSize;
		const endIndex = startIndex + this.valueSize;

		for ( let i = startIndex; i < endIndex; i ++ ) {

			this.buffer[ i ] = 0;

		}

	}

	_setAdditiveIdentityQuaternion() {

		this._setAdditiveIdentityNumeric();
		this.buffer[ this._addIndex * this.valueSize + 3 ] = 1;

	}

	_setAdditiveIdentityOther() {

		const startIndex = this._origIndex * this.valueSize;
		const targetIndex = this._addIndex * this.valueSize;

		for ( let i = 0; i < this.valueSize; i ++ ) {

			this.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];

		}

	}


	// mix functions

	_select( buffer, dstOffset, srcOffset, t, stride ) {

		if ( t >= 0.5 ) {

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

			}

		}

	}

	_slerp( buffer, dstOffset, srcOffset, t ) {

		_math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"].slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

	}

	_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		const workOffset = this._workIndex * stride;

		// Store result in intermediate buffer offset
		_math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"].multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );

		// Slerp to the intermediate result
		_math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"].slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );

	}

	_lerp( buffer, dstOffset, srcOffset, t, stride ) {

		const s = 1 - t;

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

		}

	}

	_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;

		}

	}

}





/***/ }),

/***/ "../../node_modules/three/src/animation/tracks/BooleanKeyframeTrack.js":
/*!*********************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/animation/tracks/BooleanKeyframeTrack.js ***!
  \*********************************************************************************************/
/*! exports provided: BooleanKeyframeTrack */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BooleanKeyframeTrack", function() { return BooleanKeyframeTrack; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../KeyframeTrack.js */ "../../node_modules/three/src/animation/KeyframeTrack.js");



/**
 * A Track of Boolean keyframe values.
 */
class BooleanKeyframeTrack extends _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__["KeyframeTrack"] {}

BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateDiscrete"];
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

// Note: Actually this track could have a optimized / compressed
// representation of a single value and a custom interpolant that
// computes "firstValue ^ isOdd( index )".




/***/ }),

/***/ "../../node_modules/three/src/animation/tracks/ColorKeyframeTrack.js":
/*!*******************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/animation/tracks/ColorKeyframeTrack.js ***!
  \*******************************************************************************************/
/*! exports provided: ColorKeyframeTrack */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorKeyframeTrack", function() { return ColorKeyframeTrack; });
/* harmony import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KeyframeTrack.js */ "../../node_modules/three/src/animation/KeyframeTrack.js");


/**
 * A Track of keyframe values that represent color.
 */
class ColorKeyframeTrack extends _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__["KeyframeTrack"] {}

ColorKeyframeTrack.prototype.ValueTypeName = 'color';
// ValueBufferType is inherited
// DefaultInterpolation is inherited

// Note: Very basic implementation and nothing special yet.
// However, this is the place for color space parameterization.




/***/ }),

/***/ "../../node_modules/three/src/animation/tracks/NumberKeyframeTrack.js":
/*!********************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/animation/tracks/NumberKeyframeTrack.js ***!
  \********************************************************************************************/
/*! exports provided: NumberKeyframeTrack */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberKeyframeTrack", function() { return NumberKeyframeTrack; });
/* harmony import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KeyframeTrack.js */ "../../node_modules/three/src/animation/KeyframeTrack.js");


/**
 * A Track of numeric keyframe values.
 */
class NumberKeyframeTrack extends _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__["KeyframeTrack"] {}

NumberKeyframeTrack.prototype.ValueTypeName = 'number';
// ValueBufferType is inherited
// DefaultInterpolation is inherited




/***/ }),

/***/ "../../node_modules/three/src/animation/tracks/QuaternionKeyframeTrack.js":
/*!************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/animation/tracks/QuaternionKeyframeTrack.js ***!
  \************************************************************************************************/
/*! exports provided: QuaternionKeyframeTrack */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionKeyframeTrack", function() { return QuaternionKeyframeTrack; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../KeyframeTrack.js */ "../../node_modules/three/src/animation/KeyframeTrack.js");
/* harmony import */ var _math_interpolants_QuaternionLinearInterpolant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/interpolants/QuaternionLinearInterpolant.js */ "../../node_modules/three/src/math/interpolants/QuaternionLinearInterpolant.js");




/**
 * A Track of quaternion keyframe values.
 */
class QuaternionKeyframeTrack extends _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__["KeyframeTrack"] {

	InterpolantFactoryMethodLinear( result ) {

		return new _math_interpolants_QuaternionLinearInterpolant_js__WEBPACK_IMPORTED_MODULE_2__["QuaternionLinearInterpolant"]( this.times, this.values, this.getValueSize(), result );

	}

}

QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
// ValueBufferType is inherited
QuaternionKeyframeTrack.prototype.DefaultInterpolation = _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateLinear"];
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;




/***/ }),

/***/ "../../node_modules/three/src/animation/tracks/StringKeyframeTrack.js":
/*!********************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/animation/tracks/StringKeyframeTrack.js ***!
  \********************************************************************************************/
/*! exports provided: StringKeyframeTrack */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StringKeyframeTrack", function() { return StringKeyframeTrack; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../KeyframeTrack.js */ "../../node_modules/three/src/animation/KeyframeTrack.js");



/**
 * A Track that interpolates Strings
 */
class StringKeyframeTrack extends _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__["KeyframeTrack"] {}

StringKeyframeTrack.prototype.ValueTypeName = 'string';
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateDiscrete"];
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;




/***/ }),

/***/ "../../node_modules/three/src/animation/tracks/VectorKeyframeTrack.js":
/*!********************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/animation/tracks/VectorKeyframeTrack.js ***!
  \********************************************************************************************/
/*! exports provided: VectorKeyframeTrack */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorKeyframeTrack", function() { return VectorKeyframeTrack; });
/* harmony import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KeyframeTrack.js */ "../../node_modules/three/src/animation/KeyframeTrack.js");


/**
 * A Track of vectored keyframe values.
 */
class VectorKeyframeTrack extends _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__["KeyframeTrack"] {}

VectorKeyframeTrack.prototype.ValueTypeName = 'vector';
// ValueBufferType is inherited
// DefaultInterpolation is inherited




/***/ }),

/***/ "../../node_modules/three/src/audio/Audio.js":
/*!*******************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/audio/Audio.js ***!
  \*******************************************************************/
/*! exports provided: Audio */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Audio", function() { return Audio; });
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");


class Audio extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__["Object3D"] {

	constructor( listener ) {

		super();

		this.type = 'Audio';

		this.listener = listener;
		this.context = listener.context;

		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );

		this.autoplay = false;

		this.buffer = null;
		this.detune = 0;
		this.loop = false;
		this.loopStart = 0;
		this.loopEnd = 0;
		this.offset = 0;
		this.duration = undefined;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.source = null;
		this.sourceType = 'empty';

		this._startedAt = 0;
		this._progress = 0;
		this._connected = false;

		this.filters = [];

	}

	getOutput() {

		return this.gain;

	}

	setNodeSource( audioNode ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'audioNode';
		this.source = audioNode;
		this.connect();

		return this;

	}

	setMediaElementSource( mediaElement ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaNode';
		this.source = this.context.createMediaElementSource( mediaElement );
		this.connect();

		return this;

	}

	setMediaStreamSource( mediaStream ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaStreamNode';
		this.source = this.context.createMediaStreamSource( mediaStream );
		this.connect();

		return this;

	}

	setBuffer( audioBuffer ) {

		this.buffer = audioBuffer;
		this.sourceType = 'buffer';

		if ( this.autoplay ) this.play();

		return this;

	}

	play( delay = 0 ) {

		if ( this.isPlaying === true ) {

			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;

		}

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._startedAt = this.context.currentTime + delay;

		const source = this.context.createBufferSource();
		source.buffer = this.buffer;
		source.loop = this.loop;
		source.loopStart = this.loopStart;
		source.loopEnd = this.loopEnd;
		source.onended = this.onEnded.bind( this );
		source.start( this._startedAt, this._progress + this.offset, this.duration );

		this.isPlaying = true;

		this.source = source;

		this.setDetune( this.detune );
		this.setPlaybackRate( this.playbackRate );

		return this.connect();

	}

	pause() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		if ( this.isPlaying === true ) {

			// update current progress

			this._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;

			if ( this.loop === true ) {

				// ensure _progress does not exceed duration with looped audios

				this._progress = this._progress % ( this.duration || this.buffer.duration );

			}

			this.source.stop();
			this.source.onended = null;

			this.isPlaying = false;

		}

		return this;

	}

	stop() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._progress = 0;

		this.source.stop();
		this.source.onended = null;
		this.isPlaying = false;

		return this;

	}

	connect() {

		if ( this.filters.length > 0 ) {

			this.source.connect( this.filters[ 0 ] );

			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].connect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

		} else {

			this.source.connect( this.getOutput() );

		}

		this._connected = true;

		return this;

	}

	disconnect() {

		if ( this.filters.length > 0 ) {

			this.source.disconnect( this.filters[ 0 ] );

			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

		} else {

			this.source.disconnect( this.getOutput() );

		}

		this._connected = false;

		return this;

	}

	getFilters() {

		return this.filters;

	}

	setFilters( value ) {

		if ( ! value ) value = [];

		if ( this._connected === true ) {

			this.disconnect();
			this.filters = value.slice();
			this.connect();

		} else {

			this.filters = value.slice();

		}

		return this;

	}

	setDetune( value ) {

		this.detune = value;

		if ( this.source.detune === undefined ) return; // only set detune when available

		if ( this.isPlaying === true ) {

			this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

		}

		return this;

	}

	getDetune() {

		return this.detune;

	}

	getFilter() {

		return this.getFilters()[ 0 ];

	}

	setFilter( filter ) {

		return this.setFilters( filter ? [ filter ] : [] );

	}

	setPlaybackRate( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.playbackRate = value;

		if ( this.isPlaying === true ) {

			this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

		}

		return this;

	}

	getPlaybackRate() {

		return this.playbackRate;

	}

	onEnded() {

		this.isPlaying = false;

	}

	getLoop() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return false;

		}

		return this.loop;

	}

	setLoop( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.loop = value;

		if ( this.isPlaying === true ) {

			this.source.loop = this.loop;

		}

		return this;

	}

	setLoopStart( value ) {

		this.loopStart = value;

		return this;

	}

	setLoopEnd( value ) {

		this.loopEnd = value;

		return this;

	}

	getVolume() {

		return this.gain.gain.value;

	}

	setVolume( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

}




/***/ }),

/***/ "../../node_modules/three/src/audio/AudioAnalyser.js":
/*!***************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/audio/AudioAnalyser.js ***!
  \***************************************************************************/
/*! exports provided: AudioAnalyser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioAnalyser", function() { return AudioAnalyser; });
class AudioAnalyser {

	constructor( audio, fftSize = 2048 ) {

		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize;

		this.data = new Uint8Array( this.analyser.frequencyBinCount );

		audio.getOutput().connect( this.analyser );

	}


	getFrequencyData() {

		this.analyser.getByteFrequencyData( this.data );

		return this.data;

	}

	getAverageFrequency() {

		let value = 0;
		const data = this.getFrequencyData();

		for ( let i = 0; i < data.length; i ++ ) {

			value += data[ i ];

		}

		return value / data.length;

	}

}




/***/ }),

/***/ "../../node_modules/three/src/audio/AudioContext.js":
/*!**************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/audio/AudioContext.js ***!
  \**************************************************************************/
/*! exports provided: AudioContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioContext", function() { return AudioContext; });
let _context;

const AudioContext = {

	getContext: function () {

		if ( _context === undefined ) {

			_context = new ( window.AudioContext || window.webkitAudioContext )();

		}

		return _context;

	},

	setContext: function ( value ) {

		_context = value;

	}

};




/***/ }),

/***/ "../../node_modules/three/src/audio/AudioListener.js":
/*!***************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/audio/AudioListener.js ***!
  \***************************************************************************/
/*! exports provided: AudioListener */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioListener", function() { return AudioListener; });
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Quaternion.js */ "../../node_modules/three/src/math/Quaternion.js");
/* harmony import */ var _core_Clock_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Clock.js */ "../../node_modules/three/src/core/Clock.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");
/* harmony import */ var _AudioContext_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AudioContext.js */ "../../node_modules/three/src/audio/AudioContext.js");






const _position = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _quaternion = /*@__PURE__*/ new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_1__["Quaternion"]();
const _scale = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _orientation = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

class AudioListener extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_3__["Object3D"] {

	constructor() {

		super();

		this.type = 'AudioListener';

		this.context = _AudioContext_js__WEBPACK_IMPORTED_MODULE_4__["AudioContext"].getContext();

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.filter = null;

		this.timeDelta = 0;

		// private

		this._clock = new _core_Clock_js__WEBPACK_IMPORTED_MODULE_2__["Clock"]();

	}

	getInput() {

		return this.gain;

	}

	removeFilter() {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
			this.gain.connect( this.context.destination );
			this.filter = null;

		}

		return this;

	}

	getFilter() {

		return this.filter;

	}

	setFilter( value ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );

		} else {

			this.gain.disconnect( this.context.destination );

		}

		this.filter = value;
		this.gain.connect( this.filter );
		this.filter.connect( this.context.destination );

		return this;

	}

	getMasterVolume() {

		return this.gain.gain.value;

	}

	setMasterVolume( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		const listener = this.context.listener;
		const up = this.up;

		this.timeDelta = this._clock.getDelta();

		this.matrixWorld.decompose( _position, _quaternion, _scale );

		_orientation.set( 0, 0, - 1 ).applyQuaternion( _quaternion );

		if ( listener.positionX ) {

			// code path for Chrome (see #14393)

			const endTime = this.context.currentTime + this.timeDelta;

			listener.positionX.linearRampToValueAtTime( _position.x, endTime );
			listener.positionY.linearRampToValueAtTime( _position.y, endTime );
			listener.positionZ.linearRampToValueAtTime( _position.z, endTime );
			listener.forwardX.linearRampToValueAtTime( _orientation.x, endTime );
			listener.forwardY.linearRampToValueAtTime( _orientation.y, endTime );
			listener.forwardZ.linearRampToValueAtTime( _orientation.z, endTime );
			listener.upX.linearRampToValueAtTime( up.x, endTime );
			listener.upY.linearRampToValueAtTime( up.y, endTime );
			listener.upZ.linearRampToValueAtTime( up.z, endTime );

		} else {

			listener.setPosition( _position.x, _position.y, _position.z );
			listener.setOrientation( _orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z );

		}

	}

}




/***/ }),

/***/ "../../node_modules/three/src/audio/PositionalAudio.js":
/*!*****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/audio/PositionalAudio.js ***!
  \*****************************************************************************/
/*! exports provided: PositionalAudio */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PositionalAudio", function() { return PositionalAudio; });
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Quaternion.js */ "../../node_modules/three/src/math/Quaternion.js");
/* harmony import */ var _Audio_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Audio.js */ "../../node_modules/three/src/audio/Audio.js");




const _position = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _quaternion = /*@__PURE__*/ new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_1__["Quaternion"]();
const _scale = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _orientation = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

class PositionalAudio extends _Audio_js__WEBPACK_IMPORTED_MODULE_2__["Audio"] {

	constructor( listener ) {

		super( listener );

		this.panner = this.context.createPanner();
		this.panner.panningModel = 'HRTF';
		this.panner.connect( this.gain );

	}

	getOutput() {

		return this.panner;

	}

	getRefDistance() {

		return this.panner.refDistance;

	}

	setRefDistance( value ) {

		this.panner.refDistance = value;

		return this;

	}

	getRolloffFactor() {

		return this.panner.rolloffFactor;

	}

	setRolloffFactor( value ) {

		this.panner.rolloffFactor = value;

		return this;

	}

	getDistanceModel() {

		return this.panner.distanceModel;

	}

	setDistanceModel( value ) {

		this.panner.distanceModel = value;

		return this;

	}

	getMaxDistance() {

		return this.panner.maxDistance;

	}

	setMaxDistance( value ) {

		this.panner.maxDistance = value;

		return this;

	}

	setDirectionalCone( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

		this.panner.coneInnerAngle = coneInnerAngle;
		this.panner.coneOuterAngle = coneOuterAngle;
		this.panner.coneOuterGain = coneOuterGain;

		return this;

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		if ( this.hasPlaybackControl === true && this.isPlaying === false ) return;

		this.matrixWorld.decompose( _position, _quaternion, _scale );

		_orientation.set( 0, 0, 1 ).applyQuaternion( _quaternion );

		const panner = this.panner;

		if ( panner.positionX ) {

			// code path for Chrome and Firefox (see #14393)

			const endTime = this.context.currentTime + this.listener.timeDelta;

			panner.positionX.linearRampToValueAtTime( _position.x, endTime );
			panner.positionY.linearRampToValueAtTime( _position.y, endTime );
			panner.positionZ.linearRampToValueAtTime( _position.z, endTime );
			panner.orientationX.linearRampToValueAtTime( _orientation.x, endTime );
			panner.orientationY.linearRampToValueAtTime( _orientation.y, endTime );
			panner.orientationZ.linearRampToValueAtTime( _orientation.z, endTime );

		} else {

			panner.setPosition( _position.x, _position.y, _position.z );
			panner.setOrientation( _orientation.x, _orientation.y, _orientation.z );

		}

	}

}




/***/ }),

/***/ "../../node_modules/three/src/cameras/ArrayCamera.js":
/*!***************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/cameras/ArrayCamera.js ***!
  \***************************************************************************/
/*! exports provided: ArrayCamera */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrayCamera", function() { return ArrayCamera; });
/* harmony import */ var _PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PerspectiveCamera.js */ "../../node_modules/three/src/cameras/PerspectiveCamera.js");


class ArrayCamera extends _PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_0__["PerspectiveCamera"] {

	constructor( array = [] ) {

		super();

		this.cameras = array;

	}

}

ArrayCamera.prototype.isArrayCamera = true;





/***/ }),

/***/ "../../node_modules/three/src/cameras/Camera.js":
/*!**********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/cameras/Camera.js ***!
  \**********************************************************************/
/*! exports provided: Camera */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Camera", function() { return Camera; });
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Matrix4.js */ "../../node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");




function Camera() {

	_core_Object3D_js__WEBPACK_IMPORTED_MODULE_1__["Object3D"].call( this );

	this.type = 'Camera';

	this.matrixWorldInverse = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();

	this.projectionMatrix = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
	this.projectionMatrixInverse = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();

}

Camera.prototype = Object.assign( Object.create( _core_Object3D_js__WEBPACK_IMPORTED_MODULE_1__["Object3D"].prototype ), {

	constructor: Camera,

	isCamera: true,

	copy: function ( source, recursive ) {

		_core_Object3D_js__WEBPACK_IMPORTED_MODULE_1__["Object3D"].prototype.copy.call( this, source, recursive );

		this.matrixWorldInverse.copy( source.matrixWorldInverse );

		this.projectionMatrix.copy( source.projectionMatrix );
		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

		return this;

	},

	getWorldDirection: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Camera: .getWorldDirection() target is now required' );
			target = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

		}

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

	},

	updateMatrixWorld: function ( force ) {

		_core_Object3D_js__WEBPACK_IMPORTED_MODULE_1__["Object3D"].prototype.updateMatrixWorld.call( this, force );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	},

	updateWorldMatrix: function ( updateParents, updateChildren ) {

		_core_Object3D_js__WEBPACK_IMPORTED_MODULE_1__["Object3D"].prototype.updateWorldMatrix.call( this, updateParents, updateChildren );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

} );




/***/ }),

/***/ "../../node_modules/three/src/cameras/CubeCamera.js":
/*!**************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/cameras/CubeCamera.js ***!
  \**************************************************************************/
/*! exports provided: CubeCamera */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeCamera", function() { return CubeCamera; });
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PerspectiveCamera.js */ "../../node_modules/three/src/cameras/PerspectiveCamera.js");




const fov = 90, aspect = 1;

class CubeCamera extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__["Object3D"] {

	constructor( near, far, renderTarget ) {

		super();

		this.type = 'CubeCamera';

		if ( renderTarget.isWebGLCubeRenderTarget !== true ) {

			console.error( 'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.' );
			return;

		}

		this.renderTarget = renderTarget;

		const cameraPX = new _PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__["PerspectiveCamera"]( fov, aspect, near, far );
		cameraPX.layers = this.layers;
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( 1, 0, 0 ) );
		this.add( cameraPX );

		const cameraNX = new _PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__["PerspectiveCamera"]( fov, aspect, near, far );
		cameraNX.layers = this.layers;
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( - 1, 0, 0 ) );
		this.add( cameraNX );

		const cameraPY = new _PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__["PerspectiveCamera"]( fov, aspect, near, far );
		cameraPY.layers = this.layers;
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( 0, 1, 0 ) );
		this.add( cameraPY );

		const cameraNY = new _PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__["PerspectiveCamera"]( fov, aspect, near, far );
		cameraNY.layers = this.layers;
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( 0, - 1, 0 ) );
		this.add( cameraNY );

		const cameraPZ = new _PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__["PerspectiveCamera"]( fov, aspect, near, far );
		cameraPZ.layers = this.layers;
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( 0, 0, 1 ) );
		this.add( cameraPZ );

		const cameraNZ = new _PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__["PerspectiveCamera"]( fov, aspect, near, far );
		cameraNZ.layers = this.layers;
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( 0, 0, - 1 ) );
		this.add( cameraNZ );

	}

	update( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		const renderTarget = this.renderTarget;

		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

		const currentXrEnabled = renderer.xr.enabled;
		const currentRenderTarget = renderer.getRenderTarget();

		renderer.xr.enabled = false;

		const generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderer.setRenderTarget( renderTarget, 0 );
		renderer.render( scene, cameraPX );

		renderer.setRenderTarget( renderTarget, 1 );
		renderer.render( scene, cameraNX );

		renderer.setRenderTarget( renderTarget, 2 );
		renderer.render( scene, cameraPY );

		renderer.setRenderTarget( renderTarget, 3 );
		renderer.render( scene, cameraNY );

		renderer.setRenderTarget( renderTarget, 4 );
		renderer.render( scene, cameraPZ );

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderer.setRenderTarget( renderTarget, 5 );
		renderer.render( scene, cameraNZ );

		renderer.setRenderTarget( currentRenderTarget );

		renderer.xr.enabled = currentXrEnabled;

	}

}




/***/ }),

/***/ "../../node_modules/three/src/cameras/OrthographicCamera.js":
/*!**********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/cameras/OrthographicCamera.js ***!
  \**********************************************************************************/
/*! exports provided: OrthographicCamera */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrthographicCamera", function() { return OrthographicCamera; });
/* harmony import */ var _Camera_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Camera.js */ "../../node_modules/three/src/cameras/Camera.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");



class OrthographicCamera extends _Camera_js__WEBPACK_IMPORTED_MODULE_0__["Camera"] {

	constructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

		super();

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = near;
		this.far = far;

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		return this;

	}

	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	updateProjectionMatrix() {

		const dx = ( this.right - this.left ) / ( 2 * this.zoom );
		const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		const cx = ( this.right + this.left ) / 2;
		const cy = ( this.top + this.bottom ) / 2;

		let left = cx - dx;
		let right = cx + dx;
		let top = cy + dy;
		let bottom = cy - dy;

		if ( this.view !== null && this.view.enabled ) {

			const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
			const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

			left += scaleW * this.view.offsetX;
			right = left + scaleW * this.view.width;
			top -= scaleH * this.view.offsetY;
			bottom = top - scaleH * this.view.height;

		}

		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = _core_Object3D_js__WEBPACK_IMPORTED_MODULE_1__["Object3D"].prototype.toJSON.call( this, meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		return data;

	}

}

OrthographicCamera.prototype.isOrthographicCamera = true;




/***/ }),

/***/ "../../node_modules/three/src/cameras/PerspectiveCamera.js":
/*!*********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/cameras/PerspectiveCamera.js ***!
  \*********************************************************************************/
/*! exports provided: PerspectiveCamera */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PerspectiveCamera", function() { return PerspectiveCamera; });
/* harmony import */ var _Camera_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Camera.js */ "../../node_modules/three/src/cameras/Camera.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");




function PerspectiveCamera( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

	_Camera_js__WEBPACK_IMPORTED_MODULE_0__["Camera"].call( this );

	this.type = 'PerspectiveCamera';

	this.fov = fov;
	this.zoom = 1;

	this.near = near;
	this.far = far;
	this.focus = 10;

	this.aspect = aspect;
	this.view = null;

	this.filmGauge = 35;	// width of the film (default in millimeters)
	this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

	this.updateProjectionMatrix();

}

PerspectiveCamera.prototype = Object.assign( Object.create( _Camera_js__WEBPACK_IMPORTED_MODULE_0__["Camera"].prototype ), {

	constructor: PerspectiveCamera,

	isPerspectiveCamera: true,

	copy: function ( source, recursive ) {

		_Camera_js__WEBPACK_IMPORTED_MODULE_0__["Camera"].prototype.copy.call( this, source, recursive );

		this.fov = source.fov;
		this.zoom = source.zoom;

		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;

		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;

		return this;

	},

	/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength: function ( focalLength ) {

		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		this.fov = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__["MathUtils"].RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();

	},

	/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
	getFocalLength: function () {

		const vExtentSlope = Math.tan( _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__["MathUtils"].DEG2RAD * 0.5 * this.fov );

		return 0.5 * this.getFilmHeight() / vExtentSlope;

	},

	getEffectiveFOV: function () {

		return _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__["MathUtils"].RAD2DEG * 2 * Math.atan(
			Math.tan( _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__["MathUtils"].DEG2RAD * 0.5 * this.fov ) / this.zoom );

	},

	getFilmWidth: function () {

		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min( this.aspect, 1 );

	},

	getFilmHeight: function () {

		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max( this.aspect, 1 );

	},

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

		this.aspect = fullWidth / fullHeight;

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	},

	clearViewOffset: function () {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	},

	updateProjectionMatrix: function () {

		const near = this.near;
		let top = near * Math.tan( _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__["MathUtils"].DEG2RAD * 0.5 * this.fov ) / this.zoom;
		let height = 2 * top;
		let width = this.aspect * height;
		let left = - 0.5 * width;
		const view = this.view;

		if ( this.view !== null && this.view.enabled ) {

			const fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;

			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;

		}

		const skew = this.filmOffset;
		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	},

	toJSON: function ( meta ) {

		const data = _core_Object3D_js__WEBPACK_IMPORTED_MODULE_1__["Object3D"].prototype.toJSON.call( this, meta );

		data.object.fov = this.fov;
		data.object.zoom = this.zoom;

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;

		data.object.aspect = this.aspect;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;

		return data;

	}

} );





/***/ }),

/***/ "../../node_modules/three/src/cameras/StereoCamera.js":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/cameras/StereoCamera.js ***!
  \****************************************************************************/
/*! exports provided: StereoCamera */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StereoCamera", function() { return StereoCamera; });
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Matrix4.js */ "../../node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");
/* harmony import */ var _PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PerspectiveCamera.js */ "../../node_modules/three/src/cameras/PerspectiveCamera.js");




const _eyeRight = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
const _eyeLeft = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();

class StereoCamera {

	constructor() {

		this.type = 'StereoCamera';

		this.aspect = 1;

		this.eyeSep = 0.064;

		this.cameraL = new _PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__["PerspectiveCamera"]();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;

		this.cameraR = new _PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__["PerspectiveCamera"]();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;

		this._cache = {
			focus: null,
			fov: null,
			aspect: null,
			near: null,
			far: null,
			zoom: null,
			eyeSep: null
		};

	}

	update( camera ) {

		const cache = this._cache;

		const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
			cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
			cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

		if ( needsUpdate ) {

			cache.focus = camera.focus;
			cache.fov = camera.fov;
			cache.aspect = camera.aspect * this.aspect;
			cache.near = camera.near;
			cache.far = camera.far;
			cache.zoom = camera.zoom;
			cache.eyeSep = this.eyeSep;

			// Off-axis stereoscopic effect based on
			// http://paulbourke.net/stereographics/stereorender/

			const projectionMatrix = camera.projectionMatrix.clone();
			const eyeSepHalf = cache.eyeSep / 2;
			const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
			const ymax = ( cache.near * Math.tan( _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__["MathUtils"].DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;
			let xmin, xmax;

			// translate xOffset

			_eyeLeft.elements[ 12 ] = - eyeSepHalf;
			_eyeRight.elements[ 12 ] = eyeSepHalf;

			// for left eye

			xmin = - ymax * cache.aspect + eyeSepOnProjection;
			xmax = ymax * cache.aspect + eyeSepOnProjection;

			projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraL.projectionMatrix.copy( projectionMatrix );

			// for right eye

			xmin = - ymax * cache.aspect - eyeSepOnProjection;
			xmax = ymax * cache.aspect - eyeSepOnProjection;

			projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraR.projectionMatrix.copy( projectionMatrix );

		}

		this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );
		this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );

	}

}




/***/ }),

/***/ "../../node_modules/three/src/constants.js":
/*!*****************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/constants.js ***!
  \*****************************************************************/
/*! exports provided: REVISION, MOUSE, TOUCH, CullFaceNone, CullFaceBack, CullFaceFront, CullFaceFrontBack, BasicShadowMap, PCFShadowMap, PCFSoftShadowMap, VSMShadowMap, FrontSide, BackSide, DoubleSide, FlatShading, SmoothShading, NoBlending, NormalBlending, AdditiveBlending, SubtractiveBlending, MultiplyBlending, CustomBlending, AddEquation, SubtractEquation, ReverseSubtractEquation, MinEquation, MaxEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor, DstColorFactor, OneMinusDstColorFactor, SrcAlphaSaturateFactor, NeverDepth, AlwaysDepth, LessDepth, LessEqualDepth, EqualDepth, GreaterEqualDepth, GreaterDepth, NotEqualDepth, MultiplyOperation, MixOperation, AddOperation, NoToneMapping, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, ACESFilmicToneMapping, CustomToneMapping, UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, CubeUVReflectionMapping, CubeUVRefractionMapping, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipMapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipMapLinearFilter, UnsignedByteType, ByteType, ShortType, UnsignedShortType, IntType, UnsignedIntType, FloatType, HalfFloatType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedInt248Type, AlphaFormat, RGBFormat, RGBAFormat, LuminanceFormat, LuminanceAlphaFormat, RGBEFormat, DepthFormat, DepthStencilFormat, RedFormat, RedIntegerFormat, RGFormat, RGIntegerFormat, RGBIntegerFormat, RGBAIntegerFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_BPTC_Format, SRGB8_ALPHA8_ASTC_4x4_Format, SRGB8_ALPHA8_ASTC_5x4_Format, SRGB8_ALPHA8_ASTC_5x5_Format, SRGB8_ALPHA8_ASTC_6x5_Format, SRGB8_ALPHA8_ASTC_6x6_Format, SRGB8_ALPHA8_ASTC_8x5_Format, SRGB8_ALPHA8_ASTC_8x6_Format, SRGB8_ALPHA8_ASTC_8x8_Format, SRGB8_ALPHA8_ASTC_10x5_Format, SRGB8_ALPHA8_ASTC_10x6_Format, SRGB8_ALPHA8_ASTC_10x8_Format, SRGB8_ALPHA8_ASTC_10x10_Format, SRGB8_ALPHA8_ASTC_12x10_Format, SRGB8_ALPHA8_ASTC_12x12_Format, LoopOnce, LoopRepeat, LoopPingPong, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, ZeroCurvatureEnding, ZeroSlopeEnding, WrapAroundEnding, NormalAnimationBlendMode, AdditiveAnimationBlendMode, TrianglesDrawMode, TriangleStripDrawMode, TriangleFanDrawMode, LinearEncoding, sRGBEncoding, GammaEncoding, RGBEEncoding, LogLuvEncoding, RGBM7Encoding, RGBM16Encoding, RGBDEncoding, BasicDepthPacking, RGBADepthPacking, TangentSpaceNormalMap, ObjectSpaceNormalMap, ZeroStencilOp, KeepStencilOp, ReplaceStencilOp, IncrementStencilOp, DecrementStencilOp, IncrementWrapStencilOp, DecrementWrapStencilOp, InvertStencilOp, NeverStencilFunc, LessStencilFunc, EqualStencilFunc, LessEqualStencilFunc, GreaterStencilFunc, NotEqualStencilFunc, GreaterEqualStencilFunc, AlwaysStencilFunc, StaticDrawUsage, DynamicDrawUsage, StreamDrawUsage, StaticReadUsage, DynamicReadUsage, StreamReadUsage, StaticCopyUsage, DynamicCopyUsage, StreamCopyUsage, GLSL1, GLSL3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "REVISION", function() { return REVISION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOUSE", function() { return MOUSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOUCH", function() { return TOUCH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceNone", function() { return CullFaceNone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceBack", function() { return CullFaceBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFront", function() { return CullFaceFront; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFrontBack", function() { return CullFaceFrontBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicShadowMap", function() { return BasicShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFShadowMap", function() { return PCFShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFSoftShadowMap", function() { return PCFSoftShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VSMShadowMap", function() { return VSMShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontSide", function() { return FrontSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BackSide", function() { return BackSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DoubleSide", function() { return DoubleSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlatShading", function() { return FlatShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SmoothShading", function() { return SmoothShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoBlending", function() { return NoBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NormalBlending", function() { return NormalBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdditiveBlending", function() { return AdditiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractiveBlending", function() { return SubtractiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyBlending", function() { return MultiplyBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomBlending", function() { return CustomBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddEquation", function() { return AddEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractEquation", function() { return SubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReverseSubtractEquation", function() { return ReverseSubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MinEquation", function() { return MinEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaxEquation", function() { return MaxEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroFactor", function() { return ZeroFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneFactor", function() { return OneFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcColorFactor", function() { return SrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcColorFactor", function() { return OneMinusSrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaFactor", function() { return SrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcAlphaFactor", function() { return OneMinusSrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstAlphaFactor", function() { return DstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstAlphaFactor", function() { return OneMinusDstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstColorFactor", function() { return DstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstColorFactor", function() { return OneMinusDstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaSaturateFactor", function() { return SrcAlphaSaturateFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverDepth", function() { return NeverDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysDepth", function() { return AlwaysDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessDepth", function() { return LessDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualDepth", function() { return LessEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualDepth", function() { return EqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualDepth", function() { return GreaterEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterDepth", function() { return GreaterDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualDepth", function() { return NotEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyOperation", function() { return MultiplyOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MixOperation", function() { return MixOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddOperation", function() { return AddOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoToneMapping", function() { return NoToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearToneMapping", function() { return LinearToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReinhardToneMapping", function() { return ReinhardToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CineonToneMapping", function() { return CineonToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ACESFilmicToneMapping", function() { return ACESFilmicToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomToneMapping", function() { return CustomToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UVMapping", function() { return UVMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeReflectionMapping", function() { return CubeReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeRefractionMapping", function() { return CubeRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularReflectionMapping", function() { return EquirectangularReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularRefractionMapping", function() { return EquirectangularRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVReflectionMapping", function() { return CubeUVReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVRefractionMapping", function() { return CubeUVRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RepeatWrapping", function() { return RepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClampToEdgeWrapping", function() { return ClampToEdgeWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MirroredRepeatWrapping", function() { return MirroredRepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestFilter", function() { return NearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapNearestFilter", function() { return NearestMipmapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapNearestFilter", function() { return NearestMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapLinearFilter", function() { return NearestMipmapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapLinearFilter", function() { return NearestMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearFilter", function() { return LinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapNearestFilter", function() { return LinearMipmapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapNearestFilter", function() { return LinearMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapLinearFilter", function() { return LinearMipmapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapLinearFilter", function() { return LinearMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedByteType", function() { return UnsignedByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ByteType", function() { return ByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShortType", function() { return ShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShortType", function() { return UnsignedShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntType", function() { return IntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedIntType", function() { return UnsignedIntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FloatType", function() { return FloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HalfFloatType", function() { return HalfFloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort4444Type", function() { return UnsignedShort4444Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort5551Type", function() { return UnsignedShort5551Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort565Type", function() { return UnsignedShort565Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedInt248Type", function() { return UnsignedInt248Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlphaFormat", function() { return AlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBFormat", function() { return RGBFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAFormat", function() { return RGBAFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceFormat", function() { return LuminanceFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceAlphaFormat", function() { return LuminanceAlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEFormat", function() { return RGBEFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthFormat", function() { return DepthFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthStencilFormat", function() { return DepthStencilFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedFormat", function() { return RedFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedIntegerFormat", function() { return RedIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGFormat", function() { return RGFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGIntegerFormat", function() { return RGIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBIntegerFormat", function() { return RGBIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAIntegerFormat", function() { return RGBAIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_S3TC_DXT1_Format", function() { return RGB_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT1_Format", function() { return RGBA_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT3_Format", function() { return RGBA_S3TC_DXT3_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT5_Format", function() { return RGBA_S3TC_DXT5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_4BPPV1_Format", function() { return RGB_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_2BPPV1_Format", function() { return RGB_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_4BPPV1_Format", function() { return RGBA_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_2BPPV1_Format", function() { return RGBA_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC1_Format", function() { return RGB_ETC1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC2_Format", function() { return RGB_ETC2_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ETC2_EAC_Format", function() { return RGBA_ETC2_EAC_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_4x4_Format", function() { return RGBA_ASTC_4x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x4_Format", function() { return RGBA_ASTC_5x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x5_Format", function() { return RGBA_ASTC_5x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x5_Format", function() { return RGBA_ASTC_6x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x6_Format", function() { return RGBA_ASTC_6x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x5_Format", function() { return RGBA_ASTC_8x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x6_Format", function() { return RGBA_ASTC_8x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x8_Format", function() { return RGBA_ASTC_8x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x5_Format", function() { return RGBA_ASTC_10x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x6_Format", function() { return RGBA_ASTC_10x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x8_Format", function() { return RGBA_ASTC_10x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x10_Format", function() { return RGBA_ASTC_10x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x10_Format", function() { return RGBA_ASTC_12x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x12_Format", function() { return RGBA_ASTC_12x12_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_BPTC_Format", function() { return RGBA_BPTC_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_4x4_Format", function() { return SRGB8_ALPHA8_ASTC_4x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_5x4_Format", function() { return SRGB8_ALPHA8_ASTC_5x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_5x5_Format", function() { return SRGB8_ALPHA8_ASTC_5x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_6x5_Format", function() { return SRGB8_ALPHA8_ASTC_6x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_6x6_Format", function() { return SRGB8_ALPHA8_ASTC_6x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x5_Format", function() { return SRGB8_ALPHA8_ASTC_8x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x6_Format", function() { return SRGB8_ALPHA8_ASTC_8x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x8_Format", function() { return SRGB8_ALPHA8_ASTC_8x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x5_Format", function() { return SRGB8_ALPHA8_ASTC_10x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x6_Format", function() { return SRGB8_ALPHA8_ASTC_10x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x8_Format", function() { return SRGB8_ALPHA8_ASTC_10x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x10_Format", function() { return SRGB8_ALPHA8_ASTC_10x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_12x10_Format", function() { return SRGB8_ALPHA8_ASTC_12x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_12x12_Format", function() { return SRGB8_ALPHA8_ASTC_12x12_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopOnce", function() { return LoopOnce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopRepeat", function() { return LoopRepeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopPingPong", function() { return LoopPingPong; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateDiscrete", function() { return InterpolateDiscrete; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateLinear", function() { return InterpolateLinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateSmooth", function() { return InterpolateSmooth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroCurvatureEnding", function() { return ZeroCurvatureEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroSlopeEnding", function() { return ZeroSlopeEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WrapAroundEnding", function() { return WrapAroundEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NormalAnimationBlendMode", function() { return NormalAnimationBlendMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdditiveAnimationBlendMode", function() { return AdditiveAnimationBlendMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrianglesDrawMode", function() { return TrianglesDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleStripDrawMode", function() { return TriangleStripDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleFanDrawMode", function() { return TriangleFanDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearEncoding", function() { return LinearEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sRGBEncoding", function() { return sRGBEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GammaEncoding", function() { return GammaEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEEncoding", function() { return RGBEEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogLuvEncoding", function() { return LogLuvEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM7Encoding", function() { return RGBM7Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM16Encoding", function() { return RGBM16Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBDEncoding", function() { return RGBDEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicDepthPacking", function() { return BasicDepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBADepthPacking", function() { return RGBADepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TangentSpaceNormalMap", function() { return TangentSpaceNormalMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectSpaceNormalMap", function() { return ObjectSpaceNormalMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroStencilOp", function() { return ZeroStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeepStencilOp", function() { return KeepStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReplaceStencilOp", function() { return ReplaceStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementStencilOp", function() { return IncrementStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecrementStencilOp", function() { return DecrementStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementWrapStencilOp", function() { return IncrementWrapStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecrementWrapStencilOp", function() { return DecrementWrapStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InvertStencilOp", function() { return InvertStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverStencilFunc", function() { return NeverStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessStencilFunc", function() { return LessStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualStencilFunc", function() { return EqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualStencilFunc", function() { return LessEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterStencilFunc", function() { return GreaterStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualStencilFunc", function() { return NotEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualStencilFunc", function() { return GreaterEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysStencilFunc", function() { return AlwaysStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticDrawUsage", function() { return StaticDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicDrawUsage", function() { return DynamicDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamDrawUsage", function() { return StreamDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticReadUsage", function() { return StaticReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicReadUsage", function() { return DynamicReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamReadUsage", function() { return StreamReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticCopyUsage", function() { return StaticCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicCopyUsage", function() { return DynamicCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamCopyUsage", function() { return StreamCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLSL1", function() { return GLSL1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLSL3", function() { return GLSL3; });
const REVISION = '127';
const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const CullFaceFrontBack = 3;
const BasicShadowMap = 0;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const FlatShading = 1;
const SmoothShading = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;

const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const CubeUVRefractionMapping = 307;
const RepeatWrapping = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipMapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const NearestMipMapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipMapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedShort565Type = 1019;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const RGBEFormat = RGBAFormat;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBIntegerFormat = 1032;
const RGBAIntegerFormat = 1033;

const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const LinearEncoding = 3000;
const sRGBEncoding = 3001;
const GammaEncoding = 3007;
const RGBEEncoding = 3002;
const LogLuvEncoding = 3003;
const RGBM7Encoding = 3004;
const RGBM16Encoding = 3005;
const RGBDEncoding = 3006;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;

const ZeroStencilOp = 0;
const KeepStencilOp = 7680;
const ReplaceStencilOp = 7681;
const IncrementStencilOp = 7682;
const DecrementStencilOp = 7683;
const IncrementWrapStencilOp = 34055;
const DecrementWrapStencilOp = 34056;
const InvertStencilOp = 5386;

const NeverStencilFunc = 512;
const LessStencilFunc = 513;
const EqualStencilFunc = 514;
const LessEqualStencilFunc = 515;
const GreaterStencilFunc = 516;
const NotEqualStencilFunc = 517;
const GreaterEqualStencilFunc = 518;
const AlwaysStencilFunc = 519;

const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const StreamDrawUsage = 35040;
const StaticReadUsage = 35045;
const DynamicReadUsage = 35049;
const StreamReadUsage = 35041;
const StaticCopyUsage = 35046;
const DynamicCopyUsage = 35050;
const StreamCopyUsage = 35042;

const GLSL1 = '100';
const GLSL3 = '300 es';


/***/ }),

/***/ "../../node_modules/three/src/core/BufferAttribute.js":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/core/BufferAttribute.js ***!
  \****************************************************************************/
/*! exports provided: Float64BufferAttribute, Float32BufferAttribute, Float16BufferAttribute, Uint32BufferAttribute, Int32BufferAttribute, Uint16BufferAttribute, Int16BufferAttribute, Uint8ClampedBufferAttribute, Uint8BufferAttribute, Int8BufferAttribute, BufferAttribute */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64BufferAttribute", function() { return Float64BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32BufferAttribute", function() { return Float32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float16BufferAttribute", function() { return Float16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32BufferAttribute", function() { return Uint32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32BufferAttribute", function() { return Int32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16BufferAttribute", function() { return Uint16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16BufferAttribute", function() { return Int16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedBufferAttribute", function() { return Uint8ClampedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8BufferAttribute", function() { return Uint8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8BufferAttribute", function() { return Int8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferAttribute", function() { return BufferAttribute; });
/* harmony import */ var _math_Vector4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector4.js */ "../../node_modules/three/src/math/Vector4.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");






const _vector = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
const _vector2 = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]();

function BufferAttribute( array, itemSize, normalized ) {

	if ( Array.isArray( array ) ) {

		throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

	}

	this.name = '';

	this.array = array;
	this.itemSize = itemSize;
	this.count = array !== undefined ? array.length / itemSize : 0;
	this.normalized = normalized === true;

	this.usage = _constants_js__WEBPACK_IMPORTED_MODULE_4__["StaticDrawUsage"];
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;

}

Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

Object.assign( BufferAttribute.prototype, {

	isBufferAttribute: true,

	onUploadCallback: function () {},

	setUsage: function ( value ) {

		this.usage = value;

		return this;

	},

	copy: function ( source ) {

		this.name = source.name;
		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.usage = source.usage;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	copyArray: function ( array ) {

		this.array.set( array );

		return this;

	},

	copyColorsArray: function ( colors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = colors.length; i < l; i ++ ) {

			let color = colors[ i ];

			if ( color === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
				color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_3__["Color"]();

			}

			array[ offset ++ ] = color.r;
			array[ offset ++ ] = color.g;
			array[ offset ++ ] = color.b;

		}

		return this;

	},

	copyVector2sArray: function ( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				vector = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;

		}

		return this;

	},

	copyVector3sArray: function ( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				vector = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;

		}

		return this;

	},

	copyVector4sArray: function ( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				vector = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_0__["Vector4"]();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;
			array[ offset ++ ] = vector.w;

		}

		return this;

	},

	applyMatrix3: function ( m ) {

		if ( this.itemSize === 2 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector2.fromBufferAttribute( this, i );
				_vector2.applyMatrix3( m );

				this.setXY( i, _vector2.x, _vector2.y );

			}

		} else if ( this.itemSize === 3 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector.fromBufferAttribute( this, i );
				_vector.applyMatrix3( m );

				this.setXYZ( i, _vector.x, _vector.y, _vector.z );

			}

		}

		return this;

	},

	applyMatrix4: function ( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector.x = this.getX( i );
			_vector.y = this.getY( i );
			_vector.z = this.getZ( i );

			_vector.applyMatrix4( m );

			this.setXYZ( i, _vector.x, _vector.y, _vector.z );

		}

		return this;

	},

	applyNormalMatrix: function ( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector.x = this.getX( i );
			_vector.y = this.getY( i );
			_vector.z = this.getZ( i );

			_vector.applyNormalMatrix( m );

			this.setXYZ( i, _vector.x, _vector.y, _vector.z );

		}

		return this;

	},

	transformDirection: function ( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector.x = this.getX( i );
			_vector.y = this.getY( i );
			_vector.z = this.getZ( i );

			_vector.transformDirection( m );

			this.setXYZ( i, _vector.x, _vector.y, _vector.z );

		}

		return this;

	},

	set: function ( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	},

	getX: function ( index ) {

		return this.array[ index * this.itemSize ];

	},

	setX: function ( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	},

	getY: function ( index ) {

		return this.array[ index * this.itemSize + 1 ];

	},

	setY: function ( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	},

	getZ: function ( index ) {

		return this.array[ index * this.itemSize + 2 ];

	},

	setZ: function ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	},

	getW: function ( index ) {

		return this.array[ index * this.itemSize + 3 ];

	},

	setW: function ( index, w ) {

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	},

	setXY: function ( index, x, y ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	},

	onUpload: function ( callback ) {

		this.onUploadCallback = callback;

		return this;

	},

	clone: function () {

		return new this.constructor( this.array, this.itemSize ).copy( this );

	},

	toJSON: function () {

		const data = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.prototype.slice.call( this.array ),
			normalized: this.normalized
		};

		if ( this.name !== '' ) data.name = this.name;
		if ( this.usage !== _constants_js__WEBPACK_IMPORTED_MODULE_4__["StaticDrawUsage"] ) data.usage = this.usage;
		if ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) data.updateRange = this.updateRange;

		return data;

	}

} );

//

function Int8BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );

}

Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


function Uint8BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );

}

Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );

}

Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


function Int16BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );

}

Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


function Uint16BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

}

Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


function Int32BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );

}

Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


function Uint32BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );

}

Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;

function Float16BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

}

Float16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float16BufferAttribute.prototype.constructor = Float16BufferAttribute;
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;

function Float32BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );

}

Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


function Float64BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );

}

Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

//




/***/ }),

/***/ "../../node_modules/three/src/core/BufferGeometry.js":
/*!***************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/core/BufferGeometry.js ***!
  \***************************************************************************/
/*! exports provided: BufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometry", function() { return BufferGeometry; });
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Box3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Box3.js */ "../../node_modules/three/src/math/Box3.js");
/* harmony import */ var _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventDispatcher.js */ "../../node_modules/three/src/core/EventDispatcher.js");
/* harmony import */ var _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _math_Sphere_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/Sphere.js */ "../../node_modules/three/src/math/Sphere.js");
/* harmony import */ var _Object3D_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Object3D.js */ "../../node_modules/three/src/core/Object3D.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/Matrix4.js */ "../../node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../math/Matrix3.js */ "../../node_modules/three/src/math/Matrix3.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../math/MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils.js */ "../../node_modules/three/src/utils.js");












let _id = 0;

const _m1 = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_7__["Matrix4"]();
const _obj = new _Object3D_js__WEBPACK_IMPORTED_MODULE_6__["Object3D"]();
const _offset = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _box = new _math_Box3_js__WEBPACK_IMPORTED_MODULE_2__["Box3"]();
const _boxMorphTargets = new _math_Box3_js__WEBPACK_IMPORTED_MODULE_2__["Box3"]();
const _vector = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

function BufferGeometry() {

	Object.defineProperty( this, 'id', { value: _id ++ } );

	this.uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_9__["MathUtils"].generateUUID();

	this.name = '';
	this.type = 'BufferGeometry';

	this.index = null;
	this.attributes = {};

	this.morphAttributes = {};
	this.morphTargetsRelative = false;

	this.groups = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.drawRange = { start: 0, count: Infinity };

	this.userData = {};

}

BufferGeometry.prototype = Object.assign( Object.create( _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_3__["EventDispatcher"].prototype ), {

	constructor: BufferGeometry,

	isBufferGeometry: true,

	getIndex: function () {

		return this.index;

	},

	setIndex: function ( index ) {

		if ( Array.isArray( index ) ) {

			this.index = new ( Object(_utils_js__WEBPACK_IMPORTED_MODULE_10__["arrayMax"])( index ) > 65535 ? _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["Uint32BufferAttribute"] : _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["Uint16BufferAttribute"] )( index, 1 );

		} else {

			this.index = index;

		}

		return this;

	},

	getAttribute: function ( name ) {

		return this.attributes[ name ];

	},

	setAttribute: function ( name, attribute ) {

		this.attributes[ name ] = attribute;

		return this;

	},

	deleteAttribute: function ( name ) {

		delete this.attributes[ name ];

		return this;

	},

	hasAttribute: function ( name ) {

		return this.attributes[ name ] !== undefined;

	},

	addGroup: function ( start, count, materialIndex = 0 ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex

		} );

	},

	clearGroups: function () {

		this.groups = [];

	},

	setDrawRange: function ( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	},

	applyMatrix4: function ( matrix ) {

		const position = this.attributes.position;

		if ( position !== undefined ) {

			position.applyMatrix4( matrix );

			position.needsUpdate = true;

		}

		const normal = this.attributes.normal;

		if ( normal !== undefined ) {

			const normalMatrix = new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_8__["Matrix3"]().getNormalMatrix( matrix );

			normal.applyNormalMatrix( normalMatrix );

			normal.needsUpdate = true;

		}

		const tangent = this.attributes.tangent;

		if ( tangent !== undefined ) {

			tangent.transformDirection( matrix );

			tangent.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	},

	rotateX: function ( angle ) {

		// rotate geometry around world x-axis

		_m1.makeRotationX( angle );

		this.applyMatrix4( _m1 );

		return this;

	},

	rotateY: function ( angle ) {

		// rotate geometry around world y-axis

		_m1.makeRotationY( angle );

		this.applyMatrix4( _m1 );

		return this;

	},

	rotateZ: function ( angle ) {

		// rotate geometry around world z-axis

		_m1.makeRotationZ( angle );

		this.applyMatrix4( _m1 );

		return this;

	},

	translate: function ( x, y, z ) {

		// translate geometry

		_m1.makeTranslation( x, y, z );

		this.applyMatrix4( _m1 );

		return this;

	},

	scale: function ( x, y, z ) {

		// scale geometry

		_m1.makeScale( x, y, z );

		this.applyMatrix4( _m1 );

		return this;

	},

	lookAt: function ( vector ) {

		_obj.lookAt( vector );

		_obj.updateMatrix();

		this.applyMatrix4( _obj.matrix );

		return this;

	},

	center: function () {

		this.computeBoundingBox();

		this.boundingBox.getCenter( _offset ).negate();

		this.translate( _offset.x, _offset.y, _offset.z );

		return this;

	},

	setFromPoints: function ( points ) {

		const position = [];

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			const point = points[ i ];
			position.push( point.x, point.y, point.z || 0 );

		}

		this.setAttribute( 'position', new _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["Float32BufferAttribute"]( position, 3 ) );

		return this;

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new _math_Box3_js__WEBPACK_IMPORTED_MODULE_2__["Box3"]();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );

			this.boundingBox.set(
				new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]( - Infinity, - Infinity, - Infinity ),
				new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]( + Infinity, + Infinity, + Infinity )
			);

			return;

		}

		if ( position !== undefined ) {

			this.boundingBox.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_box.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector.addVectors( this.boundingBox.min, _box.min );
						this.boundingBox.expandByPoint( _vector );

						_vector.addVectors( this.boundingBox.max, _box.max );
						this.boundingBox.expandByPoint( _vector );

					} else {

						this.boundingBox.expandByPoint( _box.min );
						this.boundingBox.expandByPoint( _box.max );

					}

				}

			}

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new _math_Sphere_js__WEBPACK_IMPORTED_MODULE_5__["Sphere"]();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );

			this.boundingSphere.set( new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), Infinity );

			return;

		}

		if ( position ) {

			// first, find the center of the bounding sphere

			const center = this.boundingSphere.center;

			_box.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector.addVectors( _box.min, _boxMorphTargets.min );
						_box.expandByPoint( _vector );

						_vector.addVectors( _box.max, _boxMorphTargets.max );
						_box.expandByPoint( _vector );

					} else {

						_box.expandByPoint( _boxMorphTargets.min );
						_box.expandByPoint( _boxMorphTargets.max );

					}

				}

			}

			_box.getCenter( center );

			// second, try to find a boundingSphere with a radius smaller than the
			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

			let maxRadiusSq = 0;

			for ( let i = 0, il = position.count; i < il; i ++ ) {

				_vector.fromBufferAttribute( position, i );

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );

			}

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					const morphTargetsRelative = this.morphTargetsRelative;

					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

						_vector.fromBufferAttribute( morphAttribute, j );

						if ( morphTargetsRelative ) {

							_offset.fromBufferAttribute( position, j );
							_vector.add( _offset );

						}

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );

					}

				}

			}

			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			if ( isNaN( this.boundingSphere.radius ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

			}

		}

	},

	computeFaceNormals: function () {

		// backwards compatibility

	},

	computeTangents: function () {

		const index = this.index;
		const attributes = this.attributes;

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( index === null ||
			 attributes.position === undefined ||
			 attributes.normal === undefined ||
			 attributes.uv === undefined ) {

			console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
			return;

		}

		const indices = index.array;
		const positions = attributes.position.array;
		const normals = attributes.normal.array;
		const uvs = attributes.uv.array;

		const nVertices = positions.length / 3;

		if ( attributes.tangent === undefined ) {

			this.setAttribute( 'tangent', new _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["BufferAttribute"]( new Float32Array( 4 * nVertices ), 4 ) );

		}

		const tangents = attributes.tangent.array;

		const tan1 = [], tan2 = [];

		for ( let i = 0; i < nVertices; i ++ ) {

			tan1[ i ] = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
			tan2[ i ] = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

		}

		const vA = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
			vB = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
			vC = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),

			uvA = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"](),
			uvB = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"](),
			uvC = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"](),

			sdir = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
			tdir = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

		function handleTriangle( a, b, c ) {

			vA.fromArray( positions, a * 3 );
			vB.fromArray( positions, b * 3 );
			vC.fromArray( positions, c * 3 );

			uvA.fromArray( uvs, a * 2 );
			uvB.fromArray( uvs, b * 2 );
			uvC.fromArray( uvs, c * 2 );

			vB.sub( vA );
			vC.sub( vA );

			uvB.sub( uvA );
			uvC.sub( uvA );

			const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

			// silently ignore degenerate uv triangles having coincident or colinear vertices

			if ( ! isFinite( r ) ) return;

			sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
			tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		let groups = this.groups;

		if ( groups.length === 0 ) {

			groups = [ {
				start: 0,
				count: indices.length
			} ];

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleTriangle(
					indices[ j + 0 ],
					indices[ j + 1 ],
					indices[ j + 2 ]
				);

			}

		}

		const tmp = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), tmp2 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
		const n = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), n2 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

		function handleVertex( v ) {

			n.fromArray( normals, v * 3 );
			n2.copy( n );

			const t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			const test = tmp2.dot( tan2[ v ] );
			const w = ( test < 0.0 ) ? - 1.0 : 1.0;

			tangents[ v * 4 ] = tmp.x;
			tangents[ v * 4 + 1 ] = tmp.y;
			tangents[ v * 4 + 2 ] = tmp.z;
			tangents[ v * 4 + 3 ] = w;

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleVertex( indices[ j + 0 ] );
				handleVertex( indices[ j + 1 ] );
				handleVertex( indices[ j + 2 ] );

			}

		}

	},

	computeVertexNormals: function () {

		const index = this.index;
		const positionAttribute = this.getAttribute( 'position' );

		if ( positionAttribute !== undefined ) {

			let normalAttribute = this.getAttribute( 'normal' );

			if ( normalAttribute === undefined ) {

				normalAttribute = new _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["BufferAttribute"]( new Float32Array( positionAttribute.count * 3 ), 3 );
				this.setAttribute( 'normal', normalAttribute );

			} else {

				// reset existing normals to zero

				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

					normalAttribute.setXYZ( i, 0, 0, 0 );

				}

			}

			const pA = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), pB = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), pC = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
			const nA = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), nB = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), nC = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
			const cb = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), ab = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

			// indexed elements

			if ( index ) {

				for ( let i = 0, il = index.count; i < il; i += 3 ) {

					const vA = index.getX( i + 0 );
					const vB = index.getX( i + 1 );
					const vC = index.getX( i + 2 );

					pA.fromBufferAttribute( positionAttribute, vA );
					pB.fromBufferAttribute( positionAttribute, vB );
					pC.fromBufferAttribute( positionAttribute, vC );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					nA.fromBufferAttribute( normalAttribute, vA );
					nB.fromBufferAttribute( normalAttribute, vB );
					nC.fromBufferAttribute( normalAttribute, vC );

					nA.add( cb );
					nB.add( cb );
					nC.add( cb );

					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

					pA.fromBufferAttribute( positionAttribute, i + 0 );
					pB.fromBufferAttribute( positionAttribute, i + 1 );
					pC.fromBufferAttribute( positionAttribute, i + 2 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

				}

			}

			this.normalizeNormals();

			normalAttribute.needsUpdate = true;

		}

	},

	merge: function ( geometry, offset ) {

		if ( ! ( geometry && geometry.isBufferGeometry ) ) {

			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			return;

		}

		if ( offset === undefined ) {

			offset = 0;

			console.warn(
				'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
				+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
			);

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			if ( geometry.attributes[ key ] === undefined ) continue;

			const attribute1 = attributes[ key ];
			const attributeArray1 = attribute1.array;

			const attribute2 = geometry.attributes[ key ];
			const attributeArray2 = attribute2.array;

			const attributeOffset = attribute2.itemSize * offset;
			const length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );

			for ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {

				attributeArray1[ j ] = attributeArray2[ i ];

			}

		}

		return this;

	},

	normalizeNormals: function () {

		const normals = this.attributes.normal;

		for ( let i = 0, il = normals.count; i < il; i ++ ) {

			_vector.fromBufferAttribute( normals, i );

			_vector.normalize();

			normals.setXYZ( i, _vector.x, _vector.y, _vector.z );

		}

	},

	toNonIndexed: function () {

		function convertBufferAttribute( attribute, indices ) {

			const array = attribute.array;
			const itemSize = attribute.itemSize;
			const normalized = attribute.normalized;

			const array2 = new array.constructor( indices.length * itemSize );

			let index = 0, index2 = 0;

			for ( let i = 0, l = indices.length; i < l; i ++ ) {

				index = indices[ i ] * itemSize;

				for ( let j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			return new _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["BufferAttribute"]( array2, itemSize, normalized );

		}

		//

		if ( this.index === null ) {

			console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
			return this;

		}

		const geometry2 = new BufferGeometry();

		const indices = this.index.array;
		const attributes = this.attributes;

		// attributes

		for ( const name in attributes ) {

			const attribute = attributes[ name ];

			const newAttribute = convertBufferAttribute( attribute, indices );

			geometry2.setAttribute( name, newAttribute );

		}

		// morph attributes

		const morphAttributes = this.morphAttributes;

		for ( const name in morphAttributes ) {

			const morphArray = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

				const attribute = morphAttribute[ i ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				morphArray.push( newAttribute );

			}

			geometry2.morphAttributes[ name ] = morphArray;

		}

		geometry2.morphTargetsRelative = this.morphTargetsRelative;

		// groups

		const groups = this.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			geometry2.addGroup( group.start, group.count, group.materialIndex );

		}

		return geometry2;

	},

	toJSON: function () {

		const data = {
			metadata: {
				version: 4.5,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;
		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		if ( this.parameters !== undefined ) {

			const parameters = this.parameters;

			for ( const key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		// for simplicity the code assumes attributes are not shared across geometries, see #15811

		data.data = { attributes: {} };

		const index = this.index;

		if ( index !== null ) {

			data.data.index = {
				type: index.array.constructor.name,
				array: Array.prototype.slice.call( index.array )
			};

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];

			data.data.attributes[ key ] = attribute.toJSON( data.data );

		}

		const morphAttributes = {};
		let hasMorphAttributes = false;

		for ( const key in this.morphAttributes ) {

			const attributeArray = this.morphAttributes[ key ];

			const array = [];

			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

				const attribute = attributeArray[ i ];

				array.push( attribute.toJSON( data.data ) );

			}

			if ( array.length > 0 ) {

				morphAttributes[ key ] = array;

				hasMorphAttributes = true;

			}

		}

		if ( hasMorphAttributes ) {

			data.data.morphAttributes = morphAttributes;
			data.data.morphTargetsRelative = this.morphTargetsRelative;

		}

		const groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		const boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	},

	clone: function () {

		/*
		 // Handle primitives

		 const parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 const values = [];

		 for ( const key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 const geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */

		return new BufferGeometry().copy( this );

	},

	copy: function ( source ) {

		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// used for storing cloned, shared data

		const data = {};

		// name

		this.name = source.name;

		// index

		const index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone( data ) );

		}

		// attributes

		const attributes = source.attributes;

		for ( const name in attributes ) {

			const attribute = attributes[ name ];
			this.setAttribute( name, attribute.clone( data ) );

		}

		// morph attributes

		const morphAttributes = source.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

				array.push( morphAttribute[ i ].clone( data ) );

			}

			this.morphAttributes[ name ] = array;

		}

		this.morphTargetsRelative = source.morphTargetsRelative;

		// groups

		const groups = source.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		// bounding box

		const boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		const boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		// user data

		this.userData = source.userData;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );





/***/ }),

/***/ "../../node_modules/three/src/core/Clock.js":
/*!******************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/core/Clock.js ***!
  \******************************************************************/
/*! exports provided: Clock */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Clock", function() { return Clock; });
class Clock {

	constructor( autoStart ) {

		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	}

	start() {

		this.startTime = now();

		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;

	}

	stop() {

		this.getElapsedTime();
		this.running = false;
		this.autoStart = false;

	}

	getElapsedTime() {

		this.getDelta();
		return this.elapsedTime;

	}

	getDelta() {

		let diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();
			return 0;

		}

		if ( this.running ) {

			const newTime = now();

			diff = ( newTime - this.oldTime ) / 1000;
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

}

function now() {

	return ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

}




/***/ }),

/***/ "../../node_modules/three/src/core/EventDispatcher.js":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/core/EventDispatcher.js ***!
  \****************************************************************************/
/*! exports provided: EventDispatcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventDispatcher", function() { return EventDispatcher; });
/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

function EventDispatcher() {}

Object.assign( EventDispatcher.prototype, {

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		const listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		const listeners = this._listeners;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			const index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function ( event ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			// Make a copy, in case listeners are removed while iterating.
			const array = listenerArray.slice( 0 );

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				array[ i ].call( this, event );

			}

			event.target = null;

		}

	}

} );





/***/ }),

/***/ "../../node_modules/three/src/core/GLBufferAttribute.js":
/*!******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/core/GLBufferAttribute.js ***!
  \******************************************************************************/
/*! exports provided: GLBufferAttribute */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLBufferAttribute", function() { return GLBufferAttribute; });
function GLBufferAttribute( buffer, type, itemSize, elementSize, count ) {

	this.buffer = buffer;
	this.type = type;
	this.itemSize = itemSize;
	this.elementSize = elementSize;
	this.count = count;

	this.version = 0;

}

Object.defineProperty( GLBufferAttribute.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

Object.assign( GLBufferAttribute.prototype, {

	isGLBufferAttribute: true,

	setBuffer: function ( buffer ) {

		this.buffer = buffer;

		return this;

	},

	setType: function ( type, elementSize ) {

		this.type = type;
		this.elementSize = elementSize;

		return this;

	},

	setItemSize: function ( itemSize ) {

		this.itemSize = itemSize;

		return this;

	},

	setCount: function ( count ) {

		this.count = count;

		return this;

	},

} );





/***/ }),

/***/ "../../node_modules/three/src/core/InstancedBufferAttribute.js":
/*!*************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/core/InstancedBufferAttribute.js ***!
  \*************************************************************************************/
/*! exports provided: InstancedBufferAttribute */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferAttribute", function() { return InstancedBufferAttribute; });
/* harmony import */ var _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");


function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {

	if ( typeof ( normalized ) === 'number' ) {

		meshPerAttribute = normalized;

		normalized = false;

		console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

	}

	_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0__["BufferAttribute"].call( this, array, itemSize, normalized );

	this.meshPerAttribute = meshPerAttribute || 1;

}

InstancedBufferAttribute.prototype = Object.assign( Object.create( _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0__["BufferAttribute"].prototype ), {

	constructor: InstancedBufferAttribute,

	isInstancedBufferAttribute: true,

	copy: function ( source ) {

		_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0__["BufferAttribute"].prototype.copy.call( this, source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	},

	toJSON: function ()	{

		const data = _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0__["BufferAttribute"].prototype.toJSON.call( this );

		data.meshPerAttribute = this.meshPerAttribute;

		data.isInstancedBufferAttribute = true;

		return data;

	}

} );






/***/ }),

/***/ "../../node_modules/three/src/core/InstancedBufferGeometry.js":
/*!************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/core/InstancedBufferGeometry.js ***!
  \************************************************************************************/
/*! exports provided: InstancedBufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferGeometry", function() { return InstancedBufferGeometry; });
/* harmony import */ var _BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");


function InstancedBufferGeometry() {

	_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"].call( this );

	this.type = 'InstancedBufferGeometry';
	this.instanceCount = Infinity;

}

InstancedBufferGeometry.prototype = Object.assign( Object.create( _BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"].prototype ), {

	constructor: InstancedBufferGeometry,

	isInstancedBufferGeometry: true,

	copy: function ( source ) {

		_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"].prototype.copy.call( this, source );

		this.instanceCount = source.instanceCount;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	toJSON: function () {

		const data = _BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"].prototype.toJSON.call( this );

		data.instanceCount = this.instanceCount;

		data.isInstancedBufferGeometry = true;

		return data;

	}

} );




/***/ }),

/***/ "../../node_modules/three/src/core/InstancedInterleavedBuffer.js":
/*!***************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/core/InstancedInterleavedBuffer.js ***!
  \***************************************************************************************/
/*! exports provided: InstancedInterleavedBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedInterleavedBuffer", function() { return InstancedInterleavedBuffer; });
/* harmony import */ var _InterleavedBuffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./InterleavedBuffer.js */ "../../node_modules/three/src/core/InterleavedBuffer.js");


function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

	_InterleavedBuffer_js__WEBPACK_IMPORTED_MODULE_0__["InterleavedBuffer"].call( this, array, stride );

	this.meshPerAttribute = meshPerAttribute || 1;

}

InstancedInterleavedBuffer.prototype = Object.assign( Object.create( _InterleavedBuffer_js__WEBPACK_IMPORTED_MODULE_0__["InterleavedBuffer"].prototype ), {

	constructor: InstancedInterleavedBuffer,

	isInstancedInterleavedBuffer: true,

	copy: function ( source ) {

		_InterleavedBuffer_js__WEBPACK_IMPORTED_MODULE_0__["InterleavedBuffer"].prototype.copy.call( this, source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	},

	clone: function ( data ) {

		const ib = _InterleavedBuffer_js__WEBPACK_IMPORTED_MODULE_0__["InterleavedBuffer"].prototype.clone.call( this, data );

		ib.meshPerAttribute = this.meshPerAttribute;

		return ib;

	},

	toJSON: function ( data ) {

		const json = _InterleavedBuffer_js__WEBPACK_IMPORTED_MODULE_0__["InterleavedBuffer"].prototype.toJSON.call( this, data );

		json.isInstancedInterleavedBuffer = true;
		json.meshPerAttribute = this.meshPerAttribute;

		return json;

	}

} );




/***/ }),

/***/ "../../node_modules/three/src/core/InterleavedBuffer.js":
/*!******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/core/InterleavedBuffer.js ***!
  \******************************************************************************/
/*! exports provided: InterleavedBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBuffer", function() { return InterleavedBuffer; });
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");



function InterleavedBuffer( array, stride ) {

	this.array = array;
	this.stride = stride;
	this.count = array !== undefined ? array.length / stride : 0;

	this.usage = _constants_js__WEBPACK_IMPORTED_MODULE_1__["StaticDrawUsage"];
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;

	this.uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].generateUUID();

}

Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

Object.assign( InterleavedBuffer.prototype, {

	isInterleavedBuffer: true,

	onUploadCallback: function () {},

	setUsage: function ( value ) {

		this.usage = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.count = source.count;
		this.stride = source.stride;
		this.usage = source.usage;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( let i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	set: function ( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	},

	clone: function ( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

		}

		const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

		const ib = new InterleavedBuffer( array, this.stride );
		ib.setUsage( this.usage );

		return ib;

	},

	onUpload: function ( callback ) {

		this.onUploadCallback = callback;

		return this;

	},

	toJSON: function ( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		// generate UUID for array buffer if necessary

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = Array.prototype.slice.call( new Uint32Array( this.array.buffer ) );

		}

		//

		return {
			uuid: this.uuid,
			buffer: this.array.buffer._uuid,
			type: this.array.constructor.name,
			stride: this.stride
		};

	}

} );




/***/ }),

/***/ "../../node_modules/three/src/core/InterleavedBufferAttribute.js":
/*!***************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/core/InterleavedBufferAttribute.js ***!
  \***************************************************************************************/
/*! exports provided: InterleavedBufferAttribute */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBufferAttribute", function() { return InterleavedBufferAttribute; });
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");



const _vector = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

	this.name = '';

	this.data = interleavedBuffer;
	this.itemSize = itemSize;
	this.offset = offset;

	this.normalized = normalized === true;

}

Object.defineProperties( InterleavedBufferAttribute.prototype, {

	count: {

		get: function () {

			return this.data.count;

		}

	},

	array: {

		get: function () {

			return this.data.array;

		}

	},

	needsUpdate: {

		set: function ( value ) {

			this.data.needsUpdate = value;

		}

	}

} );

Object.assign( InterleavedBufferAttribute.prototype, {

	isInterleavedBufferAttribute: true,

	applyMatrix4: function ( m ) {

		for ( let i = 0, l = this.data.count; i < l; i ++ ) {

			_vector.x = this.getX( i );
			_vector.y = this.getY( i );
			_vector.z = this.getZ( i );

			_vector.applyMatrix4( m );

			this.setXYZ( i, _vector.x, _vector.y, _vector.z );

		}

		return this;

	},

	applyNormalMatrix: function ( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector.x = this.getX( i );
			_vector.y = this.getY( i );
			_vector.z = this.getZ( i );

			_vector.applyNormalMatrix( m );

			this.setXYZ( i, _vector.x, _vector.y, _vector.z );

		}

		return this;

	},

	transformDirection: function ( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector.x = this.getX( i );
			_vector.y = this.getY( i );
			_vector.z = this.getZ( i );

			_vector.transformDirection( m );

			this.setXYZ( i, _vector.x, _vector.y, _vector.z );

		}

		return this;

	},

	setX: function ( index, x ) {

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	},

	setY: function ( index, y ) {

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	},

	setZ: function ( index, z ) {

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	},

	setW: function ( index, w ) {

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	},

	getX: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset ];

	},

	getY: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 1 ];

	},

	getZ: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 2 ];

	},

	getW: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 3 ];

	},

	setXY: function ( index, x, y ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	},

	clone: function ( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			return new _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"]( new this.array.constructor( array ), this.itemSize, this.normalized );

		} else {

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

			}

			return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

		}

	},

	toJSON: function ( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			// deinterleave data and save it as an ordinary buffer attribute for now

			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: array,
				normalized: this.normalized
			};

		} else {

			// save as true interlaved attribtue

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

			}

			return {
				isInterleavedBufferAttribute: true,
				itemSize: this.itemSize,
				data: this.data.uuid,
				offset: this.offset,
				normalized: this.normalized
			};

		}

	}

} );





/***/ }),

/***/ "../../node_modules/three/src/core/Layers.js":
/*!*******************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/core/Layers.js ***!
  \*******************************************************************/
/*! exports provided: Layers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Layers", function() { return Layers; });
class Layers {

	constructor() {

		this.mask = 1 | 0;

	}

	set( channel ) {

		this.mask = 1 << channel | 0;

	}

	enable( channel ) {

		this.mask |= 1 << channel | 0;

	}

	enableAll() {

		this.mask = 0xffffffff | 0;

	}

	toggle( channel ) {

		this.mask ^= 1 << channel | 0;

	}

	disable( channel ) {

		this.mask &= ~ ( 1 << channel | 0 );

	}

	disableAll() {

		this.mask = 0;

	}

	test( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

}





/***/ }),

/***/ "../../node_modules/three/src/core/Object3D.js":
/*!*********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/core/Object3D.js ***!
  \*********************************************************************/
/*! exports provided: Object3D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Object3D", function() { return Object3D; });
/* harmony import */ var _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Quaternion.js */ "../../node_modules/three/src/math/Quaternion.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Matrix4.js */ "../../node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventDispatcher.js */ "../../node_modules/three/src/core/EventDispatcher.js");
/* harmony import */ var _math_Euler_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Euler.js */ "../../node_modules/three/src/math/Euler.js");
/* harmony import */ var _Layers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Layers.js */ "../../node_modules/three/src/core/Layers.js");
/* harmony import */ var _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/Matrix3.js */ "../../node_modules/three/src/math/Matrix3.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");









let _object3DId = 0;

const _v1 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
const _q1 = new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();
const _m1 = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();
const _target = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

const _position = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
const _scale = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
const _quaternion = new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();

const _xAxis = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( 1, 0, 0 );
const _yAxis = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( 0, 1, 0 );
const _zAxis = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( 0, 0, 1 );

const _addedEvent = { type: 'added' };
const _removedEvent = { type: 'removed' };

function Object3D() {

	Object.defineProperty( this, 'id', { value: _object3DId ++ } );

	this.uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_7__["MathUtils"].generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = null;
	this.children = [];

	this.up = Object3D.DefaultUp.clone();

	const position = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
	const rotation = new _math_Euler_js__WEBPACK_IMPORTED_MODULE_4__["Euler"]();
	const quaternion = new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();
	const scale = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( 1, 1, 1 );

	function onRotationChange() {

		quaternion.setFromEuler( rotation, false );

	}

	function onQuaternionChange() {

		rotation.setFromQuaternion( quaternion, undefined, false );

	}

	rotation._onChange( onRotationChange );
	quaternion._onChange( onQuaternionChange );

	Object.defineProperties( this, {
		position: {
			configurable: true,
			enumerable: true,
			value: position
		},
		rotation: {
			configurable: true,
			enumerable: true,
			value: rotation
		},
		quaternion: {
			configurable: true,
			enumerable: true,
			value: quaternion
		},
		scale: {
			configurable: true,
			enumerable: true,
			value: scale
		},
		modelViewMatrix: {
			value: new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]()
		},
		normalMatrix: {
			value: new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__["Matrix3"]()
		}
	} );

	this.matrix = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();
	this.matrixWorld = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();

	this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
	this.matrixWorldNeedsUpdate = false;

	this.layers = new _Layers_js__WEBPACK_IMPORTED_MODULE_5__["Layers"]();
	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;
	this.renderOrder = 0;

	this.animations = [];

	this.userData = {};

}

Object3D.DefaultUp = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( 0, 1, 0 );
Object3D.DefaultMatrixAutoUpdate = true;

Object3D.prototype = Object.assign( Object.create( _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_3__["EventDispatcher"].prototype ), {

	constructor: Object3D,

	isObject3D: true,

	onBeforeRender: function () {},
	onAfterRender: function () {},

	applyMatrix4: function ( matrix ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		this.matrix.premultiply( matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	applyQuaternion: function ( q ) {

		this.quaternion.premultiply( q );

		return this;

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function ( axis, angle ) {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.multiply( _q1 );

		return this;

	},

	rotateOnWorldAxis: function ( axis, angle ) {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.premultiply( _q1 );

		return this;

	},

	rotateX: function ( angle ) {

		return this.rotateOnAxis( _xAxis, angle );

	},

	rotateY: function ( angle ) {

		return this.rotateOnAxis( _yAxis, angle );

	},

	rotateZ: function ( angle ) {

		return this.rotateOnAxis( _zAxis, angle );

	},

	translateOnAxis: function ( axis, distance ) {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1.copy( axis ).applyQuaternion( this.quaternion );

		this.position.add( _v1.multiplyScalar( distance ) );

		return this;

	},

	translateX: function ( distance ) {

		return this.translateOnAxis( _xAxis, distance );

	},

	translateY: function ( distance ) {

		return this.translateOnAxis( _yAxis, distance );

	},

	translateZ: function ( distance ) {

		return this.translateOnAxis( _zAxis, distance );

	},

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function ( vector ) {

		return vector.applyMatrix4( _m1.copy( this.matrixWorld ).invert() );

	},

	lookAt: function ( x, y, z ) {

		// This method does not support objects having non-uniformly-scaled parent(s)

		if ( x.isVector3 ) {

			_target.copy( x );

		} else {

			_target.set( x, y, z );

		}

		const parent = this.parent;

		this.updateWorldMatrix( true, false );

		_position.setFromMatrixPosition( this.matrixWorld );

		if ( this.isCamera || this.isLight ) {

			_m1.lookAt( _position, _target, this.up );

		} else {

			_m1.lookAt( _target, _position, this.up );

		}

		this.quaternion.setFromRotationMatrix( _m1 );

		if ( parent ) {

			_m1.extractRotation( parent.matrixWorld );
			_q1.setFromRotationMatrix( _m1 );
			this.quaternion.premultiply( _q1.invert() );

		}

	},

	add: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
			return this;

		}

		if ( object && object.isObject3D ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			this.children.push( object );

			object.dispatchEvent( _addedEvent );

		} else {

			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

		}

		return this;

	},

	remove: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		const index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;
			this.children.splice( index, 1 );

			object.dispatchEvent( _removedEvent );

		}

		return this;

	},

	clear: function () {

		for ( let i = 0; i < this.children.length; i ++ ) {

			const object = this.children[ i ];

			object.parent = null;

			object.dispatchEvent( _removedEvent );

		}

		this.children.length = 0;

		return this;


	},

	attach: function ( object ) {

		// adds object as a child of this, while maintaining the object's world transform

		this.updateWorldMatrix( true, false );

		_m1.copy( this.matrixWorld ).invert();

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1.multiply( object.parent.matrixWorld );

		}

		object.applyMatrix4( _m1 );

		this.add( object );

		object.updateWorldMatrix( false, true );

		return this;

	},

	getObjectById: function ( id ) {

		return this.getObjectByProperty( 'id', id );

	},

	getObjectByName: function ( name ) {

		return this.getObjectByProperty( 'name', name );

	},

	getObjectByProperty: function ( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

			const child = this.children[ i ];
			const object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getWorldPosition: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
			target = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

		}

		this.updateWorldMatrix( true, false );

		return target.setFromMatrixPosition( this.matrixWorld );

	},

	getWorldQuaternion: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
			target = new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();

		}

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position, target, _scale );

		return target;

	},

	getWorldScale: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
			target = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

		}

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position, _quaternion, target );

		return target;

	},

	getWorldDirection: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
			target = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

		}

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	},

	raycast: function () {},

	traverse: function ( callback ) {

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	},

	traverseVisible: function ( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	},

	traverseAncestors: function ( callback ) {

		const parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( force );

		}

	},

	updateWorldMatrix: function ( updateParents, updateChildren ) {

		const parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			this.matrixWorld.copy( this.matrix );

		} else {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		}

		// update children

		if ( updateChildren === true ) {

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateWorldMatrix( false, true );

			}

		}

	},

	toJSON: function ( meta ) {

		// meta is a string when called from JSON.stringify
		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		const output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {},
				skeletons: {},
				animations: {}
			};

			output.metadata = {
				version: 4.5,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		const object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;
		if ( this.frustumCulled === false ) object.frustumCulled = false;
		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();

		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

		// object specific properties

		if ( this.isInstancedMesh ) {

			object.type = 'InstancedMesh';
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();
			if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

		}

		//

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}

		if ( this.isMesh || this.isLine || this.isPoints ) {

			object.geometry = serialize( meta.geometries, this.geometry );

			const parameters = this.geometry.parameters;

			if ( parameters !== undefined && parameters.shapes !== undefined ) {

				const shapes = parameters.shapes;

				if ( Array.isArray( shapes ) ) {

					for ( let i = 0, l = shapes.length; i < l; i ++ ) {

						const shape = shapes[ i ];

						serialize( meta.shapes, shape );

					}

				} else {

					serialize( meta.shapes, shapes );

				}

			}

		}

		if ( this.isSkinnedMesh ) {

			object.bindMode = this.bindMode;
			object.bindMatrix = this.bindMatrix.toArray();

			if ( this.skeleton !== undefined ) {

				serialize( meta.skeletons, this.skeleton );

				object.skeleton = this.skeleton.uuid;

			}

		}

		if ( this.material !== undefined ) {

			if ( Array.isArray( this.material ) ) {

				const uuids = [];

				for ( let i = 0, l = this.material.length; i < l; i ++ ) {

					uuids.push( serialize( meta.materials, this.material[ i ] ) );

				}

				object.material = uuids;

			} else {

				object.material = serialize( meta.materials, this.material );

			}

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( let i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		//

		if ( this.animations.length > 0 ) {

			object.animations = [];

			for ( let i = 0; i < this.animations.length; i ++ ) {

				const animation = this.animations[ i ];

				object.animations.push( serialize( meta.animations, animation ) );

			}

		}

		if ( isRootObject ) {

			const geometries = extractFromCache( meta.geometries );
			const materials = extractFromCache( meta.materials );
			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );
			const shapes = extractFromCache( meta.shapes );
			const skeletons = extractFromCache( meta.skeletons );
			const animations = extractFromCache( meta.animations );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;
			if ( shapes.length > 0 ) output.shapes = shapes;
			if ( skeletons.length > 0 ) output.skeletons = skeletons;
			if ( animations.length > 0 ) output.animations = animations;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			const values = [];
			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

	},

	clone: function ( recursive ) {

		return new this.constructor().copy( this, recursive );

	},

	copy: function ( source, recursive = true ) {

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.rotation.order = source.rotation.order;
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( let i = 0; i < source.children.length; i ++ ) {

				const child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

} );





/***/ }),

/***/ "../../node_modules/three/src/core/Raycaster.js":
/*!**********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/core/Raycaster.js ***!
  \**********************************************************************/
/*! exports provided: Raycaster */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Raycaster", function() { return Raycaster; });
/* harmony import */ var _math_Ray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Ray.js */ "../../node_modules/three/src/math/Ray.js");
/* harmony import */ var _Layers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Layers.js */ "../../node_modules/three/src/core/Layers.js");



function Raycaster( origin, direction, near = 0, far = Infinity ) {

	this.ray = new _math_Ray_js__WEBPACK_IMPORTED_MODULE_0__["Ray"]( origin, direction );
	// direction is assumed to be normalized (for accurate distance calculations)

	this.near = near;
	this.far = far;
	this.camera = null;
	this.layers = new _Layers_js__WEBPACK_IMPORTED_MODULE_1__["Layers"]();

	this.params = {
		Mesh: {},
		Line: { threshold: 1 },
		LOD: {},
		Points: { threshold: 1 },
		Sprite: {}
	};

	Object.defineProperties( this.params, {
		PointCloud: {
			get: function () {

				console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
				return this.Points;

			}
		}
	} );

}

function ascSort( a, b ) {

	return a.distance - b.distance;

}

function intersectObject( object, raycaster, intersects, recursive ) {

	if ( object.layers.test( raycaster.layers ) ) {

		object.raycast( raycaster, intersects );

	}

	if ( recursive === true ) {

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			intersectObject( children[ i ], raycaster, intersects, true );

		}

	}

}

Object.assign( Raycaster.prototype, {

	set: function ( origin, direction ) {

		// direction is assumed to be normalized (for accurate distance calculations)

		this.ray.set( origin, direction );

	},

	setFromCamera: function ( coords, camera ) {

		if ( camera && camera.isPerspectiveCamera ) {

			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
			this.camera = camera;

		} else if ( camera && camera.isOrthographicCamera ) {

			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
			this.camera = camera;

		} else {

			console.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );

		}

	},

	intersectObject: function ( object, recursive = false, intersects = [] ) {

		intersectObject( object, this, intersects, recursive );

		intersects.sort( ascSort );

		return intersects;

	},

	intersectObjects: function ( objects, recursive = false, intersects = [] ) {

		for ( let i = 0, l = objects.length; i < l; i ++ ) {

			intersectObject( objects[ i ], this, intersects, recursive );

		}

		intersects.sort( ascSort );

		return intersects;

	}

} );





/***/ }),

/***/ "../../node_modules/three/src/core/Uniform.js":
/*!********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/core/Uniform.js ***!
  \********************************************************************/
/*! exports provided: Uniform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uniform", function() { return Uniform; });
class Uniform {

	constructor( value ) {

		if ( typeof value === 'string' ) {

			console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
			value = arguments[ 1 ];

		}

		this.value = value;

	}

	clone() {

		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

	}

}




/***/ }),

/***/ "../../node_modules/three/src/extras/DataUtils.js":
/*!************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/DataUtils.js ***!
  \************************************************************************/
/*! exports provided: DataUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataUtils", function() { return DataUtils; });
const _floatView = new Float32Array( 1 );
const _int32View = new Int32Array( _floatView.buffer );

const DataUtils = {

	// Converts float32 to float16 (stored as uint16 value).

	toHalfFloat: function ( val ) {

		// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410

		/* This method is faster than the OpenEXR implementation (very often
		* used, eg. in Ogre), with the additional benefit of rounding, inspired
		* by James Tursa?s half-precision code. */

		_floatView[ 0 ] = val;
		const x = _int32View[ 0 ];

		let bits = ( x >> 16 ) & 0x8000; /* Get the sign */
		let m = ( x >> 12 ) & 0x07ff; /* Keep one extra bit for rounding */
		const e = ( x >> 23 ) & 0xff; /* Using int is faster here */

		/* If zero, or denormal, or exponent underflows too much for a denormal
			* half, return signed zero. */
		if ( e < 103 ) return bits;

		/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
		if ( e > 142 ) {

			bits |= 0x7c00;
			/* If exponent was 0xff and one mantissa bit was set, it means NaN,
						* not Inf, so make sure we set one mantissa bit too. */
			bits |= ( ( e == 255 ) ? 0 : 1 ) && ( x & 0x007fffff );
			return bits;

		}

		/* If exponent underflows but not too much, return a denormal */
		if ( e < 113 ) {

			m |= 0x0800;
			/* Extra rounding may overflow and set mantissa to 0 and exponent
				* to 1, which is OK. */
			bits |= ( m >> ( 114 - e ) ) + ( ( m >> ( 113 - e ) ) & 1 );
			return bits;

		}

		bits |= ( ( e - 112 ) << 10 ) | ( m >> 1 );
		/* Extra rounding. An overflow will set mantissa to 0 and increment
			* the exponent, which is OK. */
		bits += m & 1;
		return bits;

	}

};




/***/ }),

/***/ "../../node_modules/three/src/extras/Earcut.js":
/*!*********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/Earcut.js ***!
  \*********************************************************************/
/*! exports provided: Earcut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Earcut", function() { return Earcut; });
/**
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */

const Earcut = {

	triangulate: function ( data, holeIndices, dim ) {

		dim = dim || 2;

		const hasHoles = holeIndices && holeIndices.length;
		const outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;
		let outerNode = linkedList( data, 0, outerLen, dim, true );
		const triangles = [];

		if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;

		let minX, minY, maxX, maxY, x, y, invSize;

		if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

		// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
		if ( data.length > 80 * dim ) {

			minX = maxX = data[ 0 ];
			minY = maxY = data[ 1 ];

			for ( let i = dim; i < outerLen; i += dim ) {

				x = data[ i ];
				y = data[ i + 1 ];
				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;

			}

			// minX, minY and invSize are later used to transform coords into integers for z-order calculation
			invSize = Math.max( maxX - minX, maxY - minY );
			invSize = invSize !== 0 ? 1 / invSize : 0;

		}

		earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

		return triangles;

	}

};

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList( data, start, end, dim, clockwise ) {

	let i, last;

	if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

		for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	} else {

		for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	}

	if ( last && equals( last, last.next ) ) {

		removeNode( last );
		last = last.next;

	}

	return last;

}

// eliminate colinear or duplicate points
function filterPoints( start, end ) {

	if ( ! start ) return start;
	if ( ! end ) end = start;

	let p = start,
		again;
	do {

		again = false;

		if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

			removeNode( p );
			p = end = p.prev;
			if ( p === p.next ) break;
			again = true;

		} else {

			p = p.next;

		}

	} while ( again || p !== end );

	return end;

}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

	if ( ! ear ) return;

	// interlink polygon nodes in z-order
	if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

	let stop = ear,
		prev, next;

	// iterate through ears, slicing them one by one
	while ( ear.prev !== ear.next ) {

		prev = ear.prev;
		next = ear.next;

		if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

			// cut off the triangle
			triangles.push( prev.i / dim );
			triangles.push( ear.i / dim );
			triangles.push( next.i / dim );

			removeNode( ear );

			// skipping the next vertex leads to less sliver triangles
			ear = next.next;
			stop = next.next;

			continue;

		}

		ear = next;

		// if we looped through the whole remaining polygon and can't find any more ears
		if ( ear === stop ) {

			// try filtering points and slicing again
			if ( ! pass ) {

				earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

				// if this didn't work, try curing all small self-intersections locally

			} else if ( pass === 1 ) {

				ear = cureLocalIntersections( filterPoints( ear ), triangles, dim );
				earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

				// as a last resort, try splitting the remaining polygon into two

			} else if ( pass === 2 ) {

				splitEarcut( ear, triangles, dim, minX, minY, invSize );

			}

			break;

		}

	}

}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar( ear ) {

	const a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	// now make sure we don't have other points inside the potential ear
	let p = ear.next.next;

	while ( p !== ear.prev ) {

		if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.next;

	}

	return true;

}

function isEarHashed( ear, minX, minY, invSize ) {

	const a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	// triangle bbox; min & max are calculated like this for speed
	const minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
		minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
		maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
		maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

	// z-order range for the current triangle bbox;
	const minZ = zOrder( minTX, minTY, minX, minY, invSize ),
		maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

	let p = ear.prevZ,
		n = ear.nextZ;

	// look for points inside the triangle in both directions
	while ( p && p.z >= minZ && n && n.z <= maxZ ) {

		if ( p !== ear.prev && p !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

		if ( n !== ear.prev && n !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
			area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	// look for remaining points in decreasing z-order
	while ( p && p.z >= minZ ) {

		if ( p !== ear.prev && p !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

	}

	// look for remaining points in increasing z-order
	while ( n && n.z <= maxZ ) {

		if ( n !== ear.prev && n !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
			area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	return true;

}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections( start, triangles, dim ) {

	let p = start;
	do {

		const a = p.prev,
			b = p.next.next;

		if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

			triangles.push( a.i / dim );
			triangles.push( p.i / dim );
			triangles.push( b.i / dim );

			// remove two nodes involved
			removeNode( p );
			removeNode( p.next );

			p = start = b;

		}

		p = p.next;

	} while ( p !== start );

	return filterPoints( p );

}

// try splitting polygon into two and triangulate them independently
function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

	// look for a valid diagonal that divides the polygon into two
	let a = start;
	do {

		let b = a.next.next;
		while ( b !== a.prev ) {

			if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

				// split the polygon in two by the diagonal
				let c = splitPolygon( a, b );

				// filter colinear points around the cuts
				a = filterPoints( a, a.next );
				c = filterPoints( c, c.next );

				// run earcut on each half
				earcutLinked( a, triangles, dim, minX, minY, invSize );
				earcutLinked( c, triangles, dim, minX, minY, invSize );
				return;

			}

			b = b.next;

		}

		a = a.next;

	} while ( a !== start );

}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles( data, holeIndices, outerNode, dim ) {

	const queue = [];
	let i, len, start, end, list;

	for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

		start = holeIndices[ i ] * dim;
		end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
		list = linkedList( data, start, end, dim, false );
		if ( list === list.next ) list.steiner = true;
		queue.push( getLeftmost( list ) );

	}

	queue.sort( compareX );

	// process holes from left to right
	for ( i = 0; i < queue.length; i ++ ) {

		eliminateHole( queue[ i ], outerNode );
		outerNode = filterPoints( outerNode, outerNode.next );

	}

	return outerNode;

}

function compareX( a, b ) {

	return a.x - b.x;

}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole( hole, outerNode ) {

	outerNode = findHoleBridge( hole, outerNode );
	if ( outerNode ) {

		const b = splitPolygon( outerNode, hole );

		// filter collinear points around the cuts
		filterPoints( outerNode, outerNode.next );
		filterPoints( b, b.next );

	}

}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge( hole, outerNode ) {

	let p = outerNode;
	const hx = hole.x;
	const hy = hole.y;
	let qx = - Infinity, m;

	// find a segment intersected by a ray from the hole's leftmost point to the left;
	// segment's endpoint with lesser x will be potential connection point
	do {

		if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

			const x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
			if ( x <= hx && x > qx ) {

				qx = x;
				if ( x === hx ) {

					if ( hy === p.y ) return p;
					if ( hy === p.next.y ) return p.next;

				}

				m = p.x < p.next.x ? p : p.next;

			}

		}

		p = p.next;

	} while ( p !== outerNode );

	if ( ! m ) return null;

	if ( hx === qx ) return m; // hole touches outer segment; pick leftmost endpoint

	// look for points inside the triangle of hole point, segment intersection and endpoint;
	// if there are no points found, we have a valid connection;
	// otherwise choose the point of the minimum angle with the ray as connection point

	const stop = m,
		mx = m.x,
		my = m.y;
	let tanMin = Infinity, tan;

	p = m;

	do {

		if ( hx >= p.x && p.x >= mx && hx !== p.x &&
				pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

			tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

			if ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {

				m = p;
				tanMin = tan;

			}

		}

		p = p.next;

	} while ( p !== stop );

	return m;

}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector( m, p ) {

	return area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;

}

// interlink polygon nodes in z-order
function indexCurve( start, minX, minY, invSize ) {

	let p = start;
	do {

		if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
		p.prevZ = p.prev;
		p.nextZ = p.next;
		p = p.next;

	} while ( p !== start );

	p.prevZ.nextZ = null;
	p.prevZ = null;

	sortLinked( p );

}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked( list ) {

	let i, p, q, e, tail, numMerges, pSize, qSize,
		inSize = 1;

	do {

		p = list;
		list = null;
		tail = null;
		numMerges = 0;

		while ( p ) {

			numMerges ++;
			q = p;
			pSize = 0;
			for ( i = 0; i < inSize; i ++ ) {

				pSize ++;
				q = q.nextZ;
				if ( ! q ) break;

			}

			qSize = inSize;

			while ( pSize > 0 || ( qSize > 0 && q ) ) {

				if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

					e = p;
					p = p.nextZ;
					pSize --;

				} else {

					e = q;
					q = q.nextZ;
					qSize --;

				}

				if ( tail ) tail.nextZ = e;
				else list = e;

				e.prevZ = tail;
				tail = e;

			}

			p = q;

		}

		tail.nextZ = null;
		inSize *= 2;

	} while ( numMerges > 1 );

	return list;

}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder( x, y, minX, minY, invSize ) {

	// coords are transformed into non-negative 15-bit integer range
	x = 32767 * ( x - minX ) * invSize;
	y = 32767 * ( y - minY ) * invSize;

	x = ( x | ( x << 8 ) ) & 0x00FF00FF;
	x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
	x = ( x | ( x << 2 ) ) & 0x33333333;
	x = ( x | ( x << 1 ) ) & 0x55555555;

	y = ( y | ( y << 8 ) ) & 0x00FF00FF;
	y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
	y = ( y | ( y << 2 ) ) & 0x33333333;
	y = ( y | ( y << 1 ) ) & 0x55555555;

	return x | ( y << 1 );

}

// find the leftmost node of a polygon ring
function getLeftmost( start ) {

	let p = start,
		leftmost = start;
	do {

		if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
		p = p.next;

	} while ( p !== start );

	return leftmost;

}

// check if a point lies within a convex triangle
function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

	return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
			( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
			( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal( a, b ) {

	return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges
		( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible
		( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors
		equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case

}

// signed area of a triangle
function area( p, q, r ) {

	return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

}

// check if two points are equal
function equals( p1, p2 ) {

	return p1.x === p2.x && p1.y === p2.y;

}

// check if two segments intersect
function intersects( p1, q1, p2, q2 ) {

	const o1 = sign( area( p1, q1, p2 ) );
	const o2 = sign( area( p1, q1, q2 ) );
	const o3 = sign( area( p2, q2, p1 ) );
	const o4 = sign( area( p2, q2, q1 ) );

	if ( o1 !== o2 && o3 !== o4 ) return true; // general case

	if ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
	if ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
	if ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
	if ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

	return false;

}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment( p, q, r ) {

	return q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );

}

function sign( num ) {

	return num > 0 ? 1 : num < 0 ? - 1 : 0;

}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon( a, b ) {

	let p = a;
	do {

		if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
				intersects( p, p.next, a, b ) ) return true;
		p = p.next;

	} while ( p !== a );

	return false;

}

// check if a polygon diagonal is locally inside the polygon
function locallyInside( a, b ) {

	return area( a.prev, a, a.next ) < 0 ?
		area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
		area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside( a, b ) {

	let p = a,
		inside = false;
	const px = ( a.x + b.x ) / 2,
		py = ( a.y + b.y ) / 2;
	do {

		if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
				( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
			inside = ! inside;
		p = p.next;

	} while ( p !== a );

	return inside;

}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon( a, b ) {

	const a2 = new Node( a.i, a.x, a.y ),
		b2 = new Node( b.i, b.x, b.y ),
		an = a.next,
		bp = b.prev;

	a.next = b;
	b.prev = a;

	a2.next = an;
	an.prev = a2;

	b2.next = a2;
	a2.prev = b2;

	bp.next = b2;
	b2.prev = bp;

	return b2;

}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode( i, x, y, last ) {

	const p = new Node( i, x, y );

	if ( ! last ) {

		p.prev = p;
		p.next = p;

	} else {

		p.next = last.next;
		p.prev = last;
		last.next.prev = p;
		last.next = p;

	}

	return p;

}

function removeNode( p ) {

	p.next.prev = p.prev;
	p.prev.next = p.next;

	if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
	if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

}

function Node( i, x, y ) {

	// vertex index in coordinates array
	this.i = i;

	// vertex coordinates
	this.x = x;
	this.y = y;

	// previous and next vertex nodes in a polygon ring
	this.prev = null;
	this.next = null;

	// z-order curve value
	this.z = null;

	// previous and next nodes in z-order
	this.prevZ = null;
	this.nextZ = null;

	// indicates whether this is a steiner point
	this.steiner = false;

}

function signedArea( data, start, end, dim ) {

	let sum = 0;
	for ( let i = start, j = end - dim; i < end; i += dim ) {

		sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
		j = i;

	}

	return sum;

}




/***/ }),

/***/ "../../node_modules/three/src/extras/ImageUtils.js":
/*!*************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/ImageUtils.js ***!
  \*************************************************************************/
/*! exports provided: ImageUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageUtils", function() { return ImageUtils; });
let _canvas;

const ImageUtils = {

	getDataURL: function ( image ) {

		if ( /^data:/i.test( image.src ) ) {

			return image.src;

		}

		if ( typeof HTMLCanvasElement == 'undefined' ) {

			return image.src;

		}

		let canvas;

		if ( image instanceof HTMLCanvasElement ) {

			canvas = image;

		} else {

			if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

			_canvas.width = image.width;
			_canvas.height = image.height;

			const context = _canvas.getContext( '2d' );

			if ( image instanceof ImageData ) {

				context.putImageData( image, 0, 0 );

			} else {

				context.drawImage( image, 0, 0, image.width, image.height );

			}

			canvas = _canvas;

		}

		if ( canvas.width > 2048 || canvas.height > 2048 ) {

			console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );

			return canvas.toDataURL( 'image/jpeg', 0.6 );

		} else {

			return canvas.toDataURL( 'image/png' );

		}

	}

};




/***/ }),

/***/ "../../node_modules/three/src/extras/PMREMGenerator.js":
/*!*****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/PMREMGenerator.js ***!
  \*****************************************************************************/
/*! exports provided: PMREMGenerator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PMREMGenerator", function() { return PMREMGenerator; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../objects/Mesh.js */ "../../node_modules/three/src/objects/Mesh.js");
/* harmony import */ var _cameras_OrthographicCamera_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cameras/OrthographicCamera.js */ "../../node_modules/three/src/cameras/OrthographicCamera.js");
/* harmony import */ var _cameras_PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../cameras/PerspectiveCamera.js */ "../../node_modules/three/src/cameras/PerspectiveCamera.js");
/* harmony import */ var _materials_RawShaderMaterial_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../materials/RawShaderMaterial.js */ "../../node_modules/three/src/materials/RawShaderMaterial.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");
/* harmony import */ var _renderers_WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../renderers/WebGLRenderTarget.js */ "../../node_modules/three/src/renderers/WebGLRenderTarget.js");
/* harmony import */ var _materials_MeshBasicMaterial_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../materials/MeshBasicMaterial.js */ "../../node_modules/three/src/materials/MeshBasicMaterial.js");
/* harmony import */ var _geometries_BoxGeometry_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geometries/BoxGeometry.js */ "../../node_modules/three/src/geometries/BoxGeometry.js");
















const LOD_MIN = 4;
const LOD_MAX = 8;
const SIZE_MAX = Math.pow( 2, LOD_MAX );

// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;

const ENCODINGS = {
	[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"] ]: 0,
	[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["sRGBEncoding"] ]: 1,
	[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBEEncoding"] ]: 2,
	[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBM7Encoding"] ]: 3,
	[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBM16Encoding"] ]: 4,
	[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBDEncoding"] ]: 5,
	[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["GammaEncoding"] ]: 6
};

const backgroundMaterial = new _materials_MeshBasicMaterial_js__WEBPACK_IMPORTED_MODULE_11__["MeshBasicMaterial"]( {
	side: _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"],
	depthWrite: false,
	depthTest: false,
} );
const backgroundBox = new _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_3__["Mesh"]( new _geometries_BoxGeometry_js__WEBPACK_IMPORTED_MODULE_12__["BoxBufferGeometry"](), backgroundMaterial );

const _flatCamera = /*@__PURE__*/ new _cameras_OrthographicCamera_js__WEBPACK_IMPORTED_MODULE_4__["OrthographicCamera"]();
const { _lodPlanes, _sizeLods, _sigmas } = /*@__PURE__*/ _createPlanes();
const _clearColor = /*@__PURE__*/ new _math_Color_js__WEBPACK_IMPORTED_MODULE_9__["Color"]();
let _oldTarget = null;

// Golden Ratio
const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
const INV_PHI = 1 / PHI;

// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const _axisDirections = [
	/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"]( 1, 1, 1 ),
	/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"]( - 1, 1, 1 ),
	/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"]( 1, 1, - 1 ),
	/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"]( - 1, 1, - 1 ),
	/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"]( 0, PHI, INV_PHI ),
	/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"]( 0, PHI, - INV_PHI ),
	/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"]( INV_PHI, 0, PHI ),
	/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"]( - INV_PHI, 0, PHI ),
	/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"]( PHI, INV_PHI, 0 ),
	/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"]( - PHI, INV_PHI, 0 ) ];

/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/

function convertLinearToRGBE( color ) {

	const maxComponent = Math.max( color.r, color.g, color.b );
	const fExp = Math.min( Math.max( Math.ceil( Math.log2( maxComponent ) ), - 128.0 ), 127.0 );
	color.multiplyScalar( Math.pow( 2.0, - fExp ) );

	const alpha = ( fExp + 128.0 ) / 255.0;
	return alpha;

}

class PMREMGenerator {

	constructor( renderer ) {

		this._renderer = renderer;
		this._pingPongRenderTarget = null;

		this._blurMaterial = _getBlurShader( MAX_SAMPLES );
		this._equirectShader = null;
		this._cubemapShader = null;

		this._compileMaterial( this._blurMaterial );

	}

	/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */
	fromScene( scene, sigma = 0, near = 0.1, far = 100 ) {

		_oldTarget = this._renderer.getRenderTarget();
		const cubeUVRenderTarget = this._allocateTargets();

		this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );
		if ( sigma > 0 ) {

			this._blur( cubeUVRenderTarget, 0, 0, sigma );

		}

		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromEquirectangular( equirectangular ) {

		return this._fromTexture( equirectangular );

	}

	/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromCubemap( cubemap ) {

		return this._fromTexture( cubemap );

	}

	/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileCubemapShader() {

		if ( this._cubemapShader === null ) {

			this._cubemapShader = _getCubemapShader();
			this._compileMaterial( this._cubemapShader );

		}

	}

	/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileEquirectangularShader() {

		if ( this._equirectShader === null ) {

			this._equirectShader = _getEquirectShader();
			this._compileMaterial( this._equirectShader );

		}

	}

	/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */
	dispose() {

		this._blurMaterial.dispose();

		if ( this._cubemapShader !== null ) this._cubemapShader.dispose();
		if ( this._equirectShader !== null ) this._equirectShader.dispose();

		for ( let i = 0; i < _lodPlanes.length; i ++ ) {

			_lodPlanes[ i ].dispose();

		}

	}

	// private interface

	_cleanup( outputTarget ) {

		this._pingPongRenderTarget.dispose();
		this._renderer.setRenderTarget( _oldTarget );
		outputTarget.scissorTest = false;
		_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

	}

	_fromTexture( texture ) {

		_oldTarget = this._renderer.getRenderTarget();
		const cubeUVRenderTarget = this._allocateTargets( texture );
		this._textureToCubeUV( texture, cubeUVRenderTarget );
		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	_allocateTargets( texture ) { // warning: null texture is valid

		const params = {
			magFilter: _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"],
			minFilter: _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"],
			generateMipmaps: false,
			type: _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedByteType"],
			format: _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBEFormat"],
			encoding: _isLDR( texture ) ? texture.encoding : _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBEEncoding"],
			depthBuffer: false
		};

		const cubeUVRenderTarget = _createRenderTarget( params );
		cubeUVRenderTarget.depthBuffer = texture ? false : true;
		this._pingPongRenderTarget = _createRenderTarget( params );
		return cubeUVRenderTarget;

	}

	_compileMaterial( material ) {

		const tmpMesh = new _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_3__["Mesh"]( _lodPlanes[ 0 ], material );
		this._renderer.compile( tmpMesh, _flatCamera );

	}

	_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

		const fov = 90;
		const aspect = 1;
		const cubeCamera = new _cameras_PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_5__["PerspectiveCamera"]( fov, aspect, near, far );
		const upSign = [ 1, - 1, 1, 1, 1, 1 ];
		const forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];
		const renderer = this._renderer;

		const originalAutoClear = renderer.autoClear;
		const outputEncoding = renderer.outputEncoding;
		const toneMapping = renderer.toneMapping;
		renderer.getClearColor( _clearColor );

		renderer.toneMapping = _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoToneMapping"];
		renderer.outputEncoding = _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"];
		renderer.autoClear = false;

		let useSolidColor = false;
		const background = scene.background;
		if ( background ) {

			if ( background.isColor ) {

				backgroundMaterial.color.copy( background ).convertSRGBToLinear();
				scene.background = null;

				const alpha = convertLinearToRGBE( backgroundMaterial.color );
				backgroundMaterial.opacity = alpha;
				useSolidColor = true;

			}

		} else {

			backgroundMaterial.color.copy( _clearColor ).convertSRGBToLinear();

			const alpha = convertLinearToRGBE( backgroundMaterial.color );
			backgroundMaterial.opacity = alpha;
			useSolidColor = true;

		}


		for ( let i = 0; i < 6; i ++ ) {

			const col = i % 3;
			if ( col == 0 ) {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

			} else if ( col == 1 ) {

				cubeCamera.up.set( 0, 0, upSign[ i ] );
				cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

			} else {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

			}

			_setViewport( cubeUVRenderTarget,
				col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX );
			renderer.setRenderTarget( cubeUVRenderTarget );

			if ( useSolidColor ) {

				renderer.render( backgroundBox, cubeCamera );

			}

			renderer.render( scene, cubeCamera );

		}

		renderer.toneMapping = toneMapping;
		renderer.outputEncoding = outputEncoding;
		renderer.autoClear = originalAutoClear;

	}

	_textureToCubeUV( texture, cubeUVRenderTarget ) {

		const renderer = this._renderer;

		if ( texture.isCubeTexture ) {

			if ( this._cubemapShader == null ) {

				this._cubemapShader = _getCubemapShader();

			}

		} else {

			if ( this._equirectShader == null ) {

				this._equirectShader = _getEquirectShader();

			}

		}

		const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
		const mesh = new _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_3__["Mesh"]( _lodPlanes[ 0 ], material );

		const uniforms = material.uniforms;

		uniforms[ 'envMap' ].value = texture;

		if ( ! texture.isCubeTexture ) {

			uniforms[ 'texelSize' ].value.set( 1.0 / texture.image.width, 1.0 / texture.image.height );

		}

		uniforms[ 'inputEncoding' ].value = ENCODINGS[ texture.encoding ];
		uniforms[ 'outputEncoding' ].value = ENCODINGS[ cubeUVRenderTarget.texture.encoding ];

		_setViewport( cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX );

		renderer.setRenderTarget( cubeUVRenderTarget );
		renderer.render( mesh, _flatCamera );

	}

	_applyPMREM( cubeUVRenderTarget ) {

		const renderer = this._renderer;
		const autoClear = renderer.autoClear;
		renderer.autoClear = false;

		for ( let i = 1; i < TOTAL_LODS; i ++ ) {

			const sigma = Math.sqrt( _sigmas[ i ] * _sigmas[ i ] - _sigmas[ i - 1 ] * _sigmas[ i - 1 ] );

			const poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];

			this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

		}

		renderer.autoClear = autoClear;

	}

	/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */
	_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

		const pingPongRenderTarget = this._pingPongRenderTarget;

		this._halfBlur(
			cubeUVRenderTarget,
			pingPongRenderTarget,
			lodIn,
			lodOut,
			sigma,
			'latitudinal',
			poleAxis );

		this._halfBlur(
			pingPongRenderTarget,
			cubeUVRenderTarget,
			lodOut,
			lodOut,
			sigma,
			'longitudinal',
			poleAxis );

	}

	_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

		const renderer = this._renderer;
		const blurMaterial = this._blurMaterial;

		if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

			console.error(
				'blur direction must be either latitudinal or longitudinal!' );

		}

		// Number of standard deviations at which to cut off the discrete approximation.
		const STANDARD_DEVIATIONS = 3;

		const blurMesh = new _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_3__["Mesh"]( _lodPlanes[ lodOut ], blurMaterial );
		const blurUniforms = blurMaterial.uniforms;

		const pixels = _sizeLods[ lodIn ] - 1;
		const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
		const sigmaPixels = sigmaRadians / radiansPerPixel;
		const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

		if ( samples > MAX_SAMPLES ) {

			console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

		}

		const weights = [];
		let sum = 0;

		for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

			const x = i / sigmaPixels;
			const weight = Math.exp( - x * x / 2 );
			weights.push( weight );

			if ( i == 0 ) {

				sum += weight;

			} else if ( i < samples ) {

				sum += 2 * weight;

			}

		}

		for ( let i = 0; i < weights.length; i ++ ) {

			weights[ i ] = weights[ i ] / sum;

		}

		blurUniforms[ 'envMap' ].value = targetIn.texture;
		blurUniforms[ 'samples' ].value = samples;
		blurUniforms[ 'weights' ].value = weights;
		blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';

		if ( poleAxis ) {

			blurUniforms[ 'poleAxis' ].value = poleAxis;

		}

		blurUniforms[ 'dTheta' ].value = radiansPerPixel;
		blurUniforms[ 'mipInt' ].value = LOD_MAX - lodIn;
		blurUniforms[ 'inputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];
		blurUniforms[ 'outputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];

		const outputSize = _sizeLods[ lodOut ];
		const x = 3 * Math.max( 0, SIZE_MAX - 2 * outputSize );
		const y = ( lodOut === 0 ? 0 : 2 * SIZE_MAX ) + 2 * outputSize * ( lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0 );

		_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
		renderer.setRenderTarget( targetOut );
		renderer.render( blurMesh, _flatCamera );

	}

}

function _isLDR( texture ) {

	if ( texture === undefined || texture.type !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedByteType"] ) return false;

	return texture.encoding === _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"] || texture.encoding === _constants_js__WEBPACK_IMPORTED_MODULE_0__["sRGBEncoding"] || texture.encoding === _constants_js__WEBPACK_IMPORTED_MODULE_0__["GammaEncoding"];

}

function _createPlanes() {

	const _lodPlanes = [];
	const _sizeLods = [];
	const _sigmas = [];

	let lod = LOD_MAX;

	for ( let i = 0; i < TOTAL_LODS; i ++ ) {

		const sizeLod = Math.pow( 2, lod );
		_sizeLods.push( sizeLod );
		let sigma = 1.0 / sizeLod;

		if ( i > LOD_MAX - LOD_MIN ) {

			sigma = EXTRA_LOD_SIGMA[ i - LOD_MAX + LOD_MIN - 1 ];

		} else if ( i == 0 ) {

			sigma = 0;

		}

		_sigmas.push( sigma );

		const texelSize = 1.0 / ( sizeLod - 1 );
		const min = - texelSize / 2;
		const max = 1 + texelSize / 2;
		const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

		const cubeFaces = 6;
		const vertices = 6;
		const positionSize = 3;
		const uvSize = 2;
		const faceIndexSize = 1;

		const position = new Float32Array( positionSize * vertices * cubeFaces );
		const uv = new Float32Array( uvSize * vertices * cubeFaces );
		const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

		for ( let face = 0; face < cubeFaces; face ++ ) {

			const x = ( face % 3 ) * 2 / 3 - 1;
			const y = face > 2 ? 0 : - 1;
			const coordinates = [
				x, y, 0,
				x + 2 / 3, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y + 1, 0
			];
			position.set( coordinates, positionSize * vertices * face );
			uv.set( uv1, uvSize * vertices * face );
			const fill = [ face, face, face, face, face, face ];
			faceIndex.set( fill, faceIndexSize * vertices * face );

		}

		const planes = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_2__["BufferGeometry"]();
		planes.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"]( position, positionSize ) );
		planes.setAttribute( 'uv', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"]( uv, uvSize ) );
		planes.setAttribute( 'faceIndex', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"]( faceIndex, faceIndexSize ) );
		_lodPlanes.push( planes );

		if ( lod > LOD_MIN ) {

			lod --;

		}

	}

	return { _lodPlanes, _sizeLods, _sigmas };

}

function _createRenderTarget( params ) {

	const cubeUVRenderTarget = new _renderers_WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_10__["WebGLRenderTarget"]( 3 * SIZE_MAX, 3 * SIZE_MAX, params );
	cubeUVRenderTarget.texture.mapping = _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeUVReflectionMapping"];
	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
	cubeUVRenderTarget.scissorTest = true;
	return cubeUVRenderTarget;

}

function _setViewport( target, x, y, width, height ) {

	target.viewport.set( x, y, width, height );
	target.scissor.set( x, y, width, height );

}

function _getBlurShader( maxSamples ) {

	const weights = new Float32Array( maxSamples );
	const poleAxis = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"]( 0, 1, 0 );
	const shaderMaterial = new _materials_RawShaderMaterial_js__WEBPACK_IMPORTED_MODULE_6__["RawShaderMaterial"]( {

		name: 'SphericalGaussianBlur',

		defines: { 'n': maxSamples },

		uniforms: {
			'envMap': { value: null },
			'samples': { value: 1 },
			'weights': { value: weights },
			'latitudinal': { value: false },
			'dTheta': { value: 0 },
			'mipInt': { value: 0 },
			'poleAxis': { value: poleAxis },
			'inputEncoding': { value: ENCODINGS[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"] ] },
			'outputEncoding': { value: ENCODINGS[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"] ] }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${ _getEncodings() }

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

		blending: _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoBlending"],
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getEquirectShader() {

	const texelSize = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_7__["Vector2"]( 1, 1 );
	const shaderMaterial = new _materials_RawShaderMaterial_js__WEBPACK_IMPORTED_MODULE_6__["RawShaderMaterial"]( {

		name: 'EquirectangularToCubeUV',

		uniforms: {
			'envMap': { value: null },
			'texelSize': { value: texelSize },
			'inputEncoding': { value: ENCODINGS[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"] ] },
			'outputEncoding': { value: ENCODINGS[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"] ] }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${ _getEncodings() }

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

		blending: _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoBlending"],
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getCubemapShader() {

	const shaderMaterial = new _materials_RawShaderMaterial_js__WEBPACK_IMPORTED_MODULE_6__["RawShaderMaterial"]( {

		name: 'CubemapToCubeUV',

		uniforms: {
			'envMap': { value: null },
			'inputEncoding': { value: ENCODINGS[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"] ] },
			'outputEncoding': { value: ENCODINGS[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"] ] }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${ _getEncodings() }

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

		blending: _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoBlending"],
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getCommonVertexShader() {

	return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;

}

function _getEncodings() {

	return /* glsl */`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`;

}




/***/ }),

/***/ "../../node_modules/three/src/extras/ShapeUtils.js":
/*!*************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/ShapeUtils.js ***!
  \*************************************************************************/
/*! exports provided: ShapeUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeUtils", function() { return ShapeUtils; });
/* harmony import */ var _Earcut_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Earcut.js */ "../../node_modules/three/src/extras/Earcut.js");


const ShapeUtils = {

	// calculate area of the contour polygon

	area: function ( contour ) {

		const n = contour.length;
		let a = 0.0;

		for ( let p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	},

	isClockWise: function ( pts ) {

		return ShapeUtils.area( pts ) < 0;

	},

	triangulateShape: function ( contour, holes ) {

		const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
		const holeIndices = []; // array of hole indices
		const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

		removeDupEndPts( contour );
		addContour( vertices, contour );

		//

		let holeIndex = contour.length;

		holes.forEach( removeDupEndPts );

		for ( let i = 0; i < holes.length; i ++ ) {

			holeIndices.push( holeIndex );
			holeIndex += holes[ i ].length;
			addContour( vertices, holes[ i ] );

		}

		//

		const triangles = _Earcut_js__WEBPACK_IMPORTED_MODULE_0__["Earcut"].triangulate( vertices, holeIndices );

		//

		for ( let i = 0; i < triangles.length; i += 3 ) {

			faces.push( triangles.slice( i, i + 3 ) );

		}

		return faces;

	}

};

function removeDupEndPts( points ) {

	const l = points.length;

	if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

		points.pop();

	}

}

function addContour( vertices, contour ) {

	for ( let i = 0; i < contour.length; i ++ ) {

		vertices.push( contour[ i ].x );
		vertices.push( contour[ i ].y );

	}

}




/***/ }),

/***/ "../../node_modules/three/src/extras/core/Curve.js":
/*!*************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/core/Curve.js ***!
  \*************************************************************************/
/*! exports provided: Curve */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Curve", function() { return Curve; });
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/Matrix4.js */ "../../node_modules/three/src/math/Matrix4.js");





/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

function Curve() {

	this.type = 'Curve';

	this.arcLengthDivisions = 200;

}

Object.assign( Curve.prototype, {

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint: function ( /* t, optionalTarget */ ) {

		console.warn( 'THREE.Curve: .getPoint() not implemented.' );
		return null;

	},

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt: function ( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getPoint( t, optionalTarget );

	},

	// Get sequence of points using getPoint( t )

	getPoints: function ( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPoint( d / divisions ) );

		}

		return points;

	},

	// Get sequence of points using getPointAt( u )

	getSpacedPoints: function ( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPointAt( d / divisions ) );

		}

		return points;

	},

	// Get total curve arc length

	getLength: function () {

		const lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	},

	// Get list of cumulative segment lengths

	getLengths: function ( divisions ) {

		if ( divisions === undefined ) divisions = this.arcLengthDivisions;

		if ( this.cacheArcLengths &&
			( this.cacheArcLengths.length === divisions + 1 ) &&
			! this.needsUpdate ) {

			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		const cache = [];
		let current, last = this.getPoint( 0 );
		let sum = 0;

		cache.push( 0 );

		for ( let p = 1; p <= divisions; p ++ ) {

			current = this.getPoint( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum: sum }; Sum is in the last element.

	},

	updateArcLengths: function () {

		this.needsUpdate = true;
		this.getLengths();

	},

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping: function ( u, distance ) {

		const arcLengths = this.getLengths();

		let i = 0;
		const il = arcLengths.length;

		let targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		// binary search for the index with largest value smaller than target u distance

		let low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		if ( arcLengths[ i ] === targetArcLength ) {

			return i / ( il - 1 );

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		const lengthBefore = arcLengths[ i ];
		const lengthAfter = arcLengths[ i + 1 ];

		const segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		const segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		const t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	},

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent: function ( t, optionalTarget ) {

		const delta = 0.0001;
		let t1 = t - delta;
		let t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		const pt1 = this.getPoint( t1 );
		const pt2 = this.getPoint( t2 );

		const tangent = optionalTarget || ( ( pt1.isVector2 ) ? new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"]() : new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]() );

		tangent.copy( pt2 ).sub( pt1 ).normalize();

		return tangent;

	},

	getTangentAt: function ( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getTangent( t, optionalTarget );

	},

	computeFrenetFrames: function ( segments, closed ) {

		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

		const normal = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

		const tangents = [];
		const normals = [];
		const binormals = [];

		const vec = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
		const mat = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_3__["Matrix4"]();

		// compute the tangent vectors for each segment on the curve

		for ( let i = 0; i <= segments; i ++ ) {

			const u = i / segments;

			tangents[ i ] = this.getTangentAt( u, new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]() );
			tangents[ i ].normalize();

		}

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the minimum tangent xyz component

		normals[ 0 ] = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
		binormals[ 0 ] = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
		let min = Number.MAX_VALUE;
		const tx = Math.abs( tangents[ 0 ].x );
		const ty = Math.abs( tangents[ 0 ].y );
		const tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= min ) {

			min = tx;
			normal.set( 1, 0, 0 );

		}

		if ( ty <= min ) {

			min = ty;
			normal.set( 0, 1, 0 );

		}

		if ( tz <= min ) {

			normal.set( 0, 0, 1 );

		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


		// compute the slowly-varying normal and binormal vectors for each segment on the curve

		for ( let i = 1; i <= segments; i ++ ) {

			normals[ i ] = normals[ i - 1 ].clone();

			binormals[ i ] = binormals[ i - 1 ].clone();

			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			if ( vec.length() > Number.EPSILON ) {

				vec.normalize();

				const theta = Math.acos( _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed === true ) {

			let theta = Math.acos( _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
			theta /= segments;

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( let i = 1; i <= segments; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}

		return {
			tangents: tangents,
			normals: normals,
			binormals: binormals
		};

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.arcLengthDivisions = source.arcLengthDivisions;

		return this;

	},

	toJSON: function () {

		const data = {
			metadata: {
				version: 4.5,
				type: 'Curve',
				generator: 'Curve.toJSON'
			}
		};

		data.arcLengthDivisions = this.arcLengthDivisions;
		data.type = this.type;

		return data;

	},

	fromJSON: function ( json ) {

		this.arcLengthDivisions = json.arcLengthDivisions;

		return this;

	}

} );





/***/ }),

/***/ "../../node_modules/three/src/extras/core/CurvePath.js":
/*!*****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/core/CurvePath.js ***!
  \*****************************************************************************/
/*! exports provided: CurvePath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CurvePath", function() { return CurvePath; });
/* harmony import */ var _Curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Curve.js */ "../../node_modules/three/src/extras/core/Curve.js");
/* harmony import */ var _curves_Curves_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../curves/Curves.js */ "../../node_modules/three/src/extras/curves/Curves.js");



/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

class CurvePath extends _Curve_js__WEBPACK_IMPORTED_MODULE_0__["Curve"] {

	constructor() {

		super();

		this.type = 'CurvePath';

		this.curves = [];
		this.autoClose = false; // Automatically closes the path

	}

	add( curve ) {

		this.curves.push( curve );

	}

	closePath() {

		// Add a line curve if start and end of lines are not connected
		const startPoint = this.curves[ 0 ].getPoint( 0 );
		const endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		if ( ! startPoint.equals( endPoint ) ) {

			this.curves.push( new _curves_Curves_js__WEBPACK_IMPORTED_MODULE_1__["LineCurve"]( endPoint, startPoint ) );

		}

	}

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	getPoint( t ) {

		const d = t * this.getLength();
		const curveLengths = this.getCurveLengths();
		let i = 0;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				const diff = curveLengths[ i ] - d;
				const curve = this.curves[ i ];

				const segmentLength = curve.getLength();
				const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

				return curve.getPointAt( u );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	}

	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	getLength() {

		const lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	}

	// cacheLengths must be recalculated.
	updateArcLengths() {

		this.needsUpdate = true;
		this.cacheLengths = null;
		this.getCurveLengths();

	}

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	getCurveLengths() {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			return this.cacheLengths;

		}

		// Get length of sub-curve
		// Push sums into cached array

		const lengths = [];
		let sums = 0;

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	}

	getSpacedPoints( divisions = 40 ) {

		const points = [];

		for ( let i = 0; i <= divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

		}

		if ( this.autoClose ) {

			points.push( points[ 0 ] );

		}

		return points;

	}

	getPoints( divisions = 12 ) {

		const points = [];
		let last;

		for ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {

			const curve = curves[ i ];
			const resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
				: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
					: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
						: divisions;

			const pts = curve.getPoints( resolution );

			for ( let j = 0; j < pts.length; j ++ ) {

				const point = pts[ j ];

				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

				points.push( point );
				last = point;

			}

		}

		if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

			points.push( points[ 0 ] );

		}

		return points;

	}

	copy( source ) {

		super.copy( source );

		this.curves = [];

		for ( let i = 0, l = source.curves.length; i < l; i ++ ) {

			const curve = source.curves[ i ];

			this.curves.push( curve.clone() );

		}

		this.autoClose = source.autoClose;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.autoClose = this.autoClose;
		data.curves = [];

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			const curve = this.curves[ i ];
			data.curves.push( curve.toJSON() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.autoClose = json.autoClose;
		this.curves = [];

		for ( let i = 0, l = json.curves.length; i < l; i ++ ) {

			const curve = json.curves[ i ];
			this.curves.push( new _curves_Curves_js__WEBPACK_IMPORTED_MODULE_1__[ curve.type ]().fromJSON( curve ) );

		}

		return this;

	}

}





/***/ }),

/***/ "../../node_modules/three/src/extras/core/Font.js":
/*!************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/core/Font.js ***!
  \************************************************************************/
/*! exports provided: Font */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Font", function() { return Font; });
/* harmony import */ var _ShapePath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ShapePath.js */ "../../node_modules/three/src/extras/core/ShapePath.js");


class Font {

	constructor( data ) {

		this.type = 'Font';

		this.data = data;

	}

	generateShapes( text, size = 100 ) {

		const shapes = [];
		const paths = createPaths( text, size, this.data );

		for ( let p = 0, pl = paths.length; p < pl; p ++ ) {

			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

		}

		return shapes;

	}

}

function createPaths( text, size, data ) {

	const chars = Array.from( text );
	const scale = size / data.resolution;
	const line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

	const paths = [];

	let offsetX = 0, offsetY = 0;

	for ( let i = 0; i < chars.length; i ++ ) {

		const char = chars[ i ];

		if ( char === '\n' ) {

			offsetX = 0;
			offsetY -= line_height;

		} else {

			const ret = createPath( char, scale, offsetX, offsetY, data );
			offsetX += ret.offsetX;
			paths.push( ret.path );

		}

	}

	return paths;

}

function createPath( char, scale, offsetX, offsetY, data ) {

	const glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

	if ( ! glyph ) {

		console.error( 'THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.' );

		return;

	}

	const path = new _ShapePath_js__WEBPACK_IMPORTED_MODULE_0__["ShapePath"]();

	let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

	if ( glyph.o ) {

		const outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

		for ( let i = 0, l = outline.length; i < l; ) {

			const action = outline[ i ++ ];

			switch ( action ) {

				case 'm': // moveTo

					x = outline[ i ++ ] * scale + offsetX;
					y = outline[ i ++ ] * scale + offsetY;

					path.moveTo( x, y );

					break;

				case 'l': // lineTo

					x = outline[ i ++ ] * scale + offsetX;
					y = outline[ i ++ ] * scale + offsetY;

					path.lineTo( x, y );

					break;

				case 'q': // quadraticCurveTo

					cpx = outline[ i ++ ] * scale + offsetX;
					cpy = outline[ i ++ ] * scale + offsetY;
					cpx1 = outline[ i ++ ] * scale + offsetX;
					cpy1 = outline[ i ++ ] * scale + offsetY;

					path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

					break;

				case 'b': // bezierCurveTo

					cpx = outline[ i ++ ] * scale + offsetX;
					cpy = outline[ i ++ ] * scale + offsetY;
					cpx1 = outline[ i ++ ] * scale + offsetX;
					cpy1 = outline[ i ++ ] * scale + offsetY;
					cpx2 = outline[ i ++ ] * scale + offsetX;
					cpy2 = outline[ i ++ ] * scale + offsetY;

					path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

					break;

			}

		}

	}

	return { offsetX: glyph.ha * scale, path: path };

}

Font.prototype.isFont = true;




/***/ }),

/***/ "../../node_modules/three/src/extras/core/Interpolations.js":
/*!**********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/core/Interpolations.js ***!
  \**********************************************************************************/
/*! exports provided: CatmullRom, QuadraticBezier, CubicBezier */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CatmullRom", function() { return CatmullRom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezier", function() { return QuadraticBezier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezier", function() { return CubicBezier; });
/**
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bézier_curve
 */

function CatmullRom( t, p0, p1, p2, p3 ) {

	const v0 = ( p2 - p0 ) * 0.5;
	const v1 = ( p3 - p1 ) * 0.5;
	const t2 = t * t;
	const t3 = t * t2;
	return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

}

//

function QuadraticBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * p;

}

function QuadraticBezierP1( t, p ) {

	return 2 * ( 1 - t ) * t * p;

}

function QuadraticBezierP2( t, p ) {

	return t * t * p;

}

function QuadraticBezier( t, p0, p1, p2 ) {

	return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
		QuadraticBezierP2( t, p2 );

}

//

function CubicBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * k * p;

}

function CubicBezierP1( t, p ) {

	const k = 1 - t;
	return 3 * k * k * t * p;

}

function CubicBezierP2( t, p ) {

	return 3 * ( 1 - t ) * t * t * p;

}

function CubicBezierP3( t, p ) {

	return t * t * t * p;

}

function CubicBezier( t, p0, p1, p2, p3 ) {

	return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
		CubicBezierP3( t, p3 );

}




/***/ }),

/***/ "../../node_modules/three/src/extras/core/Path.js":
/*!************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/core/Path.js ***!
  \************************************************************************/
/*! exports provided: Path */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return Path; });
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _CurvePath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CurvePath.js */ "../../node_modules/three/src/extras/core/CurvePath.js");
/* harmony import */ var _curves_EllipseCurve_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../curves/EllipseCurve.js */ "../../node_modules/three/src/extras/curves/EllipseCurve.js");
/* harmony import */ var _curves_SplineCurve_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../curves/SplineCurve.js */ "../../node_modules/three/src/extras/curves/SplineCurve.js");
/* harmony import */ var _curves_CubicBezierCurve_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../curves/CubicBezierCurve.js */ "../../node_modules/three/src/extras/curves/CubicBezierCurve.js");
/* harmony import */ var _curves_QuadraticBezierCurve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../curves/QuadraticBezierCurve.js */ "../../node_modules/three/src/extras/curves/QuadraticBezierCurve.js");
/* harmony import */ var _curves_LineCurve_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../curves/LineCurve.js */ "../../node_modules/three/src/extras/curves/LineCurve.js");








class Path extends _CurvePath_js__WEBPACK_IMPORTED_MODULE_1__["CurvePath"] {

	constructor( points ) {

		super();
		this.type = 'Path';

		this.currentPoint = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();

		if ( points ) {

			this.setFromPoints( points );

		}

	}

	setFromPoints( points ) {

		this.moveTo( points[ 0 ].x, points[ 0 ].y );

		for ( let i = 1, l = points.length; i < l; i ++ ) {

			this.lineTo( points[ i ].x, points[ i ].y );

		}

		return this;

	}

	moveTo( x, y ) {

		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

		return this;

	}

	lineTo( x, y ) {

		const curve = new _curves_LineCurve_js__WEBPACK_IMPORTED_MODULE_6__["LineCurve"]( this.currentPoint.clone(), new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]( x, y ) );
		this.curves.push( curve );

		this.currentPoint.set( x, y );

		return this;

	}

	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

		const curve = new _curves_QuadraticBezierCurve_js__WEBPACK_IMPORTED_MODULE_5__["QuadraticBezierCurve"](
			this.currentPoint.clone(),
			new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]( aCPx, aCPy ),
			new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	}

	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		const curve = new _curves_CubicBezierCurve_js__WEBPACK_IMPORTED_MODULE_4__["CubicBezierCurve"](
			this.currentPoint.clone(),
			new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]( aCP1x, aCP1y ),
			new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]( aCP2x, aCP2y ),
			new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	}

	splineThru( pts /*Array of Vector*/ ) {

		const npts = [ this.currentPoint.clone() ].concat( pts );

		const curve = new _curves_SplineCurve_js__WEBPACK_IMPORTED_MODULE_3__["SplineCurve"]( npts );
		this.curves.push( curve );

		this.currentPoint.copy( pts[ pts.length - 1 ] );

		return this;

	}

	arc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

		return this;

	}

	absarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		return this;

	}

	ellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		return this;

	}

	absellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const curve = new _curves_EllipseCurve_js__WEBPACK_IMPORTED_MODULE_2__["EllipseCurve"]( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		if ( this.curves.length > 0 ) {

			// if a previous curve is present, attempt to join
			const firstPoint = curve.getPoint( 0 );

			if ( ! firstPoint.equals( this.currentPoint ) ) {

				this.lineTo( firstPoint.x, firstPoint.y );

			}

		}

		this.curves.push( curve );

		const lastPoint = curve.getPoint( 1 );
		this.currentPoint.copy( lastPoint );

		return this;

	}

	copy( source ) {

		super.copy( source );

		this.currentPoint.copy( source.currentPoint );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.currentPoint = this.currentPoint.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.currentPoint.fromArray( json.currentPoint );

		return this;

	}

}





/***/ }),

/***/ "../../node_modules/three/src/extras/core/Shape.js":
/*!*************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/core/Shape.js ***!
  \*************************************************************************/
/*! exports provided: Shape */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return Shape; });
/* harmony import */ var _Path_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Path.js */ "../../node_modules/three/src/extras/core/Path.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");



class Shape extends _Path_js__WEBPACK_IMPORTED_MODULE_0__["Path"] {

	constructor( points ) {

		super( points );

		this.uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__["MathUtils"].generateUUID();

		this.type = 'Shape';

		this.holes = [];

	}

	getPointsHoles( divisions ) {

		const holesPts = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

		}

		return holesPts;

	}

	// get points of shape and holes (keypoints based on segments parameter)

	extractPoints( divisions ) {

		return {

			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	}

	copy( source ) {

		super.copy( source );

		this.holes = [];

		for ( let i = 0, l = source.holes.length; i < l; i ++ ) {

			const hole = source.holes[ i ];

			this.holes.push( hole.clone() );

		}

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.uuid = this.uuid;
		data.holes = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			const hole = this.holes[ i ];
			data.holes.push( hole.toJSON() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.uuid = json.uuid;
		this.holes = [];

		for ( let i = 0, l = json.holes.length; i < l; i ++ ) {

			const hole = json.holes[ i ];
			this.holes.push( new _Path_js__WEBPACK_IMPORTED_MODULE_0__["Path"]().fromJSON( hole ) );

		}

		return this;

	}

}





/***/ }),

/***/ "../../node_modules/three/src/extras/core/ShapePath.js":
/*!*****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/core/ShapePath.js ***!
  \*****************************************************************************/
/*! exports provided: ShapePath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapePath", function() { return ShapePath; });
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/Color.js */ "../../node_modules/three/src/math/Color.js");
/* harmony import */ var _Path_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Path.js */ "../../node_modules/three/src/extras/core/Path.js");
/* harmony import */ var _Shape_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Shape.js */ "../../node_modules/three/src/extras/core/Shape.js");
/* harmony import */ var _ShapeUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ShapeUtils.js */ "../../node_modules/three/src/extras/ShapeUtils.js");





class ShapePath {

	constructor() {

		this.type = 'ShapePath';

		this.color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"]();

		this.subPaths = [];
		this.currentPath = null;

	}

	moveTo( x, y ) {

		this.currentPath = new _Path_js__WEBPACK_IMPORTED_MODULE_1__["Path"]();
		this.subPaths.push( this.currentPath );
		this.currentPath.moveTo( x, y );

		return this;

	}

	lineTo( x, y ) {

		this.currentPath.lineTo( x, y );

		return this;

	}

	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

		return this;

	}

	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

		return this;

	}

	splineThru( pts ) {

		this.currentPath.splineThru( pts );

		return this;

	}

	toShapes( isCCW, noHoles ) {

		function toShapesNoHoles( inSubpaths ) {

			const shapes = [];

			for ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {

				const tmpPath = inSubpaths[ i ];

				const tmpShape = new _Shape_js__WEBPACK_IMPORTED_MODULE_2__["Shape"]();
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );

			}

			return shapes;

		}

		function isPointInsidePolygon( inPt, inPolygon ) {

			const polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			let inside = false;
			for ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

				let edgeLowPt = inPolygon[ p ];
				let edgeHighPt = inPolygon[ q ];

				let edgeDx = edgeHighPt.x - edgeLowPt.x;
				let edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

					// not parallel
					if ( edgeDy < 0 ) {

						edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

					}

					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y === edgeLowPt.y ) {

						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!

					} else {

						const perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt

					}

				} else {

					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;

				}

			}

			return	inside;

		}

		const isClockWise = _ShapeUtils_js__WEBPACK_IMPORTED_MODULE_3__["ShapeUtils"].isClockWise;

		const subPaths = this.subPaths;
		if ( subPaths.length === 0 ) return [];

		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


		let solid, tmpPath, tmpShape;
		const shapes = [];

		if ( subPaths.length === 1 ) {

			tmpPath = subPaths[ 0 ];
			tmpShape = new _Shape_js__WEBPACK_IMPORTED_MODULE_2__["Shape"]();
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		let holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);

		const betterShapeHoles = [];
		const newShapes = [];
		let newShapeHoles = [];
		let mainIdx = 0;
		let tmpPoints;

		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];

		for ( let i = 0, l = subPaths.length; i < l; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

				newShapes[ mainIdx ] = { s: new _Shape_js__WEBPACK_IMPORTED_MODULE_2__["Shape"](), p: tmpPoints };
				newShapes[ mainIdx ].s.curves = tmpPath.curves;

				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {

			let ambiguous = false;
			const toChange = [];

			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				betterShapeHoles[ sIdx ] = [];

			}

			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				const sho = newShapeHoles[ sIdx ];

				for ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {

					const ho = sho[ hIdx ];
					let hole_unassigned = true;

					for ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {

								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );

							} else {

								ambiguous = true;

							}

						}

					}

					if ( hole_unassigned ) {

						betterShapeHoles[ sIdx ].push( ho );

					}

				}

			}
			// console.log("ambiguous: ", ambiguous);

			if ( toChange.length > 0 ) {

				// console.log("to change: ", toChange);
				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

			}

		}

		let tmpHoles;

		for ( let i = 0, il = newShapes.length; i < il; i ++ ) {

			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];

			for ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

				tmpShape.holes.push( tmpHoles[ j ].h );

			}

		}

		//console.log("shape", shapes);

		return shapes;

	}

}





/***/ }),

/***/ "../../node_modules/three/src/extras/curves/ArcCurve.js":
/*!******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/curves/ArcCurve.js ***!
  \******************************************************************************/
/*! exports provided: ArcCurve */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArcCurve", function() { return ArcCurve; });
/* harmony import */ var _EllipseCurve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EllipseCurve.js */ "../../node_modules/three/src/extras/curves/EllipseCurve.js");


class ArcCurve extends _EllipseCurve_js__WEBPACK_IMPORTED_MODULE_0__["EllipseCurve"] {

	constructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		super( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		this.type = 'ArcCurve';

	}

}

ArcCurve.prototype.isArcCurve = true;




/***/ }),

/***/ "../../node_modules/three/src/extras/curves/CatmullRomCurve3.js":
/*!**************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/curves/CatmullRomCurve3.js ***!
  \**************************************************************************************/
/*! exports provided: CatmullRomCurve3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CatmullRomCurve3", function() { return CatmullRomCurve3; });
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _core_Curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Curve.js */ "../../node_modules/three/src/extras/core/Curve.js");



/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */


/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {

	let c0 = 0, c1 = 0, c2 = 0, c3 = 0;

	/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
	function init( x0, x1, t0, t1 ) {

		c0 = x0;
		c1 = t0;
		c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		c3 = 2 * x0 - 2 * x1 + t0 + t1;

	}

	return {

		initCatmullRom: function ( x0, x1, x2, x3, tension ) {

			init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

		},

		initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

			// compute tangents when parameterized in [t1,t2]
			let t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			let t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;

			init( x1, x2, t1, t2 );

		},

		calc: function ( t ) {

			const t2 = t * t;
			const t3 = t2 * t;
			return c0 + c1 * t + c2 * t2 + c3 * t3;

		}

	};

}

//

const tmp = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();

class CatmullRomCurve3 extends _core_Curve_js__WEBPACK_IMPORTED_MODULE_1__["Curve"] {

	constructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {

		super();

		this.type = 'CatmullRomCurve3';

		this.points = points;
		this.closed = closed;
		this.curveType = curveType;
		this.tension = tension;

	}

	getPoint( t, optionalTarget = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]() ) {

		const point = optionalTarget;

		const points = this.points;
		const l = points.length;

		const p = ( l - ( this.closed ? 0 : 1 ) ) * t;
		let intPoint = Math.floor( p );
		let weight = p - intPoint;

		if ( this.closed ) {

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

		} else if ( weight === 0 && intPoint === l - 1 ) {

			intPoint = l - 2;
			weight = 1;

		}

		let p0, p3; // 4 points (p1 & p2 defined below)

		if ( this.closed || intPoint > 0 ) {

			p0 = points[ ( intPoint - 1 ) % l ];

		} else {

			// extrapolate first point
			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
			p0 = tmp;

		}

		const p1 = points[ intPoint % l ];
		const p2 = points[ ( intPoint + 1 ) % l ];

		if ( this.closed || intPoint + 2 < l ) {

			p3 = points[ ( intPoint + 2 ) % l ];

		} else {

			// extrapolate last point
			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
			p3 = tmp;

		}

		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

			// init Centripetal / Chordal Catmull-Rom
			const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			let dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
			let dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
			let dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

			// safety check for repeated points
			if ( dt1 < 1e-4 ) dt1 = 1.0;
			if ( dt0 < 1e-4 ) dt0 = dt1;
			if ( dt2 < 1e-4 ) dt2 = dt1;

			px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

		} else if ( this.curveType === 'catmullrom' ) {

			px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

		}

		point.set(
			px.calc( weight ),
			py.calc( weight ),
			pz.calc( weight )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.points = [];

		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			const point = source.points[ i ];

			this.points.push( point.clone() );

		}

		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.points = [];

		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			const point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.points = [];

		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			const point = json.points[ i ];
			this.points.push( new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]().fromArray( point ) );

		}

		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;

		return this;

	}

}

CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;




/***/ }),

/***/ "../../node_modules/three/src/extras/curves/CubicBezierCurve.js":
/*!**************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/curves/CubicBezierCurve.js ***!
  \**************************************************************************************/
/*! exports provided: CubicBezierCurve */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve", function() { return CubicBezierCurve; });
/* harmony import */ var _core_Curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Curve.js */ "../../node_modules/three/src/extras/core/Curve.js");
/* harmony import */ var _core_Interpolations_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Interpolations.js */ "../../node_modules/three/src/extras/core/Interpolations.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");




class CubicBezierCurve extends _core_Curve_js__WEBPACK_IMPORTED_MODULE_0__["Curve"] {

	constructor( v0 = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"](), v1 = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"](), v2 = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"](), v3 = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]() ) {

		super();

		this.type = 'CubicBezierCurve';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	}

	getPoint( t, optionalTarget = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			Object(_core_Interpolations_js__WEBPACK_IMPORTED_MODULE_1__["CubicBezier"])( t, v0.x, v1.x, v2.x, v3.x ),
			Object(_core_Interpolations_js__WEBPACK_IMPORTED_MODULE_1__["CubicBezier"])( t, v0.y, v1.y, v2.y, v3.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	}

}

CubicBezierCurve.prototype.isCubicBezierCurve = true;




/***/ }),

/***/ "../../node_modules/three/src/extras/curves/CubicBezierCurve3.js":
/*!***************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/curves/CubicBezierCurve3.js ***!
  \***************************************************************************************/
/*! exports provided: CubicBezierCurve3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve3", function() { return CubicBezierCurve3; });
/* harmony import */ var _core_Curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Curve.js */ "../../node_modules/three/src/extras/core/Curve.js");
/* harmony import */ var _core_Interpolations_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Interpolations.js */ "../../node_modules/three/src/extras/core/Interpolations.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");




class CubicBezierCurve3 extends _core_Curve_js__WEBPACK_IMPORTED_MODULE_0__["Curve"] {

	constructor( v0 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"](), v1 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"](), v2 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"](), v3 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]() ) {

		super();

		this.type = 'CubicBezierCurve3';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	}

	getPoint( t, optionalTarget = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			Object(_core_Interpolations_js__WEBPACK_IMPORTED_MODULE_1__["CubicBezier"])( t, v0.x, v1.x, v2.x, v3.x ),
			Object(_core_Interpolations_js__WEBPACK_IMPORTED_MODULE_1__["CubicBezier"])( t, v0.y, v1.y, v2.y, v3.y ),
			Object(_core_Interpolations_js__WEBPACK_IMPORTED_MODULE_1__["CubicBezier"])( t, v0.z, v1.z, v2.z, v3.z )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	}

}

CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;




/***/ }),

/***/ "../../node_modules/three/src/extras/curves/Curves.js":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/curves/Curves.js ***!
  \****************************************************************************/
/*! exports provided: ArcCurve, CatmullRomCurve3, CubicBezierCurve, CubicBezierCurve3, EllipseCurve, LineCurve, LineCurve3, QuadraticBezierCurve, QuadraticBezierCurve3, SplineCurve */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ArcCurve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ArcCurve.js */ "../../node_modules/three/src/extras/curves/ArcCurve.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ArcCurve", function() { return _ArcCurve_js__WEBPACK_IMPORTED_MODULE_0__["ArcCurve"]; });

/* harmony import */ var _CatmullRomCurve3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CatmullRomCurve3.js */ "../../node_modules/three/src/extras/curves/CatmullRomCurve3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CatmullRomCurve3", function() { return _CatmullRomCurve3_js__WEBPACK_IMPORTED_MODULE_1__["CatmullRomCurve3"]; });

/* harmony import */ var _CubicBezierCurve_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CubicBezierCurve.js */ "../../node_modules/three/src/extras/curves/CubicBezierCurve.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve", function() { return _CubicBezierCurve_js__WEBPACK_IMPORTED_MODULE_2__["CubicBezierCurve"]; });

/* harmony import */ var _CubicBezierCurve3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CubicBezierCurve3.js */ "../../node_modules/three/src/extras/curves/CubicBezierCurve3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve3", function() { return _CubicBezierCurve3_js__WEBPACK_IMPORTED_MODULE_3__["CubicBezierCurve3"]; });

/* harmony import */ var _EllipseCurve_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EllipseCurve.js */ "../../node_modules/three/src/extras/curves/EllipseCurve.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EllipseCurve", function() { return _EllipseCurve_js__WEBPACK_IMPORTED_MODULE_4__["EllipseCurve"]; });

/* harmony import */ var _LineCurve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./LineCurve.js */ "../../node_modules/three/src/extras/curves/LineCurve.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LineCurve", function() { return _LineCurve_js__WEBPACK_IMPORTED_MODULE_5__["LineCurve"]; });

/* harmony import */ var _LineCurve3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./LineCurve3.js */ "../../node_modules/three/src/extras/curves/LineCurve3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LineCurve3", function() { return _LineCurve3_js__WEBPACK_IMPORTED_MODULE_6__["LineCurve3"]; });

/* harmony import */ var _QuadraticBezierCurve_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./QuadraticBezierCurve.js */ "../../node_modules/three/src/extras/curves/QuadraticBezierCurve.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve", function() { return _QuadraticBezierCurve_js__WEBPACK_IMPORTED_MODULE_7__["QuadraticBezierCurve"]; });

/* harmony import */ var _QuadraticBezierCurve3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./QuadraticBezierCurve3.js */ "../../node_modules/three/src/extras/curves/QuadraticBezierCurve3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve3", function() { return _QuadraticBezierCurve3_js__WEBPACK_IMPORTED_MODULE_8__["QuadraticBezierCurve3"]; });

/* harmony import */ var _SplineCurve_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./SplineCurve.js */ "../../node_modules/three/src/extras/curves/SplineCurve.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SplineCurve", function() { return _SplineCurve_js__WEBPACK_IMPORTED_MODULE_9__["SplineCurve"]; });













/***/ }),

/***/ "../../node_modules/three/src/extras/curves/EllipseCurve.js":
/*!**********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/curves/EllipseCurve.js ***!
  \**********************************************************************************/
/*! exports provided: EllipseCurve */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EllipseCurve", function() { return EllipseCurve; });
/* harmony import */ var _core_Curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Curve.js */ "../../node_modules/three/src/extras/core/Curve.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");



class EllipseCurve extends _core_Curve_js__WEBPACK_IMPORTED_MODULE_0__["Curve"] {

	constructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {

		super();

		this.type = 'EllipseCurve';

		this.aX = aX;
		this.aY = aY;

		this.xRadius = xRadius;
		this.yRadius = yRadius;

		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;

		this.aClockwise = aClockwise;

		this.aRotation = aRotation;

	}

	getPoint( t, optionalTarget ) {

		const point = optionalTarget || new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"]();

		const twoPi = Math.PI * 2;
		let deltaAngle = this.aEndAngle - this.aStartAngle;
		const samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

		// ensures that deltaAngle is 0 .. 2 PI
		while ( deltaAngle < 0 ) deltaAngle += twoPi;
		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

		if ( deltaAngle < Number.EPSILON ) {

			if ( samePoints ) {

				deltaAngle = 0;

			} else {

				deltaAngle = twoPi;

			}

		}

		if ( this.aClockwise === true && ! samePoints ) {

			if ( deltaAngle === twoPi ) {

				deltaAngle = - twoPi;

			} else {

				deltaAngle = deltaAngle - twoPi;

			}

		}

		const angle = this.aStartAngle + t * deltaAngle;
		let x = this.aX + this.xRadius * Math.cos( angle );
		let y = this.aY + this.yRadius * Math.sin( angle );

		if ( this.aRotation !== 0 ) {

			const cos = Math.cos( this.aRotation );
			const sin = Math.sin( this.aRotation );

			const tx = x - this.aX;
			const ty = y - this.aY;

			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;

		}

		return point.set( x, y );

	}

	copy( source ) {

		super.copy( source );

		this.aX = source.aX;
		this.aY = source.aY;

		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;

		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;

		this.aClockwise = source.aClockwise;

		this.aRotation = source.aRotation;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.aX = this.aX;
		data.aY = this.aY;

		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;

		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;

		data.aClockwise = this.aClockwise;

		data.aRotation = this.aRotation;

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.aX = json.aX;
		this.aY = json.aY;

		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;

		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;

		this.aClockwise = json.aClockwise;

		this.aRotation = json.aRotation;

		return this;

	}

}

EllipseCurve.prototype.isEllipseCurve = true;




/***/ }),

/***/ "../../node_modules/three/src/extras/curves/LineCurve.js":
/*!*******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/curves/LineCurve.js ***!
  \*******************************************************************************/
/*! exports provided: LineCurve */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve", function() { return LineCurve; });
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _core_Curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Curve.js */ "../../node_modules/three/src/extras/core/Curve.js");



class LineCurve extends _core_Curve_js__WEBPACK_IMPORTED_MODULE_1__["Curve"] {

	constructor( v1 = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"](), v2 = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]() ) {

		super();

		this.type = 'LineCurve';

		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]() ) {

		const point = optionalTarget;

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	}

	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	}

	getTangent( t, optionalTarget ) {

		const tangent = optionalTarget || new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();

		tangent.copy( this.v2 ).sub( this.v1 ).normalize();

		return tangent;

	}

	copy( source ) {

		super.copy( source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

LineCurve.prototype.isLineCurve = true;




/***/ }),

/***/ "../../node_modules/three/src/extras/curves/LineCurve3.js":
/*!********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/curves/LineCurve3.js ***!
  \********************************************************************************/
/*! exports provided: LineCurve3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve3", function() { return LineCurve3; });
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _core_Curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Curve.js */ "../../node_modules/three/src/extras/core/Curve.js");



class LineCurve3 extends _core_Curve_js__WEBPACK_IMPORTED_MODULE_1__["Curve"] {

	constructor( v1 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), v2 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]() ) {

		super();

		this.type = 'LineCurve3';
		this.isLineCurve3 = true;

		this.v1 = v1;
		this.v2 = v2;

	}
	getPoint( t, optionalTarget = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]() ) {

		const point = optionalTarget;

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	}
	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	}
	copy( source ) {

		super.copy( source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}
	toJSON() {

		const data = super.toJSON();

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}
	fromJSON( json ) {

		super.fromJSON( json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}




/***/ }),

/***/ "../../node_modules/three/src/extras/curves/QuadraticBezierCurve.js":
/*!******************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/curves/QuadraticBezierCurve.js ***!
  \******************************************************************************************/
/*! exports provided: QuadraticBezierCurve */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve", function() { return QuadraticBezierCurve; });
/* harmony import */ var _core_Curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Curve.js */ "../../node_modules/three/src/extras/core/Curve.js");
/* harmony import */ var _core_Interpolations_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Interpolations.js */ "../../node_modules/three/src/extras/core/Interpolations.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");




class QuadraticBezierCurve extends _core_Curve_js__WEBPACK_IMPORTED_MODULE_0__["Curve"] {

	constructor( v0 = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"](), v1 = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"](), v2 = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]() ) {

		super();

		this.type = 'QuadraticBezierCurve';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			Object(_core_Interpolations_js__WEBPACK_IMPORTED_MODULE_1__["QuadraticBezier"])( t, v0.x, v1.x, v2.x ),
			Object(_core_Interpolations_js__WEBPACK_IMPORTED_MODULE_1__["QuadraticBezier"])( t, v0.y, v1.y, v2.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;




/***/ }),

/***/ "../../node_modules/three/src/extras/curves/QuadraticBezierCurve3.js":
/*!*******************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/curves/QuadraticBezierCurve3.js ***!
  \*******************************************************************************************/
/*! exports provided: QuadraticBezierCurve3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve3", function() { return QuadraticBezierCurve3; });
/* harmony import */ var _core_Curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Curve.js */ "../../node_modules/three/src/extras/core/Curve.js");
/* harmony import */ var _core_Interpolations_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Interpolations.js */ "../../node_modules/three/src/extras/core/Interpolations.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");




class QuadraticBezierCurve3 extends _core_Curve_js__WEBPACK_IMPORTED_MODULE_0__["Curve"] {

	constructor( v0 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"](), v1 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"](), v2 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]() ) {

		super();

		this.type = 'QuadraticBezierCurve3';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			Object(_core_Interpolations_js__WEBPACK_IMPORTED_MODULE_1__["QuadraticBezier"])( t, v0.x, v1.x, v2.x ),
			Object(_core_Interpolations_js__WEBPACK_IMPORTED_MODULE_1__["QuadraticBezier"])( t, v0.y, v1.y, v2.y ),
			Object(_core_Interpolations_js__WEBPACK_IMPORTED_MODULE_1__["QuadraticBezier"])( t, v0.z, v1.z, v2.z )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;




/***/ }),

/***/ "../../node_modules/three/src/extras/curves/SplineCurve.js":
/*!*********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/curves/SplineCurve.js ***!
  \*********************************************************************************/
/*! exports provided: SplineCurve */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SplineCurve", function() { return SplineCurve; });
/* harmony import */ var _core_Curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Curve.js */ "../../node_modules/three/src/extras/core/Curve.js");
/* harmony import */ var _core_Interpolations_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Interpolations.js */ "../../node_modules/three/src/extras/core/Interpolations.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");




class SplineCurve extends _core_Curve_js__WEBPACK_IMPORTED_MODULE_0__["Curve"] {

	constructor( points = [] ) {

		super();

		this.type = 'SplineCurve';

		this.points = points;

	}

	getPoint( t, optionalTarget = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]() ) {

		const point = optionalTarget;

		const points = this.points;
		const p = ( points.length - 1 ) * t;

		const intPoint = Math.floor( p );
		const weight = p - intPoint;

		const p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		const p1 = points[ intPoint ];
		const p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		const p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		point.set(
			Object(_core_Interpolations_js__WEBPACK_IMPORTED_MODULE_1__["CatmullRom"])( weight, p0.x, p1.x, p2.x, p3.x ),
			Object(_core_Interpolations_js__WEBPACK_IMPORTED_MODULE_1__["CatmullRom"])( weight, p0.y, p1.y, p2.y, p3.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.points = [];

		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			const point = source.points[ i ];

			this.points.push( point.clone() );

		}

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.points = [];

		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			const point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.points = [];

		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			const point = json.points[ i ];
			this.points.push( new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]().fromArray( point ) );

		}

		return this;

	}

}

SplineCurve.prototype.isSplineCurve = true;




/***/ }),

/***/ "../../node_modules/three/src/extras/objects/ImmediateRenderObject.js":
/*!********************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/extras/objects/ImmediateRenderObject.js ***!
  \********************************************************************************************/
/*! exports provided: ImmediateRenderObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImmediateRenderObject", function() { return ImmediateRenderObject; });
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");


function ImmediateRenderObject( material ) {

	_core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__["Object3D"].call( this );

	this.material = material;
	this.render = function ( /* renderCallback */ ) {};

	this.hasPositions = false;
	this.hasNormals = false;
	this.hasColors = false;
	this.hasUvs = false;

	this.positionArray = null;
	this.normalArray = null;
	this.colorArray = null;
	this.uvArray = null;

	this.count = 0;

}

ImmediateRenderObject.prototype = Object.create( _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__["Object3D"].prototype );
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

ImmediateRenderObject.prototype.isImmediateRenderObject = true;





/***/ }),

/***/ "../../node_modules/three/src/geometries/BoxGeometry.js":
/*!******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/BoxGeometry.js ***!
  \******************************************************************************/
/*! exports provided: BoxGeometry, BoxBufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxGeometry", function() { return BoxGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxBufferGeometry", function() { return BoxGeometry; });
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");




class BoxGeometry extends _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"] {

	constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

		super();

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		const scope = this;

		// segments

		widthSegments = Math.floor( widthSegments );
		heightSegments = Math.floor( heightSegments );
		depthSegments = Math.floor( depthSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let numberOfVertices = 0;
		let groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( vertices, 3 ) );
		this.setAttribute( 'normal', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( normals, 3 ) );
		this.setAttribute( 'uv', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			const segmentWidth = width / gridX;
			const segmentHeight = height / gridY;

			const widthHalf = width / 2;
			const heightHalf = height / 2;
			const depthHalf = depth / 2;

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			let vertexCounter = 0;
			let groupCount = 0;

			const vector = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

			// generate vertices, normals and uvs

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segmentHeight - heightHalf;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = numberOfVertices + ix + gridX1 * iy;
					const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

}




/***/ }),

/***/ "../../node_modules/three/src/geometries/CircleGeometry.js":
/*!*********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/CircleGeometry.js ***!
  \*********************************************************************************/
/*! exports provided: CircleGeometry, CircleBufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleGeometry", function() { return CircleGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleBufferGeometry", function() { return CircleGeometry; });
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");





class CircleGeometry extends _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"] {

	constructor( radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		segments = Math.max( 3, segments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
		const uv = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__["Vector2"]();

		// center point

		vertices.push( 0, 0, 0 );
		normals.push( 0, 0, 1 );
		uvs.push( 0.5, 0.5 );

		for ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {

			const segment = thetaStart + s / segments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uvs

			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// indices

		for ( let i = 1; i <= segments; i ++ ) {

			indices.push( i, i + 1, 0 );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( vertices, 3 ) );
		this.setAttribute( 'normal', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( normals, 3 ) );
		this.setAttribute( 'uv', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( uvs, 2 ) );

	}

}





/***/ }),

/***/ "../../node_modules/three/src/geometries/ConeGeometry.js":
/*!*******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/ConeGeometry.js ***!
  \*******************************************************************************/
/*! exports provided: ConeGeometry, ConeBufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConeGeometry", function() { return ConeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConeBufferGeometry", function() { return ConeGeometry; });
/* harmony import */ var _CylinderGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CylinderGeometry.js */ "../../node_modules/three/src/geometries/CylinderGeometry.js");


class ConeGeometry extends _CylinderGeometry_js__WEBPACK_IMPORTED_MODULE_0__["CylinderGeometry"] {

	constructor( radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

}




/***/ }),

/***/ "../../node_modules/three/src/geometries/CylinderGeometry.js":
/*!***********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/CylinderGeometry.js ***!
  \***********************************************************************************/
/*! exports provided: CylinderGeometry, CylinderBufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CylinderGeometry", function() { return CylinderGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CylinderBufferGeometry", function() { return CylinderGeometry; });
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");





class CylinderGeometry extends _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"] {

	constructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();
		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		const scope = this;

		radialSegments = Math.floor( radialSegments );
		heightSegments = Math.floor( heightSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let index = 0;
		const indexArray = [];
		const halfHeight = height / 2;
		let groupStart = 0;

		// generate geometry

		generateTorso();

		if ( openEnded === false ) {

			if ( radiusTop > 0 ) generateCap( true );
			if ( radiusBottom > 0 ) generateCap( false );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( vertices, 3 ) );
		this.setAttribute( 'normal', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( normals, 3 ) );
		this.setAttribute( 'uv', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( uvs, 2 ) );

		function generateTorso() {

			const normal = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
			const vertex = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

			let groupCount = 0;

			// this will be used to calculate the normal
			const slope = ( radiusBottom - radiusTop ) / height;

			// generate vertices, normals and uvs

			for ( let y = 0; y <= heightSegments; y ++ ) {

				const indexRow = [];

				const v = y / heightSegments;

				// calculate the radius of the current row

				const radius = v * ( radiusBottom - radiusTop ) + radiusTop;

				for ( let x = 0; x <= radialSegments; x ++ ) {

					const u = x / radialSegments;

					const theta = u * thetaLength + thetaStart;

					const sinTheta = Math.sin( theta );
					const cosTheta = Math.cos( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.set( sinTheta, slope, cosTheta ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u, 1 - v );

					// save index of vertex in respective row

					indexRow.push( index ++ );

				}

				// now save vertices of the row in our index array

				indexArray.push( indexRow );

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				for ( let y = 0; y < heightSegments; y ++ ) {

					// we use the index array to access the correct indices

					const a = indexArray[ y ][ x ];
					const b = indexArray[ y + 1 ][ x ];
					const c = indexArray[ y + 1 ][ x + 1 ];
					const d = indexArray[ y ][ x + 1 ];

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// update group counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, 0 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

		function generateCap( top ) {

			// save the index of the first center vertex
			const centerIndexStart = index;

			const uv = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__["Vector2"]();
			const vertex = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

			let groupCount = 0;

			const radius = ( top === true ) ? radiusTop : radiusBottom;
			const sign = ( top === true ) ? 1 : - 1;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for ( let x = 1; x <= radialSegments; x ++ ) {

				// vertex

				vertices.push( 0, halfHeight * sign, 0 );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uvs.push( 0.5, 0.5 );

				// increase index

				index ++;

			}

			// save the index of the last center vertex
			const centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for ( let x = 0; x <= radialSegments; x ++ ) {

				const u = x / radialSegments;
				const theta = u * thetaLength + thetaStart;

				const cosTheta = Math.cos( theta );
				const sinTheta = Math.sin( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uv.x = ( cosTheta * 0.5 ) + 0.5;
				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
				uvs.push( uv.x, uv.y );

				// increase index

				index ++;

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				const c = centerIndexStart + x;
				const i = centerIndexEnd + x;

				if ( top === true ) {

					// face top

					indices.push( i, i + 1, c );

				} else {

					// face bottom

					indices.push( i + 1, i, c );

				}

				groupCount += 3;

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

	}

}





/***/ }),

/***/ "../../node_modules/three/src/geometries/DodecahedronGeometry.js":
/*!***************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/DodecahedronGeometry.js ***!
  \***************************************************************************************/
/*! exports provided: DodecahedronGeometry, DodecahedronBufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DodecahedronGeometry", function() { return DodecahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DodecahedronBufferGeometry", function() { return DodecahedronGeometry; });
/* harmony import */ var _PolyhedronGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PolyhedronGeometry.js */ "../../node_modules/three/src/geometries/PolyhedronGeometry.js");


class DodecahedronGeometry extends _PolyhedronGeometry_js__WEBPACK_IMPORTED_MODULE_0__["PolyhedronGeometry"] {

	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;
		const r = 1 / t;

		const vertices = [

			// (±1, ±1, ±1)
			- 1, - 1, - 1,	- 1, - 1, 1,
			- 1, 1, - 1, - 1, 1, 1,
			1, - 1, - 1, 1, - 1, 1,
			1, 1, - 1, 1, 1, 1,

			// (0, ±1/φ, ±φ)
			0, - r, - t, 0, - r, t,
			0, r, - t, 0, r, t,

			// (±1/φ, ±φ, 0)
			- r, - t, 0, - r, t, 0,
			r, - t, 0, r, t, 0,

			// (±φ, 0, ±1/φ)
			- t, 0, - r, t, 0, - r,
			- t, 0, r, t, 0, r
		];

		const indices = [
			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
			1, 12, 14, 	1, 14, 5, 	1, 5, 9
		];

		super( vertices, indices, radius, detail );

		this.type = 'DodecahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

}





/***/ }),

/***/ "../../node_modules/three/src/geometries/EdgesGeometry.js":
/*!********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/EdgesGeometry.js ***!
  \********************************************************************************/
/*! exports provided: EdgesGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgesGeometry", function() { return EdgesGeometry; });
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");
/* harmony import */ var _math_Triangle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Triangle.js */ "../../node_modules/three/src/math/Triangle.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");






const _v0 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
const _v1 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
const _normal = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
const _triangle = new _math_Triangle_js__WEBPACK_IMPORTED_MODULE_3__["Triangle"]();

class EdgesGeometry extends _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"] {

	constructor( geometry, thresholdAngle ) {

		super();

		this.type = 'EdgesGeometry';

		this.parameters = {
			thresholdAngle: thresholdAngle
		};

		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

		if ( geometry.isGeometry === true ) {

			console.error( 'THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );
			return;

		}

		const precisionPoints = 4;
		const precision = Math.pow( 10, precisionPoints );
		const thresholdDot = Math.cos( _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__["MathUtils"].DEG2RAD * thresholdAngle );

		const indexAttr = geometry.getIndex();
		const positionAttr = geometry.getAttribute( 'position' );
		const indexCount = indexAttr ? indexAttr.count : positionAttr.count;

		const indexArr = [ 0, 0, 0 ];
		const vertKeys = [ 'a', 'b', 'c' ];
		const hashes = new Array( 3 );

		const edgeData = {};
		const vertices = [];
		for ( let i = 0; i < indexCount; i += 3 ) {

			if ( indexAttr ) {

				indexArr[ 0 ] = indexAttr.getX( i );
				indexArr[ 1 ] = indexAttr.getX( i + 1 );
				indexArr[ 2 ] = indexAttr.getX( i + 2 );

			} else {

				indexArr[ 0 ] = i;
				indexArr[ 1 ] = i + 1;
				indexArr[ 2 ] = i + 2;

			}

			const { a, b, c } = _triangle;
			a.fromBufferAttribute( positionAttr, indexArr[ 0 ] );
			b.fromBufferAttribute( positionAttr, indexArr[ 1 ] );
			c.fromBufferAttribute( positionAttr, indexArr[ 2 ] );
			_triangle.getNormal( _normal );

			// create hashes for the edge from the vertices
			hashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;
			hashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;
			hashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;

			// skip degenerate triangles
			if ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {

				continue;

			}

			// iterate over every edge
			for ( let j = 0; j < 3; j ++ ) {

				// get the first and next vertex making up the edge
				const jNext = ( j + 1 ) % 3;
				const vecHash0 = hashes[ j ];
				const vecHash1 = hashes[ jNext ];
				const v0 = _triangle[ vertKeys[ j ] ];
				const v1 = _triangle[ vertKeys[ jNext ] ];

				const hash = `${ vecHash0 }_${ vecHash1 }`;
				const reverseHash = `${ vecHash1 }_${ vecHash0 }`;

				if ( reverseHash in edgeData && edgeData[ reverseHash ] ) {

					// if we found a sibling edge add it into the vertex array if
					// it meets the angle threshold and delete the edge from the map.
					if ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {

						vertices.push( v0.x, v0.y, v0.z );
						vertices.push( v1.x, v1.y, v1.z );

					}

					edgeData[ reverseHash ] = null;

				} else if ( ! ( hash in edgeData ) ) {

					// if we've already got an edge here then skip adding a new one
					edgeData[ hash ] = {

						index0: indexArr[ j ],
						index1: indexArr[ jNext ],
						normal: _normal.clone(),

					};

				}

			}

		}

		// iterate over all remaining, unmatched edges and add them to the vertex array
		for ( const key in edgeData ) {

			if ( edgeData[ key ] ) {

				const { index0, index1 } = edgeData[ key ];
				_v0.fromBufferAttribute( positionAttr, index0 );
				_v1.fromBufferAttribute( positionAttr, index1 );

				vertices.push( _v0.x, _v0.y, _v0.z );
				vertices.push( _v1.x, _v1.y, _v1.z );

			}

		}

		this.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( vertices, 3 ) );

	}

}




/***/ }),

/***/ "../../node_modules/three/src/geometries/ExtrudeGeometry.js":
/*!**********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/ExtrudeGeometry.js ***!
  \**********************************************************************************/
/*! exports provided: ExtrudeGeometry, ExtrudeBufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExtrudeGeometry", function() { return ExtrudeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExtrudeBufferGeometry", function() { return ExtrudeGeometry; });
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _extras_ShapeUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extras/ShapeUtils.js */ "../../node_modules/three/src/extras/ShapeUtils.js");
/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */







class ExtrudeGeometry extends _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"] {

	constructor( shapes, options ) {

		super();

		this.type = 'ExtrudeGeometry';

		this.parameters = {
			shapes: shapes,
			options: options
		};

		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

		const scope = this;

		const verticesArray = [];
		const uvArray = [];

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];
			addShape( shape );

		}

		// build geometry

		this.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( verticesArray, 3 ) );
		this.setAttribute( 'uv', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( uvArray, 2 ) );

		this.computeVertexNormals();

		// functions

		function addShape( shape ) {

			const placeholder = [];

			// options

			const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
			const steps = options.steps !== undefined ? options.steps : 1;
			let depth = options.depth !== undefined ? options.depth : 100;

			let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
			let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
			let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
			let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
			let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

			const extrudePath = options.extrudePath;

			const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

			// deprecated options

			if ( options.amount !== undefined ) {

				console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
				depth = options.amount;

			}

			//

			let extrudePts, extrudeByPath = false;
			let splineTube, binormal, normal, position2;

			if ( extrudePath ) {

				extrudePts = extrudePath.getSpacedPoints( steps );

				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion

				// SETUP TNB variables

				// TODO1 - have a .isClosed in spline?

				splineTube = extrudePath.computeFrenetFrames( steps, false );

				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				binormal = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();
				normal = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();
				position2 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();

			}

			// Safeguards if bevels are not enabled

			if ( ! bevelEnabled ) {

				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;
				bevelOffset = 0;

			}

			// Variables initialization

			const shapePoints = shape.extractPoints( curveSegments );

			let vertices = shapePoints.shape;
			const holes = shapePoints.holes;

			const reverse = ! _extras_ShapeUtils_js__WEBPACK_IMPORTED_MODULE_4__["ShapeUtils"].isClockWise( vertices );

			if ( reverse ) {

				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];

					if ( _extras_ShapeUtils_js__WEBPACK_IMPORTED_MODULE_4__["ShapeUtils"].isClockWise( ahole ) ) {

						holes[ h ] = ahole.reverse();

					}

				}

			}


			const faces = _extras_ShapeUtils_js__WEBPACK_IMPORTED_MODULE_4__["ShapeUtils"].triangulateShape( vertices, holes );

			/* Vertices */

			const contour = vertices; // vertices has all points but contour has only points of circumference

			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				const ahole = holes[ h ];

				vertices = vertices.concat( ahole );

			}


			function scalePt2( pt, vec, size ) {

				if ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );

				return vec.clone().multiplyScalar( size ).add( pt );

			}

			const vlen = vertices.length, flen = faces.length;


			// Find directions for point movement


			function getBevelVec( inPt, inPrev, inNext ) {

				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.

				let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html

				const v_prev_x = inPt.x - inPrev.x,
					v_prev_y = inPt.y - inPrev.y;
				const v_next_x = inNext.x - inPt.x,
					v_next_y = inNext.y - inPt.y;

				const v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

				// check for collinear edges
				const collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				if ( Math.abs( collinear0 ) > Number.EPSILON ) {

					// not collinear

					// length of vectors for normalizing

					const v_prev_len = Math.sqrt( v_prev_lensq );
					const v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

					// shift adjacent points by unit vectors to the left

					const ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					const ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

					const ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					const ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

					// scaling factor for v_prev to intersection point

					const sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
						( v_prev_x * v_next_y - v_prev_y * v_next_x );

					// vector from inPt to intersection point

					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					const v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {

						return new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]( v_trans_x, v_trans_y );

					} else {

						shrink_by = Math.sqrt( v_trans_lensq / 2 );

					}

				} else {

					// handle special case of collinear edges

					let direction_eq = false; // assumes: opposite

					if ( v_prev_x > Number.EPSILON ) {

						if ( v_next_x > Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( v_prev_x < - Number.EPSILON ) {

							if ( v_next_x < - Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

								direction_eq = true;

							}

						}

					}

					if ( direction_eq ) {

						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y = v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );

					} else {

						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );

					}

				}

				return new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]( v_trans_x / shrink_by, v_trans_y / shrink_by );

			}


			const contourMovements = [];

			for ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)

				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

			}

			const holesMovements = [];
			let oneHoleMovements, verticesMovements = contourMovements.concat();

			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				const ahole = holes[ h ];

				oneHoleMovements = [];

				for ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) j = 0;
					if ( k === il ) k = 0;

					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

				}

				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );

			}


			// Loop bevelSegments, 1 for the front, 1 for the back

			for ( let b = 0; b < bevelSegments; b ++ ) {

				//for ( b = bevelSegments; b > 0; b -- ) {

				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				// contract shape

				for ( let i = 0, il = contour.length; i < il; i ++ ) {

					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

					v( vert.x, vert.y, - z );

				}

				// expand holes

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						v( vert.x, vert.y, - z );

					}

				}

			}

			const bs = bevelSize + bevelOffset;

			// Back facing vertices

			for ( let i = 0; i < vlen; i ++ ) {

				const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, 0 );

				} else {

					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

			// Add stepped vertices...
			// Including front facing vertices

			for ( let s = 1; s <= steps; s ++ ) {

				for ( let i = 0; i < vlen; i ++ ) {

					const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, depth / steps * s );

					} else {

						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

			}


			// Add bevel segments planes

			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( let b = bevelSegments - 1; b >= 0; b -- ) {

				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				// contract shape

				for ( let i = 0, il = contour.length; i < il; i ++ ) {

					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y, depth + z );

				}

				// expand holes

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						if ( ! extrudeByPath ) {

							v( vert.x, vert.y, depth + z );

						} else {

							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

						}

					}

				}

			}

			/* Faces */

			// Top and bottom faces

			buildLidFaces();

			// Sides faces

			buildSideFaces();


			/////  Internal functions

			function buildLidFaces() {

				const start = verticesArray.length / 3;

				if ( bevelEnabled ) {

					let layer = 0; // steps + 1
					let offset = vlen * layer;

					// Bottom faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

					}

					layer = steps + bevelSegments * 2;
					offset = vlen * layer;

					// Top faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

					}

				} else {

					// Bottom faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );

					}

					// Top faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

					}

				}

				scope.addGroup( start, verticesArray.length / 3 - start, 0 );

			}

			// Create faces for the z-sides of the shape

			function buildSideFaces() {

				const start = verticesArray.length / 3;
				let layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					sidewalls( ahole, layeroffset );

					//, true
					layeroffset += ahole.length;

				}


				scope.addGroup( start, verticesArray.length / 3 - start, 1 );


			}

			function sidewalls( contour, layeroffset ) {

				let i = contour.length;

				while ( -- i >= 0 ) {

					const j = i;
					let k = i - 1;
					if ( k < 0 ) k = contour.length - 1;

					//console.log('b', i,j, i-1, k,vertices.length);

					for ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {

						const slen1 = vlen * s;
						const slen2 = vlen * ( s + 1 );

						const a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;

						f4( a, b, c, d );

					}

				}

			}

			function v( x, y, z ) {

				placeholder.push( x );
				placeholder.push( y );
				placeholder.push( z );

			}


			function f3( a, b, c ) {

				addVertex( a );
				addVertex( b );
				addVertex( c );

				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );

			}

			function f4( a, b, c, d ) {

				addVertex( a );
				addVertex( b );
				addVertex( d );

				addVertex( b );
				addVertex( c );
				addVertex( d );


				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 3 ] );

				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );
				addUV( uvs[ 3 ] );

			}

			function addVertex( index ) {

				verticesArray.push( placeholder[ index * 3 + 0 ] );
				verticesArray.push( placeholder[ index * 3 + 1 ] );
				verticesArray.push( placeholder[ index * 3 + 2 ] );

			}


			function addUV( vector2 ) {

				uvArray.push( vector2.x );
				uvArray.push( vector2.y );

			}

		}

	}

	toJSON() {

		const data = _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"].prototype.toJSON.call( this );

		const shapes = this.parameters.shapes;
		const options = this.parameters.options;

		return toJSON( shapes, options, data );

	}

}

const WorldUVGenerator = {

	generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

		const a_x = vertices[ indexA * 3 ];
		const a_y = vertices[ indexA * 3 + 1 ];
		const b_x = vertices[ indexB * 3 ];
		const b_y = vertices[ indexB * 3 + 1 ];
		const c_x = vertices[ indexC * 3 ];
		const c_y = vertices[ indexC * 3 + 1 ];

		return [
			new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]( a_x, a_y ),
			new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]( b_x, b_y ),
			new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]( c_x, c_y )
		];

	},

	generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

		const a_x = vertices[ indexA * 3 ];
		const a_y = vertices[ indexA * 3 + 1 ];
		const a_z = vertices[ indexA * 3 + 2 ];
		const b_x = vertices[ indexB * 3 ];
		const b_y = vertices[ indexB * 3 + 1 ];
		const b_z = vertices[ indexB * 3 + 2 ];
		const c_x = vertices[ indexC * 3 ];
		const c_y = vertices[ indexC * 3 + 1 ];
		const c_z = vertices[ indexC * 3 + 2 ];
		const d_x = vertices[ indexD * 3 ];
		const d_y = vertices[ indexD * 3 + 1 ];
		const d_z = vertices[ indexD * 3 + 2 ];

		if ( Math.abs( a_y - b_y ) < 0.01 ) {

			return [
				new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]( a_x, 1 - a_z ),
				new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]( b_x, 1 - b_z ),
				new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]( c_x, 1 - c_z ),
				new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]( d_x, 1 - d_z )
			];

		} else {

			return [
				new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]( a_y, 1 - a_z ),
				new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]( b_y, 1 - b_z ),
				new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]( c_y, 1 - c_z ),
				new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]( d_y, 1 - d_z )
			];

		}

	}

};

function toJSON( shapes, options, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

	return data;

}





/***/ }),

/***/ "../../node_modules/three/src/geometries/Geometries.js":
/*!*****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/Geometries.js ***!
  \*****************************************************************************/
/*! exports provided: BoxGeometry, BoxBufferGeometry, CircleGeometry, CircleBufferGeometry, ConeGeometry, ConeBufferGeometry, CylinderGeometry, CylinderBufferGeometry, DodecahedronGeometry, DodecahedronBufferGeometry, EdgesGeometry, ExtrudeGeometry, ExtrudeBufferGeometry, IcosahedronGeometry, IcosahedronBufferGeometry, LatheGeometry, LatheBufferGeometry, OctahedronGeometry, OctahedronBufferGeometry, ParametricGeometry, ParametricBufferGeometry, PlaneGeometry, PlaneBufferGeometry, PolyhedronGeometry, PolyhedronBufferGeometry, RingGeometry, RingBufferGeometry, ShapeGeometry, ShapeBufferGeometry, SphereGeometry, SphereBufferGeometry, TetrahedronGeometry, TetrahedronBufferGeometry, TextGeometry, TextBufferGeometry, TorusGeometry, TorusBufferGeometry, TorusKnotGeometry, TorusKnotBufferGeometry, TubeGeometry, TubeBufferGeometry, WireframeGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _BoxGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BoxGeometry.js */ "../../node_modules/three/src/geometries/BoxGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BoxGeometry", function() { return _BoxGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BoxGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BoxBufferGeometry", function() { return _BoxGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BoxBufferGeometry"]; });

/* harmony import */ var _CircleGeometry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CircleGeometry.js */ "../../node_modules/three/src/geometries/CircleGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CircleGeometry", function() { return _CircleGeometry_js__WEBPACK_IMPORTED_MODULE_1__["CircleGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CircleBufferGeometry", function() { return _CircleGeometry_js__WEBPACK_IMPORTED_MODULE_1__["CircleBufferGeometry"]; });

/* harmony import */ var _ConeGeometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ConeGeometry.js */ "../../node_modules/three/src/geometries/ConeGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ConeGeometry", function() { return _ConeGeometry_js__WEBPACK_IMPORTED_MODULE_2__["ConeGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ConeBufferGeometry", function() { return _ConeGeometry_js__WEBPACK_IMPORTED_MODULE_2__["ConeBufferGeometry"]; });

/* harmony import */ var _CylinderGeometry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CylinderGeometry.js */ "../../node_modules/three/src/geometries/CylinderGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CylinderGeometry", function() { return _CylinderGeometry_js__WEBPACK_IMPORTED_MODULE_3__["CylinderGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CylinderBufferGeometry", function() { return _CylinderGeometry_js__WEBPACK_IMPORTED_MODULE_3__["CylinderBufferGeometry"]; });

/* harmony import */ var _DodecahedronGeometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DodecahedronGeometry.js */ "../../node_modules/three/src/geometries/DodecahedronGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DodecahedronGeometry", function() { return _DodecahedronGeometry_js__WEBPACK_IMPORTED_MODULE_4__["DodecahedronGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DodecahedronBufferGeometry", function() { return _DodecahedronGeometry_js__WEBPACK_IMPORTED_MODULE_4__["DodecahedronBufferGeometry"]; });

/* harmony import */ var _EdgesGeometry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EdgesGeometry.js */ "../../node_modules/three/src/geometries/EdgesGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EdgesGeometry", function() { return _EdgesGeometry_js__WEBPACK_IMPORTED_MODULE_5__["EdgesGeometry"]; });

/* harmony import */ var _ExtrudeGeometry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ExtrudeGeometry.js */ "../../node_modules/three/src/geometries/ExtrudeGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ExtrudeGeometry", function() { return _ExtrudeGeometry_js__WEBPACK_IMPORTED_MODULE_6__["ExtrudeGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ExtrudeBufferGeometry", function() { return _ExtrudeGeometry_js__WEBPACK_IMPORTED_MODULE_6__["ExtrudeBufferGeometry"]; });

/* harmony import */ var _IcosahedronGeometry_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./IcosahedronGeometry.js */ "../../node_modules/three/src/geometries/IcosahedronGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IcosahedronGeometry", function() { return _IcosahedronGeometry_js__WEBPACK_IMPORTED_MODULE_7__["IcosahedronGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IcosahedronBufferGeometry", function() { return _IcosahedronGeometry_js__WEBPACK_IMPORTED_MODULE_7__["IcosahedronBufferGeometry"]; });

/* harmony import */ var _LatheGeometry_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./LatheGeometry.js */ "../../node_modules/three/src/geometries/LatheGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LatheGeometry", function() { return _LatheGeometry_js__WEBPACK_IMPORTED_MODULE_8__["LatheGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LatheBufferGeometry", function() { return _LatheGeometry_js__WEBPACK_IMPORTED_MODULE_8__["LatheBufferGeometry"]; });

/* harmony import */ var _OctahedronGeometry_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./OctahedronGeometry.js */ "../../node_modules/three/src/geometries/OctahedronGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OctahedronGeometry", function() { return _OctahedronGeometry_js__WEBPACK_IMPORTED_MODULE_9__["OctahedronGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OctahedronBufferGeometry", function() { return _OctahedronGeometry_js__WEBPACK_IMPORTED_MODULE_9__["OctahedronBufferGeometry"]; });

/* harmony import */ var _ParametricGeometry_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ParametricGeometry.js */ "../../node_modules/three/src/geometries/ParametricGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ParametricGeometry", function() { return _ParametricGeometry_js__WEBPACK_IMPORTED_MODULE_10__["ParametricGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ParametricBufferGeometry", function() { return _ParametricGeometry_js__WEBPACK_IMPORTED_MODULE_10__["ParametricBufferGeometry"]; });

/* harmony import */ var _PlaneGeometry_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./PlaneGeometry.js */ "../../node_modules/three/src/geometries/PlaneGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PlaneGeometry", function() { return _PlaneGeometry_js__WEBPACK_IMPORTED_MODULE_11__["PlaneGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PlaneBufferGeometry", function() { return _PlaneGeometry_js__WEBPACK_IMPORTED_MODULE_11__["PlaneBufferGeometry"]; });

/* harmony import */ var _PolyhedronGeometry_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./PolyhedronGeometry.js */ "../../node_modules/three/src/geometries/PolyhedronGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PolyhedronGeometry", function() { return _PolyhedronGeometry_js__WEBPACK_IMPORTED_MODULE_12__["PolyhedronGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PolyhedronBufferGeometry", function() { return _PolyhedronGeometry_js__WEBPACK_IMPORTED_MODULE_12__["PolyhedronBufferGeometry"]; });

/* harmony import */ var _RingGeometry_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./RingGeometry.js */ "../../node_modules/three/src/geometries/RingGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RingGeometry", function() { return _RingGeometry_js__WEBPACK_IMPORTED_MODULE_13__["RingGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RingBufferGeometry", function() { return _RingGeometry_js__WEBPACK_IMPORTED_MODULE_13__["RingBufferGeometry"]; });

/* harmony import */ var _ShapeGeometry_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./ShapeGeometry.js */ "../../node_modules/three/src/geometries/ShapeGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShapeGeometry", function() { return _ShapeGeometry_js__WEBPACK_IMPORTED_MODULE_14__["ShapeGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShapeBufferGeometry", function() { return _ShapeGeometry_js__WEBPACK_IMPORTED_MODULE_14__["ShapeBufferGeometry"]; });

/* harmony import */ var _SphereGeometry_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./SphereGeometry.js */ "../../node_modules/three/src/geometries/SphereGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SphereGeometry", function() { return _SphereGeometry_js__WEBPACK_IMPORTED_MODULE_15__["SphereGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SphereBufferGeometry", function() { return _SphereGeometry_js__WEBPACK_IMPORTED_MODULE_15__["SphereBufferGeometry"]; });

/* harmony import */ var _TetrahedronGeometry_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./TetrahedronGeometry.js */ "../../node_modules/three/src/geometries/TetrahedronGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TetrahedronGeometry", function() { return _TetrahedronGeometry_js__WEBPACK_IMPORTED_MODULE_16__["TetrahedronGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TetrahedronBufferGeometry", function() { return _TetrahedronGeometry_js__WEBPACK_IMPORTED_MODULE_16__["TetrahedronBufferGeometry"]; });

/* harmony import */ var _TextGeometry_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./TextGeometry.js */ "../../node_modules/three/src/geometries/TextGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextGeometry", function() { return _TextGeometry_js__WEBPACK_IMPORTED_MODULE_17__["TextGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextBufferGeometry", function() { return _TextGeometry_js__WEBPACK_IMPORTED_MODULE_17__["TextBufferGeometry"]; });

/* harmony import */ var _TorusGeometry_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./TorusGeometry.js */ "../../node_modules/three/src/geometries/TorusGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TorusGeometry", function() { return _TorusGeometry_js__WEBPACK_IMPORTED_MODULE_18__["TorusGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TorusBufferGeometry", function() { return _TorusGeometry_js__WEBPACK_IMPORTED_MODULE_18__["TorusBufferGeometry"]; });

/* harmony import */ var _TorusKnotGeometry_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./TorusKnotGeometry.js */ "../../node_modules/three/src/geometries/TorusKnotGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TorusKnotGeometry", function() { return _TorusKnotGeometry_js__WEBPACK_IMPORTED_MODULE_19__["TorusKnotGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TorusKnotBufferGeometry", function() { return _TorusKnotGeometry_js__WEBPACK_IMPORTED_MODULE_19__["TorusKnotBufferGeometry"]; });

/* harmony import */ var _TubeGeometry_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./TubeGeometry.js */ "../../node_modules/three/src/geometries/TubeGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TubeGeometry", function() { return _TubeGeometry_js__WEBPACK_IMPORTED_MODULE_20__["TubeGeometry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TubeBufferGeometry", function() { return _TubeGeometry_js__WEBPACK_IMPORTED_MODULE_20__["TubeBufferGeometry"]; });

/* harmony import */ var _WireframeGeometry_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./WireframeGeometry.js */ "../../node_modules/three/src/geometries/WireframeGeometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WireframeGeometry", function() { return _WireframeGeometry_js__WEBPACK_IMPORTED_MODULE_21__["WireframeGeometry"]; });

























/***/ }),

/***/ "../../node_modules/three/src/geometries/IcosahedronGeometry.js":
/*!**************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/IcosahedronGeometry.js ***!
  \**************************************************************************************/
/*! exports provided: IcosahedronGeometry, IcosahedronBufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IcosahedronGeometry", function() { return IcosahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IcosahedronBufferGeometry", function() { return IcosahedronGeometry; });
/* harmony import */ var _PolyhedronGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PolyhedronGeometry.js */ "../../node_modules/three/src/geometries/PolyhedronGeometry.js");


class IcosahedronGeometry extends _PolyhedronGeometry_js__WEBPACK_IMPORTED_MODULE_0__["PolyhedronGeometry"] {

	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;

		const vertices = [
			- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
			0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
			t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
		];

		const indices = [
			0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
			1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
			3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
			4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

}





/***/ }),

/***/ "../../node_modules/three/src/geometries/LatheGeometry.js":
/*!********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/LatheGeometry.js ***!
  \********************************************************************************/
/*! exports provided: LatheGeometry, LatheBufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LatheGeometry", function() { return LatheGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LatheBufferGeometry", function() { return LatheGeometry; });
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");






class LatheGeometry extends _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_1__["BufferGeometry"] {

	constructor( points, segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {

		super();

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = Math.floor( segments );

		// clamp phiLength so it's in range of [ 0, 2PI ]

		phiLength = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_4__["MathUtils"].clamp( phiLength, 0, Math.PI * 2 );

		// buffers

		const indices = [];
		const vertices = [];
		const uvs = [];

		// helper variables

		const inverseSegments = 1.0 / segments;
		const vertex = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
		const uv = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__["Vector2"]();

		// generate vertices and uvs

		for ( let i = 0; i <= segments; i ++ ) {

			const phi = phiStart + i * inverseSegments * phiLength;

			const sin = Math.sin( phi );
			const cos = Math.cos( phi );

			for ( let j = 0; j <= ( points.length - 1 ); j ++ ) {

				// vertex

				vertex.x = points[ j ].x * sin;
				vertex.y = points[ j ].y;
				vertex.z = points[ j ].x * cos;

				vertices.push( vertex.x, vertex.y, vertex.z );

				// uv

				uv.x = i / segments;
				uv.y = j / ( points.length - 1 );

				uvs.push( uv.x, uv.y );


			}

		}

		// indices

		for ( let i = 0; i < segments; i ++ ) {

			for ( let j = 0; j < ( points.length - 1 ); j ++ ) {

				const base = j + i * points.length;

				const a = base;
				const b = base + points.length;
				const c = base + points.length + 1;
				const d = base + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"]( vertices, 3 ) );
		this.setAttribute( 'uv', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"]( uvs, 2 ) );

		// generate normals

		this.computeVertexNormals();

		// if the geometry is closed, we need to average the normals along the seam.
		// because the corresponding vertices are identical (but still have different UVs).

		if ( phiLength === Math.PI * 2 ) {

			const normals = this.attributes.normal.array;
			const n1 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
			const n2 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
			const n = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

			// this is the buffer offset for the last line of vertices

			const base = segments * points.length * 3;

			for ( let i = 0, j = 0; i < points.length; i ++, j += 3 ) {

				// select the normal of the vertex in the first line

				n1.x = normals[ j + 0 ];
				n1.y = normals[ j + 1 ];
				n1.z = normals[ j + 2 ];

				// select the normal of the vertex in the last line

				n2.x = normals[ base + j + 0 ];
				n2.y = normals[ base + j + 1 ];
				n2.z = normals[ base + j + 2 ];

				// average normals

				n.addVectors( n1, n2 ).normalize();

				// assign the new values to both normals

				normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
				normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
				normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

			}

		}

	}

}





/***/ }),

/***/ "../../node_modules/three/src/geometries/OctahedronGeometry.js":
/*!*************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/OctahedronGeometry.js ***!
  \*************************************************************************************/
/*! exports provided: OctahedronGeometry, OctahedronBufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OctahedronGeometry", function() { return OctahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OctahedronBufferGeometry", function() { return OctahedronGeometry; });
/* harmony import */ var _PolyhedronGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PolyhedronGeometry.js */ "../../node_modules/three/src/geometries/PolyhedronGeometry.js");


class OctahedronGeometry extends _PolyhedronGeometry_js__WEBPACK_IMPORTED_MODULE_0__["PolyhedronGeometry"] {

	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
			0, - 1, 0, 	0, 0, 1,	0, 0, - 1
		];

		const indices = [
			0, 2, 4,	0, 4, 3,	0, 3, 5,
			0, 5, 2,	1, 2, 5,	1, 5, 3,
			1, 3, 4,	1, 4, 2
		];

		super( vertices, indices, radius, detail );

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

}




/***/ }),

/***/ "../../node_modules/three/src/geometries/ParametricGeometry.js":
/*!*************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/ParametricGeometry.js ***!
  \*************************************************************************************/
/*! exports provided: ParametricGeometry, ParametricBufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParametricGeometry", function() { return ParametricGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParametricBufferGeometry", function() { return ParametricGeometry; });
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/**
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
 */





function ParametricGeometry( func, slices, stacks ) {

	_core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"].call( this );

	this.type = 'ParametricGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	// buffers

	const indices = [];
	const vertices = [];
	const normals = [];
	const uvs = [];

	const EPS = 0.00001;

	const normal = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

	const p0 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"](), p1 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
	const pu = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"](), pv = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

	if ( func.length < 3 ) {

		console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );

	}

	// generate vertices, normals and uvs

	const sliceCount = slices + 1;

	for ( let i = 0; i <= stacks; i ++ ) {

		const v = i / stacks;

		for ( let j = 0; j <= slices; j ++ ) {

			const u = j / slices;

			// vertex

			func( u, v, p0 );
			vertices.push( p0.x, p0.y, p0.z );

			// normal

			// approximate tangent vectors via finite differences

			if ( u - EPS >= 0 ) {

				func( u - EPS, v, p1 );
				pu.subVectors( p0, p1 );

			} else {

				func( u + EPS, v, p1 );
				pu.subVectors( p1, p0 );

			}

			if ( v - EPS >= 0 ) {

				func( u, v - EPS, p1 );
				pv.subVectors( p0, p1 );

			} else {

				func( u, v + EPS, p1 );
				pv.subVectors( p1, p0 );

			}

			// cross product of tangent vectors returns surface normal

			normal.crossVectors( pu, pv ).normalize();
			normals.push( normal.x, normal.y, normal.z );

			// uv

			uvs.push( u, v );

		}

	}

	// generate indices

	for ( let i = 0; i < stacks; i ++ ) {

		for ( let j = 0; j < slices; j ++ ) {

			const a = i * sliceCount + j;
			const b = i * sliceCount + j + 1;
			const c = ( i + 1 ) * sliceCount + j + 1;
			const d = ( i + 1 ) * sliceCount + j;

			// faces one and two

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( vertices, 3 ) );
	this.setAttribute( 'normal', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( normals, 3 ) );
	this.setAttribute( 'uv', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( uvs, 2 ) );

}

ParametricGeometry.prototype = Object.create( _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"].prototype );
ParametricGeometry.prototype.constructor = ParametricGeometry;





/***/ }),

/***/ "../../node_modules/three/src/geometries/PlaneGeometry.js":
/*!********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/PlaneGeometry.js ***!
  \********************************************************************************/
/*! exports provided: PlaneGeometry, PlaneBufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneGeometry", function() { return PlaneGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneBufferGeometry", function() { return PlaneGeometry; });
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");



class PlaneGeometry extends _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"] {

	constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

		super();
		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		const width_half = width / 2;
		const height_half = height / 2;

		const gridX = Math.floor( widthSegments );
		const gridY = Math.floor( heightSegments );

		const gridX1 = gridX + 1;
		const gridY1 = gridY + 1;

		const segment_width = width / gridX;
		const segment_height = height / gridY;

		//

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		for ( let iy = 0; iy < gridY1; iy ++ ) {

			const y = iy * segment_height - height_half;

			for ( let ix = 0; ix < gridX1; ix ++ ) {

				const x = ix * segment_width - width_half;

				vertices.push( x, - y, 0 );

				normals.push( 0, 0, 1 );

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

			}

		}

		for ( let iy = 0; iy < gridY; iy ++ ) {

			for ( let ix = 0; ix < gridX; ix ++ ) {

				const a = ix + gridX1 * iy;
				const b = ix + gridX1 * ( iy + 1 );
				const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				const d = ( ix + 1 ) + gridX1 * iy;

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		this.setIndex( indices );
		this.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( vertices, 3 ) );
		this.setAttribute( 'normal', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( normals, 3 ) );
		this.setAttribute( 'uv', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( uvs, 2 ) );

	}

}




/***/ }),

/***/ "../../node_modules/three/src/geometries/PolyhedronGeometry.js":
/*!*************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/PolyhedronGeometry.js ***!
  \*************************************************************************************/
/*! exports provided: PolyhedronGeometry, PolyhedronBufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyhedronGeometry", function() { return PolyhedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyhedronBufferGeometry", function() { return PolyhedronGeometry; });
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");





class PolyhedronGeometry extends _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"] {

	constructor( vertices, indices, radius = 1, detail = 0 ) {

		super();

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		// default buffer data

		const vertexBuffer = [];
		const uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide( detail );

		// all vertices should lie on a conceptual sphere with a given radius

		applyRadius( radius );

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( vertexBuffer, 3 ) );
		this.setAttribute( 'normal', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( vertexBuffer.slice(), 3 ) );
		this.setAttribute( 'uv', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( uvBuffer, 2 ) );

		if ( detail === 0 ) {

			this.computeVertexNormals(); // flat normals

		} else {

			this.normalizeNormals(); // smooth normals

		}

		// helper functions

		function subdivide( detail ) {

			const a = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
			const b = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
			const c = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

			// iterate over all faces and apply a subdivison with the given detail value

			for ( let i = 0; i < indices.length; i += 3 ) {

				// get the vertices of the face

				getVertexByIndex( indices[ i + 0 ], a );
				getVertexByIndex( indices[ i + 1 ], b );
				getVertexByIndex( indices[ i + 2 ], c );

				// perform subdivision

				subdivideFace( a, b, c, detail );

			}

		}

		function subdivideFace( a, b, c, detail ) {

			const cols = detail + 1;

			// we use this multidimensional array as a data structure for creating the subdivision

			const v = [];

			// construct all of the vertices for this subdivision

			for ( let i = 0; i <= cols; i ++ ) {

				v[ i ] = [];

				const aj = a.clone().lerp( c, i / cols );
				const bj = b.clone().lerp( c, i / cols );

				const rows = cols - i;

				for ( let j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

					}

				}

			}

			// construct all of the faces

			for ( let i = 0; i < cols; i ++ ) {

				for ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					const k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
						pushVertex( v[ i ][ k ] );

					} else {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );

					}

				}

			}

		}

		function applyRadius( radius ) {

			const vertex = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

			// iterate over the entire buffer and apply the radius to each vertex

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				vertex.normalize().multiplyScalar( radius );

				vertexBuffer[ i + 0 ] = vertex.x;
				vertexBuffer[ i + 1 ] = vertex.y;
				vertexBuffer[ i + 2 ] = vertex.z;

			}

		}

		function generateUVs() {

			const vertex = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				const u = azimuth( vertex ) / 2 / Math.PI + 0.5;
				const v = inclination( vertex ) / Math.PI + 0.5;
				uvBuffer.push( u, 1 - v );

			}

			correctUVs();

			correctSeam();

		}

		function correctSeam() {

			// handle case when face straddles the seam, see #3269

			for ( let i = 0; i < uvBuffer.length; i += 6 ) {

				// uv data of a single face

				const x0 = uvBuffer[ i + 0 ];
				const x1 = uvBuffer[ i + 2 ];
				const x2 = uvBuffer[ i + 4 ];

				const max = Math.max( x0, x1, x2 );
				const min = Math.min( x0, x1, x2 );

				// 0.9 is somewhat arbitrary

				if ( max > 0.9 && min < 0.1 ) {

					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

				}

			}

		}

		function pushVertex( vertex ) {

			vertexBuffer.push( vertex.x, vertex.y, vertex.z );

		}

		function getVertexByIndex( index, vertex ) {

			const stride = index * 3;

			vertex.x = vertices[ stride + 0 ];
			vertex.y = vertices[ stride + 1 ];
			vertex.z = vertices[ stride + 2 ];

		}

		function correctUVs() {

			const a = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
			const b = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
			const c = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

			const centroid = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

			const uvA = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__["Vector2"]();
			const uvB = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__["Vector2"]();
			const uvC = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__["Vector2"]();

			for ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

				const azi = azimuth( centroid );

				correctUV( uvA, j + 0, a, azi );
				correctUV( uvB, j + 2, b, azi );
				correctUV( uvC, j + 4, c, azi );

			}

		}

		function correctUV( uv, stride, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

				uvBuffer[ stride ] = uv.x - 1;

			}

			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

			}

		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}

	}

}




/***/ }),

/***/ "../../node_modules/three/src/geometries/RingGeometry.js":
/*!*******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/RingGeometry.js ***!
  \*******************************************************************************/
/*! exports provided: RingGeometry, RingBufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RingGeometry", function() { return RingGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RingBufferGeometry", function() { return RingGeometry; });
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");





class RingGeometry extends _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"] {

	constructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		thetaSegments = Math.max( 3, thetaSegments );
		phiSegments = Math.max( 1, phiSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// some helper variables

		let radius = innerRadius;
		const radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
		const vertex = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();
		const uv = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= phiSegments; j ++ ) {

			for ( let i = 0; i <= thetaSegments; i ++ ) {

				// values are generate from the inside of the ring to the outside

				const segment = thetaStart + i / thetaSegments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uv

				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
				uv.y = ( vertex.y / outerRadius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// increase the radius for next row of vertices

			radius += radiusStep;

		}

		// indices

		for ( let j = 0; j < phiSegments; j ++ ) {

			const thetaSegmentLevel = j * ( thetaSegments + 1 );

			for ( let i = 0; i < thetaSegments; i ++ ) {

				const segment = i + thetaSegmentLevel;

				const a = segment;
				const b = segment + thetaSegments + 1;
				const c = segment + thetaSegments + 2;
				const d = segment + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( vertices, 3 ) );
		this.setAttribute( 'normal', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( normals, 3 ) );
		this.setAttribute( 'uv', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( uvs, 2 ) );

	}

}





/***/ }),

/***/ "../../node_modules/three/src/geometries/ShapeGeometry.js":
/*!********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/ShapeGeometry.js ***!
  \********************************************************************************/
/*! exports provided: ShapeGeometry, ShapeBufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeGeometry", function() { return ShapeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeBufferGeometry", function() { return ShapeGeometry; });
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _extras_ShapeUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extras/ShapeUtils.js */ "../../node_modules/three/src/extras/ShapeUtils.js");




class ShapeGeometry extends _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"] {

	constructor( shapes, curveSegments = 12 ) {

		super();
		this.type = 'ShapeGeometry';

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let groupStart = 0;
		let groupCount = 0;

		// allow single and array values for "shapes" parameter

		if ( Array.isArray( shapes ) === false ) {

			addShape( shapes );

		} else {

			for ( let i = 0; i < shapes.length; i ++ ) {

				addShape( shapes[ i ] );

				this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

				groupStart += groupCount;
				groupCount = 0;

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( vertices, 3 ) );
		this.setAttribute( 'normal', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( normals, 3 ) );
		this.setAttribute( 'uv', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( uvs, 2 ) );


		// helper functions

		function addShape( shape ) {

			const indexOffset = vertices.length / 3;
			const points = shape.extractPoints( curveSegments );

			let shapeVertices = points.shape;
			const shapeHoles = points.holes;

			// check direction of vertices

			if ( _extras_ShapeUtils_js__WEBPACK_IMPORTED_MODULE_2__["ShapeUtils"].isClockWise( shapeVertices ) === false ) {

				shapeVertices = shapeVertices.reverse();

			}

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];

				if ( _extras_ShapeUtils_js__WEBPACK_IMPORTED_MODULE_2__["ShapeUtils"].isClockWise( shapeHole ) === true ) {

					shapeHoles[ i ] = shapeHole.reverse();

				}

			}

			const faces = _extras_ShapeUtils_js__WEBPACK_IMPORTED_MODULE_2__["ShapeUtils"].triangulateShape( shapeVertices, shapeHoles );

			// join vertices of inner and outer paths to a single array

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];
				shapeVertices = shapeVertices.concat( shapeHole );

			}

			// vertices, normals, uvs

			for ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {

				const vertex = shapeVertices[ i ];

				vertices.push( vertex.x, vertex.y, 0 );
				normals.push( 0, 0, 1 );
				uvs.push( vertex.x, vertex.y ); // world uvs

			}

			// incides

			for ( let i = 0, l = faces.length; i < l; i ++ ) {

				const face = faces[ i ];

				const a = face[ 0 ] + indexOffset;
				const b = face[ 1 ] + indexOffset;
				const c = face[ 2 ] + indexOffset;

				indices.push( a, b, c );
				groupCount += 3;

			}

		}

	}

	toJSON() {

		const data = _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"].prototype.toJSON.call( this );

		const shapes = this.parameters.shapes;

		return toJSON( shapes, data );

	}

}

function toJSON( shapes, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	return data;

}




/***/ }),

/***/ "../../node_modules/three/src/geometries/SphereGeometry.js":
/*!*********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/SphereGeometry.js ***!
  \*********************************************************************************/
/*! exports provided: SphereGeometry, SphereBufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphereGeometry", function() { return SphereGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphereBufferGeometry", function() { return SphereGeometry; });
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");




class SphereGeometry extends _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"] {

	constructor( radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

		super();
		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		widthSegments = Math.max( 3, Math.floor( widthSegments ) );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) );

		const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

		let index = 0;
		const grid = [];

		const vertex = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
		const normal = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// generate vertices, normals and uvs

		for ( let iy = 0; iy <= heightSegments; iy ++ ) {

			const verticesRow = [];

			const v = iy / heightSegments;

			// special case for the poles

			let uOffset = 0;

			if ( iy == 0 && thetaStart == 0 ) {

				uOffset = 0.5 / widthSegments;

			} else if ( iy == heightSegments && thetaEnd == Math.PI ) {

				uOffset = - 0.5 / widthSegments;

			}

			for ( let ix = 0; ix <= widthSegments; ix ++ ) {

				const u = ix / widthSegments;

				// vertex

				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.copy( vertex ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u + uOffset, 1 - v );

				verticesRow.push( index ++ );

			}

			grid.push( verticesRow );

		}

		// indices

		for ( let iy = 0; iy < heightSegments; iy ++ ) {

			for ( let ix = 0; ix < widthSegments; ix ++ ) {

				const a = grid[ iy ][ ix + 1 ];
				const b = grid[ iy ][ ix ];
				const c = grid[ iy + 1 ][ ix ];
				const d = grid[ iy + 1 ][ ix + 1 ];

				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( vertices, 3 ) );
		this.setAttribute( 'normal', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( normals, 3 ) );
		this.setAttribute( 'uv', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( uvs, 2 ) );

	}

}




/***/ }),

/***/ "../../node_modules/three/src/geometries/TetrahedronGeometry.js":
/*!**************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/TetrahedronGeometry.js ***!
  \**************************************************************************************/
/*! exports provided: TetrahedronGeometry, TetrahedronBufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TetrahedronGeometry", function() { return TetrahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TetrahedronBufferGeometry", function() { return TetrahedronGeometry; });
/* harmony import */ var _PolyhedronGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PolyhedronGeometry.js */ "../../node_modules/three/src/geometries/PolyhedronGeometry.js");


class TetrahedronGeometry extends _PolyhedronGeometry_js__WEBPACK_IMPORTED_MODULE_0__["PolyhedronGeometry"] {

	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
		];

		const indices = [
			2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

}




/***/ }),

/***/ "../../node_modules/three/src/geometries/TextGeometry.js":
/*!*******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/TextGeometry.js ***!
  \*******************************************************************************/
/*! exports provided: TextGeometry, TextBufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextGeometry", function() { return TextGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextBufferGeometry", function() { return TextGeometry; });
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _ExtrudeGeometry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExtrudeGeometry.js */ "../../node_modules/three/src/geometries/ExtrudeGeometry.js");
/**
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */




class TextGeometry extends _ExtrudeGeometry_js__WEBPACK_IMPORTED_MODULE_1__["ExtrudeGeometry"] {

	constructor( text, parameters = {} ) {

		const font = parameters.font;

		if ( ! ( font && font.isFont ) ) {

			console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
			return new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]();

		}

		const shapes = font.generateShapes( text, parameters.size );

		// translate parameters to ExtrudeGeometry API

		parameters.depth = parameters.height !== undefined ? parameters.height : 50;

		// defaults

		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

		super( shapes, parameters );

		this.type = 'TextGeometry';

	}

}





/***/ }),

/***/ "../../node_modules/three/src/geometries/TorusGeometry.js":
/*!********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/TorusGeometry.js ***!
  \********************************************************************************/
/*! exports provided: TorusGeometry, TorusBufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusGeometry", function() { return TorusGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusBufferGeometry", function() { return TorusGeometry; });
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");




class TorusGeometry extends _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"] {

	constructor( radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2 ) {

		super();
		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radialSegments = Math.floor( radialSegments );
		tubularSegments = Math.floor( tubularSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const center = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
		const vertex = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
		const normal = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= radialSegments; j ++ ) {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				const u = i / tubularSegments * arc;
				const v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
				normal.subVectors( vertex, center ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= radialSegments; j ++ ) {

			for ( let i = 1; i <= tubularSegments; i ++ ) {

				// indices

				const a = ( tubularSegments + 1 ) * j + i - 1;
				const b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				const c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				const d = ( tubularSegments + 1 ) * j + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( vertices, 3 ) );
		this.setAttribute( 'normal', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( normals, 3 ) );
		this.setAttribute( 'uv', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( uvs, 2 ) );

	}

}




/***/ }),

/***/ "../../node_modules/three/src/geometries/TorusKnotGeometry.js":
/*!************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/TorusKnotGeometry.js ***!
  \************************************************************************************/
/*! exports provided: TorusKnotGeometry, TorusKnotBufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusKnotGeometry", function() { return TorusKnotGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusKnotBufferGeometry", function() { return TorusKnotGeometry; });
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");




class TorusKnotGeometry extends _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"] {

	constructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {

		super();
		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		tubularSegments = Math.floor( tubularSegments );
		radialSegments = Math.floor( radialSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
		const normal = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

		const P1 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
		const P2 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

		const B = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
		const T = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
		const N = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

		// generate vertices, normals and uvs

		for ( let i = 0; i <= tubularSegments; ++ i ) {

			// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

			const u = i / tubularSegments * p * Math.PI * 2;

			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

			calculatePositionOnCurve( u, p, q, radius, P1 );
			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

			// calculate orthonormal basis

			T.subVectors( P2, P1 );
			N.addVectors( P2, P1 );
			B.crossVectors( T, N );
			N.crossVectors( B, T );

			// normalize B, N. T can be ignored, we don't use it

			B.normalize();
			N.normalize();

			for ( let j = 0; j <= radialSegments; ++ j ) {

				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

				const v = j / radialSegments * Math.PI * 2;
				const cx = - tube * Math.cos( v );
				const cy = tube * Math.sin( v );

				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

				vertex.x = P1.x + ( cx * N.x + cy * B.x );
				vertex.y = P1.y + ( cx * N.y + cy * B.y );
				vertex.z = P1.z + ( cx * N.z + cy * B.z );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

				normal.subVectors( vertex, P1 ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= tubularSegments; j ++ ) {

			for ( let i = 1; i <= radialSegments; i ++ ) {

				// indices

				const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				const b = ( radialSegments + 1 ) * j + ( i - 1 );
				const c = ( radialSegments + 1 ) * j + i;
				const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( vertices, 3 ) );
		this.setAttribute( 'normal', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( normals, 3 ) );
		this.setAttribute( 'uv', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( uvs, 2 ) );

		// this function calculates the current position on the torus curve

		function calculatePositionOnCurve( u, p, q, radius, position ) {

			const cu = Math.cos( u );
			const su = Math.sin( u );
			const quOverP = q / p * u;
			const cs = Math.cos( quOverP );

			position.x = radius * ( 2 + cs ) * 0.5 * cu;
			position.y = radius * ( 2 + cs ) * su * 0.5;
			position.z = radius * Math.sin( quOverP ) * 0.5;

		}

	}

}




/***/ }),

/***/ "../../node_modules/three/src/geometries/TubeGeometry.js":
/*!*******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/TubeGeometry.js ***!
  \*******************************************************************************/
/*! exports provided: TubeGeometry, TubeBufferGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TubeGeometry", function() { return TubeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TubeBufferGeometry", function() { return TubeGeometry; });
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");





class TubeGeometry extends _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"] {

	constructor( path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {

		super();
		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		const frames = path.computeFrenetFrames( tubularSegments, closed );

		// expose internals

		this.tangents = frames.tangents;
		this.normals = frames.normals;
		this.binormals = frames.binormals;

		// helper variables

		const vertex = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();
		const normal = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();
		const uv = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]();
		let P = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();

		// buffer

		const vertices = [];
		const normals = [];
		const uvs = [];
		const indices = [];

		// create buffer data

		generateBufferData();

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( vertices, 3 ) );
		this.setAttribute( 'normal', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( normals, 3 ) );
		this.setAttribute( 'uv', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( uvs, 2 ) );

		// functions

		function generateBufferData() {

			for ( let i = 0; i < tubularSegments; i ++ ) {

				generateSegment( i );

			}

			// if the geometry is not closed, generate the last row of vertices and normals
			// at the regular position on the given path
			//
			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

			generateSegment( ( closed === false ) ? tubularSegments : 0 );

			// uvs are generated in a separate function.
			// this makes it easy compute correct values for closed geometries

			generateUVs();

			// finally create faces

			generateIndices();

		}

		function generateSegment( i ) {

			// we use getPointAt to sample evenly distributed points from the given path

			P = path.getPointAt( i / tubularSegments, P );

			// retrieve corresponding normal and binormal

			const N = frames.normals[ i ];
			const B = frames.binormals[ i ];

			// generate normals and vertices for the current segment

			for ( let j = 0; j <= radialSegments; j ++ ) {

				const v = j / radialSegments * Math.PI * 2;

				const sin = Math.sin( v );
				const cos = - Math.cos( v );

				// normal

				normal.x = ( cos * N.x + sin * B.x );
				normal.y = ( cos * N.y + sin * B.y );
				normal.z = ( cos * N.z + sin * B.z );
				normal.normalize();

				normals.push( normal.x, normal.y, normal.z );

				// vertex

				vertex.x = P.x + radius * normal.x;
				vertex.y = P.y + radius * normal.y;
				vertex.z = P.z + radius * normal.z;

				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		function generateIndices() {

			for ( let j = 1; j <= tubularSegments; j ++ ) {

				for ( let i = 1; i <= radialSegments; i ++ ) {

					const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					const b = ( radialSegments + 1 ) * j + ( i - 1 );
					const c = ( radialSegments + 1 ) * j + i;
					const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

		}

		function generateUVs() {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				for ( let j = 0; j <= radialSegments; j ++ ) {

					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;

					uvs.push( uv.x, uv.y );

				}

			}

		}

	}
	toJSON() {

		const data = _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"].prototype.toJSON.call( this );

		data.path = this.parameters.path.toJSON();

		return data;

	}

}





/***/ }),

/***/ "../../node_modules/three/src/geometries/WireframeGeometry.js":
/*!************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/geometries/WireframeGeometry.js ***!
  \************************************************************************************/
/*! exports provided: WireframeGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireframeGeometry", function() { return WireframeGeometry; });
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");




class WireframeGeometry extends _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"] {

	constructor( geometry ) {

		super();
		this.type = 'WireframeGeometry';

		if ( geometry.isGeometry === true ) {

			console.error( 'THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );
			return;

		}

		// buffer

		const vertices = [];

		// helper variables

		const edge = [ 0, 0 ], edges = {};

		const vertex = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

		if ( geometry.index !== null ) {

			// indexed BufferGeometry

			const position = geometry.attributes.position;
			const indices = geometry.index;
			let groups = geometry.groups;

			if ( groups.length === 0 ) {

				groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

			}

			// create a data structure that contains all eges without duplicates

			for ( let o = 0, ol = groups.length; o < ol; ++ o ) {

				const group = groups[ o ];

				const start = group.start;
				const count = group.count;

				for ( let i = start, l = ( start + count ); i < l; i += 3 ) {

					for ( let j = 0; j < 3; j ++ ) {

						const edge1 = indices.getX( i + j );
						const edge2 = indices.getX( i + ( j + 1 ) % 3 );
						edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
						edge[ 1 ] = Math.max( edge1, edge2 );

						const key = edge[ 0 ] + ',' + edge[ 1 ];

						if ( edges[ key ] === undefined ) {

							edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

						}

					}

				}

			}

			// generate vertices

			for ( const key in edges ) {

				const e = edges[ key ];

				vertex.fromBufferAttribute( position, e.index1 );
				vertices.push( vertex.x, vertex.y, vertex.z );

				vertex.fromBufferAttribute( position, e.index2 );
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		} else {

			// non-indexed BufferGeometry

			const position = geometry.attributes.position;

			for ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

				for ( let j = 0; j < 3; j ++ ) {

					// three edges per triangle, an edge is represented as (index1, index2)
					// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

					const index1 = 3 * i + j;
					vertex.fromBufferAttribute( position, index1 );
					vertices.push( vertex.x, vertex.y, vertex.z );

					const index2 = 3 * i + ( ( j + 1 ) % 3 );
					vertex.fromBufferAttribute( position, index2 );
					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			}

		}

		// build geometry

		this.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]( vertices, 3 ) );

	}

}





/***/ }),

/***/ "../../node_modules/three/src/helpers/ArrowHelper.js":
/*!***************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/helpers/ArrowHelper.js ***!
  \***************************************************************************/
/*! exports provided: ArrowHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrowHelper", function() { return ArrowHelper; });
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");
/* harmony import */ var _geometries_CylinderGeometry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geometries/CylinderGeometry.js */ "../../node_modules/three/src/geometries/CylinderGeometry.js");
/* harmony import */ var _materials_MeshBasicMaterial_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../materials/MeshBasicMaterial.js */ "../../node_modules/three/src/materials/MeshBasicMaterial.js");
/* harmony import */ var _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../materials/LineBasicMaterial.js */ "../../node_modules/three/src/materials/LineBasicMaterial.js");
/* harmony import */ var _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../objects/Mesh.js */ "../../node_modules/three/src/objects/Mesh.js");
/* harmony import */ var _objects_Line_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../objects/Line.js */ "../../node_modules/three/src/objects/Line.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");










const _axis = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"]();
let _lineGeometry, _coneGeometry;

class ArrowHelper extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_2__["Object3D"] {

	// dir is assumed to be normalized

	constructor( dir = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"]( 0, 0, 1 ), origin = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"]( 0, 0, 0 ), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

		super();

		this.type = 'ArrowHelper';

		if ( _lineGeometry === undefined ) {

			_lineGeometry = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_1__["BufferGeometry"]();
			_lineGeometry.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0__["Float32BufferAttribute"]( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

			_coneGeometry = new _geometries_CylinderGeometry_js__WEBPACK_IMPORTED_MODULE_3__["CylinderGeometry"]( 0, 0.5, 1, 5, 1 );
			_coneGeometry.translate( 0, - 0.5, 0 );

		}

		this.position.copy( origin );

		this.line = new _objects_Line_js__WEBPACK_IMPORTED_MODULE_7__["Line"]( _lineGeometry, new _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_5__["LineBasicMaterial"]( { color: color, toneMapped: false } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		this.cone = new _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_6__["Mesh"]( _coneGeometry, new _materials_MeshBasicMaterial_js__WEBPACK_IMPORTED_MODULE_4__["MeshBasicMaterial"]( { color: color, toneMapped: false } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

	setDirection( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			_axis.set( dir.z, 0, - dir.x ).normalize();

			const radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( _axis, radians );

		}

	}

	setLength( length, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

		this.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458
		this.line.updateMatrix();

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	}

	setColor( color ) {

		this.line.material.color.set( color );
		this.cone.material.color.set( color );

	}

	copy( source ) {

		super.copy( source, false );

		this.line.copy( source.line );
		this.cone.copy( source.cone );

		return this;

	}

}





/***/ }),

/***/ "../../node_modules/three/src/helpers/AxesHelper.js":
/*!**************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/helpers/AxesHelper.js ***!
  \**************************************************************************/
/*! exports provided: AxesHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxesHelper", function() { return AxesHelper; });
/* harmony import */ var _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../objects/LineSegments.js */ "../../node_modules/three/src/objects/LineSegments.js");
/* harmony import */ var _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../materials/LineBasicMaterial.js */ "../../node_modules/three/src/materials/LineBasicMaterial.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");





class AxesHelper extends _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_0__["LineSegments"] {

	constructor( size = 1 ) {

		const vertices = [
			0, 0, 0,	size, 0, 0,
			0, 0, 0,	0, size, 0,
			0, 0, 0,	0, 0, size
		];

		const colors = [
			1, 0, 0,	1, 0.6, 0,
			0, 1, 0,	0.6, 1, 0,
			0, 0, 1,	0, 0.6, 1
		];

		const geometry = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_3__["BufferGeometry"]();
		geometry.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__["Float32BufferAttribute"]( vertices, 3 ) );
		geometry.setAttribute( 'color', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__["Float32BufferAttribute"]( colors, 3 ) );

		const material = new _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_1__["LineBasicMaterial"]( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'AxesHelper';

	}

}





/***/ }),

/***/ "../../node_modules/three/src/helpers/Box3Helper.js":
/*!**************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/helpers/Box3Helper.js ***!
  \**************************************************************************/
/*! exports provided: Box3Helper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box3Helper", function() { return Box3Helper; });
/* harmony import */ var _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../objects/LineSegments.js */ "../../node_modules/three/src/objects/LineSegments.js");
/* harmony import */ var _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../materials/LineBasicMaterial.js */ "../../node_modules/three/src/materials/LineBasicMaterial.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");






class Box3Helper extends _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_0__["LineSegments"] {

	constructor( box, color = 0xffff00 ) {

		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

		const positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

		const geometry = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_3__["BufferGeometry"]();

		geometry.setIndex( new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__["BufferAttribute"]( indices, 1 ) );

		geometry.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__["Float32BufferAttribute"]( positions, 3 ) );

		super( geometry, new _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_1__["LineBasicMaterial"]( { color: color, toneMapped: false } ) );

		this.box = box;

		this.type = 'Box3Helper';

		this.geometry.computeBoundingSphere();

	}

	updateMatrixWorld( force ) {

		const box = this.box;

		if ( box.isEmpty() ) return;

		box.getCenter( this.position );

		box.getSize( this.scale );

		this.scale.multiplyScalar( 0.5 );

		super.updateMatrixWorld( force );

	}

}




/***/ }),

/***/ "../../node_modules/three/src/helpers/BoxHelper.js":
/*!*************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/helpers/BoxHelper.js ***!
  \*************************************************************************/
/*! exports provided: BoxHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxHelper", function() { return BoxHelper; });
/* harmony import */ var _math_Box3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Box3.js */ "../../node_modules/three/src/math/Box3.js");
/* harmony import */ var _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../objects/LineSegments.js */ "../../node_modules/three/src/objects/LineSegments.js");
/* harmony import */ var _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../materials/LineBasicMaterial.js */ "../../node_modules/three/src/materials/LineBasicMaterial.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");






const _box = /*@__PURE__*/ new _math_Box3_js__WEBPACK_IMPORTED_MODULE_0__["Box3"]();

class BoxHelper extends _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_1__["LineSegments"] {

	constructor( object, color = 0xffff00 ) {

		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		const positions = new Float32Array( 8 * 3 );

		const geometry = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_4__["BufferGeometry"]();
		geometry.setIndex( new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_3__["BufferAttribute"]( indices, 1 ) );
		geometry.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_3__["BufferAttribute"]( positions, 3 ) );

		super( geometry, new _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_2__["LineBasicMaterial"]( { color: color, toneMapped: false } ) );

		this.object = object;
		this.type = 'BoxHelper';

		this.matrixAutoUpdate = false;

		this.update();

	}

	update( object ) {

		if ( object !== undefined ) {

			console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

		}

		if ( this.object !== undefined ) {

			_box.setFromObject( this.object );

		}

		if ( _box.isEmpty() ) return;

		const min = _box.min;
		const max = _box.max;

		/*
			5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		const position = this.geometry.attributes.position;
		const array = position.array;

		array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
		array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
		array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
		array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

		position.needsUpdate = true;

		this.geometry.computeBoundingSphere();


	}

	setFromObject( object ) {

		this.object = object;
		this.update();

		return this;

	}

	copy( source ) {

		_objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_1__["LineSegments"].prototype.copy.call( this, source );

		this.object = source.object;

		return this;

	}

}





/***/ }),

/***/ "../../node_modules/three/src/helpers/CameraHelper.js":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/helpers/CameraHelper.js ***!
  \****************************************************************************/
/*! exports provided: CameraHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CameraHelper", function() { return CameraHelper; });
/* harmony import */ var _cameras_Camera_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cameras/Camera.js */ "../../node_modules/three/src/cameras/Camera.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../objects/LineSegments.js */ "../../node_modules/three/src/objects/LineSegments.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");
/* harmony import */ var _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../materials/LineBasicMaterial.js */ "../../node_modules/three/src/materials/LineBasicMaterial.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");








const _vector = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
const _camera = /*@__PURE__*/ new _cameras_Camera_js__WEBPACK_IMPORTED_MODULE_0__["Camera"]();

/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

class CameraHelper extends _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_2__["LineSegments"] {

	constructor( camera ) {

		const geometry = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__["BufferGeometry"]();
		const material = new _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_4__["LineBasicMaterial"]( { color: 0xffffff, vertexColors: true, toneMapped: false } );

		const vertices = [];
		const colors = [];

		const pointMap = {};

		// colors

		const colorFrustum = new _math_Color_js__WEBPACK_IMPORTED_MODULE_3__["Color"]( 0xffaa00 );
		const colorCone = new _math_Color_js__WEBPACK_IMPORTED_MODULE_3__["Color"]( 0xff0000 );
		const colorUp = new _math_Color_js__WEBPACK_IMPORTED_MODULE_3__["Color"]( 0x00aaff );
		const colorTarget = new _math_Color_js__WEBPACK_IMPORTED_MODULE_3__["Color"]( 0xffffff );
		const colorCross = new _math_Color_js__WEBPACK_IMPORTED_MODULE_3__["Color"]( 0x333333 );

		// near

		addLine( 'n1', 'n2', colorFrustum );
		addLine( 'n2', 'n4', colorFrustum );
		addLine( 'n4', 'n3', colorFrustum );
		addLine( 'n3', 'n1', colorFrustum );

		// far

		addLine( 'f1', 'f2', colorFrustum );
		addLine( 'f2', 'f4', colorFrustum );
		addLine( 'f4', 'f3', colorFrustum );
		addLine( 'f3', 'f1', colorFrustum );

		// sides

		addLine( 'n1', 'f1', colorFrustum );
		addLine( 'n2', 'f2', colorFrustum );
		addLine( 'n3', 'f3', colorFrustum );
		addLine( 'n4', 'f4', colorFrustum );

		// cone

		addLine( 'p', 'n1', colorCone );
		addLine( 'p', 'n2', colorCone );
		addLine( 'p', 'n3', colorCone );
		addLine( 'p', 'n4', colorCone );

		// up

		addLine( 'u1', 'u2', colorUp );
		addLine( 'u2', 'u3', colorUp );
		addLine( 'u3', 'u1', colorUp );

		// target

		addLine( 'c', 't', colorTarget );
		addLine( 'p', 'c', colorCross );

		// cross

		addLine( 'cn1', 'cn2', colorCross );
		addLine( 'cn3', 'cn4', colorCross );

		addLine( 'cf1', 'cf2', colorCross );
		addLine( 'cf3', 'cf4', colorCross );

		function addLine( a, b, color ) {

			addPoint( a, color );
			addPoint( b, color );

		}

		function addPoint( id, color ) {

			vertices.push( 0, 0, 0 );
			colors.push( color.r, color.g, color.b );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

		}

		geometry.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_6__["Float32BufferAttribute"]( vertices, 3 ) );
		geometry.setAttribute( 'color', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_6__["Float32BufferAttribute"]( colors, 3 ) );

		super( geometry, material );

		this.type = 'CameraHelper';

		this.camera = camera;
		if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

	}

	update() {

		const geometry = this.geometry;
		const pointMap = this.pointMap;

		const w = 1, h = 1;

		// we need just camera projection matrix inverse
		// world matrix must be identity

		_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );

		// center / target

		setPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );
		setPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );

		// near

		setPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );
		setPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );
		setPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );
		setPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );

		// far

		setPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );
		setPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );
		setPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );
		setPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );

		// up

		setPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );
		setPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );
		setPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );

		// cross

		setPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );
		setPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );
		setPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );
		setPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );

		setPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );
		setPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );
		setPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );
		setPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );

		geometry.getAttribute( 'position' ).needsUpdate = true;

	}

}


function setPoint( point, pointMap, geometry, camera, x, y, z ) {

	_vector.set( x, y, z ).unproject( camera );

	const points = pointMap[ point ];

	if ( points !== undefined ) {

		const position = geometry.getAttribute( 'position' );

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			position.setXYZ( points[ i ], _vector.x, _vector.y, _vector.z );

		}

	}

}




/***/ }),

/***/ "../../node_modules/three/src/helpers/DirectionalLightHelper.js":
/*!**************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/helpers/DirectionalLightHelper.js ***!
  \**************************************************************************************/
/*! exports provided: DirectionalLightHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLightHelper", function() { return DirectionalLightHelper; });
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");
/* harmony import */ var _objects_Line_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../objects/Line.js */ "../../node_modules/three/src/objects/Line.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../materials/LineBasicMaterial.js */ "../../node_modules/three/src/materials/LineBasicMaterial.js");







const _v1 = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _v2 = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _v3 = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

class DirectionalLightHelper extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_1__["Object3D"] {

	constructor( light, size, color ) {

		super();
		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		if ( size === undefined ) size = 1;

		let geometry = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_4__["BufferGeometry"]();
		geometry.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_3__["Float32BufferAttribute"]( [
			- size, size, 0,
			size, size, 0,
			size, - size, 0,
			- size, - size, 0,
			- size, size, 0
		], 3 ) );

		const material = new _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_5__["LineBasicMaterial"]( { fog: false, toneMapped: false } );

		this.lightPlane = new _objects_Line_js__WEBPACK_IMPORTED_MODULE_2__["Line"]( geometry, material );
		this.add( this.lightPlane );

		geometry = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_4__["BufferGeometry"]();
		geometry.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_3__["Float32BufferAttribute"]( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

		this.targetLine = new _objects_Line_js__WEBPACK_IMPORTED_MODULE_2__["Line"]( geometry, material );
		this.add( this.targetLine );

		this.update();

	}

	dispose() {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();

	}

	update() {

		_v1.setFromMatrixPosition( this.light.matrixWorld );
		_v2.setFromMatrixPosition( this.light.target.matrixWorld );
		_v3.subVectors( _v2, _v1 );

		this.lightPlane.lookAt( _v2 );

		if ( this.color !== undefined ) {

			this.lightPlane.material.color.set( this.color );
			this.targetLine.material.color.set( this.color );

		} else {

			this.lightPlane.material.color.copy( this.light.color );
			this.targetLine.material.color.copy( this.light.color );

		}

		this.targetLine.lookAt( _v2 );
		this.targetLine.scale.z = _v3.length();

	}

}





/***/ }),

/***/ "../../node_modules/three/src/helpers/GridHelper.js":
/*!**************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/helpers/GridHelper.js ***!
  \**************************************************************************/
/*! exports provided: GridHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridHelper", function() { return GridHelper; });
/* harmony import */ var _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../objects/LineSegments.js */ "../../node_modules/three/src/objects/LineSegments.js");
/* harmony import */ var _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../materials/LineBasicMaterial.js */ "../../node_modules/three/src/materials/LineBasicMaterial.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");






class GridHelper extends _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_0__["LineSegments"] {

	constructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {

		color1 = new _math_Color_js__WEBPACK_IMPORTED_MODULE_4__["Color"]( color1 );
		color2 = new _math_Color_js__WEBPACK_IMPORTED_MODULE_4__["Color"]( color2 );

		const center = divisions / 2;
		const step = size / divisions;
		const halfSize = size / 2;

		const vertices = [], colors = [];

		for ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

			vertices.push( - halfSize, 0, k, halfSize, 0, k );
			vertices.push( k, 0, - halfSize, k, 0, halfSize );

			const color = i === center ? color1 : color2;

			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;

		}

		const geometry = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_3__["BufferGeometry"]();
		geometry.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__["Float32BufferAttribute"]( vertices, 3 ) );
		geometry.setAttribute( 'color', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__["Float32BufferAttribute"]( colors, 3 ) );

		const material = new _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_1__["LineBasicMaterial"]( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'GridHelper';

	}

}





/***/ }),

/***/ "../../node_modules/three/src/helpers/HemisphereLightHelper.js":
/*!*************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/helpers/HemisphereLightHelper.js ***!
  \*************************************************************************************/
/*! exports provided: HemisphereLightHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLightHelper", function() { return HemisphereLightHelper; });
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");
/* harmony import */ var _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../objects/Mesh.js */ "../../node_modules/three/src/objects/Mesh.js");
/* harmony import */ var _materials_MeshBasicMaterial_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../materials/MeshBasicMaterial.js */ "../../node_modules/three/src/materials/MeshBasicMaterial.js");
/* harmony import */ var _geometries_OctahedronGeometry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geometries/OctahedronGeometry.js */ "../../node_modules/three/src/geometries/OctahedronGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");








const _vector = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _color1 = /*@__PURE__*/ new _math_Color_js__WEBPACK_IMPORTED_MODULE_1__["Color"]();
const _color2 = /*@__PURE__*/ new _math_Color_js__WEBPACK_IMPORTED_MODULE_1__["Color"]();

class HemisphereLightHelper extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_2__["Object3D"] {

	constructor( light, size, color ) {

		super();
		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		const geometry = new _geometries_OctahedronGeometry_js__WEBPACK_IMPORTED_MODULE_5__["OctahedronGeometry"]( size );
		geometry.rotateY( Math.PI * 0.5 );

		this.material = new _materials_MeshBasicMaterial_js__WEBPACK_IMPORTED_MODULE_4__["MeshBasicMaterial"]( { wireframe: true, fog: false, toneMapped: false } );
		if ( this.color === undefined ) this.material.vertexColors = true;

		const position = geometry.getAttribute( 'position' );
		const colors = new Float32Array( position.count * 3 );

		geometry.setAttribute( 'color', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_6__["BufferAttribute"]( colors, 3 ) );

		this.add( new _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_3__["Mesh"]( geometry, this.material ) );

		this.update();

	}

	dispose() {

		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	}

	update() {

		const mesh = this.children[ 0 ];

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			const colors = mesh.geometry.getAttribute( 'color' );

			_color1.copy( this.light.color );
			_color2.copy( this.light.groundColor );

			for ( let i = 0, l = colors.count; i < l; i ++ ) {

				const color = ( i < ( l / 2 ) ) ? _color1 : _color2;

				colors.setXYZ( i, color.r, color.g, color.b );

			}

			colors.needsUpdate = true;

		}

		mesh.lookAt( _vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );

	}

}





/***/ }),

/***/ "../../node_modules/three/src/helpers/PlaneHelper.js":
/*!***************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/helpers/PlaneHelper.js ***!
  \***************************************************************************/
/*! exports provided: PlaneHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneHelper", function() { return PlaneHelper; });
/* harmony import */ var _objects_Line_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../objects/Line.js */ "../../node_modules/three/src/objects/Line.js");
/* harmony import */ var _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../objects/Mesh.js */ "../../node_modules/three/src/objects/Mesh.js");
/* harmony import */ var _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../materials/LineBasicMaterial.js */ "../../node_modules/three/src/materials/LineBasicMaterial.js");
/* harmony import */ var _materials_MeshBasicMaterial_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../materials/MeshBasicMaterial.js */ "../../node_modules/three/src/materials/MeshBasicMaterial.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");








class PlaneHelper extends _objects_Line_js__WEBPACK_IMPORTED_MODULE_0__["Line"] {

	constructor( plane, size = 1, hex = 0xffff00 ) {

		const color = hex;

		const positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];

		const geometry = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__["BufferGeometry"]();
		geometry.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["Float32BufferAttribute"]( positions, 3 ) );
		geometry.computeBoundingSphere();

		super( geometry, new _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_2__["LineBasicMaterial"]( { color: color, toneMapped: false } ) );

		this.type = 'PlaneHelper';

		this.plane = plane;

		this.size = size;

		const positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];

		const geometry2 = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__["BufferGeometry"]();
		geometry2.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["Float32BufferAttribute"]( positions2, 3 ) );
		geometry2.computeBoundingSphere();

		this.add( new _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_1__["Mesh"]( geometry2, new _materials_MeshBasicMaterial_js__WEBPACK_IMPORTED_MODULE_3__["MeshBasicMaterial"]( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );

	}

	updateMatrixWorld( force ) {

		let scale = - this.plane.constant;

		if ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter

		this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );

		this.children[ 0 ].material.side = ( scale < 0 ) ? _constants_js__WEBPACK_IMPORTED_MODULE_6__["BackSide"] : _constants_js__WEBPACK_IMPORTED_MODULE_6__["FrontSide"]; // renderer flips side when determinant < 0; flipping not wanted here

		this.lookAt( this.plane.normal );

		super.updateMatrixWorld( force );

	}

}




/***/ }),

/***/ "../../node_modules/three/src/helpers/PointLightHelper.js":
/*!********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/helpers/PointLightHelper.js ***!
  \********************************************************************************/
/*! exports provided: PointLightHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLightHelper", function() { return PointLightHelper; });
/* harmony import */ var _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../objects/Mesh.js */ "../../node_modules/three/src/objects/Mesh.js");
/* harmony import */ var _materials_MeshBasicMaterial_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../materials/MeshBasicMaterial.js */ "../../node_modules/three/src/materials/MeshBasicMaterial.js");
/* harmony import */ var _geometries_SphereGeometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometries/SphereGeometry.js */ "../../node_modules/three/src/geometries/SphereGeometry.js");




class PointLightHelper extends _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_0__["Mesh"] {

	constructor( light, sphereSize, color ) {

		const geometry = new _geometries_SphereGeometry_js__WEBPACK_IMPORTED_MODULE_2__["SphereGeometry"]( sphereSize, 4, 2 );
		const material = new _materials_MeshBasicMaterial_js__WEBPACK_IMPORTED_MODULE_1__["MeshBasicMaterial"]( { wireframe: true, fog: false, toneMapped: false } );

		super( geometry, material );

		this.light = light;
		this.light.updateMatrixWorld();

		this.color = color;

		this.type = 'PointLightHelper';

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();


		/*
	// TODO: delete this comment?
	const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
	const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	const d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

	update() {

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			this.material.color.copy( this.light.color );

		}

		/*
		const d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	}

}





/***/ }),

/***/ "../../node_modules/three/src/helpers/PolarGridHelper.js":
/*!*******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/helpers/PolarGridHelper.js ***!
  \*******************************************************************************/
/*! exports provided: PolarGridHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolarGridHelper", function() { return PolarGridHelper; });
/* harmony import */ var _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../objects/LineSegments.js */ "../../node_modules/three/src/objects/LineSegments.js");
/* harmony import */ var _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../materials/LineBasicMaterial.js */ "../../node_modules/three/src/materials/LineBasicMaterial.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");






class PolarGridHelper extends _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_0__["LineSegments"] {

	constructor( radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888 ) {

		color1 = new _math_Color_js__WEBPACK_IMPORTED_MODULE_4__["Color"]( color1 );
		color2 = new _math_Color_js__WEBPACK_IMPORTED_MODULE_4__["Color"]( color2 );

		const vertices = [];
		const colors = [];

		// create the radials

		for ( let i = 0; i <= radials; i ++ ) {

			const v = ( i / radials ) * ( Math.PI * 2 );

			const x = Math.sin( v ) * radius;
			const z = Math.cos( v ) * radius;

			vertices.push( 0, 0, 0 );
			vertices.push( x, 0, z );

			const color = ( i & 1 ) ? color1 : color2;

			colors.push( color.r, color.g, color.b );
			colors.push( color.r, color.g, color.b );

		}

		// create the circles

		for ( let i = 0; i <= circles; i ++ ) {

			const color = ( i & 1 ) ? color1 : color2;

			const r = radius - ( radius / circles * i );

			for ( let j = 0; j < divisions; j ++ ) {

				// first vertex

				let v = ( j / divisions ) * ( Math.PI * 2 );

				let x = Math.sin( v ) * r;
				let z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

				// second vertex

				v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

			}

		}

		const geometry = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_3__["BufferGeometry"]();
		geometry.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__["Float32BufferAttribute"]( vertices, 3 ) );
		geometry.setAttribute( 'color', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__["Float32BufferAttribute"]( colors, 3 ) );

		const material = new _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_1__["LineBasicMaterial"]( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'PolarGridHelper';

	}

}





/***/ }),

/***/ "../../node_modules/three/src/helpers/SkeletonHelper.js":
/*!******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/helpers/SkeletonHelper.js ***!
  \******************************************************************************/
/*! exports provided: SkeletonHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkeletonHelper", function() { return SkeletonHelper; });
/* harmony import */ var _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../objects/LineSegments.js */ "../../node_modules/three/src/objects/LineSegments.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Matrix4.js */ "../../node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../materials/LineBasicMaterial.js */ "../../node_modules/three/src/materials/LineBasicMaterial.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");








const _vector = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
const _boneMatrix = /*@__PURE__*/ new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
const _matrixWorldInv = /*@__PURE__*/ new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();


class SkeletonHelper extends _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_0__["LineSegments"] {

	constructor( object ) {

		const bones = getBoneList( object );

		const geometry = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__["BufferGeometry"]();

		const vertices = [];
		const colors = [];

		const color1 = new _math_Color_js__WEBPACK_IMPORTED_MODULE_3__["Color"]( 0, 0, 1 );
		const color2 = new _math_Color_js__WEBPACK_IMPORTED_MODULE_3__["Color"]( 0, 1, 0 );

		for ( let i = 0; i < bones.length; i ++ ) {

			const bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				vertices.push( 0, 0, 0 );
				vertices.push( 0, 0, 0 );
				colors.push( color1.r, color1.g, color1.b );
				colors.push( color2.r, color2.g, color2.b );

			}

		}

		geometry.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_6__["Float32BufferAttribute"]( vertices, 3 ) );
		geometry.setAttribute( 'color', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_6__["Float32BufferAttribute"]( colors, 3 ) );

		const material = new _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_2__["LineBasicMaterial"]( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );

		super( geometry, material );

		this.type = 'SkeletonHelper';
		this.isSkeletonHelper = true;

		this.root = object;
		this.bones = bones;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	}

	updateMatrixWorld( force ) {

		const bones = this.bones;

		const geometry = this.geometry;
		const position = geometry.getAttribute( 'position' );

		_matrixWorldInv.copy( this.root.matrixWorld ).invert();

		for ( let i = 0, j = 0; i < bones.length; i ++ ) {

			const bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );
				_vector.setFromMatrixPosition( _boneMatrix );
				position.setXYZ( j, _vector.x, _vector.y, _vector.z );

				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );
				_vector.setFromMatrixPosition( _boneMatrix );
				position.setXYZ( j + 1, _vector.x, _vector.y, _vector.z );

				j += 2;

			}

		}

		geometry.getAttribute( 'position' ).needsUpdate = true;

		super.updateMatrixWorld( force );

	}

}


function getBoneList( object ) {

	const boneList = [];

	if ( object && object.isBone ) {

		boneList.push( object );

	}

	for ( let i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

	}

	return boneList;

}





/***/ }),

/***/ "../../node_modules/three/src/helpers/SpotLightHelper.js":
/*!*******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/helpers/SpotLightHelper.js ***!
  \*******************************************************************************/
/*! exports provided: SpotLightHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLightHelper", function() { return SpotLightHelper; });
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");
/* harmony import */ var _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../objects/LineSegments.js */ "../../node_modules/three/src/objects/LineSegments.js");
/* harmony import */ var _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../materials/LineBasicMaterial.js */ "../../node_modules/three/src/materials/LineBasicMaterial.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");







const _vector = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

class SpotLightHelper extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_1__["Object3D"] {

	constructor( light, color ) {

		super();
		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		const geometry = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__["BufferGeometry"]();

		const positions = [
			0, 0, 0, 	0, 0, 1,
			0, 0, 0, 	1, 0, 1,
			0, 0, 0,	- 1, 0, 1,
			0, 0, 0, 	0, 1, 1,
			0, 0, 0, 	0, - 1, 1
		];

		for ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

			const p1 = ( i / l ) * Math.PI * 2;
			const p2 = ( j / l ) * Math.PI * 2;

			positions.push(
				Math.cos( p1 ), Math.sin( p1 ), 1,
				Math.cos( p2 ), Math.sin( p2 ), 1
			);

		}

		geometry.setAttribute( 'position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["Float32BufferAttribute"]( positions, 3 ) );

		const material = new _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_3__["LineBasicMaterial"]( { fog: false, toneMapped: false } );

		this.cone = new _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_2__["LineSegments"]( geometry, material );
		this.add( this.cone );

		this.update();

	}

	dispose() {

		this.cone.geometry.dispose();
		this.cone.material.dispose();

	}

	update() {

		this.light.updateMatrixWorld();

		const coneLength = this.light.distance ? this.light.distance : 1000;
		const coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		_vector.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( _vector );

		if ( this.color !== undefined ) {

			this.cone.material.color.set( this.color );

		} else {

			this.cone.material.color.copy( this.light.color );

		}

	}

}





/***/ }),

/***/ "../../node_modules/three/src/lights/AmbientLight.js":
/*!***************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/lights/AmbientLight.js ***!
  \***************************************************************************/
/*! exports provided: AmbientLight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AmbientLight", function() { return AmbientLight; });
/* harmony import */ var _Light_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Light.js */ "../../node_modules/three/src/lights/Light.js");


class AmbientLight extends _Light_js__WEBPACK_IMPORTED_MODULE_0__["Light"] {

	constructor( color, intensity ) {

		super( color, intensity );

		this.type = 'AmbientLight';

	}

}

AmbientLight.prototype.isAmbientLight = true;




/***/ }),

/***/ "../../node_modules/three/src/lights/AmbientLightProbe.js":
/*!********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/lights/AmbientLightProbe.js ***!
  \********************************************************************************/
/*! exports provided: AmbientLightProbe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AmbientLightProbe", function() { return AmbientLightProbe; });
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");
/* harmony import */ var _LightProbe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LightProbe.js */ "../../node_modules/three/src/lights/LightProbe.js");



class AmbientLightProbe extends _LightProbe_js__WEBPACK_IMPORTED_MODULE_1__["LightProbe"] {

	constructor( color, intensity = 1 ) {

		super( undefined, intensity );

		const color1 = new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"]().set( color );

		// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
		this.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );

	}

}

AmbientLightProbe.prototype.isAmbientLightProbe = true;




/***/ }),

/***/ "../../node_modules/three/src/lights/DirectionalLight.js":
/*!*******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/lights/DirectionalLight.js ***!
  \*******************************************************************************/
/*! exports provided: DirectionalLight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLight", function() { return DirectionalLight; });
/* harmony import */ var _Light_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Light.js */ "../../node_modules/three/src/lights/Light.js");
/* harmony import */ var _DirectionalLightShadow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DirectionalLightShadow.js */ "../../node_modules/three/src/lights/DirectionalLightShadow.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");




class DirectionalLight extends _Light_js__WEBPACK_IMPORTED_MODULE_0__["Light"] {

	constructor( color, intensity ) {

		super( color, intensity );

		this.type = 'DirectionalLight';

		this.position.copy( _core_Object3D_js__WEBPACK_IMPORTED_MODULE_2__["Object3D"].DefaultUp );
		this.updateMatrix();

		this.target = new _core_Object3D_js__WEBPACK_IMPORTED_MODULE_2__["Object3D"]();

		this.shadow = new _DirectionalLightShadow_js__WEBPACK_IMPORTED_MODULE_1__["DirectionalLightShadow"]();

	}

	copy( source ) {

		super.copy( source );

		this.target = source.target.clone();
		this.shadow = source.shadow.clone();

		return this;

	}

}

DirectionalLight.prototype.isDirectionalLight = true;




/***/ }),

/***/ "../../node_modules/three/src/lights/DirectionalLightShadow.js":
/*!*************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/lights/DirectionalLightShadow.js ***!
  \*************************************************************************************/
/*! exports provided: DirectionalLightShadow */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLightShadow", function() { return DirectionalLightShadow; });
/* harmony import */ var _LightShadow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LightShadow.js */ "../../node_modules/three/src/lights/LightShadow.js");
/* harmony import */ var _cameras_OrthographicCamera_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cameras/OrthographicCamera.js */ "../../node_modules/three/src/cameras/OrthographicCamera.js");



class DirectionalLightShadow extends _LightShadow_js__WEBPACK_IMPORTED_MODULE_0__["LightShadow"] {

	constructor() {

		super( new _cameras_OrthographicCamera_js__WEBPACK_IMPORTED_MODULE_1__["OrthographicCamera"]( - 5, 5, 5, - 5, 0.5, 500 ) );

	}

}

DirectionalLightShadow.prototype.isDirectionalLightShadow = true;




/***/ }),

/***/ "../../node_modules/three/src/lights/HemisphereLight.js":
/*!******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/lights/HemisphereLight.js ***!
  \******************************************************************************/
/*! exports provided: HemisphereLight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLight", function() { return HemisphereLight; });
/* harmony import */ var _Light_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Light.js */ "../../node_modules/three/src/lights/Light.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");




class HemisphereLight extends _Light_js__WEBPACK_IMPORTED_MODULE_0__["Light"] {

	constructor( skyColor, groundColor, intensity ) {

		super( skyColor, intensity );

		this.type = 'HemisphereLight';

		this.position.copy( _core_Object3D_js__WEBPACK_IMPORTED_MODULE_2__["Object3D"].DefaultUp );
		this.updateMatrix();

		this.groundColor = new _math_Color_js__WEBPACK_IMPORTED_MODULE_1__["Color"]( groundColor );

	}

	copy( source ) {

		_Light_js__WEBPACK_IMPORTED_MODULE_0__["Light"].prototype.copy.call( this, source );

		this.groundColor.copy( source.groundColor );

		return this;

	}

}

HemisphereLight.prototype.isHemisphereLight = true;




/***/ }),

/***/ "../../node_modules/three/src/lights/HemisphereLightProbe.js":
/*!***********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/lights/HemisphereLightProbe.js ***!
  \***********************************************************************************/
/*! exports provided: HemisphereLightProbe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLightProbe", function() { return HemisphereLightProbe; });
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _LightProbe_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LightProbe.js */ "../../node_modules/three/src/lights/LightProbe.js");




class HemisphereLightProbe extends _LightProbe_js__WEBPACK_IMPORTED_MODULE_2__["LightProbe"] {

	constructor( skyColor, groundColor, intensity = 1 ) {

		super( undefined, intensity );

		const color1 = new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"]().set( skyColor );
		const color2 = new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"]().set( groundColor );

		const sky = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( color1.r, color1.g, color1.b );
		const ground = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( color2.r, color2.g, color2.b );

		// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
		const c0 = Math.sqrt( Math.PI );
		const c1 = c0 * Math.sqrt( 0.75 );

		this.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );
		this.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );

	}

}

HemisphereLightProbe.prototype.isHemisphereLightProbe = true;




/***/ }),

/***/ "../../node_modules/three/src/lights/Light.js":
/*!********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/lights/Light.js ***!
  \********************************************************************/
/*! exports provided: Light */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Light", function() { return Light; });
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");



class Light extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__["Object3D"] {

	constructor( color, intensity = 1 ) {

		super();

		this.type = 'Light';

		this.color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_1__["Color"]( color );
		this.intensity = intensity;

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );
		this.intensity = source.intensity;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

		return data;

	}

}

Light.prototype.isLight = true;




/***/ }),

/***/ "../../node_modules/three/src/lights/LightProbe.js":
/*!*************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/lights/LightProbe.js ***!
  \*************************************************************************/
/*! exports provided: LightProbe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LightProbe", function() { return LightProbe; });
/* harmony import */ var _math_SphericalHarmonics3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/SphericalHarmonics3.js */ "../../node_modules/three/src/math/SphericalHarmonics3.js");
/* harmony import */ var _Light_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Light.js */ "../../node_modules/three/src/lights/Light.js");



class LightProbe extends _Light_js__WEBPACK_IMPORTED_MODULE_1__["Light"] {

	constructor( sh = new _math_SphericalHarmonics3_js__WEBPACK_IMPORTED_MODULE_0__["SphericalHarmonics3"](), intensity = 1 ) {

		super( undefined, intensity );

		this.sh = sh;

	}

	copy( source ) {

		super.copy( source );

		this.sh.copy( source.sh );

		return this;

	}

	fromJSON( json ) {

		this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
		this.sh.fromArray( json.sh );

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.sh = this.sh.toArray();

		return data;

	}

}

LightProbe.prototype.isLightProbe = true;




/***/ }),

/***/ "../../node_modules/three/src/lights/LightShadow.js":
/*!**************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/lights/LightShadow.js ***!
  \**************************************************************************/
/*! exports provided: LightShadow */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LightShadow", function() { return LightShadow; });
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Matrix4.js */ "../../node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Vector4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector4.js */ "../../node_modules/three/src/math/Vector4.js");
/* harmony import */ var _math_Frustum_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Frustum.js */ "../../node_modules/three/src/math/Frustum.js");






const _projScreenMatrix = /*@__PURE__*/ new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
const _lightPositionWorld = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
const _lookTarget = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

class LightShadow {

	constructor( camera ) {

		this.camera = camera;

		this.bias = 0;
		this.normalBias = 0;
		this.radius = 1;

		this.mapSize = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"]( 512, 512 );

		this.map = null;
		this.mapPass = null;
		this.matrix = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();

		this.autoUpdate = true;
		this.needsUpdate = false;

		this._frustum = new _math_Frustum_js__WEBPACK_IMPORTED_MODULE_4__["Frustum"]();
		this._frameExtents = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"]( 1, 1 );

		this._viewportCount = 1;

		this._viewports = [

			new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_3__["Vector4"]( 0, 0, 1, 1 )

		];

	}

	getViewportCount() {

		return this._viewportCount;

	}

	getFrustum() {

		return this._frustum;

	}

	updateMatrices( light ) {

		const shadowCamera = this.camera;
		const shadowMatrix = this.matrix;

		_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
		shadowCamera.position.copy( _lightPositionWorld );

		_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
		shadowCamera.lookAt( _lookTarget );
		shadowCamera.updateMatrixWorld();

		_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix );

		shadowMatrix.set(
			0.5, 0.0, 0.0, 0.5,
			0.0, 0.5, 0.0, 0.5,
			0.0, 0.0, 0.5, 0.5,
			0.0, 0.0, 0.0, 1.0
		);

		shadowMatrix.multiply( shadowCamera.projectionMatrix );
		shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

	}

	getViewport( viewportIndex ) {

		return this._viewports[ viewportIndex ];

	}

	getFrameExtents() {

		return this._frameExtents;

	}

	copy( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.radius = source.radius;

		this.mapSize.copy( source.mapSize );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	toJSON() {

		const object = {};

		if ( this.bias !== 0 ) object.bias = this.bias;
		if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
		if ( this.radius !== 1 ) object.radius = this.radius;
		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

		object.camera = this.camera.toJSON( false ).object;
		delete object.camera.matrix;

		return object;

	}

}




/***/ }),

/***/ "../../node_modules/three/src/lights/PointLight.js":
/*!*************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/lights/PointLight.js ***!
  \*************************************************************************/
/*! exports provided: PointLight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLight", function() { return PointLight; });
/* harmony import */ var _Light_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Light.js */ "../../node_modules/three/src/lights/Light.js");
/* harmony import */ var _PointLightShadow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PointLightShadow.js */ "../../node_modules/three/src/lights/PointLightShadow.js");



class PointLight extends _Light_js__WEBPACK_IMPORTED_MODULE_0__["Light"] {

	constructor( color, intensity, distance = 0, decay = 1 ) {

		super( color, intensity );

		this.type = 'PointLight';

		this.distance = distance;
		this.decay = decay; // for physically correct lights, should be 2.

		this.shadow = new _PointLightShadow_js__WEBPACK_IMPORTED_MODULE_1__["PointLightShadow"]();

	}

	get power() {

		// intensity = power per solid angle.
		// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		return this.intensity * 4 * Math.PI;

	}

	set power( power ) {

		// intensity = power per solid angle.
		// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		this.intensity = power / ( 4 * Math.PI );

	}

	copy( source ) {

		super.copy( source );

		this.distance = source.distance;
		this.decay = source.decay;

		this.shadow = source.shadow.clone();

		return this;

	}

}

PointLight.prototype.isPointLight = true;




/***/ }),

/***/ "../../node_modules/three/src/lights/PointLightShadow.js":
/*!*******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/lights/PointLightShadow.js ***!
  \*******************************************************************************/
/*! exports provided: PointLightShadow */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLightShadow", function() { return PointLightShadow; });
/* harmony import */ var _LightShadow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LightShadow.js */ "../../node_modules/three/src/lights/LightShadow.js");
/* harmony import */ var _cameras_PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cameras/PerspectiveCamera.js */ "../../node_modules/three/src/cameras/PerspectiveCamera.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Matrix4.js */ "../../node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Vector4_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/Vector4.js */ "../../node_modules/three/src/math/Vector4.js");







const _projScreenMatrix = /*@__PURE__*/ new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();
const _lightPositionWorld = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
const _lookTarget = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();

class PointLightShadow extends _LightShadow_js__WEBPACK_IMPORTED_MODULE_0__["LightShadow"] {

	constructor() {

		super( new _cameras_PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_1__["PerspectiveCamera"]( 90, 1, 0.5, 500 ) );

		this._frameExtents = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__["Vector2"]( 4, 2 );

		this._viewportCount = 6;

		this._viewports = [
			// These viewports map a cube-map onto a 2D texture with the
			// following orientation:
			//
			//  xzXZ
			//   y Y
			//
			// X - Positive x direction
			// x - Negative x direction
			// Y - Positive y direction
			// y - Negative y direction
			// Z - Positive z direction
			// z - Negative z direction

			// positive X
			new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_5__["Vector4"]( 2, 1, 1, 1 ),
			// negative X
			new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_5__["Vector4"]( 0, 1, 1, 1 ),
			// positive Z
			new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_5__["Vector4"]( 3, 1, 1, 1 ),
			// negative Z
			new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_5__["Vector4"]( 1, 1, 1, 1 ),
			// positive Y
			new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_5__["Vector4"]( 3, 0, 1, 1 ),
			// negative Y
			new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_5__["Vector4"]( 1, 0, 1, 1 )
		];

		this._cubeDirections = [
			new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]( 1, 0, 0 ), new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]( - 1, 0, 0 ), new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]( 0, 0, 1 ),
			new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]( 0, 0, - 1 ), new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]( 0, 1, 0 ), new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]( 0, - 1, 0 )
		];

		this._cubeUps = [
			new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]( 0, 1, 0 ), new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]( 0, 1, 0 ), new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]( 0, 1, 0 ),
			new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]( 0, 1, 0 ), new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]( 0, 0, 1 ),	new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]( 0, 0, - 1 )
		];

	}

	updateMatrices( light, viewportIndex = 0 ) {

		const camera = this.camera;
		const shadowMatrix = this.matrix;

		const far = light.distance || camera.far;

		if ( far !== camera.far ) {

			camera.far = far;
			camera.updateProjectionMatrix();

		}

		_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
		camera.position.copy( _lightPositionWorld );

		_lookTarget.copy( camera.position );
		_lookTarget.add( this._cubeDirections[ viewportIndex ] );
		camera.up.copy( this._cubeUps[ viewportIndex ] );
		camera.lookAt( _lookTarget );
		camera.updateMatrixWorld();

		shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix );

	}

}

PointLightShadow.prototype.isPointLightShadow = true;




/***/ }),

/***/ "../../node_modules/three/src/lights/RectAreaLight.js":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/lights/RectAreaLight.js ***!
  \****************************************************************************/
/*! exports provided: RectAreaLight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RectAreaLight", function() { return RectAreaLight; });
/* harmony import */ var _Light_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Light.js */ "../../node_modules/three/src/lights/Light.js");


class RectAreaLight extends _Light_js__WEBPACK_IMPORTED_MODULE_0__["Light"] {

	constructor( color, intensity, width = 10, height = 10 ) {

		super( color, intensity );

		this.type = 'RectAreaLight';

		this.width = width;
		this.height = height;

	}

	copy( source ) {

		super.copy( source );

		this.width = source.width;
		this.height = source.height;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.width = this.width;
		data.object.height = this.height;

		return data;

	}

}

RectAreaLight.prototype.isRectAreaLight = true;




/***/ }),

/***/ "../../node_modules/three/src/lights/SpotLight.js":
/*!************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/lights/SpotLight.js ***!
  \************************************************************************/
/*! exports provided: SpotLight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLight", function() { return SpotLight; });
/* harmony import */ var _Light_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Light.js */ "../../node_modules/three/src/lights/Light.js");
/* harmony import */ var _SpotLightShadow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SpotLightShadow.js */ "../../node_modules/three/src/lights/SpotLightShadow.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");




class SpotLight extends _Light_js__WEBPACK_IMPORTED_MODULE_0__["Light"] {

	constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1 ) {

		super( color, intensity );

		this.type = 'SpotLight';

		this.position.copy( _core_Object3D_js__WEBPACK_IMPORTED_MODULE_2__["Object3D"].DefaultUp );
		this.updateMatrix();

		this.target = new _core_Object3D_js__WEBPACK_IMPORTED_MODULE_2__["Object3D"]();

		this.distance = distance;
		this.angle = angle;
		this.penumbra = penumbra;
		this.decay = decay; // for physically correct lights, should be 2.

		this.shadow = new _SpotLightShadow_js__WEBPACK_IMPORTED_MODULE_1__["SpotLightShadow"]();

	}

	get power() {

		// intensity = power per solid angle.
		// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		return this.intensity * Math.PI;

	}

	set power( power ) {

		// intensity = power per solid angle.
		// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		this.intensity = power / Math.PI;

	}

	copy( source ) {

		super.copy( source );

		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

}

SpotLight.prototype.isSpotLight = true;




/***/ }),

/***/ "../../node_modules/three/src/lights/SpotLightShadow.js":
/*!******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/lights/SpotLightShadow.js ***!
  \******************************************************************************/
/*! exports provided: SpotLightShadow */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLightShadow", function() { return SpotLightShadow; });
/* harmony import */ var _LightShadow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LightShadow.js */ "../../node_modules/three/src/lights/LightShadow.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");
/* harmony import */ var _cameras_PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cameras/PerspectiveCamera.js */ "../../node_modules/three/src/cameras/PerspectiveCamera.js");




class SpotLightShadow extends _LightShadow_js__WEBPACK_IMPORTED_MODULE_0__["LightShadow"] {

	constructor() {

		super( new _cameras_PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__["PerspectiveCamera"]( 50, 1, 0.5, 500 ) );

		this.focus = 1;

	}

	updateMatrices( light ) {

		const camera = this.camera;

		const fov = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__["MathUtils"].RAD2DEG * 2 * light.angle * this.focus;
		const aspect = this.mapSize.width / this.mapSize.height;
		const far = light.distance || camera.far;

		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();

		}

		super.updateMatrices( light );

	}

	copy( source ) {

		super.copy( source );

		this.focus = source.focus;

		return this;

	}

}

SpotLightShadow.prototype.isSpotLightShadow = true;




/***/ }),

/***/ "../../node_modules/three/src/loaders/AnimationLoader.js":
/*!*******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/loaders/AnimationLoader.js ***!
  \*******************************************************************************/
/*! exports provided: AnimationLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationLoader", function() { return AnimationLoader; });
/* harmony import */ var _animation_AnimationClip_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../animation/AnimationClip.js */ "../../node_modules/three/src/animation/AnimationClip.js");
/* harmony import */ var _FileLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FileLoader.js */ "../../node_modules/three/src/loaders/FileLoader.js");
/* harmony import */ var _Loader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Loader.js */ "../../node_modules/three/src/loaders/Loader.js");




class AnimationLoader extends _Loader_js__WEBPACK_IMPORTED_MODULE_2__["Loader"] {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new _FileLoader_js__WEBPACK_IMPORTED_MODULE_1__["FileLoader"]( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const animations = [];

		for ( let i = 0; i < json.length; i ++ ) {

			const clip = _animation_AnimationClip_js__WEBPACK_IMPORTED_MODULE_0__["AnimationClip"].parse( json[ i ] );

			animations.push( clip );

		}

		return animations;

	}

}





/***/ }),

/***/ "../../node_modules/three/src/loaders/AudioLoader.js":
/*!***************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/loaders/AudioLoader.js ***!
  \***************************************************************************/
/*! exports provided: AudioLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioLoader", function() { return AudioLoader; });
/* harmony import */ var _audio_AudioContext_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../audio/AudioContext.js */ "../../node_modules/three/src/audio/AudioContext.js");
/* harmony import */ var _FileLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FileLoader.js */ "../../node_modules/three/src/loaders/FileLoader.js");
/* harmony import */ var _Loader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Loader.js */ "../../node_modules/three/src/loaders/Loader.js");




class AudioLoader extends _Loader_js__WEBPACK_IMPORTED_MODULE_2__["Loader"] {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new _FileLoader_js__WEBPACK_IMPORTED_MODULE_1__["FileLoader"]( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( buffer ) {

			try {

				// Create a copy of the buffer. The `decodeAudioData` method
				// detaches the buffer when complete, preventing reuse.
				const bufferCopy = buffer.slice( 0 );

				const context = _audio_AudioContext_js__WEBPACK_IMPORTED_MODULE_0__["AudioContext"].getContext();
				context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

					onLoad( audioBuffer );

				} );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

}





/***/ }),

/***/ "../../node_modules/three/src/loaders/BufferGeometryLoader.js":
/*!************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/loaders/BufferGeometryLoader.js ***!
  \************************************************************************************/
/*! exports provided: BufferGeometryLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometryLoader", function() { return BufferGeometryLoader; });
/* harmony import */ var _math_Sphere_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Sphere.js */ "../../node_modules/three/src/math/Sphere.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _FileLoader_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FileLoader.js */ "../../node_modules/three/src/loaders/FileLoader.js");
/* harmony import */ var _Loader_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Loader.js */ "../../node_modules/three/src/loaders/Loader.js");
/* harmony import */ var _core_InstancedBufferGeometry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/InstancedBufferGeometry.js */ "../../node_modules/three/src/core/InstancedBufferGeometry.js");
/* harmony import */ var _core_InstancedBufferAttribute_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/InstancedBufferAttribute.js */ "../../node_modules/three/src/core/InstancedBufferAttribute.js");
/* harmony import */ var _core_InterleavedBufferAttribute_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/InterleavedBufferAttribute.js */ "../../node_modules/three/src/core/InterleavedBufferAttribute.js");
/* harmony import */ var _core_InterleavedBuffer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../core/InterleavedBuffer.js */ "../../node_modules/three/src/core/InterleavedBuffer.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils.js */ "../../node_modules/three/src/utils.js");












class BufferGeometryLoader extends _Loader_js__WEBPACK_IMPORTED_MODULE_5__["Loader"] {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new _FileLoader_js__WEBPACK_IMPORTED_MODULE_4__["FileLoader"]( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const interleavedBufferMap = {};
		const arrayBufferMap = {};

		function getInterleavedBuffer( json, uuid ) {

			if ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];

			const interleavedBuffers = json.interleavedBuffers;
			const interleavedBuffer = interleavedBuffers[ uuid ];

			const buffer = getArrayBuffer( json, interleavedBuffer.buffer );

			const array = Object(_utils_js__WEBPACK_IMPORTED_MODULE_10__["getTypedArray"])( interleavedBuffer.type, buffer );
			const ib = new _core_InterleavedBuffer_js__WEBPACK_IMPORTED_MODULE_9__["InterleavedBuffer"]( array, interleavedBuffer.stride );
			ib.uuid = interleavedBuffer.uuid;

			interleavedBufferMap[ uuid ] = ib;

			return ib;

		}

		function getArrayBuffer( json, uuid ) {

			if ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];

			const arrayBuffers = json.arrayBuffers;
			const arrayBuffer = arrayBuffers[ uuid ];

			const ab = new Uint32Array( arrayBuffer ).buffer;

			arrayBufferMap[ uuid ] = ab;

			return ab;

		}

		const geometry = json.isInstancedBufferGeometry ? new _core_InstancedBufferGeometry_js__WEBPACK_IMPORTED_MODULE_6__["InstancedBufferGeometry"]() : new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_3__["BufferGeometry"]();

		const index = json.data.index;

		if ( index !== undefined ) {

			const typedArray = Object(_utils_js__WEBPACK_IMPORTED_MODULE_10__["getTypedArray"])( index.type, index.array );
			geometry.setIndex( new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__["BufferAttribute"]( typedArray, 1 ) );

		}

		const attributes = json.data.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];
			let bufferAttribute;

			if ( attribute.isInterleavedBufferAttribute ) {

				const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
				bufferAttribute = new _core_InterleavedBufferAttribute_js__WEBPACK_IMPORTED_MODULE_8__["InterleavedBufferAttribute"]( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

			} else {

				const typedArray = Object(_utils_js__WEBPACK_IMPORTED_MODULE_10__["getTypedArray"])( attribute.type, attribute.array );
				const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? _core_InstancedBufferAttribute_js__WEBPACK_IMPORTED_MODULE_7__["InstancedBufferAttribute"] : _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__["BufferAttribute"];
				bufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );

			}

			if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
			if ( attribute.usage !== undefined ) bufferAttribute.setUsage( attribute.usage );

			if ( attribute.updateRange !== undefined ) {

				bufferAttribute.updateRange.offset = attribute.updateRange.offset;
				bufferAttribute.updateRange.count = attribute.updateRange.count;

			}

			geometry.setAttribute( key, bufferAttribute );

		}

		const morphAttributes = json.data.morphAttributes;

		if ( morphAttributes ) {

			for ( const key in morphAttributes ) {

				const attributeArray = morphAttributes[ key ];

				const array = [];

				for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

					const attribute = attributeArray[ i ];
					let bufferAttribute;

					if ( attribute.isInterleavedBufferAttribute ) {

						const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
						bufferAttribute = new _core_InterleavedBufferAttribute_js__WEBPACK_IMPORTED_MODULE_8__["InterleavedBufferAttribute"]( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

					} else {

						const typedArray = Object(_utils_js__WEBPACK_IMPORTED_MODULE_10__["getTypedArray"])( attribute.type, attribute.array );
						bufferAttribute = new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__["BufferAttribute"]( typedArray, attribute.itemSize, attribute.normalized );

					}

					if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
					array.push( bufferAttribute );

				}

				geometry.morphAttributes[ key ] = array;

			}

		}

		const morphTargetsRelative = json.data.morphTargetsRelative;

		if ( morphTargetsRelative ) {

			geometry.morphTargetsRelative = true;

		}

		const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

		if ( groups !== undefined ) {

			for ( let i = 0, n = groups.length; i !== n; ++ i ) {

				const group = groups[ i ];

				geometry.addGroup( group.start, group.count, group.materialIndex );

			}

		}

		const boundingSphere = json.data.boundingSphere;

		if ( boundingSphere !== undefined ) {

			const center = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new _math_Sphere_js__WEBPACK_IMPORTED_MODULE_0__["Sphere"]( center, boundingSphere.radius );

		}

		if ( json.name ) geometry.name = json.name;
		if ( json.userData ) geometry.userData = json.userData;

		return geometry;

	}

}




/***/ }),

/***/ "../../node_modules/three/src/loaders/Cache.js":
/*!*********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/loaders/Cache.js ***!
  \*********************************************************************/
/*! exports provided: Cache */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cache", function() { return Cache; });
const Cache = {

	enabled: false,

	files: {},

	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {};

	}

};





/***/ }),

/***/ "../../node_modules/three/src/loaders/CompressedTextureLoader.js":
/*!***************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/loaders/CompressedTextureLoader.js ***!
  \***************************************************************************************/
/*! exports provided: CompressedTextureLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedTextureLoader", function() { return CompressedTextureLoader; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _FileLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FileLoader.js */ "../../node_modules/three/src/loaders/FileLoader.js");
/* harmony import */ var _textures_CompressedTexture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../textures/CompressedTexture.js */ "../../node_modules/three/src/textures/CompressedTexture.js");
/* harmony import */ var _Loader_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Loader.js */ "../../node_modules/three/src/loaders/Loader.js");





/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

function CompressedTextureLoader( manager ) {

	_Loader_js__WEBPACK_IMPORTED_MODULE_3__["Loader"].call( this, manager );

}

CompressedTextureLoader.prototype = Object.assign( Object.create( _Loader_js__WEBPACK_IMPORTED_MODULE_3__["Loader"].prototype ), {

	constructor: CompressedTextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		const scope = this;

		const images = [];

		const texture = new _textures_CompressedTexture_js__WEBPACK_IMPORTED_MODULE_2__["CompressedTexture"]();

		const loader = new _FileLoader_js__WEBPACK_IMPORTED_MODULE_1__["FileLoader"]( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( scope.withCredentials );

		let loaded = 0;

		function loadTexture( i ) {

			loader.load( url[ i ], function ( buffer ) {

				const texDatas = scope.parse( buffer, true );

				images[ i ] = {
					width: texDatas.width,
					height: texDatas.height,
					format: texDatas.format,
					mipmaps: texDatas.mipmaps
				};

				loaded += 1;

				if ( loaded === 6 ) {

					if ( texDatas.mipmapCount === 1 ) texture.minFilter = _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"];

					texture.image = images;
					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, onProgress, onError );

		}

		if ( Array.isArray( url ) ) {

			for ( let i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				const texDatas = scope.parse( buffer, true );

				if ( texDatas.isCubemap ) {

					const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( let f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps: [] };

						for ( let i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

					texture.image = images;

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"];

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, onProgress, onError );

		}

		return texture;

	}

} );





/***/ }),

/***/ "../../node_modules/three/src/loaders/CubeTextureLoader.js":
/*!*********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/loaders/CubeTextureLoader.js ***!
  \*********************************************************************************/
/*! exports provided: CubeTextureLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeTextureLoader", function() { return CubeTextureLoader; });
/* harmony import */ var _ImageLoader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageLoader.js */ "../../node_modules/three/src/loaders/ImageLoader.js");
/* harmony import */ var _textures_CubeTexture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../textures/CubeTexture.js */ "../../node_modules/three/src/textures/CubeTexture.js");
/* harmony import */ var _Loader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Loader.js */ "../../node_modules/three/src/loaders/Loader.js");




class CubeTextureLoader extends _Loader_js__WEBPACK_IMPORTED_MODULE_2__["Loader"] {

	constructor( manager ) {

		super( manager );

	}

	load( urls, onLoad, onProgress, onError ) {

		const texture = new _textures_CubeTexture_js__WEBPACK_IMPORTED_MODULE_1__["CubeTexture"]();

		const loader = new _ImageLoader_js__WEBPACK_IMPORTED_MODULE_0__["ImageLoader"]( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		let loaded = 0;

		function loadTexture( i ) {

			loader.load( urls[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded ++;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, undefined, onError );

		}

		for ( let i = 0; i < urls.length; ++ i ) {

			loadTexture( i );

		}

		return texture;

	}

}





/***/ }),

/***/ "../../node_modules/three/src/loaders/DataTextureLoader.js":
/*!*********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/loaders/DataTextureLoader.js ***!
  \*********************************************************************************/
/*! exports provided: DataTextureLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTextureLoader", function() { return DataTextureLoader; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _FileLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FileLoader.js */ "../../node_modules/three/src/loaders/FileLoader.js");
/* harmony import */ var _textures_DataTexture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../textures/DataTexture.js */ "../../node_modules/three/src/textures/DataTexture.js");
/* harmony import */ var _Loader_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Loader.js */ "../../node_modules/three/src/loaders/Loader.js");





/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

function DataTextureLoader( manager ) {

	_Loader_js__WEBPACK_IMPORTED_MODULE_3__["Loader"].call( this, manager );

}

DataTextureLoader.prototype = Object.assign( Object.create( _Loader_js__WEBPACK_IMPORTED_MODULE_3__["Loader"].prototype ), {

	constructor: DataTextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		const scope = this;

		const texture = new _textures_DataTexture_js__WEBPACK_IMPORTED_MODULE_2__["DataTexture"]();

		const loader = new _FileLoader_js__WEBPACK_IMPORTED_MODULE_1__["FileLoader"]( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setPath( this.path );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( buffer ) {

			const texData = scope.parse( buffer );

			if ( ! texData ) return;

			if ( texData.image !== undefined ) {

				texture.image = texData.image;

			} else if ( texData.data !== undefined ) {

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : _constants_js__WEBPACK_IMPORTED_MODULE_0__["ClampToEdgeWrapping"];
			texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : _constants_js__WEBPACK_IMPORTED_MODULE_0__["ClampToEdgeWrapping"];

			texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"];
			texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"];

			texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

			if ( texData.encoding !== undefined ) {

				texture.encoding = texData.encoding;

			}

			if ( texData.flipY !== undefined ) {

				texture.flipY = texData.flipY;

			}

			if ( texData.format !== undefined ) {

				texture.format = texData.format;

			}

			if ( texData.type !== undefined ) {

				texture.type = texData.type;

			}

			if ( texData.mipmaps !== undefined ) {

				texture.mipmaps = texData.mipmaps;
				texture.minFilter = _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearMipmapLinearFilter"]; // presumably...

			}

			if ( texData.mipmapCount === 1 ) {

				texture.minFilter = _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"];

			}

			if ( texData.generateMipmaps !== undefined ) {

				texture.generateMipmaps = texData.generateMipmaps;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	}

} );





/***/ }),

/***/ "../../node_modules/three/src/loaders/FileLoader.js":
/*!**************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/loaders/FileLoader.js ***!
  \**************************************************************************/
/*! exports provided: FileLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileLoader", function() { return FileLoader; });
/* harmony import */ var _Cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Cache.js */ "../../node_modules/three/src/loaders/Cache.js");
/* harmony import */ var _Loader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Loader.js */ "../../node_modules/three/src/loaders/Loader.js");



const loading = {};

function FileLoader( manager ) {

	_Loader_js__WEBPACK_IMPORTED_MODULE_1__["Loader"].call( this, manager );

}

FileLoader.prototype = Object.assign( Object.create( _Loader_js__WEBPACK_IMPORTED_MODULE_1__["Loader"].prototype ), {

	constructor: FileLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = _Cache_js__WEBPACK_IMPORTED_MODULE_0__["Cache"].get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		// Check if request is duplicate

		if ( loading[ url ] !== undefined ) {

			loading[ url ].push( {

				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError

			} );

			return;

		}

		// Check for data: URI
		const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
		const dataUriRegexResult = url.match( dataUriRegex );
		let request;

		// Safari can not handle Data URIs through XMLHttpRequest so process manually
		if ( dataUriRegexResult ) {

			const mimeType = dataUriRegexResult[ 1 ];
			const isBase64 = !! dataUriRegexResult[ 2 ];

			let data = dataUriRegexResult[ 3 ];
			data = decodeURIComponent( data );

			if ( isBase64 ) data = atob( data );

			try {

				let response;
				const responseType = ( this.responseType || '' ).toLowerCase();

				switch ( responseType ) {

					case 'arraybuffer':
					case 'blob':

						const view = new Uint8Array( data.length );

						for ( let i = 0; i < data.length; i ++ ) {

							view[ i ] = data.charCodeAt( i );

						}

						if ( responseType === 'blob' ) {

							response = new Blob( [ view.buffer ], { type: mimeType } );

						} else {

							response = view.buffer;

						}

						break;

					case 'document':

						const parser = new DOMParser();
						response = parser.parseFromString( data, mimeType );

						break;

					case 'json':

						response = JSON.parse( data );

						break;

					default: // 'text' or other

						response = data;

						break;

				}

				// Wait for next browser tick like standard XMLHttpRequest event dispatching does
				setTimeout( function () {

					if ( onLoad ) onLoad( response );

					scope.manager.itemEnd( url );

				}, 0 );

			} catch ( error ) {

				// Wait for next browser tick like standard XMLHttpRequest event dispatching does
				setTimeout( function () {

					if ( onError ) onError( error );

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}, 0 );

			}

		} else {

			// Initialise array for duplicate requests

			loading[ url ] = [];

			loading[ url ].push( {

				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError

			} );

			request = new XMLHttpRequest();

			request.open( 'GET', url, true );

			request.addEventListener( 'load', function ( event ) {

				const response = this.response;

				const callbacks = loading[ url ];

				delete loading[ url ];

				if ( this.status === 200 || this.status === 0 ) {

					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.

					if ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

					// Add to cache only on HTTP success, so that we do not cache
					// error response bodies as proper responses to requests.
					_Cache_js__WEBPACK_IMPORTED_MODULE_0__["Cache"].add( url, response );

					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						const callback = callbacks[ i ];
						if ( callback.onLoad ) callback.onLoad( response );

					}

					scope.manager.itemEnd( url );

				} else {

					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						const callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );

					}

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}

			}, false );

			request.addEventListener( 'progress', function ( event ) {

				const callbacks = loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onProgress ) callback.onProgress( event );

				}

			}, false );

			request.addEventListener( 'error', function ( event ) {

				const callbacks = loading[ url ];

				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( event );

				}

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}, false );

			request.addEventListener( 'abort', function ( event ) {

				const callbacks = loading[ url ];

				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( event );

				}

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}, false );

			if ( this.responseType !== undefined ) request.responseType = this.responseType;
			if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

			if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

			for ( const header in this.requestHeader ) {

				request.setRequestHeader( header, this.requestHeader[ header ] );

			}

			request.send( null );

		}

		scope.manager.itemStart( url );

		return request;

	},

	setResponseType: function ( value ) {

		this.responseType = value;
		return this;

	},

	setMimeType: function ( value ) {

		this.mimeType = value;
		return this;

	}

} );





/***/ }),

/***/ "../../node_modules/three/src/loaders/FontLoader.js":
/*!**************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/loaders/FontLoader.js ***!
  \**************************************************************************/
/*! exports provided: FontLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontLoader", function() { return FontLoader; });
/* harmony import */ var _extras_core_Font_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extras/core/Font.js */ "../../node_modules/three/src/extras/core/Font.js");
/* harmony import */ var _FileLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FileLoader.js */ "../../node_modules/three/src/loaders/FileLoader.js");
/* harmony import */ var _Loader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Loader.js */ "../../node_modules/three/src/loaders/Loader.js");




class FontLoader extends _Loader_js__WEBPACK_IMPORTED_MODULE_2__["Loader"] {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new _FileLoader_js__WEBPACK_IMPORTED_MODULE_1__["FileLoader"]( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			let json;

			try {

				json = JSON.parse( text );

			} catch ( e ) {

				console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
				json = JSON.parse( text.substring( 65, text.length - 2 ) );

			}

			const font = scope.parse( json );

			if ( onLoad ) onLoad( font );

		}, onProgress, onError );

	}

	parse( json ) {

		return new _extras_core_Font_js__WEBPACK_IMPORTED_MODULE_0__["Font"]( json );

	}

}





/***/ }),

/***/ "../../node_modules/three/src/loaders/ImageBitmapLoader.js":
/*!*********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/loaders/ImageBitmapLoader.js ***!
  \*********************************************************************************/
/*! exports provided: ImageBitmapLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageBitmapLoader", function() { return ImageBitmapLoader; });
/* harmony import */ var _Cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Cache.js */ "../../node_modules/three/src/loaders/Cache.js");
/* harmony import */ var _Loader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Loader.js */ "../../node_modules/three/src/loaders/Loader.js");



function ImageBitmapLoader( manager ) {

	if ( typeof createImageBitmap === 'undefined' ) {

		console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

	}

	if ( typeof fetch === 'undefined' ) {

		console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

	}

	_Loader_js__WEBPACK_IMPORTED_MODULE_1__["Loader"].call( this, manager );

	this.options = { premultiplyAlpha: 'none' };

}

ImageBitmapLoader.prototype = Object.assign( Object.create( _Loader_js__WEBPACK_IMPORTED_MODULE_1__["Loader"].prototype ), {

	constructor: ImageBitmapLoader,

	isImageBitmapLoader: true,

	setOptions: function setOptions( options ) {

		this.options = options;

		return this;

	},

	load: function ( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = _Cache_js__WEBPACK_IMPORTED_MODULE_0__["Cache"].get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const fetchOptions = {};
		fetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';
		fetchOptions.headers = this.requestHeader;

		fetch( url, fetchOptions ).then( function ( res ) {

			return res.blob();

		} ).then( function ( blob ) {

			return createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );

		} ).then( function ( imageBitmap ) {

			_Cache_js__WEBPACK_IMPORTED_MODULE_0__["Cache"].add( url, imageBitmap );

			if ( onLoad ) onLoad( imageBitmap );

			scope.manager.itemEnd( url );

		} ).catch( function ( e ) {

			if ( onError ) onError( e );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		} );

		scope.manager.itemStart( url );

	}

} );




/***/ }),

/***/ "../../node_modules/three/src/loaders/ImageLoader.js":
/*!***************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/loaders/ImageLoader.js ***!
  \***************************************************************************/
/*! exports provided: ImageLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageLoader", function() { return ImageLoader; });
/* harmony import */ var _Cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Cache.js */ "../../node_modules/three/src/loaders/Cache.js");
/* harmony import */ var _Loader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Loader.js */ "../../node_modules/three/src/loaders/Loader.js");



class ImageLoader extends _Loader_js__WEBPACK_IMPORTED_MODULE_1__["Loader"] {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = _Cache_js__WEBPACK_IMPORTED_MODULE_0__["Cache"].get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

		function onImageLoad() {

			image.removeEventListener( 'load', onImageLoad, false );
			image.removeEventListener( 'error', onImageError, false );

			_Cache_js__WEBPACK_IMPORTED_MODULE_0__["Cache"].add( url, this );

			if ( onLoad ) onLoad( this );

			scope.manager.itemEnd( url );

		}

		function onImageError( event ) {

			image.removeEventListener( 'load', onImageLoad, false );
			image.removeEventListener( 'error', onImageError, false );

			if ( onError ) onError( event );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		}

		image.addEventListener( 'load', onImageLoad, false );
		image.addEventListener( 'error', onImageError, false );

		if ( url.substr( 0, 5 ) !== 'data:' ) {

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		}

		scope.manager.itemStart( url );

		image.src = url;

		return image;

	}

}





/***/ }),

/***/ "../../node_modules/three/src/loaders/Loader.js":
/*!**********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/loaders/Loader.js ***!
  \**********************************************************************/
/*! exports provided: Loader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Loader", function() { return Loader; });
/* harmony import */ var _LoadingManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LoadingManager.js */ "../../node_modules/three/src/loaders/LoadingManager.js");


function Loader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : _LoadingManager_js__WEBPACK_IMPORTED_MODULE_0__["DefaultLoadingManager"];

	this.crossOrigin = 'anonymous';
	this.withCredentials = false;
	this.path = '';
	this.resourcePath = '';
	this.requestHeader = {};

}

Object.assign( Loader.prototype, {

	load: function ( /* url, onLoad, onProgress, onError */ ) {},

	loadAsync: function ( url, onProgress ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.load( url, resolve, onProgress, reject );

		} );

	},

	parse: function ( /* data */ ) {},

	setCrossOrigin: function ( crossOrigin ) {

		this.crossOrigin = crossOrigin;
		return this;

	},

	setWithCredentials: function ( value ) {

		this.withCredentials = value;
		return this;

	},

	setPath: function ( path ) {

		this.path = path;
		return this;

	},

	setResourcePath: function ( resourcePath ) {

		this.resourcePath = resourcePath;
		return this;

	},

	setRequestHeader: function ( requestHeader ) {

		this.requestHeader = requestHeader;
		return this;

	}

} );




/***/ }),

/***/ "../../node_modules/three/src/loaders/LoaderUtils.js":
/*!***************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/loaders/LoaderUtils.js ***!
  \***************************************************************************/
/*! exports provided: LoaderUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoaderUtils", function() { return LoaderUtils; });
const LoaderUtils = {

	decodeText: function ( array ) {

		if ( typeof TextDecoder !== 'undefined' ) {

			return new TextDecoder().decode( array );

		}

		// Avoid the String.fromCharCode.apply(null, array) shortcut, which
		// throws a "maximum call stack size exceeded" error for large arrays.

		let s = '';

		for ( let i = 0, il = array.length; i < il; i ++ ) {

			// Implicitly assumes little-endian.
			s += String.fromCharCode( array[ i ] );

		}

		try {

			// merges multi-byte utf-8 characters.

			return decodeURIComponent( escape( s ) );

		} catch ( e ) { // see #16358

			return s;

		}

	},

	extractUrlBase: function ( url ) {

		const index = url.lastIndexOf( '/' );

		if ( index === - 1 ) return './';

		return url.substr( 0, index + 1 );

	}

};




/***/ }),

/***/ "../../node_modules/three/src/loaders/LoadingManager.js":
/*!******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/loaders/LoadingManager.js ***!
  \******************************************************************************/
/*! exports provided: DefaultLoadingManager, LoadingManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultLoadingManager", function() { return DefaultLoadingManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoadingManager", function() { return LoadingManager; });
function LoadingManager( onLoad, onProgress, onError ) {

	const scope = this;

	let isLoading = false;
	let itemsLoaded = 0;
	let itemsTotal = 0;
	let urlModifier = undefined;
	const handlers = [];

	// Refer to #5689 for the reason why we don't set .onStart
	// in the constructor

	this.onStart = undefined;
	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		itemsTotal ++;

		if ( isLoading === false ) {

			if ( scope.onStart !== undefined ) {

				scope.onStart( url, itemsLoaded, itemsTotal );

			}

		}

		isLoading = true;

	};

	this.itemEnd = function ( url ) {

		itemsLoaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, itemsLoaded, itemsTotal );

		}

		if ( itemsLoaded === itemsTotal ) {

			isLoading = false;

			if ( scope.onLoad !== undefined ) {

				scope.onLoad();

			}

		}

	};

	this.itemError = function ( url ) {

		if ( scope.onError !== undefined ) {

			scope.onError( url );

		}

	};

	this.resolveURL = function ( url ) {

		if ( urlModifier ) {

			return urlModifier( url );

		}

		return url;

	};

	this.setURLModifier = function ( transform ) {

		urlModifier = transform;

		return this;

	};

	this.addHandler = function ( regex, loader ) {

		handlers.push( regex, loader );

		return this;

	};

	this.removeHandler = function ( regex ) {

		const index = handlers.indexOf( regex );

		if ( index !== - 1 ) {

			handlers.splice( index, 2 );

		}

		return this;

	};

	this.getHandler = function ( file ) {

		for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

			const regex = handlers[ i ];
			const loader = handlers[ i + 1 ];

			if ( regex.global ) regex.lastIndex = 0; // see #17920

			if ( regex.test( file ) ) {

				return loader;

			}

		}

		return null;

	};

}

const DefaultLoadingManager = new LoadingManager();





/***/ }),

/***/ "../../node_modules/three/src/loaders/MaterialLoader.js":
/*!******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/loaders/MaterialLoader.js ***!
  \******************************************************************************/
/*! exports provided: MaterialLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaterialLoader", function() { return MaterialLoader; });
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Vector4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector4.js */ "../../node_modules/three/src/math/Vector4.js");
/* harmony import */ var _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Matrix3.js */ "../../node_modules/three/src/math/Matrix3.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/Matrix4.js */ "../../node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _FileLoader_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./FileLoader.js */ "../../node_modules/three/src/loaders/FileLoader.js");
/* harmony import */ var _Loader_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Loader.js */ "../../node_modules/three/src/loaders/Loader.js");
/* harmony import */ var _materials_Materials_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../materials/Materials.js */ "../../node_modules/three/src/materials/Materials.js");










class MaterialLoader extends _Loader_js__WEBPACK_IMPORTED_MODULE_7__["Loader"] {

	constructor( manager ) {

		super( manager );
		this.textures = {};

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new _FileLoader_js__WEBPACK_IMPORTED_MODULE_6__["FileLoader"]( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const textures = this.textures;

		function getTexture( name ) {

			if ( textures[ name ] === undefined ) {

				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

			}

			return textures[ name ];

		}

		const material = new _materials_Materials_js__WEBPACK_IMPORTED_MODULE_8__[ json.type ]();

		if ( json.uuid !== undefined ) material.uuid = json.uuid;
		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );
		if ( json.roughness !== undefined ) material.roughness = json.roughness;
		if ( json.metalness !== undefined ) material.metalness = json.metalness;
		if ( json.sheen !== undefined ) material.sheen = new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"]().setHex( json.sheen );
		if ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;
		if ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;
		if ( json.fog !== undefined ) material.fog = json.fog;
		if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.combine !== undefined ) material.combine = json.combine;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.shadowSide !== undefined ) material.shadowSide = json.shadowSide;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;

		if ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;
		if ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;
		if ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;
		if ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;
		if ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;
		if ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;
		if ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;
		if ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;

		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

		if ( json.rotation !== undefined ) material.rotation = json.rotation;

		if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
		if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
		if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
		if ( json.scale !== undefined ) material.scale = json.scale;

		if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
		if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
		if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

		if ( json.skinning !== undefined ) material.skinning = json.skinning;
		if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
		if ( json.morphNormals !== undefined ) material.morphNormals = json.morphNormals;
		if ( json.dithering !== undefined ) material.dithering = json.dithering;

		if ( json.alphaToCoverage !== undefined ) material.alphaToCoverage = json.alphaToCoverage;
		if ( json.premultipliedAlpha !== undefined ) material.premultipliedAlpha = json.premultipliedAlpha;

		if ( json.vertexTangents !== undefined ) material.vertexTangents = json.vertexTangents;

		if ( json.visible !== undefined ) material.visible = json.visible;

		if ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;

		if ( json.userData !== undefined ) material.userData = json.userData;

		if ( json.vertexColors !== undefined ) {

			if ( typeof json.vertexColors === 'number' ) {

				material.vertexColors = ( json.vertexColors > 0 ) ? true : false;

			} else {

				material.vertexColors = json.vertexColors;

			}

		}

		// Shader Material

		if ( json.uniforms !== undefined ) {

			for ( const name in json.uniforms ) {

				const uniform = json.uniforms[ name ];

				material.uniforms[ name ] = {};

				switch ( uniform.type ) {

					case 't':
						material.uniforms[ name ].value = getTexture( uniform.value );
						break;

					case 'c':
						material.uniforms[ name ].value = new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"]().setHex( uniform.value );
						break;

					case 'v2':
						material.uniforms[ name ].value = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"]().fromArray( uniform.value );
						break;

					case 'v3':
						material.uniforms[ name ].value = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]().fromArray( uniform.value );
						break;

					case 'v4':
						material.uniforms[ name ].value = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_3__["Vector4"]().fromArray( uniform.value );
						break;

					case 'm3':
						material.uniforms[ name ].value = new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_4__["Matrix3"]().fromArray( uniform.value );
						break;

					case 'm4':
						material.uniforms[ name ].value = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_5__["Matrix4"]().fromArray( uniform.value );
						break;

					default:
						material.uniforms[ name ].value = uniform.value;

				}

			}

		}

		if ( json.defines !== undefined ) material.defines = json.defines;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;

		if ( json.extensions !== undefined ) {

			for ( const key in json.extensions ) {

				material.extensions[ key ] = json.extensions[ key ];

			}

		}

		// Deprecated

		if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading

		// for PointsMaterial

		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

		// maps

		if ( json.map !== undefined ) material.map = getTexture( json.map );
		if ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );

		if ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );

		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
		if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
		if ( json.normalScale !== undefined ) {

			let normalScale = json.normalScale;

			if ( Array.isArray( normalScale ) === false ) {

				// Blender exporter used to export a scalar. See #7459

				normalScale = [ normalScale, normalScale ];

			}

			material.normalScale = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"]().fromArray( normalScale );

		}

		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
		if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;

		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
		if ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;

		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

		if ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );
		if ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );
		if ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );
		if ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"]().fromArray( json.clearcoatNormalScale );

		if ( json.transmission !== undefined ) material.transmission = json.transmission;
		if ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );

		return material;

	}

	setTextures( value ) {

		this.textures = value;
		return this;

	}

}





/***/ }),

/***/ "../../node_modules/three/src/loaders/ObjectLoader.js":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/loaders/ObjectLoader.js ***!
  \****************************************************************************/
/*! exports provided: ObjectLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectLoader", function() { return ObjectLoader; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");
/* harmony import */ var _objects_Group_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../objects/Group.js */ "../../node_modules/three/src/objects/Group.js");
/* harmony import */ var _objects_InstancedMesh_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../objects/InstancedMesh.js */ "../../node_modules/three/src/objects/InstancedMesh.js");
/* harmony import */ var _objects_Sprite_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../objects/Sprite.js */ "../../node_modules/three/src/objects/Sprite.js");
/* harmony import */ var _objects_Points_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../objects/Points.js */ "../../node_modules/three/src/objects/Points.js");
/* harmony import */ var _objects_Line_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../objects/Line.js */ "../../node_modules/three/src/objects/Line.js");
/* harmony import */ var _objects_LineLoop_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../objects/LineLoop.js */ "../../node_modules/three/src/objects/LineLoop.js");
/* harmony import */ var _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../objects/LineSegments.js */ "../../node_modules/three/src/objects/LineSegments.js");
/* harmony import */ var _objects_LOD_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../objects/LOD.js */ "../../node_modules/three/src/objects/LOD.js");
/* harmony import */ var _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../objects/Mesh.js */ "../../node_modules/three/src/objects/Mesh.js");
/* harmony import */ var _objects_SkinnedMesh_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../objects/SkinnedMesh.js */ "../../node_modules/three/src/objects/SkinnedMesh.js");
/* harmony import */ var _objects_Bone_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../objects/Bone.js */ "../../node_modules/three/src/objects/Bone.js");
/* harmony import */ var _objects_Skeleton_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../objects/Skeleton.js */ "../../node_modules/three/src/objects/Skeleton.js");
/* harmony import */ var _extras_core_Shape_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../extras/core/Shape.js */ "../../node_modules/three/src/extras/core/Shape.js");
/* harmony import */ var _scenes_Fog_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../scenes/Fog.js */ "../../node_modules/three/src/scenes/Fog.js");
/* harmony import */ var _scenes_FogExp2_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../scenes/FogExp2.js */ "../../node_modules/three/src/scenes/FogExp2.js");
/* harmony import */ var _lights_HemisphereLight_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../lights/HemisphereLight.js */ "../../node_modules/three/src/lights/HemisphereLight.js");
/* harmony import */ var _lights_SpotLight_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../lights/SpotLight.js */ "../../node_modules/three/src/lights/SpotLight.js");
/* harmony import */ var _lights_PointLight_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../lights/PointLight.js */ "../../node_modules/three/src/lights/PointLight.js");
/* harmony import */ var _lights_DirectionalLight_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../lights/DirectionalLight.js */ "../../node_modules/three/src/lights/DirectionalLight.js");
/* harmony import */ var _lights_AmbientLight_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../lights/AmbientLight.js */ "../../node_modules/three/src/lights/AmbientLight.js");
/* harmony import */ var _lights_RectAreaLight_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../lights/RectAreaLight.js */ "../../node_modules/three/src/lights/RectAreaLight.js");
/* harmony import */ var _lights_LightProbe_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../lights/LightProbe.js */ "../../node_modules/three/src/lights/LightProbe.js");
/* harmony import */ var _cameras_OrthographicCamera_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../cameras/OrthographicCamera.js */ "../../node_modules/three/src/cameras/OrthographicCamera.js");
/* harmony import */ var _cameras_PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../cameras/PerspectiveCamera.js */ "../../node_modules/three/src/cameras/PerspectiveCamera.js");
/* harmony import */ var _scenes_Scene_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../scenes/Scene.js */ "../../node_modules/three/src/scenes/Scene.js");
/* harmony import */ var _textures_CubeTexture_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../textures/CubeTexture.js */ "../../node_modules/three/src/textures/CubeTexture.js");
/* harmony import */ var _textures_Texture_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ../textures/Texture.js */ "../../node_modules/three/src/textures/Texture.js");
/* harmony import */ var _textures_DataTexture_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ../textures/DataTexture.js */ "../../node_modules/three/src/textures/DataTexture.js");
/* harmony import */ var _ImageLoader_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./ImageLoader.js */ "../../node_modules/three/src/loaders/ImageLoader.js");
/* harmony import */ var _LoadingManager_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./LoadingManager.js */ "../../node_modules/three/src/loaders/LoadingManager.js");
/* harmony import */ var _animation_AnimationClip_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ../animation/AnimationClip.js */ "../../node_modules/three/src/animation/AnimationClip.js");
/* harmony import */ var _MaterialLoader_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./MaterialLoader.js */ "../../node_modules/three/src/loaders/MaterialLoader.js");
/* harmony import */ var _LoaderUtils_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./LoaderUtils.js */ "../../node_modules/three/src/loaders/LoaderUtils.js");
/* harmony import */ var _BufferGeometryLoader_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./BufferGeometryLoader.js */ "../../node_modules/three/src/loaders/BufferGeometryLoader.js");
/* harmony import */ var _Loader_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./Loader.js */ "../../node_modules/three/src/loaders/Loader.js");
/* harmony import */ var _FileLoader_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./FileLoader.js */ "../../node_modules/three/src/loaders/FileLoader.js");
/* harmony import */ var _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ../geometries/Geometries.js */ "../../node_modules/three/src/geometries/Geometries.js");
/* harmony import */ var _extras_curves_Curves_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ../extras/curves/Curves.js */ "../../node_modules/three/src/extras/curves/Curves.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ../utils.js */ "../../node_modules/three/src/utils.js");












































class ObjectLoader extends _Loader_js__WEBPACK_IMPORTED_MODULE_38__["Loader"] {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const path = ( this.path === '' ) ? _LoaderUtils_js__WEBPACK_IMPORTED_MODULE_36__["LoaderUtils"].extractUrlBase( url ) : this.path;
		this.resourcePath = this.resourcePath || path;

		const loader = new _FileLoader_js__WEBPACK_IMPORTED_MODULE_39__["FileLoader"]( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			let json = null;

			try {

				json = JSON.parse( text );

			} catch ( error ) {

				if ( onError !== undefined ) onError( error );

				console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

				return;

			}

			const metadata = json.metadata;

			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

				console.error( 'THREE.ObjectLoader: Can\'t load ' + url );
				return;

			}

			scope.parse( json, onLoad );

		}, onProgress, onError );

	}

	parse( json, onLoad ) {

		const animations = this.parseAnimations( json.animations );
		const shapes = this.parseShapes( json.shapes );
		const geometries = this.parseGeometries( json.geometries, shapes );

		const images = this.parseImages( json.images, function () {

			if ( onLoad !== undefined ) onLoad( object );

		} );

		const textures = this.parseTextures( json.textures, images );
		const materials = this.parseMaterials( json.materials, textures );

		const object = this.parseObject( json.object, geometries, materials, animations );
		const skeletons = this.parseSkeletons( json.skeletons, object );

		this.bindSkeletons( object, skeletons );

		//

		if ( onLoad !== undefined ) {

			let hasImages = false;

			for ( const uuid in images ) {

				if ( images[ uuid ] instanceof HTMLImageElement ) {

					hasImages = true;
					break;

				}

			}

			if ( hasImages === false ) onLoad( object );

		}

		return object;

	}

	parseShapes( json ) {

		const shapes = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const shape = new _extras_core_Shape_js__WEBPACK_IMPORTED_MODULE_16__["Shape"]().fromJSON( json[ i ] );

				shapes[ shape.uuid ] = shape;

			}

		}

		return shapes;

	}

	parseSkeletons( json, object ) {

		const skeletons = {};
		const bones = {};

		// generate bone lookup table

		object.traverse( function ( child ) {

			if ( child.isBone ) bones[ child.uuid ] = child;

		} );

		// create skeletons

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const skeleton = new _objects_Skeleton_js__WEBPACK_IMPORTED_MODULE_15__["Skeleton"]().fromJSON( json[ i ], bones );

				skeletons[ skeleton.uuid ] = skeleton;

			}

		}

		return skeletons;

	}

	parseGeometries( json, shapes ) {

		const geometries = {};
		let geometryShapes;

		if ( json !== undefined ) {

			const bufferGeometryLoader = new _BufferGeometryLoader_js__WEBPACK_IMPORTED_MODULE_37__["BufferGeometryLoader"]();

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				let geometry;
				const data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':
					case 'PlaneBufferGeometry':

						geometry = new _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_40__[ data.type ](
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'BoxGeometry':
					case 'BoxBufferGeometry':

						geometry = new _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_40__[ data.type ](
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CircleGeometry':
					case 'CircleBufferGeometry':

						geometry = new _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_40__[ data.type ](
							data.radius,
							data.segments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'CylinderGeometry':
					case 'CylinderBufferGeometry':

						geometry = new _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_40__[ data.type ](
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'ConeGeometry':
					case 'ConeBufferGeometry':

						geometry = new _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_40__[ data.type ](
							data.radius,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'SphereGeometry':
					case 'SphereBufferGeometry':

						geometry = new _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_40__[ data.type ](
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'DodecahedronGeometry':
					case 'DodecahedronBufferGeometry':
					case 'IcosahedronGeometry':
					case 'IcosahedronBufferGeometry':
					case 'OctahedronGeometry':
					case 'OctahedronBufferGeometry':
					case 'TetrahedronGeometry':
					case 'TetrahedronBufferGeometry':

						geometry = new _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_40__[ data.type ](
							data.radius,
							data.detail
						);

						break;

					case 'RingGeometry':
					case 'RingBufferGeometry':

						geometry = new _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_40__[ data.type ](
							data.innerRadius,
							data.outerRadius,
							data.thetaSegments,
							data.phiSegments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'TorusGeometry':
					case 'TorusBufferGeometry':

						geometry = new _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_40__[ data.type ](
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':
					case 'TorusKnotBufferGeometry':

						geometry = new _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_40__[ data.type ](
							data.radius,
							data.tube,
							data.tubularSegments,
							data.radialSegments,
							data.p,
							data.q
						);

						break;

					case 'TubeGeometry':
					case 'TubeBufferGeometry':

						// This only works for built-in curves (e.g. CatmullRomCurve3).
						// User defined curves or instances of CurvePath will not be deserialized.
						geometry = new _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_40__[ data.type ](
							new _extras_curves_Curves_js__WEBPACK_IMPORTED_MODULE_41__[ data.path.type ]().fromJSON( data.path ),
							data.tubularSegments,
							data.radius,
							data.radialSegments,
							data.closed
						);

						break;

					case 'LatheGeometry':
					case 'LatheBufferGeometry':

						geometry = new _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_40__[ data.type ](
							data.points,
							data.segments,
							data.phiStart,
							data.phiLength
						);

						break;

					case 'PolyhedronGeometry':
					case 'PolyhedronBufferGeometry':

						geometry = new _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_40__[ data.type ](
							data.vertices,
							data.indices,
							data.radius,
							data.details
						);

						break;

					case 'ShapeGeometry':
					case 'ShapeBufferGeometry':

						geometryShapes = [];

						for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

							const shape = shapes[ data.shapes[ j ] ];

							geometryShapes.push( shape );

						}

						geometry = new _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_40__[ data.type ](
							geometryShapes,
							data.curveSegments
						);

						break;


					case 'ExtrudeGeometry':
					case 'ExtrudeBufferGeometry':

						geometryShapes = [];

						for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

							const shape = shapes[ data.shapes[ j ] ];

							geometryShapes.push( shape );

						}

						const extrudePath = data.options.extrudePath;

						if ( extrudePath !== undefined ) {

							data.options.extrudePath = new _extras_curves_Curves_js__WEBPACK_IMPORTED_MODULE_41__[ extrudePath.type ]().fromJSON( extrudePath );

						}

						geometry = new _geometries_Geometries_js__WEBPACK_IMPORTED_MODULE_40__[ data.type ](
							geometryShapes,
							data.options
						);

						break;

					case 'BufferGeometry':
					case 'InstancedBufferGeometry':

						geometry = bufferGeometryLoader.parse( data );

						break;

					case 'Geometry':

						console.error( 'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.' );

						break;

					default:

						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

						continue;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;
				if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	}

	parseMaterials( json, textures ) {

		const cache = {}; // MultiMaterial
		const materials = {};

		if ( json !== undefined ) {

			const loader = new _MaterialLoader_js__WEBPACK_IMPORTED_MODULE_35__["MaterialLoader"]();
			loader.setTextures( textures );

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				if ( data.type === 'MultiMaterial' ) {

					// Deprecated

					const array = [];

					for ( let j = 0; j < data.materials.length; j ++ ) {

						const material = data.materials[ j ];

						if ( cache[ material.uuid ] === undefined ) {

							cache[ material.uuid ] = loader.parse( material );

						}

						array.push( cache[ material.uuid ] );

					}

					materials[ data.uuid ] = array;

				} else {

					if ( cache[ data.uuid ] === undefined ) {

						cache[ data.uuid ] = loader.parse( data );

					}

					materials[ data.uuid ] = cache[ data.uuid ];

				}

			}

		}

		return materials;

	}

	parseAnimations( json ) {

		const animations = {};

		if ( json !== undefined ) {

			for ( let i = 0; i < json.length; i ++ ) {

				const data = json[ i ];

				const clip = _animation_AnimationClip_js__WEBPACK_IMPORTED_MODULE_34__["AnimationClip"].parse( data );

				animations[ clip.uuid ] = clip;

			}

		}

		return animations;

	}

	parseImages( json, onLoad ) {

		const scope = this;
		const images = {};

		let loader;

		function loadImage( url ) {

			scope.manager.itemStart( url );

			return loader.load( url, function () {

				scope.manager.itemEnd( url );

			}, undefined, function () {

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			} );

		}

		function deserializeImage( image ) {

			if ( typeof image === 'string' ) {

				const url = image;

				const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

				return loadImage( path );

			} else {

				if ( image.data ) {

					return {
						data: Object(_utils_js__WEBPACK_IMPORTED_MODULE_42__["getTypedArray"])( image.type, image.data ),
						width: image.width,
						height: image.height
					};

				} else {

					return null;

				}

			}

		}

		if ( json !== undefined && json.length > 0 ) {

			const manager = new _LoadingManager_js__WEBPACK_IMPORTED_MODULE_33__["LoadingManager"]( onLoad );

			loader = new _ImageLoader_js__WEBPACK_IMPORTED_MODULE_32__["ImageLoader"]( manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( let i = 0, il = json.length; i < il; i ++ ) {

				const image = json[ i ];
				const url = image.url;

				if ( Array.isArray( url ) ) {

					// load array of images e.g CubeTexture

					images[ image.uuid ] = [];

					for ( let j = 0, jl = url.length; j < jl; j ++ ) {

						const currentUrl = url[ j ];

						const deserializedImage = deserializeImage( currentUrl );

						if ( deserializedImage !== null ) {

							if ( deserializedImage instanceof HTMLImageElement ) {

								images[ image.uuid ].push( deserializedImage );

							} else {

								// special case: handle array of data textures for cube textures

								images[ image.uuid ].push( new _textures_DataTexture_js__WEBPACK_IMPORTED_MODULE_31__["DataTexture"]( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

							}

						}

					}

				} else {

					// load single image

					const deserializedImage = deserializeImage( image.url );

					if ( deserializedImage !== null ) {

						images[ image.uuid ] = deserializedImage;

					}

				}

			}

		}

		return images;

	}

	parseTextures( json, images ) {

		function parseConstant( value, type ) {

			if ( typeof value === 'number' ) return value;

			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

			return type[ value ];

		}

		const textures = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				if ( data.image === undefined ) {

					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

				}

				if ( images[ data.image ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

				}

				let texture;
				const image = images[ data.image ];

				if ( Array.isArray( image ) ) {

					texture = new _textures_CubeTexture_js__WEBPACK_IMPORTED_MODULE_29__["CubeTexture"]( image );

					if ( image.length === 6 ) texture.needsUpdate = true;

				} else {

					if ( image && image.data ) {

						texture = new _textures_DataTexture_js__WEBPACK_IMPORTED_MODULE_31__["DataTexture"]( image.data, image.width, image.height );

					} else {

						texture = new _textures_Texture_js__WEBPACK_IMPORTED_MODULE_30__["Texture"]( image );

					}

					if ( image ) texture.needsUpdate = true; // textures can have undefined image data

				}

				texture.uuid = data.uuid;

				if ( data.name !== undefined ) texture.name = data.name;

				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
				if ( data.center !== undefined ) texture.center.fromArray( data.center );
				if ( data.rotation !== undefined ) texture.rotation = data.rotation;

				if ( data.wrap !== undefined ) {

					texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
					texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

				}

				if ( data.format !== undefined ) texture.format = data.format;
				if ( data.type !== undefined ) texture.type = data.type;
				if ( data.encoding !== undefined ) texture.encoding = data.encoding;

				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

				if ( data.flipY !== undefined ) texture.flipY = data.flipY;

				if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
				if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;

				textures[ data.uuid ] = texture;

			}

		}

		return textures;

	}

	parseObject( data, geometries, materials, animations ) {

		let object;

		function getGeometry( name ) {

			if ( geometries[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

			}

			return geometries[ name ];

		}

		function getMaterial( name ) {

			if ( name === undefined ) return undefined;

			if ( Array.isArray( name ) ) {

				const array = [];

				for ( let i = 0, l = name.length; i < l; i ++ ) {

					const uuid = name[ i ];

					if ( materials[ uuid ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

					}

					array.push( materials[ uuid ] );

				}

				return array;

			}

			if ( materials[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined material', name );

			}

			return materials[ name ];

		}

		let geometry, material;

		switch ( data.type ) {

			case 'Scene':

				object = new _scenes_Scene_js__WEBPACK_IMPORTED_MODULE_28__["Scene"]();

				if ( data.background !== undefined ) {

					if ( Number.isInteger( data.background ) ) {

						object.background = new _math_Color_js__WEBPACK_IMPORTED_MODULE_2__["Color"]( data.background );

					}

				}

				if ( data.fog !== undefined ) {

					if ( data.fog.type === 'Fog' ) {

						object.fog = new _scenes_Fog_js__WEBPACK_IMPORTED_MODULE_17__["Fog"]( data.fog.color, data.fog.near, data.fog.far );

					} else if ( data.fog.type === 'FogExp2' ) {

						object.fog = new _scenes_FogExp2_js__WEBPACK_IMPORTED_MODULE_18__["FogExp2"]( data.fog.color, data.fog.density );

					}

				}

				break;

			case 'PerspectiveCamera':

				object = new _cameras_PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_27__["PerspectiveCamera"]( data.fov, data.aspect, data.near, data.far );

				if ( data.focus !== undefined ) object.focus = data.focus;
				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
				if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'OrthographicCamera':

				object = new _cameras_OrthographicCamera_js__WEBPACK_IMPORTED_MODULE_26__["OrthographicCamera"]( data.left, data.right, data.top, data.bottom, data.near, data.far );

				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'AmbientLight':

				object = new _lights_AmbientLight_js__WEBPACK_IMPORTED_MODULE_23__["AmbientLight"]( data.color, data.intensity );

				break;

			case 'DirectionalLight':

				object = new _lights_DirectionalLight_js__WEBPACK_IMPORTED_MODULE_22__["DirectionalLight"]( data.color, data.intensity );

				break;

			case 'PointLight':

				object = new _lights_PointLight_js__WEBPACK_IMPORTED_MODULE_21__["PointLight"]( data.color, data.intensity, data.distance, data.decay );

				break;

			case 'RectAreaLight':

				object = new _lights_RectAreaLight_js__WEBPACK_IMPORTED_MODULE_24__["RectAreaLight"]( data.color, data.intensity, data.width, data.height );

				break;

			case 'SpotLight':

				object = new _lights_SpotLight_js__WEBPACK_IMPORTED_MODULE_20__["SpotLight"]( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

				break;

			case 'HemisphereLight':

				object = new _lights_HemisphereLight_js__WEBPACK_IMPORTED_MODULE_19__["HemisphereLight"]( data.color, data.groundColor, data.intensity );

				break;

			case 'LightProbe':

				object = new _lights_LightProbe_js__WEBPACK_IMPORTED_MODULE_25__["LightProbe"]().fromJSON( data );

				break;

			case 'SkinnedMesh':

				geometry = getGeometry( data.geometry );
			 	material = getMaterial( data.material );

				object = new _objects_SkinnedMesh_js__WEBPACK_IMPORTED_MODULE_13__["SkinnedMesh"]( geometry, material );

				if ( data.bindMode !== undefined ) object.bindMode = data.bindMode;
				if ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );
				if ( data.skeleton !== undefined ) object.skeleton = data.skeleton;

				break;

			case 'Mesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );

				object = new _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_12__["Mesh"]( geometry, material );

				break;

			case 'InstancedMesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );
				const count = data.count;
				const instanceMatrix = data.instanceMatrix;
				const instanceColor = data.instanceColor;

				object = new _objects_InstancedMesh_js__WEBPACK_IMPORTED_MODULE_5__["InstancedMesh"]( geometry, material, count );
				object.instanceMatrix = new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"]( new Float32Array( instanceMatrix.array ), 16 );
				if ( instanceColor !== undefined ) object.instanceColor = new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"]( new Float32Array( instanceColor.array ), instanceColor.itemSize );

				break;

			case 'LOD':

				object = new _objects_LOD_js__WEBPACK_IMPORTED_MODULE_11__["LOD"]();

				break;

			case 'Line':

				object = new _objects_Line_js__WEBPACK_IMPORTED_MODULE_8__["Line"]( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'LineLoop':

				object = new _objects_LineLoop_js__WEBPACK_IMPORTED_MODULE_9__["LineLoop"]( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'LineSegments':

				object = new _objects_LineSegments_js__WEBPACK_IMPORTED_MODULE_10__["LineSegments"]( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'PointCloud':
			case 'Points':

				object = new _objects_Points_js__WEBPACK_IMPORTED_MODULE_7__["Points"]( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'Sprite':

				object = new _objects_Sprite_js__WEBPACK_IMPORTED_MODULE_6__["Sprite"]( getMaterial( data.material ) );

				break;

			case 'Group':

				object = new _objects_Group_js__WEBPACK_IMPORTED_MODULE_4__["Group"]();

				break;

			case 'Bone':

				object = new _objects_Bone_js__WEBPACK_IMPORTED_MODULE_14__["Bone"]();

				break;

			default:

				object = new _core_Object3D_js__WEBPACK_IMPORTED_MODULE_3__["Object3D"]();

		}

		object.uuid = data.uuid;

		if ( data.name !== undefined ) object.name = data.name;

		if ( data.matrix !== undefined ) {

			object.matrix.fromArray( data.matrix );

			if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
			if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

		} else {

			if ( data.position !== undefined ) object.position.fromArray( data.position );
			if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
			if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
			if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

		}

		if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
		if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

		if ( data.shadow ) {

			if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
			if ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;
			if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
			if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
			if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

		}

		if ( data.visible !== undefined ) object.visible = data.visible;
		if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
		if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
		if ( data.userData !== undefined ) object.userData = data.userData;
		if ( data.layers !== undefined ) object.layers.mask = data.layers;

		if ( data.children !== undefined ) {

			const children = data.children;

			for ( let i = 0; i < children.length; i ++ ) {

				object.add( this.parseObject( children[ i ], geometries, materials, animations ) );

			}

		}

		if ( data.animations !== undefined ) {

			const objectAnimations = data.animations;

			for ( let i = 0; i < objectAnimations.length; i ++ ) {

				const uuid = objectAnimations[ i ];

				object.animations.push( animations[ uuid ] );

			}

		}

		if ( data.type === 'LOD' ) {

			if ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;

			const levels = data.levels;

			for ( let l = 0; l < levels.length; l ++ ) {

				const level = levels[ l ];
				const child = object.getObjectByProperty( 'uuid', level.object );

				if ( child !== undefined ) {

					object.addLevel( child, level.distance );

				}

			}

		}

		return object;

	}

	bindSkeletons( object, skeletons ) {

		if ( Object.keys( skeletons ).length === 0 ) return;

		object.traverse( function ( child ) {

			if ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {

				const skeleton = skeletons[ child.skeleton ];

				if ( skeleton === undefined ) {

					console.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );

				} else {

					child.bind( skeleton, child.bindMatrix );

				}

			}

		} );

	}

	/* DEPRECATED */

	setTexturePath( value ) {

		console.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );
		return this.setResourcePath( value );

	}

}

const TEXTURE_MAPPING = {
	UVMapping: _constants_js__WEBPACK_IMPORTED_MODULE_0__["UVMapping"],
	CubeReflectionMapping: _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeReflectionMapping"],
	CubeRefractionMapping: _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeRefractionMapping"],
	EquirectangularReflectionMapping: _constants_js__WEBPACK_IMPORTED_MODULE_0__["EquirectangularReflectionMapping"],
	EquirectangularRefractionMapping: _constants_js__WEBPACK_IMPORTED_MODULE_0__["EquirectangularRefractionMapping"],
	CubeUVReflectionMapping: _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeUVReflectionMapping"],
	CubeUVRefractionMapping: _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeUVRefractionMapping"]
};

const TEXTURE_WRAPPING = {
	RepeatWrapping: _constants_js__WEBPACK_IMPORTED_MODULE_0__["RepeatWrapping"],
	ClampToEdgeWrapping: _constants_js__WEBPACK_IMPORTED_MODULE_0__["ClampToEdgeWrapping"],
	MirroredRepeatWrapping: _constants_js__WEBPACK_IMPORTED_MODULE_0__["MirroredRepeatWrapping"]
};

const TEXTURE_FILTER = {
	NearestFilter: _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"],
	NearestMipmapNearestFilter: _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestMipmapNearestFilter"],
	NearestMipmapLinearFilter: _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestMipmapLinearFilter"],
	LinearFilter: _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"],
	LinearMipmapNearestFilter: _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearMipmapNearestFilter"],
	LinearMipmapLinearFilter: _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearMipmapLinearFilter"]
};




/***/ }),

/***/ "../../node_modules/three/src/loaders/TextureLoader.js":
/*!*****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/loaders/TextureLoader.js ***!
  \*****************************************************************************/
/*! exports provided: TextureLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextureLoader", function() { return TextureLoader; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _ImageLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImageLoader.js */ "../../node_modules/three/src/loaders/ImageLoader.js");
/* harmony import */ var _textures_Texture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../textures/Texture.js */ "../../node_modules/three/src/textures/Texture.js");
/* harmony import */ var _Loader_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Loader.js */ "../../node_modules/three/src/loaders/Loader.js");





function TextureLoader( manager ) {

	_Loader_js__WEBPACK_IMPORTED_MODULE_3__["Loader"].call( this, manager );

}

TextureLoader.prototype = Object.assign( Object.create( _Loader_js__WEBPACK_IMPORTED_MODULE_3__["Loader"].prototype ), {

	constructor: TextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		const texture = new _textures_Texture_js__WEBPACK_IMPORTED_MODULE_2__["Texture"]();

		const loader = new _ImageLoader_js__WEBPACK_IMPORTED_MODULE_1__["ImageLoader"]( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		loader.load( url, function ( image ) {

			texture.image = image;

			// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
			const isJPEG = url.search( /\.jpe?g($|\?)/i ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

			texture.format = isJPEG ? _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBFormat"] : _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"];
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	}

} );





/***/ }),

/***/ "../../node_modules/three/src/materials/LineBasicMaterial.js":
/*!***********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/materials/LineBasicMaterial.js ***!
  \***********************************************************************************/
/*! exports provided: LineBasicMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineBasicMaterial", function() { return LineBasicMaterial; });
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Material.js */ "../../node_modules/three/src/materials/Material.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");



/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */

class LineBasicMaterial extends _Material_js__WEBPACK_IMPORTED_MODULE_0__["Material"] {

	constructor( parameters ) {

		super();

		this.type = 'LineBasicMaterial';

		this.color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_1__["Color"]( 0xffffff );

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.morphTargets = false;

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		this.morphTargets = source.morphTargets;

		return this;

	}

}

LineBasicMaterial.prototype.isLineBasicMaterial = true;




/***/ }),

/***/ "../../node_modules/three/src/materials/LineDashedMaterial.js":
/*!************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/materials/LineDashedMaterial.js ***!
  \************************************************************************************/
/*! exports provided: LineDashedMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineDashedMaterial", function() { return LineDashedMaterial; });
/* harmony import */ var _LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LineBasicMaterial.js */ "../../node_modules/three/src/materials/LineBasicMaterial.js");


/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */

class LineDashedMaterial extends _LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_0__["LineBasicMaterial"] {

	constructor( parameters ) {

		super();

		this.type = 'LineDashedMaterial';

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		return this;

	}

}

LineDashedMaterial.prototype.isLineDashedMaterial = true;




/***/ }),

/***/ "../../node_modules/three/src/materials/Material.js":
/*!**************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/materials/Material.js ***!
  \**************************************************************************/
/*! exports provided: Material */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Material", function() { return Material; });
/* harmony import */ var _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/EventDispatcher.js */ "../../node_modules/three/src/core/EventDispatcher.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");




let materialId = 0;

function Material() {

	Object.defineProperty( this, 'id', { value: materialId ++ } );

	this.uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__["MathUtils"].generateUUID();

	this.name = '';
	this.type = 'Material';

	this.fog = true;

	this.blending = _constants_js__WEBPACK_IMPORTED_MODULE_1__["NormalBlending"];
	this.side = _constants_js__WEBPACK_IMPORTED_MODULE_1__["FrontSide"];
	this.vertexColors = false;

	this.opacity = 1;
	this.transparent = false;

	this.blendSrc = _constants_js__WEBPACK_IMPORTED_MODULE_1__["SrcAlphaFactor"];
	this.blendDst = _constants_js__WEBPACK_IMPORTED_MODULE_1__["OneMinusSrcAlphaFactor"];
	this.blendEquation = _constants_js__WEBPACK_IMPORTED_MODULE_1__["AddEquation"];
	this.blendSrcAlpha = null;
	this.blendDstAlpha = null;
	this.blendEquationAlpha = null;

	this.depthFunc = _constants_js__WEBPACK_IMPORTED_MODULE_1__["LessEqualDepth"];
	this.depthTest = true;
	this.depthWrite = true;

	this.stencilWriteMask = 0xff;
	this.stencilFunc = _constants_js__WEBPACK_IMPORTED_MODULE_1__["AlwaysStencilFunc"];
	this.stencilRef = 0;
	this.stencilFuncMask = 0xff;
	this.stencilFail = _constants_js__WEBPACK_IMPORTED_MODULE_1__["KeepStencilOp"];
	this.stencilZFail = _constants_js__WEBPACK_IMPORTED_MODULE_1__["KeepStencilOp"];
	this.stencilZPass = _constants_js__WEBPACK_IMPORTED_MODULE_1__["KeepStencilOp"];
	this.stencilWrite = false;

	this.clippingPlanes = null;
	this.clipIntersection = false;
	this.clipShadows = false;

	this.shadowSide = null;

	this.colorWrite = true;

	this.precision = null; // override the renderer's default precision for this material

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.dithering = false;

	this.alphaTest = 0;
	this.alphaToCoverage = false;
	this.premultipliedAlpha = false;

	this.visible = true;

	this.toneMapped = true;

	this.userData = {};

	this.version = 0;

}

Material.prototype = Object.assign( Object.create( _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_0__["EventDispatcher"].prototype ), {

	constructor: Material,

	isMaterial: true,

	onBeforeCompile: function ( /* shaderobject, renderer */ ) {},

	customProgramCacheKey: function () {

		return this.onBeforeCompile.toString();

	},

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( const key in values ) {

			const newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
				continue;

			}

			// for backward compatability if shading is set in the constructor
			if ( key === 'shading' ) {

				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( newValue === _constants_js__WEBPACK_IMPORTED_MODULE_1__["FlatShading"] ) ? true : false;
				continue;

			}

			const currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( 'THREE.' + this.type + ': \'' + key + '\' is not a property of this material.' );
				continue;

			}

			if ( currentValue && currentValue.isColor ) {

				currentValue.set( newValue );

			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				currentValue.copy( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	},

	toJSON: function ( meta ) {

		const isRoot = ( meta === undefined || typeof meta === 'string' );

		if ( isRoot ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		const data = {
			metadata: {
				version: 4.5,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) data.name = this.name;

		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;

		if ( this.sheen && this.sheen.isColor ) data.sheen = this.sheen.getHex();
		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;
		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

		}

		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

		if ( this.lightMap && this.lightMap.isTexture ) {

			data.lightMap = this.lightMap.toJSON( meta ).uuid;
			data.lightMapIntensity = this.lightMapIntensity;

		}

		if ( this.aoMap && this.aoMap.isTexture ) {

			data.aoMap = this.aoMap.toJSON( meta ).uuid;
			data.aoMapIntensity = this.aoMapIntensity;

		}

		if ( this.bumpMap && this.bumpMap.isTexture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}

		if ( this.normalMap && this.normalMap.isTexture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();

		}

		if ( this.displacementMap && this.displacementMap.isTexture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}

		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

		if ( this.envMap && this.envMap.isTexture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;
			data.reflectivity = this.reflectivity; // Scale behind envMap
			data.refractionRatio = this.refractionRatio;

			if ( this.combine !== undefined ) data.combine = this.combine;
			if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;

		}

		if ( this.gradientMap && this.gradientMap.isTexture ) {

			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		}

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.blending !== _constants_js__WEBPACK_IMPORTED_MODULE_1__["NormalBlending"] ) data.blending = this.blending;
		if ( this.side !== _constants_js__WEBPACK_IMPORTED_MODULE_1__["FrontSide"] ) data.side = this.side;
		if ( this.vertexColors ) data.vertexColors = true;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = this.transparent;

		data.depthFunc = this.depthFunc;
		data.depthTest = this.depthTest;
		data.depthWrite = this.depthWrite;
		data.colorWrite = this.colorWrite;

		data.stencilWrite = this.stencilWrite;
		data.stencilWriteMask = this.stencilWriteMask;
		data.stencilFunc = this.stencilFunc;
		data.stencilRef = this.stencilRef;
		data.stencilFuncMask = this.stencilFuncMask;
		data.stencilFail = this.stencilFail;
		data.stencilZFail = this.stencilZFail;
		data.stencilZPass = this.stencilZPass;

		// rotation (SpriteMaterial)
		if ( this.rotation && this.rotation !== 0 ) data.rotation = this.rotation;

		if ( this.polygonOffset === true ) data.polygonOffset = true;
		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

		if ( this.linewidth && this.linewidth !== 1 ) data.linewidth = this.linewidth;
		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
		if ( this.scale !== undefined ) data.scale = this.scale;

		if ( this.dithering === true ) data.dithering = true;

		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.alphaToCoverage === true ) data.alphaToCoverage = this.alphaToCoverage;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

		if ( this.wireframe === true ) data.wireframe = this.wireframe;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		if ( this.morphTargets === true ) data.morphTargets = true;
		if ( this.morphNormals === true ) data.morphNormals = true;
		if ( this.skinning === true ) data.skinning = true;

		if ( this.flatShading === true ) data.flatShading = this.flatShading;

		if ( this.visible === false ) data.visible = false;

		if ( this.toneMapped === false ) data.toneMapped = false;

		if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			const values = [];

			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRoot ) {

			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.name = source.name;

		this.fog = source.fog;

		this.blending = source.blending;
		this.side = source.side;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.stencilWriteMask = source.stencilWriteMask;
		this.stencilFunc = source.stencilFunc;
		this.stencilRef = source.stencilRef;
		this.stencilFuncMask = source.stencilFuncMask;
		this.stencilFail = source.stencilFail;
		this.stencilZFail = source.stencilZFail;
		this.stencilZPass = source.stencilZPass;
		this.stencilWrite = source.stencilWrite;

		const srcPlanes = source.clippingPlanes;
		let dstPlanes = null;

		if ( srcPlanes !== null ) {

			const n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( let i = 0; i !== n; ++ i ) {

				dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

		}

		this.clippingPlanes = dstPlanes;
		this.clipIntersection = source.clipIntersection;
		this.clipShadows = source.clipShadows;

		this.shadowSide = source.shadowSide;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.dithering = source.dithering;

		this.alphaTest = source.alphaTest;
		this.alphaToCoverage = source.alphaToCoverage;
		this.premultipliedAlpha = source.premultipliedAlpha;

		this.visible = source.visible;

		this.toneMapped = source.toneMapped;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

Object.defineProperty( Material.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );




/***/ }),

/***/ "../../node_modules/three/src/materials/Materials.js":
/*!***************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/materials/Materials.js ***!
  \***************************************************************************/
/*! exports provided: ShadowMaterial, SpriteMaterial, RawShaderMaterial, ShaderMaterial, PointsMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshPhongMaterial, MeshToonMaterial, MeshNormalMaterial, MeshLambertMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshBasicMaterial, MeshMatcapMaterial, LineDashedMaterial, LineBasicMaterial, Material */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ShadowMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ShadowMaterial.js */ "../../node_modules/three/src/materials/ShadowMaterial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShadowMaterial", function() { return _ShadowMaterial_js__WEBPACK_IMPORTED_MODULE_0__["ShadowMaterial"]; });

/* harmony import */ var _SpriteMaterial_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SpriteMaterial.js */ "../../node_modules/three/src/materials/SpriteMaterial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SpriteMaterial", function() { return _SpriteMaterial_js__WEBPACK_IMPORTED_MODULE_1__["SpriteMaterial"]; });

/* harmony import */ var _RawShaderMaterial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RawShaderMaterial.js */ "../../node_modules/three/src/materials/RawShaderMaterial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RawShaderMaterial", function() { return _RawShaderMaterial_js__WEBPACK_IMPORTED_MODULE_2__["RawShaderMaterial"]; });

/* harmony import */ var _ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ShaderMaterial.js */ "../../node_modules/three/src/materials/ShaderMaterial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShaderMaterial", function() { return _ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_3__["ShaderMaterial"]; });

/* harmony import */ var _PointsMaterial_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PointsMaterial.js */ "../../node_modules/three/src/materials/PointsMaterial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointsMaterial", function() { return _PointsMaterial_js__WEBPACK_IMPORTED_MODULE_4__["PointsMaterial"]; });

/* harmony import */ var _MeshPhysicalMaterial_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MeshPhysicalMaterial.js */ "../../node_modules/three/src/materials/MeshPhysicalMaterial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshPhysicalMaterial", function() { return _MeshPhysicalMaterial_js__WEBPACK_IMPORTED_MODULE_5__["MeshPhysicalMaterial"]; });

/* harmony import */ var _MeshStandardMaterial_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MeshStandardMaterial.js */ "../../node_modules/three/src/materials/MeshStandardMaterial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshStandardMaterial", function() { return _MeshStandardMaterial_js__WEBPACK_IMPORTED_MODULE_6__["MeshStandardMaterial"]; });

/* harmony import */ var _MeshPhongMaterial_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./MeshPhongMaterial.js */ "../../node_modules/three/src/materials/MeshPhongMaterial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshPhongMaterial", function() { return _MeshPhongMaterial_js__WEBPACK_IMPORTED_MODULE_7__["MeshPhongMaterial"]; });

/* harmony import */ var _MeshToonMaterial_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./MeshToonMaterial.js */ "../../node_modules/three/src/materials/MeshToonMaterial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshToonMaterial", function() { return _MeshToonMaterial_js__WEBPACK_IMPORTED_MODULE_8__["MeshToonMaterial"]; });

/* harmony import */ var _MeshNormalMaterial_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./MeshNormalMaterial.js */ "../../node_modules/three/src/materials/MeshNormalMaterial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshNormalMaterial", function() { return _MeshNormalMaterial_js__WEBPACK_IMPORTED_MODULE_9__["MeshNormalMaterial"]; });

/* harmony import */ var _MeshLambertMaterial_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./MeshLambertMaterial.js */ "../../node_modules/three/src/materials/MeshLambertMaterial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshLambertMaterial", function() { return _MeshLambertMaterial_js__WEBPACK_IMPORTED_MODULE_10__["MeshLambertMaterial"]; });

/* harmony import */ var _MeshDepthMaterial_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./MeshDepthMaterial.js */ "../../node_modules/three/src/materials/MeshDepthMaterial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshDepthMaterial", function() { return _MeshDepthMaterial_js__WEBPACK_IMPORTED_MODULE_11__["MeshDepthMaterial"]; });

/* harmony import */ var _MeshDistanceMaterial_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./MeshDistanceMaterial.js */ "../../node_modules/three/src/materials/MeshDistanceMaterial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshDistanceMaterial", function() { return _MeshDistanceMaterial_js__WEBPACK_IMPORTED_MODULE_12__["MeshDistanceMaterial"]; });

/* harmony import */ var _MeshBasicMaterial_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./MeshBasicMaterial.js */ "../../node_modules/three/src/materials/MeshBasicMaterial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshBasicMaterial", function() { return _MeshBasicMaterial_js__WEBPACK_IMPORTED_MODULE_13__["MeshBasicMaterial"]; });

/* harmony import */ var _MeshMatcapMaterial_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./MeshMatcapMaterial.js */ "../../node_modules/three/src/materials/MeshMatcapMaterial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeshMatcapMaterial", function() { return _MeshMatcapMaterial_js__WEBPACK_IMPORTED_MODULE_14__["MeshMatcapMaterial"]; });

/* harmony import */ var _LineDashedMaterial_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./LineDashedMaterial.js */ "../../node_modules/three/src/materials/LineDashedMaterial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LineDashedMaterial", function() { return _LineDashedMaterial_js__WEBPACK_IMPORTED_MODULE_15__["LineDashedMaterial"]; });

/* harmony import */ var _LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./LineBasicMaterial.js */ "../../node_modules/three/src/materials/LineBasicMaterial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LineBasicMaterial", function() { return _LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_16__["LineBasicMaterial"]; });

/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./Material.js */ "../../node_modules/three/src/materials/Material.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Material", function() { return _Material_js__WEBPACK_IMPORTED_MODULE_17__["Material"]; });





















/***/ }),

/***/ "../../node_modules/three/src/materials/MeshBasicMaterial.js":
/*!***********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/materials/MeshBasicMaterial.js ***!
  \***********************************************************************************/
/*! exports provided: MeshBasicMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshBasicMaterial", function() { return MeshBasicMaterial; });
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Material.js */ "../../node_modules/three/src/materials/Material.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");




/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */

class MeshBasicMaterial extends _Material_js__WEBPACK_IMPORTED_MODULE_0__["Material"] {

	constructor( parameters ) {

		super();

		this.type = 'MeshBasicMaterial';

		this.color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_2__["Color"]( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = _constants_js__WEBPACK_IMPORTED_MODULE_1__["MultiplyOperation"];
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		return this;

	}

}

MeshBasicMaterial.prototype.isMeshBasicMaterial = true;




/***/ }),

/***/ "../../node_modules/three/src/materials/MeshDepthMaterial.js":
/*!***********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/materials/MeshDepthMaterial.js ***!
  \***********************************************************************************/
/*! exports provided: MeshDepthMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshDepthMaterial", function() { return MeshDepthMaterial; });
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Material.js */ "../../node_modules/three/src/materials/Material.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");



/**
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

class MeshDepthMaterial extends _Material_js__WEBPACK_IMPORTED_MODULE_0__["Material"] {

	constructor( parameters ) {

		super();

		this.type = 'MeshDepthMaterial';

		this.depthPacking = _constants_js__WEBPACK_IMPORTED_MODULE_1__["BasicDepthPacking"];

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.depthPacking = source.depthPacking;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	}

}

MeshDepthMaterial.prototype.isMeshDepthMaterial = true;




/***/ }),

/***/ "../../node_modules/three/src/materials/MeshDistanceMaterial.js":
/*!**************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/materials/MeshDistanceMaterial.js ***!
  \**************************************************************************************/
/*! exports provided: MeshDistanceMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshDistanceMaterial", function() { return MeshDistanceMaterial; });
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Material.js */ "../../node_modules/three/src/materials/Material.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");



/**
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */

class MeshDistanceMaterial extends _Material_js__WEBPACK_IMPORTED_MODULE_0__["Material"] {

	constructor( parameters ) {

		super();

		this.type = 'MeshDistanceMaterial';

		this.referencePosition = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
		this.nearDistance = 1;
		this.farDistance = 1000;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.fog = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.referencePosition.copy( source.referencePosition );
		this.nearDistance = source.nearDistance;
		this.farDistance = source.farDistance;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		return this;

	}

}

MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;




/***/ }),

/***/ "../../node_modules/three/src/materials/MeshLambertMaterial.js":
/*!*************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/materials/MeshLambertMaterial.js ***!
  \*************************************************************************************/
/*! exports provided: MeshLambertMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshLambertMaterial", function() { return MeshLambertMaterial; });
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Material.js */ "../../node_modules/three/src/materials/Material.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");




/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

class MeshLambertMaterial extends _Material_js__WEBPACK_IMPORTED_MODULE_0__["Material"] {

	constructor( parameters ) {

		super();

		this.type = 'MeshLambertMaterial';

		this.color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_2__["Color"]( 0xffffff ); // diffuse

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new _math_Color_js__WEBPACK_IMPORTED_MODULE_2__["Color"]( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = _constants_js__WEBPACK_IMPORTED_MODULE_1__["MultiplyOperation"];
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	}

}

MeshLambertMaterial.prototype.isMeshLambertMaterial = true;




/***/ }),

/***/ "../../node_modules/three/src/materials/MeshMatcapMaterial.js":
/*!************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/materials/MeshMatcapMaterial.js ***!
  \************************************************************************************/
/*! exports provided: MeshMatcapMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshMatcapMaterial", function() { return MeshMatcapMaterial; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Material.js */ "../../node_modules/three/src/materials/Material.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");





/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 *
 *  flatShading: <bool>
 * }
 */

class MeshMatcapMaterial extends _Material_js__WEBPACK_IMPORTED_MODULE_1__["Material"] {

	constructor( parameters ) {

		super();

		this.defines = { 'MATCAP': '' };

		this.type = 'MeshMatcapMaterial';

		this.color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_3__["Color"]( 0xffffff ); // diffuse

		this.matcap = null;

		this.map = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = _constants_js__WEBPACK_IMPORTED_MODULE_0__["TangentSpaceNormalMap"];
		this.normalScale = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.flatShading = false;

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.defines = { 'MATCAP': '' };

		this.color.copy( source.color );

		this.matcap = source.matcap;

		this.map = source.map;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.flatShading = source.flatShading;

		return this;

	}

}

MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;




/***/ }),

/***/ "../../node_modules/three/src/materials/MeshNormalMaterial.js":
/*!************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/materials/MeshNormalMaterial.js ***!
  \************************************************************************************/
/*! exports provided: MeshNormalMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshNormalMaterial", function() { return MeshNormalMaterial; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Material.js */ "../../node_modules/three/src/materials/Material.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");




/**
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  flatShading: <bool>
 * }
 */

class MeshNormalMaterial extends _Material_js__WEBPACK_IMPORTED_MODULE_1__["Material"] {

	constructor( parameters ) {

		super();

		this.type = 'MeshNormalMaterial';

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = _constants_js__WEBPACK_IMPORTED_MODULE_0__["TangentSpaceNormalMap"];
		this.normalScale = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.flatShading = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.flatShading = source.flatShading;

		return this;

	}

}

MeshNormalMaterial.prototype.isMeshNormalMaterial = true;




/***/ }),

/***/ "../../node_modules/three/src/materials/MeshPhongMaterial.js":
/*!***********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/materials/MeshPhongMaterial.js ***!
  \***********************************************************************************/
/*! exports provided: MeshPhongMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshPhongMaterial", function() { return MeshPhongMaterial; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Material.js */ "../../node_modules/three/src/materials/Material.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");





/**
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.MultiplyOperation,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  flatShading: <bool>
 * }
 */

class MeshPhongMaterial extends _Material_js__WEBPACK_IMPORTED_MODULE_1__["Material"] {

	constructor( parameters ) {

		super();

		this.type = 'MeshPhongMaterial';

		this.color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_3__["Color"]( 0xffffff ); // diffuse
		this.specular = new _math_Color_js__WEBPACK_IMPORTED_MODULE_3__["Color"]( 0x111111 );
		this.shininess = 30;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new _math_Color_js__WEBPACK_IMPORTED_MODULE_3__["Color"]( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = _constants_js__WEBPACK_IMPORTED_MODULE_0__["TangentSpaceNormalMap"];
		this.normalScale = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = _constants_js__WEBPACK_IMPORTED_MODULE_0__["MultiplyOperation"];
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.flatShading = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.flatShading = source.flatShading;

		return this;

	}

}

MeshPhongMaterial.prototype.isMeshPhongMaterial = true;




/***/ }),

/***/ "../../node_modules/three/src/materials/MeshPhysicalMaterial.js":
/*!**************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/materials/MeshPhysicalMaterial.js ***!
  \**************************************************************************************/
/*! exports provided: MeshPhysicalMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshPhysicalMaterial", function() { return MeshPhysicalMaterial; });
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _MeshStandardMaterial_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MeshStandardMaterial.js */ "../../node_modules/three/src/materials/MeshStandardMaterial.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");





/**
 * parameters = {
 *  clearcoat: <float>,
 *  clearcoatMap: new THREE.Texture( <Image> ),
 *  clearcoatRoughness: <float>,
 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
 *  clearcoatNormalScale: <Vector2>,
 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
 *
 *  reflectivity: <float>,
 *  ior: <float>,
 *
 *  sheen: <Color>,
 *
 *  transmission: <float>,
 *  transmissionMap: new THREE.Texture( <Image> )
 * }
 */

function MeshPhysicalMaterial( parameters ) {

	_MeshStandardMaterial_js__WEBPACK_IMPORTED_MODULE_1__["MeshStandardMaterial"].call( this );

	this.defines = {

		'STANDARD': '',
		'PHYSICAL': ''

	};

	this.type = 'MeshPhysicalMaterial';

	this.clearcoat = 0.0;
	this.clearcoatMap = null;
	this.clearcoatRoughness = 0.0;
	this.clearcoatRoughnessMap = null;
	this.clearcoatNormalScale = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]( 1, 1 );
	this.clearcoatNormalMap = null;

	this.reflectivity = 0.5; // maps to F0 = 0.04

	Object.defineProperty( this, 'ior', {
		get: function () {

			return ( 1 + 0.4 * this.reflectivity ) / ( 1 - 0.4 * this.reflectivity );

		},
		set: function ( ior ) {

			this.reflectivity = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__["MathUtils"].clamp( 2.5 * ( ior - 1 ) / ( ior + 1 ), 0, 1 );

		}
	} );

	this.sheen = null; // null will disable sheen bsdf

	this.transmission = 0.0;
	this.transmissionMap = null;

	this.setValues( parameters );

}

MeshPhysicalMaterial.prototype = Object.create( _MeshStandardMaterial_js__WEBPACK_IMPORTED_MODULE_1__["MeshStandardMaterial"].prototype );
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

MeshPhysicalMaterial.prototype.copy = function ( source ) {

	_MeshStandardMaterial_js__WEBPACK_IMPORTED_MODULE_1__["MeshStandardMaterial"].prototype.copy.call( this, source );

	this.defines = {

		'STANDARD': '',
		'PHYSICAL': ''

	};

	this.clearcoat = source.clearcoat;
	this.clearcoatMap = source.clearcoatMap;
	this.clearcoatRoughness = source.clearcoatRoughness;
	this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
	this.clearcoatNormalMap = source.clearcoatNormalMap;
	this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

	this.reflectivity = source.reflectivity;

	if ( source.sheen ) {

		this.sheen = ( this.sheen || new _math_Color_js__WEBPACK_IMPORTED_MODULE_2__["Color"]() ).copy( source.sheen );

	} else {

		this.sheen = null;

	}

	this.transmission = source.transmission;
	this.transmissionMap = source.transmissionMap;

	return this;

};




/***/ }),

/***/ "../../node_modules/three/src/materials/MeshStandardMaterial.js":
/*!**************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/materials/MeshStandardMaterial.js ***!
  \**************************************************************************************/
/*! exports provided: MeshStandardMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshStandardMaterial", function() { return MeshStandardMaterial; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Material.js */ "../../node_modules/three/src/materials/Material.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");





/**
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  flatShading: <bool>
 * }
 */

function MeshStandardMaterial( parameters ) {

	_Material_js__WEBPACK_IMPORTED_MODULE_1__["Material"].call( this );

	this.defines = { 'STANDARD': '' };

	this.type = 'MeshStandardMaterial';

	this.color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_3__["Color"]( 0xffffff ); // diffuse
	this.roughness = 1.0;
	this.metalness = 0.0;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new _math_Color_js__WEBPACK_IMPORTED_MODULE_3__["Color"]( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalMapType = _constants_js__WEBPACK_IMPORTED_MODULE_0__["TangentSpaceNormalMap"];
	this.normalScale = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.roughnessMap = null;

	this.metalnessMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.envMapIntensity = 1.0;

	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.flatShading = false;

	this.vertexTangents = false;

	this.setValues( parameters );

}

MeshStandardMaterial.prototype = Object.create( _Material_js__WEBPACK_IMPORTED_MODULE_1__["Material"].prototype );
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

MeshStandardMaterial.prototype.copy = function ( source ) {

	_Material_js__WEBPACK_IMPORTED_MODULE_1__["Material"].prototype.copy.call( this, source );

	this.defines = { 'STANDARD': '' };

	this.color.copy( source.color );
	this.roughness = source.roughness;
	this.metalness = source.metalness;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalMapType = source.normalMapType;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.roughnessMap = source.roughnessMap;

	this.metalnessMap = source.metalnessMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.envMapIntensity = source.envMapIntensity;

	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.flatShading = source.flatShading;

	this.vertexTangents = source.vertexTangents;

	return this;

};





/***/ }),

/***/ "../../node_modules/three/src/materials/MeshToonMaterial.js":
/*!**********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/materials/MeshToonMaterial.js ***!
  \**********************************************************************************/
/*! exports provided: MeshToonMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshToonMaterial", function() { return MeshToonMaterial; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Material.js */ "../../node_modules/three/src/materials/Material.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");





/**
 * parameters = {
 *  color: <hex>,
 *
 *  map: new THREE.Texture( <Image> ),
 *  gradientMap: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

class MeshToonMaterial extends _Material_js__WEBPACK_IMPORTED_MODULE_1__["Material"] {

	constructor( parameters ) {

		super();

		this.defines = { 'TOON': '' };

		this.type = 'MeshToonMaterial';

		this.color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_3__["Color"]( 0xffffff );

		this.map = null;
		this.gradientMap = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new _math_Color_js__WEBPACK_IMPORTED_MODULE_3__["Color"]( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = _constants_js__WEBPACK_IMPORTED_MODULE_0__["TangentSpaceNormalMap"];
		this.normalScale = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;
		this.gradientMap = source.gradientMap;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	}

}

MeshToonMaterial.prototype.isMeshToonMaterial = true;




/***/ }),

/***/ "../../node_modules/three/src/materials/PointsMaterial.js":
/*!********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/materials/PointsMaterial.js ***!
  \********************************************************************************/
/*! exports provided: PointsMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointsMaterial", function() { return PointsMaterial; });
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Material.js */ "../../node_modules/three/src/materials/Material.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");



/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */

class PointsMaterial extends _Material_js__WEBPACK_IMPORTED_MODULE_0__["Material"] {

	constructor( parameters ) {

		super();

		this.type = 'PointsMaterial';

		this.color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_1__["Color"]( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.morphTargets = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		this.morphTargets = source.morphTargets;

		return this;

	}

}

PointsMaterial.prototype.isPointsMaterial = true;




/***/ }),

/***/ "../../node_modules/three/src/materials/RawShaderMaterial.js":
/*!***********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/materials/RawShaderMaterial.js ***!
  \***********************************************************************************/
/*! exports provided: RawShaderMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RawShaderMaterial", function() { return RawShaderMaterial; });
/* harmony import */ var _ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ShaderMaterial.js */ "../../node_modules/three/src/materials/ShaderMaterial.js");


class RawShaderMaterial extends _ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_0__["ShaderMaterial"] {

	constructor( parameters ) {

		super( parameters );

		this.type = 'RawShaderMaterial';

	}

}

RawShaderMaterial.prototype.isRawShaderMaterial = true;




/***/ }),

/***/ "../../node_modules/three/src/materials/ShaderMaterial.js":
/*!********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/materials/ShaderMaterial.js ***!
  \********************************************************************************/
/*! exports provided: ShaderMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderMaterial", function() { return ShaderMaterial; });
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Material.js */ "../../node_modules/three/src/materials/Material.js");
/* harmony import */ var _renderers_shaders_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderers/shaders/UniformsUtils.js */ "../../node_modules/three/src/renderers/shaders/UniformsUtils.js");
/* harmony import */ var _renderers_shaders_ShaderChunk_default_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderers/shaders/ShaderChunk/default_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/default_vertex.glsl.js");
/* harmony import */ var _renderers_shaders_ShaderChunk_default_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderers/shaders/ShaderChunk/default_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/default_fragment.glsl.js");






/**
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function ShaderMaterial( parameters ) {

	_Material_js__WEBPACK_IMPORTED_MODULE_0__["Material"].call( this );

	this.type = 'ShaderMaterial';

	this.defines = {};
	this.uniforms = {};

	this.vertexShader = _renderers_shaders_ShaderChunk_default_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_2__["default"];
	this.fragmentShader = _renderers_shaders_ShaderChunk_default_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_3__["default"];

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog
	this.lights = false; // set to use scene lights
	this.clipping = false; // set to use user-defined clipping planes

	this.skinning = false; // set to use skinning attribute streams
	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	this.extensions = {
		derivatives: false, // set to use derivatives
		fragDepth: false, // set to use fragment depth values
		drawBuffers: false, // set to use draw buffers
		shaderTextureLOD: false // set to use shader texture LOD
	};

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		'color': [ 1, 1, 1 ],
		'uv': [ 0, 0 ],
		'uv2': [ 0, 0 ]
	};

	this.index0AttributeName = undefined;
	this.uniformsNeedUpdate = false;

	this.glslVersion = null;

	if ( parameters !== undefined ) {

		if ( parameters.attributes !== undefined ) {

			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

		}

		this.setValues( parameters );

	}

}

ShaderMaterial.prototype = Object.create( _Material_js__WEBPACK_IMPORTED_MODULE_0__["Material"].prototype );
ShaderMaterial.prototype.constructor = ShaderMaterial;

ShaderMaterial.prototype.isShaderMaterial = true;

ShaderMaterial.prototype.copy = function ( source ) {

	_Material_js__WEBPACK_IMPORTED_MODULE_0__["Material"].prototype.copy.call( this, source );

	this.fragmentShader = source.fragmentShader;
	this.vertexShader = source.vertexShader;

	this.uniforms = Object(_renderers_shaders_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["cloneUniforms"])( source.uniforms );

	this.defines = Object.assign( {}, source.defines );

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.lights = source.lights;
	this.clipping = source.clipping;

	this.skinning = source.skinning;

	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.extensions = Object.assign( {}, source.extensions );

	this.glslVersion = source.glslVersion;

	return this;

};

ShaderMaterial.prototype.toJSON = function ( meta ) {

	const data = _Material_js__WEBPACK_IMPORTED_MODULE_0__["Material"].prototype.toJSON.call( this, meta );

	data.glslVersion = this.glslVersion;
	data.uniforms = {};

	for ( const name in this.uniforms ) {

		const uniform = this.uniforms[ name ];
		const value = uniform.value;

		if ( value && value.isTexture ) {

			data.uniforms[ name ] = {
				type: 't',
				value: value.toJSON( meta ).uuid
			};

		} else if ( value && value.isColor ) {

			data.uniforms[ name ] = {
				type: 'c',
				value: value.getHex()
			};

		} else if ( value && value.isVector2 ) {

			data.uniforms[ name ] = {
				type: 'v2',
				value: value.toArray()
			};

		} else if ( value && value.isVector3 ) {

			data.uniforms[ name ] = {
				type: 'v3',
				value: value.toArray()
			};

		} else if ( value && value.isVector4 ) {

			data.uniforms[ name ] = {
				type: 'v4',
				value: value.toArray()
			};

		} else if ( value && value.isMatrix3 ) {

			data.uniforms[ name ] = {
				type: 'm3',
				value: value.toArray()
			};

		} else if ( value && value.isMatrix4 ) {

			data.uniforms[ name ] = {
				type: 'm4',
				value: value.toArray()
			};

		} else {

			data.uniforms[ name ] = {
				value: value
			};

			// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

		}

	}

	if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

	data.vertexShader = this.vertexShader;
	data.fragmentShader = this.fragmentShader;

	const extensions = {};

	for ( const key in this.extensions ) {

		if ( this.extensions[ key ] === true ) extensions[ key ] = true;

	}

	if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

	return data;

};





/***/ }),

/***/ "../../node_modules/three/src/materials/ShadowMaterial.js":
/*!********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/materials/ShadowMaterial.js ***!
  \********************************************************************************/
/*! exports provided: ShadowMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMaterial", function() { return ShadowMaterial; });
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Material.js */ "../../node_modules/three/src/materials/Material.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");



/**
 * parameters = {
 *  color: <THREE.Color>
 * }
 */

class ShadowMaterial extends _Material_js__WEBPACK_IMPORTED_MODULE_0__["Material"] {

	constructor( parameters ) {

		super();

		this.type = 'ShadowMaterial';

		this.color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_1__["Color"]( 0x000000 );
		this.transparent = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		return this;

	}

}

ShadowMaterial.prototype.isShadowMaterial = true;




/***/ }),

/***/ "../../node_modules/three/src/materials/SpriteMaterial.js":
/*!********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/materials/SpriteMaterial.js ***!
  \********************************************************************************/
/*! exports provided: SpriteMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteMaterial", function() { return SpriteMaterial; });
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Material.js */ "../../node_modules/three/src/materials/Material.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");



/**
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */

class SpriteMaterial extends _Material_js__WEBPACK_IMPORTED_MODULE_0__["Material"] {

	constructor( parameters ) {

		super();

		this.type = 'SpriteMaterial';

		this.color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_1__["Color"]( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.rotation = 0;

		this.sizeAttenuation = true;

		this.transparent = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.rotation = source.rotation;

		this.sizeAttenuation = source.sizeAttenuation;

		return this;

	}

}

SpriteMaterial.prototype.isSpriteMaterial = true;




/***/ }),

/***/ "../../node_modules/three/src/math/Box2.js":
/*!*****************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/Box2.js ***!
  \*****************************************************************/
/*! exports provided: Box2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box2", function() { return Box2; });
/* harmony import */ var _Vector2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector2.js */ "../../node_modules/three/src/math/Vector2.js");


const _vector = /*@__PURE__*/ new _Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();

class Box2 {

	constructor( min = new _Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]( + Infinity, + Infinity ), max = new _Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]( - Infinity, - Infinity ) ) {

		this.min = min;
		this.max = max;

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector.copy( size ).multiplyScalar( 0.5 );
		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = + Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	}

	getCenter( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .getCenter() target is now required' );
			target = new _Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();

		}

		return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .getSize() target is now required' );
			target = new _Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();

		}

		return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	containsPoint( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ? false : true;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .getParameter() target is now required' );
			target = new _Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();

		}

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	}

	intersectsBox( box ) {

		// using 4 splitting planes to rule out intersections

		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

	}

	clampPoint( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .clampPoint() target is now required' );
			target = new _Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();

		}

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		const clampedPoint = _vector.copy( point ).clamp( this.min, this.max );
		return clampedPoint.sub( point ).length();

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

Box2.prototype.isBox2 = true;




/***/ }),

/***/ "../../node_modules/three/src/math/Box3.js":
/*!*****************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/Box3.js ***!
  \*****************************************************************/
/*! exports provided: Box3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box3", function() { return Box3; });
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3.js */ "../../node_modules/three/src/math/Vector3.js");


class Box3 {

	constructor( min = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]( + Infinity, + Infinity, + Infinity ), max = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]( - Infinity, - Infinity, - Infinity ) ) {

		this.min = min;
		this.max = max;

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromArray( array ) {

		let minX = + Infinity;
		let minY = + Infinity;
		let minZ = + Infinity;

		let maxX = - Infinity;
		let maxY = - Infinity;
		let maxZ = - Infinity;

		for ( let i = 0, l = array.length; i < l; i += 3 ) {

			const x = array[ i ];
			const y = array[ i + 1 ];
			const z = array[ i + 2 ];

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	}

	setFromBufferAttribute( attribute ) {

		let minX = + Infinity;
		let minY = + Infinity;
		let minZ = + Infinity;

		let maxX = - Infinity;
		let maxY = - Infinity;
		let maxZ = - Infinity;

		for ( let i = 0, l = attribute.count; i < l; i ++ ) {

			const x = attribute.getX( i );
			const y = attribute.getY( i );
			const z = attribute.getZ( i );

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector.copy( size ).multiplyScalar( 0.5 );

		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	setFromObject( object ) {

		this.makeEmpty();

		return this.expandByObject( object );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	}

	getCenter( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getCenter() target is now required' );
			target = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

		}

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getSize() target is now required' );
			target = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

		}

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	expandByObject( object ) {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		object.updateWorldMatrix( false, false );

		const geometry = object.geometry;

		if ( geometry !== undefined ) {

			if ( geometry.boundingBox === null ) {

				geometry.computeBoundingBox();

			}

			_box.copy( geometry.boundingBox );
			_box.applyMatrix4( object.matrixWorld );

			this.union( _box );

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			this.expandByObject( children[ i ] );

		}

		return this;

	}

	containsPoint( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ||
			point.z < this.min.z || point.z > this.max.z ? false : true;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getParameter() target is now required' );
			target = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

		}

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	}

	intersectsBox( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ||
			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

	}

	intersectsSphere( sphere ) {

		// Find the point on the AABB closest to the sphere center.
		this.clampPoint( sphere.center, _vector );

		// If that point is inside the sphere, the AABB and sphere intersect.
		return _vector.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	intersectsPlane( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		let min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= - plane.constant && max >= - plane.constant );

	}

	intersectsTriangle( triangle ) {

		if ( this.isEmpty() ) {

			return false;

		}

		// compute box center and extents
		this.getCenter( _center );
		_extents.subVectors( this.max, _center );

		// translate triangle to aabb origin
		_v0.subVectors( triangle.a, _center );
		_v1.subVectors( triangle.b, _center );
		_v2.subVectors( triangle.c, _center );

		// compute edge vectors for triangle
		_f0.subVectors( _v1, _v0 );
		_f1.subVectors( _v2, _v1 );
		_f2.subVectors( _v0, _v2 );

		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		let axes = [
			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
		];
		if ( ! satForAxes( axes, _v0, _v1, _v2, _extents ) ) {

			return false;

		}

		// test 3 face normals from the aabb
		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
		if ( ! satForAxes( axes, _v0, _v1, _v2, _extents ) ) {

			return false;

		}

		// finally testing the face normal of the triangle
		// use already existing triangle edge vectors here
		_triangleNormal.crossVectors( _f0, _f1 );
		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

		return satForAxes( axes, _v0, _v1, _v2, _extents );

	}

	clampPoint( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .clampPoint() target is now required' );
			target = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

		}

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		const clampedPoint = _vector.copy( point ).clamp( this.min, this.max );

		return clampedPoint.sub( point ).length();

	}

	getBoundingSphere( target ) {

		if ( target === undefined ) {

			console.error( 'THREE.Box3: .getBoundingSphere() target is now required' );
			//target = new Sphere(); // removed to avoid cyclic dependency

		}

		this.getCenter( target.center );

		target.radius = this.getSize( _vector ).length() * 0.5;

		return target;

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if ( this.isEmpty() ) this.makeEmpty();

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	applyMatrix4( matrix ) {

		// transform of empty box is an empty box.
		if ( this.isEmpty() ) return this;

		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

		this.setFromPoints( _points );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

Box3.prototype.isBox3 = true;

const _points = [
	/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
	/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
	/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
	/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
	/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
	/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
	/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
	/*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]()
];

const _vector = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

const _box = /*@__PURE__*/ new Box3();

// triangle centered vertices

const _v0 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _v1 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _v2 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

// triangle edge vectors

const _f0 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _f1 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _f2 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

const _center = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _extents = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _triangleNormal = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _testAxis = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

function satForAxes( axes, v0, v1, v2, extents ) {

	for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

		_testAxis.fromArray( axes, i );
		// project the aabb onto the seperating axis
		const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
		// project all 3 vertices of the triangle onto the seperating axis
		const p0 = v0.dot( _testAxis );
		const p1 = v1.dot( _testAxis );
		const p2 = v2.dot( _testAxis );
		// actual test, basically see if either of the most extreme of the triangle points intersects r
		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

			// points of the projected triangle are outside the projected half-length of the aabb
			// the axis is seperating and we can exit
			return false;

		}

	}

	return true;

}




/***/ }),

/***/ "../../node_modules/three/src/math/Color.js":
/*!******************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/Color.js ***!
  \******************************************************************/
/*! exports provided: Color */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");


const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };

function hue2rgb( p, q, t ) {

	if ( t < 0 ) t += 1;
	if ( t > 1 ) t -= 1;
	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
	if ( t < 1 / 2 ) return q;
	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
	return p;

}

function SRGBToLinear( c ) {

	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

}

function LinearToSRGB( c ) {

	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

}

class Color {

	constructor( r, g, b ) {

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string
			return this.set( r );

		}

		return this.setRGB( r, g, b );

	}

	set( value ) {

		if ( value && value.isColor ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	}

	setScalar( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	}

	setHex( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	}

	setRGB( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	}

	setHSL( h, s, l ) {

		// h,s,l ranges are in 0.0 - 1.0
		h = _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].euclideanModulo( h, 1 );
		s = _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].clamp( s, 0, 1 );
		l = _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].clamp( l, 0, 1 );

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			const q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		return this;

	}

	setStyle( style ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		let m;

		if ( m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			let color;
			const name = m[ 1 ];
			const components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						handleAlpha( color[ 4 ] );

						return this;

					}

					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						handleAlpha( color[ 4 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						const h = parseFloat( color[ 1 ] ) / 360;
						const s = parseInt( color[ 2 ], 10 ) / 100;
						const l = parseInt( color[ 3 ], 10 ) / 100;

						handleAlpha( color[ 4 ] );

						return this.setHSL( h, s, l );

					}

					break;

			}

		} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

			// hex color

			const hex = m[ 1 ];
			const size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				return this;

			}

		}

		if ( style && style.length > 0 ) {

			return this.setColorName( style );

		}

		return this;

	}

	setColorName( style ) {

		// color keywords
		const hex = _colorKeywords[ style ];

		if ( hex !== undefined ) {

			// red
			this.setHex( hex );

		} else {

			// unknown color
			console.warn( 'THREE.Color: Unknown color ' + style );

		}

		return this;

	}

	clone() {

		return new this.constructor( this.r, this.g, this.b );

	}

	copy( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	}

	copyGammaToLinear( color, gammaFactor = 2.0 ) {

		this.r = Math.pow( color.r, gammaFactor );
		this.g = Math.pow( color.g, gammaFactor );
		this.b = Math.pow( color.b, gammaFactor );

		return this;

	}

	copyLinearToGamma( color, gammaFactor = 2.0 ) {

		const safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

		this.r = Math.pow( color.r, safeInverse );
		this.g = Math.pow( color.g, safeInverse );
		this.b = Math.pow( color.b, safeInverse );

		return this;

	}

	convertGammaToLinear( gammaFactor ) {

		this.copyGammaToLinear( this, gammaFactor );

		return this;

	}

	convertLinearToGamma( gammaFactor ) {

		this.copyLinearToGamma( this, gammaFactor );

		return this;

	}

	copySRGBToLinear( color ) {

		this.r = SRGBToLinear( color.r );
		this.g = SRGBToLinear( color.g );
		this.b = SRGBToLinear( color.b );

		return this;

	}

	copyLinearToSRGB( color ) {

		this.r = LinearToSRGB( color.r );
		this.g = LinearToSRGB( color.g );
		this.b = LinearToSRGB( color.b );

		return this;

	}

	convertSRGBToLinear() {

		this.copySRGBToLinear( this );

		return this;

	}

	convertLinearToSRGB() {

		this.copyLinearToSRGB( this );

		return this;

	}

	getHex() {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	}

	getHexString() {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	}

	getHSL( target ) {

		// h,s,l ranges are in 0.0 - 1.0

		if ( target === undefined ) {

			console.warn( 'THREE.Color: .getHSL() target is now required' );
			target = { h: 0, s: 0, l: 0 };

		}

		const r = this.r, g = this.g, b = this.b;

		const max = Math.max( r, g, b );
		const min = Math.min( r, g, b );

		let hue, saturation;
		const lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			const delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		target.h = hue;
		target.s = saturation;
		target.l = lightness;

		return target;

	}

	getStyle() {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	}

	offsetHSL( h, s, l ) {

		this.getHSL( _hslA );

		_hslA.h += h; _hslA.s += s; _hslA.l += l;

		this.setHSL( _hslA.h, _hslA.s, _hslA.l );

		return this;

	}

	add( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	}

	addColors( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	}

	addScalar( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	}

	sub( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	}

	multiply( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	}

	multiplyScalar( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	}

	lerp( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	}

	lerpColors( color1, color2, alpha ) {

		this.r = color1.r + ( color2.r - color1.r ) * alpha;
		this.g = color1.g + ( color2.g - color1.g ) * alpha;
		this.b = color1.b + ( color2.b - color1.b ) * alpha;

		return this;

	}

	lerpHSL( color, alpha ) {

		this.getHSL( _hslA );
		color.getHSL( _hslB );

		const h = _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].lerp( _hslA.h, _hslB.h, alpha );
		const s = _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].lerp( _hslA.s, _hslB.s, alpha );
		const l = _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].lerp( _hslA.l, _hslB.l, alpha );

		this.setHSL( h, s, l );

		return this;

	}

	equals( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	}

	fromArray( array, offset = 0 ) {

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.r = attribute.getX( index );
		this.g = attribute.getY( index );
		this.b = attribute.getZ( index );

		if ( attribute.normalized === true ) {

			// assuming Uint8Array

			this.r /= 255;
			this.g /= 255;
			this.b /= 255;

		}

		return this;

	}

	toJSON() {

		return this.getHex();

	}

}

Color.NAMES = _colorKeywords;

Color.prototype.isColor = true;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;




/***/ }),

/***/ "../../node_modules/three/src/math/Cylindrical.js":
/*!************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/Cylindrical.js ***!
  \************************************************************************/
/*! exports provided: Cylindrical */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cylindrical", function() { return Cylindrical; });
/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */

class Cylindrical {

	constructor( radius = 1, theta = 0, y = 0 ) {

		this.radius = radius; // distance from the origin to a point in the x-z plane
		this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
		this.y = y; // height above the x-z plane

		return this;

	}

	set( radius, theta, y ) {

		this.radius = radius;
		this.theta = theta;
		this.y = y;

		return this;

	}

	copy( other ) {

		this.radius = other.radius;
		this.theta = other.theta;
		this.y = other.y;

		return this;

	}

	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + z * z );
		this.theta = Math.atan2( x, z );
		this.y = y;

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}




/***/ }),

/***/ "../../node_modules/three/src/math/Euler.js":
/*!******************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/Euler.js ***!
  \******************************************************************/
/*! exports provided: Euler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Euler", function() { return Euler; });
/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Quaternion.js */ "../../node_modules/three/src/math/Quaternion.js");
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _Matrix4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Matrix4.js */ "../../node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");





const _matrix = /*@__PURE__*/ new _Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();
const _quaternion = /*@__PURE__*/ new _Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();

class Euler {

	constructor( x = 0, y = 0, z = 0, order = Euler.DefaultOrder ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get order() {

		return this._order;

	}

	set order( value ) {

		this._order = value;
		this._onChangeCallback();

	}

	set( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._order );

	}

	copy( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m, order, update ) {

		const clamp = _MathUtils_js__WEBPACK_IMPORTED_MODULE_3__["MathUtils"].clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements;
		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		switch ( order ) {

			case 'XYZ':

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

				break;

			case 'YXZ':

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

				break;

			case 'ZXY':

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

				break;

			case 'ZYX':

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

				break;

			case 'YZX':

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

				break;

			case 'XZY':

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

				break;

			default:

				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		}

		this._order = order;

		if ( update !== false ) this._onChangeCallback();

		return this;

	}

	setFromQuaternion( q, order, update ) {

		_matrix.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix, order, update );

	}

	setFromVector3( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	}

	reorder( newOrder ) {

		// WARNING: this discards revolution information -bhouston

		_quaternion.setFromEuler( this );

		return this.setFromQuaternion( _quaternion, newOrder );

	}

	equals( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	}

	fromArray( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	}

	toVector3( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( this._x, this._y, this._z );

		}

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

}

Euler.prototype.isEuler = true;

Euler.DefaultOrder = 'XYZ';
Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];




/***/ }),

/***/ "../../node_modules/three/src/math/Frustum.js":
/*!********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/Frustum.js ***!
  \********************************************************************/
/*! exports provided: Frustum */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Frustum", function() { return Frustum; });
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _Sphere_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Sphere.js */ "../../node_modules/three/src/math/Sphere.js");
/* harmony import */ var _Plane_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Plane.js */ "../../node_modules/three/src/math/Plane.js");




const _sphere = /*@__PURE__*/ new _Sphere_js__WEBPACK_IMPORTED_MODULE_1__["Sphere"]();
const _vector = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

class Frustum {

	constructor( p0 = new _Plane_js__WEBPACK_IMPORTED_MODULE_2__["Plane"](), p1 = new _Plane_js__WEBPACK_IMPORTED_MODULE_2__["Plane"](), p2 = new _Plane_js__WEBPACK_IMPORTED_MODULE_2__["Plane"](), p3 = new _Plane_js__WEBPACK_IMPORTED_MODULE_2__["Plane"](), p4 = new _Plane_js__WEBPACK_IMPORTED_MODULE_2__["Plane"](), p5 = new _Plane_js__WEBPACK_IMPORTED_MODULE_2__["Plane"]() ) {

		this.planes = [ p0, p1, p2, p3, p4, p5 ];

	}

	set( p0, p1, p2, p3, p4, p5 ) {

		const planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	}

	copy( frustum ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	}

	setFromProjectionMatrix( m ) {

		const planes = this.planes;
		const me = m.elements;
		const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	}

	intersectsObject( object ) {

		const geometry = object.geometry;

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

		return this.intersectsSphere( _sphere );

	}

	intersectsSprite( sprite ) {

		_sphere.center.set( 0, 0, 0 );
		_sphere.radius = 0.7071067811865476;
		_sphere.applyMatrix4( sprite.matrixWorld );

		return this.intersectsSphere( _sphere );

	}

	intersectsSphere( sphere ) {

		const planes = this.planes;
		const center = sphere.center;
		const negRadius = - sphere.radius;

		for ( let i = 0; i < 6; i ++ ) {

			const distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	}

	intersectsBox( box ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			const plane = planes[ i ];

			// corner at max distance

			_vector.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			_vector.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			_vector.z = plane.normal.z > 0 ? box.max.z : box.min.z;

			if ( plane.distanceToPoint( _vector ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	containsPoint( point ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}





/***/ }),

/***/ "../../node_modules/three/src/math/Interpolant.js":
/*!************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/Interpolant.js ***!
  \************************************************************************/
/*! exports provided: Interpolant */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Interpolant", function() { return Interpolant; });
/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */

function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	this.parameterPositions = parameterPositions;
	this._cachedIndex = 0;

	this.resultBuffer = resultBuffer !== undefined ?
		resultBuffer : new sampleValues.constructor( sampleSize );
	this.sampleValues = sampleValues;
	this.valueSize = sampleSize;

}

Object.assign( Interpolant.prototype, {

	evaluate: function ( t ) {

		const pp = this.parameterPositions;
		let i1 = this._cachedIndex,
			t1 = pp[ i1 ],
			t0 = pp[ i1 - 1 ];

		validate_interval: {

			seek: {

				let right;

				linear_scan: {

					//- See http://jsperf.com/comparison-to-undefined/3
					//- slower code:
					//-
					//- 				if ( t >= t1 || t1 === undefined ) {
					forward_scan: if ( ! ( t < t1 ) ) {

						for ( let giveUpAt = i1 + 2; ; ) {

							if ( t1 === undefined ) {

								if ( t < t0 ) break forward_scan;

								// after end

								i1 = pp.length;
								this._cachedIndex = i1;
								return this.afterEnd_( i1 - 1, t, t0 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t0 = t1;
							t1 = pp[ ++ i1 ];

							if ( t < t1 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the right side of the index
						right = pp.length;
						break linear_scan;

					}

					//- slower code:
					//-					if ( t < t0 || t0 === undefined ) {
					if ( ! ( t >= t0 ) ) {

						// looping?

						const t1global = pp[ 1 ];

						if ( t < t1global ) {

							i1 = 2; // + 1, using the scan for the details
							t0 = t1global;

						}

						// linear reverse scan

						for ( let giveUpAt = i1 - 2; ; ) {

							if ( t0 === undefined ) {

								// before start

								this._cachedIndex = 0;
								return this.beforeStart_( 0, t, t1 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t1 = t0;
							t0 = pp[ -- i1 - 1 ];

							if ( t >= t0 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the left side of the index
						right = i1;
						i1 = 0;
						break linear_scan;

					}

					// the interval is valid

					break validate_interval;

				} // linear scan

				// binary search

				while ( i1 < right ) {

					const mid = ( i1 + right ) >>> 1;

					if ( t < pp[ mid ] ) {

						right = mid;

					} else {

						i1 = mid + 1;

					}

				}

				t1 = pp[ i1 ];
				t0 = pp[ i1 - 1 ];

				// check boundary cases, again

				if ( t0 === undefined ) {

					this._cachedIndex = 0;
					return this.beforeStart_( 0, t, t1 );

				}

				if ( t1 === undefined ) {

					i1 = pp.length;
					this._cachedIndex = i1;
					return this.afterEnd_( i1 - 1, t0, t );

				}

			} // seek

			this._cachedIndex = i1;

			this.intervalChanged_( i1, t0, t1 );

		} // validate_interval

		return this.interpolate_( i1, t0, t, t1 );

	},

	settings: null, // optional, subclass-specific settings structure
	// Note: The indirection allows central control of many interpolants.

	// --- Protected interface

	DefaultSettings_: {},

	getSettings_: function () {

		return this.settings || this.DefaultSettings_;

	},

	copySampleValue_: function ( index ) {

		// copies a sample value to the result buffer

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	},

	// Template methods for derived classes:

	interpolate_: function ( /* i1, t0, t, t1 */ ) {

		throw new Error( 'call to abstract method' );
		// implementations shall return this.resultBuffer

	},

	intervalChanged_: function ( /* i1, t0, t1 */ ) {

		// empty

	}

} );

// DECLARE ALIAS AFTER assign prototype
Object.assign( Interpolant.prototype, {

	//( 0, t, t0 ), returns this.resultBuffer
	beforeStart_: Interpolant.prototype.copySampleValue_,

	//( N-1, tN-1, t ), returns this.resultBuffer
	afterEnd_: Interpolant.prototype.copySampleValue_,

} );





/***/ }),

/***/ "../../node_modules/three/src/math/Line3.js":
/*!******************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/Line3.js ***!
  \******************************************************************/
/*! exports provided: Line3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line3", function() { return Line3; });
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");



const _startP = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _startEnd = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

class Line3 {

	constructor( start = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), end = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]() ) {

		this.start = start;
		this.end = end;

	}

	set( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	}

	copy( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	}

	getCenter( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .getCenter() target is now required' );
			target = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

		}

		return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	}

	delta( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .delta() target is now required' );
			target = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

		}

		return target.subVectors( this.end, this.start );

	}

	distanceSq() {

		return this.start.distanceToSquared( this.end );

	}

	distance() {

		return this.start.distanceTo( this.end );

	}

	at( t, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .at() target is now required' );
			target = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

		}

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	closestPointToPointParameter( point, clampToLine ) {

		_startP.subVectors( point, this.start );
		_startEnd.subVectors( this.end, this.start );

		const startEnd2 = _startEnd.dot( _startEnd );
		const startEnd_startP = _startEnd.dot( _startP );

		let t = startEnd_startP / startEnd2;

		if ( clampToLine ) {

			t = _MathUtils_js__WEBPACK_IMPORTED_MODULE_1__["MathUtils"].clamp( t, 0, 1 );

		}

		return t;

	}

	closestPointToPoint( point, clampToLine, target ) {

		const t = this.closestPointToPointParameter( point, clampToLine );

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );
			target = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

		}

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	applyMatrix4( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	}

	equals( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}




/***/ }),

/***/ "../../node_modules/three/src/math/MathUtils.js":
/*!**********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/MathUtils.js ***!
  \**********************************************************************/
/*! exports provided: MathUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MathUtils", function() { return MathUtils; });
const _lut = [];

for ( let i = 0; i < 256; i ++ ) {

	_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

}

let _seed = 1234567;

const MathUtils = {

	DEG2RAD: Math.PI / 180,
	RAD2DEG: 180 / Math.PI,

	generateUUID: function () {

		// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

		const d0 = Math.random() * 0xffffffff | 0;
		const d1 = Math.random() * 0xffffffff | 0;
		const d2 = Math.random() * 0xffffffff | 0;
		const d3 = Math.random() * 0xffffffff | 0;
		const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

		// .toUpperCase() here flattens concatenated strings to save heap memory space.
		return uuid.toUpperCase();

	},

	clamp: function ( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	},

	// compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation

	euclideanModulo: function ( n, m ) {

		return ( ( n % m ) + m ) % m;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/

	inverseLerp: function ( x, y, value ) {

		if ( x !== y ) {

			return ( value - x ) / ( y - x );

		 } else {

			return 0;

		 }

	},

	// https://en.wikipedia.org/wiki/Linear_interpolation

	lerp: function ( x, y, t ) {

		return ( 1 - t ) * x + t * y;

	},

	// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/

	damp: function ( x, y, lambda, dt ) {

		return MathUtils.lerp( x, y, 1 - Math.exp( - lambda * dt ) );

	},

	// https://www.desmos.com/calculator/vcsjnyz7x4

	pingpong: function ( x, length = 1 ) {

		return length - Math.abs( MathUtils.euclideanModulo( x, length * 2 ) - length );

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	// Deterministic pseudo-random float in the interval [ 0, 1 ]

	seededRandom: function ( s ) {

		if ( s !== undefined ) _seed = s % 2147483647;

		// Park-Miller algorithm

		_seed = _seed * 16807 % 2147483647;

		return ( _seed - 1 ) / 2147483646;

	},

	degToRad: function ( degrees ) {

		return degrees * MathUtils.DEG2RAD;

	},

	radToDeg: function ( radians ) {

		return radians * MathUtils.RAD2DEG;

	},

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	},

	ceilPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

	},

	floorPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

	},

	setQuaternionFromProperEuler: function ( q, a, b, c, order ) {

		// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

		// rotations are applied to the axes in the order specified by 'order'
		// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
		// angles are in radians

		const cos = Math.cos;
		const sin = Math.sin;

		const c2 = cos( b / 2 );
		const s2 = sin( b / 2 );

		const c13 = cos( ( a + c ) / 2 );
		const s13 = sin( ( a + c ) / 2 );

		const c1_3 = cos( ( a - c ) / 2 );
		const s1_3 = sin( ( a - c ) / 2 );

		const c3_1 = cos( ( c - a ) / 2 );
		const s3_1 = sin( ( c - a ) / 2 );

		switch ( order ) {

			case 'XYX':
				q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
				break;

			case 'YZY':
				q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
				break;

			case 'ZXZ':
				q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
				break;

			case 'XZX':
				q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
				break;

			case 'YXY':
				q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
				break;

			case 'ZYZ':
				q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
				break;

			default:
				console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

		}

	}

};





/***/ }),

/***/ "../../node_modules/three/src/math/Matrix3.js":
/*!********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/Matrix3.js ***!
  \********************************************************************/
/*! exports provided: Matrix3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix3", function() { return Matrix3; });
class Matrix3 {

	constructor() {

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrix3Column( this, 0 );
		yAxis.setFromMatrix3Column( this, 1 );
		zAxis.setFromMatrix3Column( this, 2 );

		return this;

	}

	setFromMatrix4( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	}

	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	}

	invert() {

		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	}

	transpose() {

		let tmp;
		const m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	}

	getNormalMatrix( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).invert().transpose();

	}

	transposeIntoArray( r ) {

		const m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	}

	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

		const c = Math.cos( rotation );
		const s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

		return this;

	}

	scale( sx, sy ) {

		const te = this.elements;

		te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
		te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

		return this;

	}

	rotate( theta ) {

		const c = Math.cos( theta );
		const s = Math.sin( theta );

		const te = this.elements;

		const a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
		const a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

		te[ 0 ] = c * a11 + s * a21;
		te[ 3 ] = c * a12 + s * a22;
		te[ 6 ] = c * a13 + s * a23;

		te[ 1 ] = - s * a11 + c * a21;
		te[ 4 ] = - s * a12 + c * a22;
		te[ 7 ] = - s * a13 + c * a23;

		return this;

	}

	translate( tx, ty ) {

		const te = this.elements;

		te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
		te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

	clone() {

		return new this.constructor().fromArray( this.elements );

	}

}

Matrix3.prototype.isMatrix3 = true;




/***/ }),

/***/ "../../node_modules/three/src/math/Matrix4.js":
/*!********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/Matrix4.js ***!
  \********************************************************************/
/*! exports provided: Matrix4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix4", function() { return Matrix4; });
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3.js */ "../../node_modules/three/src/math/Vector3.js");


class Matrix4 {

	constructor() {

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	clone() {

		return new Matrix4().fromArray( this.elements );

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	}

	copyPosition( m ) {

		const te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	}

	setFromMatrix3( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ], 0,
			me[ 1 ], me[ 4 ], me[ 7 ], 0,
			me[ 2 ], me[ 5 ], me[ 8 ], 0,
			0, 0, 0, 1

		);

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	}

	makeBasis( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	}

	extractRotation( m ) {

		// this method does not support reflection matrices

		const te = this.elements;
		const me = m.elements;

		const scaleX = 1 / _v1.setFromMatrixColumn( m, 0 ).length();
		const scaleY = 1 / _v1.setFromMatrixColumn( m, 1 ).length();
		const scaleZ = 1 / _v1.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		const te = this.elements;

		const x = euler.x, y = euler.y, z = euler.z;
		const a = Math.cos( x ), b = Math.sin( x );
		const c = Math.cos( y ), d = Math.sin( y );
		const e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromQuaternion( q ) {

		return this.compose( _zero, q, _one );

	}

	lookAt( eye, target, up ) {

		const te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	}

	multiply( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	}

	transpose() {

		const te = this.elements;
		let tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	}

	setPosition( x, y, z ) {

		const te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	}

	invert() {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	}

	scale( v ) {

		const te = this.elements;
		const x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	}

	getMaxScaleOnAxis() {

		const te = this.elements;

		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	}

	makeTranslation( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationX( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationY( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	}

	makeRotationZ( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationAxis( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		const c = Math.cos( angle );
		const s = Math.sin( angle );
		const t = 1 - c;
		const x = axis.x, y = axis.y, z = axis.z;
		const tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeScale( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeShear( x, y, z ) {

		this.set(

			1, y, z, 0,
			x, 1, z, 0,
			x, y, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	compose( position, quaternion, scale ) {

		const te = this.elements;

		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		const x2 = x + x,	y2 = y + y, z2 = z + z;
		const xx = x * x2, xy = x * y2, xz = x * z2;
		const yy = y * y2, yz = y * z2, zz = z * z2;
		const wx = w * x2, wy = w * y2, wz = w * z2;

		const sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	}

	decompose( position, quaternion, scale ) {

		const te = this.elements;

		let sx = _v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		const sy = _v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		const sz = _v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		const det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1.copy( this );

		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;

		_m1.elements[ 0 ] *= invSX;
		_m1.elements[ 1 ] *= invSX;
		_m1.elements[ 2 ] *= invSX;

		_m1.elements[ 4 ] *= invSY;
		_m1.elements[ 5 ] *= invSY;
		_m1.elements[ 6 ] *= invSY;

		_m1.elements[ 8 ] *= invSZ;
		_m1.elements[ 9 ] *= invSZ;
		_m1.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	}

	makePerspective( left, right, top, bottom, near, far ) {

		if ( far === undefined ) {

			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

		}

		const te = this.elements;
		const x = 2 * near / ( right - left );
		const y = 2 * near / ( top - bottom );

		const a = ( right + left ) / ( right - left );
		const b = ( top + bottom ) / ( top - bottom );
		const c = - ( far + near ) / ( far - near );
		const d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	}

	makeOrthographic( left, right, top, bottom, near, far ) {

		const te = this.elements;
		const w = 1.0 / ( right - left );
		const h = 1.0 / ( top - bottom );
		const p = 1.0 / ( far - near );

		const x = ( right + left ) * w;
		const y = ( top + bottom ) * h;
		const z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

}

Matrix4.prototype.isMatrix4 = true;

const _v1 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _m1 = /*@__PURE__*/ new Matrix4();
const _zero = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]( 0, 0, 0 );
const _one = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]( 1, 1, 1 );
const _x = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _y = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _z = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();




/***/ }),

/***/ "../../node_modules/three/src/math/Plane.js":
/*!******************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/Plane.js ***!
  \******************************************************************/
/*! exports provided: Plane */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Plane", function() { return Plane; });
/* harmony import */ var _Matrix3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix3.js */ "../../node_modules/three/src/math/Matrix3.js");
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector3.js */ "../../node_modules/three/src/math/Vector3.js");



const _vector1 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
const _vector2 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
const _normalMatrix = /*@__PURE__*/ new _Matrix3_js__WEBPACK_IMPORTED_MODULE_0__["Matrix3"]();

class Plane {

	constructor( normal = new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]( 1, 0, 0 ), constant = 0 ) {

		// normal is assumed to be normalized

		this.normal = normal;
		this.constant = constant;

	}

	set( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	}

	setComponents( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	}

	setFromNormalAndCoplanarPoint( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );

		return this;

	}

	setFromCoplanarPoints( a, b, c ) {

		const normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

		this.setFromNormalAndCoplanarPoint( normal, a );

		return this;

	}

	copy( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	}

	normalize() {

		// Note: will lead to a divide by zero if the plane is invalid.

		const inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	}

	negate() {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	}

	distanceToPoint( point ) {

		return this.normal.dot( point ) + this.constant;

	}

	distanceToSphere( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	}

	projectPoint( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .projectPoint() target is now required' );
			target = new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

		}

		return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

	}

	intersectLine( line, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .intersectLine() target is now required' );
			target = new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

		}

		const direction = line.delta( _vector1 );

		const denominator = this.normal.dot( direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( this.distanceToPoint( line.start ) === 0 ) {

				return target.copy( line.start );

			}

			// Unsure if this is the correct method to handle this case.
			return null;

		}

		const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

		if ( t < 0 || t > 1 ) {

			return null;

		}

		return target.copy( direction ).multiplyScalar( t ).add( line.start );

	}

	intersectsLine( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		const startSign = this.distanceToPoint( line.start );
		const endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	}

	intersectsBox( box ) {

		return box.intersectsPlane( this );

	}

	intersectsSphere( sphere ) {

		return sphere.intersectsPlane( this );

	}

	coplanarPoint( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );
			target = new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

		}

		return target.copy( this.normal ).multiplyScalar( - this.constant );

	}

	applyMatrix4( matrix, optionalNormalMatrix ) {

		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

		const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

		const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

		this.constant = - referencePoint.dot( normal );

		return this;

	}

	translate( offset ) {

		this.constant -= offset.dot( this.normal );

		return this;

	}

	equals( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

Plane.prototype.isPlane = true;




/***/ }),

/***/ "../../node_modules/three/src/math/Quaternion.js":
/*!***********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/Quaternion.js ***!
  \***********************************************************************/
/*! exports provided: Quaternion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quaternion", function() { return Quaternion; });
/* harmony import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");


class Quaternion {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

	}

	static slerp( qa, qb, qm, t ) {

		console.warn( 'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.' );
		return qm.slerpQuaternions( qa, qb, t );

	}

	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		let x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( t === 0 ) {

			dst[ dstOffset + 0 ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
			return;

		}

		if ( t === 1 ) {

			dst[ dstOffset + 0 ] = x1;
			dst[ dstOffset + 1 ] = y1;
			dst[ dstOffset + 2 ] = z1;
			dst[ dstOffset + 3 ] = w1;
			return;

		}

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			let s = 1 - t;
			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				const sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			const tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		const x0 = src0[ srcOffset0 ];
		const y0 = src0[ srcOffset0 + 1 ];
		const z0 = src0[ srcOffset0 + 2 ];
		const w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 ];
		const y1 = src1[ srcOffset1 + 1 ];
		const z1 = src1[ srcOffset1 + 2 ];
		const w1 = src1[ srcOffset1 + 3 ];

		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		return dst;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get w() {

		return this._w;

	}

	set w( value ) {

		this._w = value;
		this._onChangeCallback();

	}

	set( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._w );

	}

	copy( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	}

	setFromEuler( euler, update ) {

		if ( ! ( euler && euler.isEuler ) ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		const cos = Math.cos;
		const sin = Math.sin;

		const c1 = cos( x / 2 );
		const c2 = cos( y / 2 );
		const c3 = cos( z / 2 );

		const s1 = sin( x / 2 );
		const s2 = sin( y / 2 );
		const s3 = sin( z / 2 );

		switch ( order ) {

			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			default:
				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		}

		if ( update !== false ) this._onChangeCallback();

		return this;

	}

	setFromAxisAngle( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		const halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33;

		if ( trace > 0 ) {

			const s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	}

	setFromUnitVectors( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		let r = vFrom.dot( vTo ) + 1;

		if ( r < Number.EPSILON ) {

			// vFrom and vTo point in opposite directions

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	}

	angleTo( q ) {

		return 2 * Math.acos( Math.abs( _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].clamp( this.dot( q ), - 1, 1 ) ) );

	}

	rotateTowards( q, step ) {

		const angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		const t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	}

	identity() {

		return this.set( 0, 0, 0, 1 );

	}

	invert() {

		// quaternion is assumed to have unit length

		return this.conjugate();

	}

	conjugate() {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	}

	dot( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	}

	lengthSq() {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	}

	length() {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	}

	normalize() {

		let l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	}

	multiply( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	}

	premultiply( q ) {

		return this.multiplyQuaternions( q, this );

	}

	multiplyQuaternions( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	}

	slerp( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		const x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			const s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize();
			this._onChangeCallback();

			return this;

		}

		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	}

	slerpQuaternions( qa, qb, t ) {

		this.copy( qa ).slerp( qb, t );

	}

	equals( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	}

	fromArray( array, offset = 0 ) {

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		return this;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

}

Quaternion.prototype.isQuaternion = true;




/***/ }),

/***/ "../../node_modules/three/src/math/Ray.js":
/*!****************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/Ray.js ***!
  \****************************************************************/
/*! exports provided: Ray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ray", function() { return Ray; });
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3.js */ "../../node_modules/three/src/math/Vector3.js");


const _vector = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _segCenter = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _segDir = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _diff = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

const _edge1 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _edge2 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _normal = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

class Ray {

	constructor( origin = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), direction = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]( 0, 0, - 1 ) ) {

		this.origin = origin;
		this.direction = direction;

	}

	set( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	}

	copy( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	}

	at( t, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Ray: .at() target is now required' );
			target = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

		}

		return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	}

	lookAt( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	}

	recast( t ) {

		this.origin.copy( this.at( t, _vector ) );

		return this;

	}

	closestPointToPoint( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );
			target = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

		}

		target.subVectors( point, this.origin );

		const directionDistance = target.dot( this.direction );

		if ( directionDistance < 0 ) {

			return target.copy( this.origin );

		}

		return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	}

	distanceToPoint( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	}

	distanceSqToPoint( point ) {

		const directionDistance = _vector.subVectors( point, this.origin ).dot( this.direction );

		// point behind the ray

		if ( directionDistance < 0 ) {

			return this.origin.distanceToSquared( point );

		}

		_vector.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		return _vector.distanceToSquared( point );

	}

	distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
		_segDir.copy( v1 ).sub( v0 ).normalize();
		_diff.copy( this.origin ).sub( _segCenter );

		const segExtent = v0.distanceTo( v1 ) * 0.5;
		const a01 = - this.direction.dot( _segDir );
		const b0 = _diff.dot( this.direction );
		const b1 = - _diff.dot( _segDir );
		const c = _diff.lengthSq();
		const det = Math.abs( 1 - a01 * a01 );
		let s0, s1, sqrDist, extDet;

		if ( det > 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						const invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet ) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );

		}

		return sqrDist;

	}

	intersectSphere( sphere, target ) {

		_vector.subVectors( sphere.center, this.origin );
		const tca = _vector.dot( this.direction );
		const d2 = _vector.dot( _vector ) - tca * tca;
		const radius2 = sphere.radius * sphere.radius;

		if ( d2 > radius2 ) return null;

		const thc = Math.sqrt( radius2 - d2 );

		// t0 = first intersect point - entrance on front of sphere
		const t0 = tca - thc;

		// t1 = second intersect point - exit point on back of sphere
		const t1 = tca + thc;

		// test to see if both t0 and t1 are behind the ray - if so, return null
		if ( t0 < 0 && t1 < 0 ) return null;

		// test to see if t0 is behind the ray:
		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		// in order to always return an intersect point that is in front of the ray.
		if ( t0 < 0 ) return this.at( t1, target );

		// else t0 is in front of the ray, so return the first collision point scaled by t0
		return this.at( t0, target );

	}

	intersectsSphere( sphere ) {

		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	distanceToPlane( plane ) {

		const denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t : null;

	}

	intersectPlane( plane, target ) {

		const t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, target );

	}

	intersectsPlane( plane ) {

		// check if the ray lies on the plane first

		const distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		const denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	}

	intersectBox( box, target ) {

		let tmin, tmax, tymin, tymax, tzmin, tzmax;

		const invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		const origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, target );

	}

	intersectsBox( box ) {

		return this.intersectBox( box, _vector ) !== null;

	}

	intersectTriangle( a, b, c, backfaceCulling, target ) {

		// Compute the offset origin, edges, and normal.

		// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		_edge1.subVectors( b, a );
		_edge2.subVectors( c, a );
		_normal.crossVectors( _edge1, _edge2 );

		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		let DdN = this.direction.dot( _normal );
		let sign;

		if ( DdN > 0 ) {

			if ( backfaceCulling ) return null;
			sign = 1;

		} else if ( DdN < 0 ) {

			sign = - 1;
			DdN = - DdN;

		} else {

			return null;

		}

		_diff.subVectors( this.origin, a );
		const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

		// b1 < 0, no intersection
		if ( DdQxE2 < 0 ) {

			return null;

		}

		const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

		// b2 < 0, no intersection
		if ( DdE1xQ < 0 ) {

			return null;

		}

		// b1+b2 > 1, no intersection
		if ( DdQxE2 + DdE1xQ > DdN ) {

			return null;

		}

		// Line intersects triangle, check if ray does.
		const QdN = - sign * _diff.dot( _normal );

		// t < 0, no intersection
		if ( QdN < 0 ) {

			return null;

		}

		// Ray intersects triangle.
		return this.at( QdN / DdN, target );

	}

	applyMatrix4( matrix4 ) {

		this.origin.applyMatrix4( matrix4 );
		this.direction.transformDirection( matrix4 );

		return this;

	}

	equals( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}




/***/ }),

/***/ "../../node_modules/three/src/math/Sphere.js":
/*!*******************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/Sphere.js ***!
  \*******************************************************************/
/*! exports provided: Sphere */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sphere", function() { return Sphere; });
/* harmony import */ var _Box3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Box3.js */ "../../node_modules/three/src/math/Box3.js");
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector3.js */ "../../node_modules/three/src/math/Vector3.js");



const _box = /*@__PURE__*/ new _Box3_js__WEBPACK_IMPORTED_MODULE_0__["Box3"]();
const _v1 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
const _toFarthestPoint = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
const _toPoint = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

class Sphere {

	constructor( center = new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"](), radius = - 1 ) {

		this.center = center;
		this.radius = radius;

	}

	set( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	}

	setFromPoints( points, optionalCenter ) {

		const center = this.center;

		if ( optionalCenter !== undefined ) {

			center.copy( optionalCenter );

		} else {

			_box.setFromPoints( points ).getCenter( center );

		}

		let maxRadiusSq = 0;

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

		}

		this.radius = Math.sqrt( maxRadiusSq );

		return this;

	}

	copy( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	}

	isEmpty() {

		return ( this.radius < 0 );

	}

	makeEmpty() {

		this.center.set( 0, 0, 0 );
		this.radius = - 1;

		return this;

	}

	containsPoint( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	}

	distanceToPoint( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	}

	intersectsSphere( sphere ) {

		const radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	}

	intersectsBox( box ) {

		return box.intersectsSphere( this );

	}

	intersectsPlane( plane ) {

		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

	}

	clampPoint( point, target ) {

		const deltaLengthSq = this.center.distanceToSquared( point );

		if ( target === undefined ) {

			console.warn( 'THREE.Sphere: .clampPoint() target is now required' );
			target = new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

		}

		target.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			target.sub( this.center ).normalize();
			target.multiplyScalar( this.radius ).add( this.center );

		}

		return target;

	}

	getBoundingBox( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );
			target = new _Box3_js__WEBPACK_IMPORTED_MODULE_0__["Box3"]();

		}

		if ( this.isEmpty() ) {

			// Empty sphere produces empty bounding box
			target.makeEmpty();
			return target;

		}

		target.set( this.center, this.center );
		target.expandByScalar( this.radius );

		return target;

	}

	applyMatrix4( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	}

	translate( offset ) {

		this.center.add( offset );

		return this;

	}

	expandByPoint( point ) {

		// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671

		_toPoint.subVectors( point, this.center );

		const lengthSq = _toPoint.lengthSq();

		if ( lengthSq > ( this.radius * this.radius ) ) {

			const length = Math.sqrt( lengthSq );
			const missingRadiusHalf = ( length - this.radius ) * 0.5;

			// Nudge this sphere towards the target point. Add half the missing distance to radius,
			// and the other half to position. This gives a tighter enclosure, instead of if
			// the whole missing distance were just added to radius.

			this.center.add( _toPoint.multiplyScalar( missingRadiusHalf / length ) );
			this.radius += missingRadiusHalf;

		}

		return this;

	}

	union( sphere ) {

		// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769

		// To enclose another sphere into this sphere, we only need to enclose two points:
		// 1) Enclose the farthest point on the other sphere into this sphere.
		// 2) Enclose the opposite point of the farthest point into this sphere.

		_toFarthestPoint.subVectors( sphere.center, this.center ).normalize().multiplyScalar( sphere.radius );

		this.expandByPoint( _v1.copy( sphere.center ).add( _toFarthestPoint ) );
		this.expandByPoint( _v1.copy( sphere.center ).sub( _toFarthestPoint ) );

		return this;

	}

	equals( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}




/***/ }),

/***/ "../../node_modules/three/src/math/Spherical.js":
/*!**********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/Spherical.js ***!
  \**********************************************************************/
/*! exports provided: Spherical */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Spherical", function() { return Spherical; });
/* harmony import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");
/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */



class Spherical {

	constructor( radius = 1, phi = 0, theta = 0 ) {

		this.radius = radius;
		this.phi = phi; // polar angle
		this.theta = theta; // azimuthal angle

		return this;

	}

	set( radius, phi, theta ) {

		this.radius = radius;
		this.phi = phi;
		this.theta = theta;

		return this;

	}

	copy( other ) {

		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;

		return this;

	}

	// restrict phi to be betwee EPS and PI-EPS
	makeSafe() {

		const EPS = 0.000001;
		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

		return this;

	}

	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + y * y + z * z );

		if ( this.radius === 0 ) {

			this.theta = 0;
			this.phi = 0;

		} else {

			this.theta = Math.atan2( x, z );
			this.phi = Math.acos( _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].clamp( y / this.radius, - 1, 1 ) );

		}

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}




/***/ }),

/***/ "../../node_modules/three/src/math/SphericalHarmonics3.js":
/*!********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/SphericalHarmonics3.js ***!
  \********************************************************************************/
/*! exports provided: SphericalHarmonics3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphericalHarmonics3", function() { return SphericalHarmonics3; });
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3.js */ "../../node_modules/three/src/math/Vector3.js");


/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */

// 3-band SH defined by 9 coefficients

class SphericalHarmonics3 {

	constructor() {

		this.coefficients = [];

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients.push( new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]() );

		}

	}

	set( coefficients ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].copy( coefficients[ i ] );

		}

		return this;

	}

	zero() {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].set( 0, 0, 0 );

		}

		return this;

	}

	// get the radiance in the direction of the normal
	// target is a Vector3
	getAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

		// band 1
		target.addScaledVector( coeff[ 1 ], 0.488603 * y );
		target.addScaledVector( coeff[ 2 ], 0.488603 * z );
		target.addScaledVector( coeff[ 3 ], 0.488603 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
		target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
		target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
		target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
		target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

		return target;

	}

	// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
	// target is a Vector3
	// https://graphics.stanford.edu/papers/envmap/envmap.pdf
	getIrradianceAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095

		// band 1
		target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603
		target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
		target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548
		target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
		target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3
		target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
		target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274

		return target;

	}

	add( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].add( sh.coefficients[ i ] );

		}

		return this;

	}

	addScaledSH( sh, s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

		}

		return this;

	}

	scale( s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].multiplyScalar( s );

		}

		return this;

	}

	lerp( sh, alpha ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

		}

		return this;

	}

	equals( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

				return false;

			}

		}

		return true;

	}

	copy( sh ) {

		return this.set( sh.coefficients );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	fromArray( array, offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].toArray( array, offset + ( i * 3 ) );

		}

		return array;

	}

	// evaluate the basis functions
	// shBasis is an Array[ 9 ]
	static getBasisAt( normal, shBasis ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		// band 0
		shBasis[ 0 ] = 0.282095;

		// band 1
		shBasis[ 1 ] = 0.488603 * y;
		shBasis[ 2 ] = 0.488603 * z;
		shBasis[ 3 ] = 0.488603 * x;

		// band 2
		shBasis[ 4 ] = 1.092548 * x * y;
		shBasis[ 5 ] = 1.092548 * y * z;
		shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
		shBasis[ 7 ] = 1.092548 * x * z;
		shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

	}

}

SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;




/***/ }),

/***/ "../../node_modules/three/src/math/Triangle.js":
/*!*********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/Triangle.js ***!
  \*********************************************************************/
/*! exports provided: Triangle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Triangle", function() { return Triangle; });
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _Plane_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Plane.js */ "../../node_modules/three/src/math/Plane.js");



const _v0 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _v1 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _v2 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _v3 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

const _vab = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vac = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vbc = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vap = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vbp = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vcp = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

class Triangle {

	constructor( a = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), b = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), c = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]() ) {

		this.a = a;
		this.b = b;
		this.c = c;

	}

	static getNormal( a, b, c, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getNormal() target is now required' );
			target = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

		}

		target.subVectors( c, b );
		_v0.subVectors( a, b );
		target.cross( _v0 );

		const targetLengthSq = target.lengthSq();
		if ( targetLengthSq > 0 ) {

			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

		}

		return target.set( 0, 0, 0 );

	}

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	static getBarycoord( point, a, b, c, target ) {

		_v0.subVectors( c, a );
		_v1.subVectors( b, a );
		_v2.subVectors( point, a );

		const dot00 = _v0.dot( _v0 );
		const dot01 = _v0.dot( _v1 );
		const dot02 = _v0.dot( _v2 );
		const dot11 = _v1.dot( _v1 );
		const dot12 = _v1.dot( _v2 );

		const denom = ( dot00 * dot11 - dot01 * dot01 );

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getBarycoord() target is now required' );
			target = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

		}

		// collinear or singular triangle
		if ( denom === 0 ) {

			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return target.set( - 2, - 1, - 1 );

		}

		const invDenom = 1 / denom;
		const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return target.set( 1 - u - v, v, u );

	}

	static containsPoint( point, a, b, c ) {

		this.getBarycoord( point, a, b, c, _v3 );

		return ( _v3.x >= 0 ) && ( _v3.y >= 0 ) && ( ( _v3.x + _v3.y ) <= 1 );

	}

	static getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

		this.getBarycoord( point, p1, p2, p3, _v3 );

		target.set( 0, 0 );
		target.addScaledVector( uv1, _v3.x );
		target.addScaledVector( uv2, _v3.y );
		target.addScaledVector( uv3, _v3.z );

		return target;

	}

	static isFrontFacing( a, b, c, direction ) {

		_v0.subVectors( c, b );
		_v1.subVectors( a, b );

		// strictly front facing
		return ( _v0.cross( _v1 ).dot( direction ) < 0 ) ? true : false;

	}

	set( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	}

	setFromPointsAndIndices( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	}

	getArea() {

		_v0.subVectors( this.c, this.b );
		_v1.subVectors( this.a, this.b );

		return _v0.cross( _v1 ).length() * 0.5;

	}

	getMidpoint( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getMidpoint() target is now required' );
			target = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

		}

		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	}

	getNormal( target ) {

		return Triangle.getNormal( this.a, this.b, this.c, target );

	}

	getPlane( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getPlane() target is now required' );
			target = new _Plane_js__WEBPACK_IMPORTED_MODULE_1__["Plane"]();

		}

		return target.setFromCoplanarPoints( this.a, this.b, this.c );

	}

	getBarycoord( point, target ) {

		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

	}

	getUV( point, uv1, uv2, uv3, target ) {

		return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

	}

	containsPoint( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	}

	isFrontFacing( direction ) {

		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

	}

	intersectsBox( box ) {

		return box.intersectsTriangle( this );

	}

	closestPointToPoint( p, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );
			target = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

		}

		const a = this.a, b = this.b, c = this.c;
		let v, w;

		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
		// basically, we're distinguishing which of the voronoi regions of the triangle
		// the point lies in with the minimum amount of redundant computation.

		_vab.subVectors( b, a );
		_vac.subVectors( c, a );
		_vap.subVectors( p, a );
		const d1 = _vab.dot( _vap );
		const d2 = _vac.dot( _vap );
		if ( d1 <= 0 && d2 <= 0 ) {

			// vertex region of A; barycentric coords (1, 0, 0)
			return target.copy( a );

		}

		_vbp.subVectors( p, b );
		const d3 = _vab.dot( _vbp );
		const d4 = _vac.dot( _vbp );
		if ( d3 >= 0 && d4 <= d3 ) {

			// vertex region of B; barycentric coords (0, 1, 0)
			return target.copy( b );

		}

		const vc = d1 * d4 - d3 * d2;
		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

			v = d1 / ( d1 - d3 );
			// edge region of AB; barycentric coords (1-v, v, 0)
			return target.copy( a ).addScaledVector( _vab, v );

		}

		_vcp.subVectors( p, c );
		const d5 = _vab.dot( _vcp );
		const d6 = _vac.dot( _vcp );
		if ( d6 >= 0 && d5 <= d6 ) {

			// vertex region of C; barycentric coords (0, 0, 1)
			return target.copy( c );

		}

		const vb = d5 * d2 - d1 * d6;
		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

			w = d2 / ( d2 - d6 );
			// edge region of AC; barycentric coords (1-w, 0, w)
			return target.copy( a ).addScaledVector( _vac, w );

		}

		const va = d3 * d6 - d5 * d4;
		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

			_vbc.subVectors( c, b );
			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
			// edge region of BC; barycentric coords (0, 1-w, w)
			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

		}

		// face region
		const denom = 1 / ( va + vb + vc );
		// u = va * denom
		v = vb * denom;
		w = vc * denom;

		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

	}

	equals( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

}




/***/ }),

/***/ "../../node_modules/three/src/math/Vector2.js":
/*!********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/Vector2.js ***!
  \********************************************************************/
/*! exports provided: Vector2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector2", function() { return Vector2; });
class Vector2 {

	constructor( x = 0, y = 0 ) {

		this.x = x;
		this.y = y;

	}

	get width() {

		return this.x;

	}

	set width( value ) {

		this.x = value;

	}

	get height() {

		return this.y;

	}

	set height( value ) {

		this.y = value;

	}

	set( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;

		return this;

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y;

	}

	cross( v ) {

		return this.x * v.y - this.y * v.x;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	angle() {

		// computes the angle in radians with respect to the positive x-axis

		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

		return angle;

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	}

	rotateAround( center, angle ) {

		const c = Math.cos( angle ), s = Math.sin( angle );

		const x = this.x - center.x;
		const y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();

		return this;

	}

}

Vector2.prototype.isVector2 = true;




/***/ }),

/***/ "../../node_modules/three/src/math/Vector3.js":
/*!********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/Vector3.js ***!
  \********************************************************************/
/*! exports provided: Vector3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector3", function() { return Vector3; });
/* harmony import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");
/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Quaternion.js */ "../../node_modules/three/src/math/Quaternion.js");



class Vector3 {

	constructor( x = 0, y = 0, z = 0 ) {

		this.x = x;
		this.y = y;
		this.z = z;

	}

	set( x, y, z ) {

		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	}

	multiply( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	}

	multiplyVectors( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	}

	applyEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		return this.applyQuaternion( _quaternion.setFromEuler( euler ) );

	}

	applyAxisAngle( axis, angle ) {

		return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	}

	applyNormalMatrix( m ) {

		return this.applyMatrix3( m ).normalize();

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	}

	applyQuaternion( q ) {

		const x = this.x, y = this.y, z = this.z;
		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		const ix = qw * x + qy * z - qz * y;
		const iy = qw * y + qz * x - qx * z;
		const iz = qw * z + qx * y - qy * x;
		const iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	}

	project( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	}

	unproject( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	}

	transformDirection( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	}

	// TODO lengthSquared?

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;

		return this;

	}

	cross( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		return this.crossVectors( this, v );

	}

	crossVectors( a, b ) {

		const ax = a.x, ay = a.y, az = a.z;
		const bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	}

	projectOnVector( v ) {

		const denominator = v.lengthSq();

		if ( denominator === 0 ) return this.set( 0, 0, 0 );

		const scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	}

	projectOnPlane( planeNormal ) {

		_vector.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector );

	}

	reflect( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	}

	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].clamp( theta, - 1, 1 ) );

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	}

	setFromSpherical( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	}

	setFromSphericalCoords( radius, phi, theta ) {

		const sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	}

	setFromCylindrical( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	}

	setFromCylindricalCoords( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	}

	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	}

	setFromMatrixScale( m ) {

		const sx = this.setFromMatrixColumn( m, 0 ).length();
		const sy = this.setFromMatrixColumn( m, 1 ).length();
		const sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	}

	setFromMatrixColumn( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	}

	setFromMatrix3Column( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();

		return this;

	}

}

Vector3.prototype.isVector3 = true;

const _vector = /*@__PURE__*/ new Vector3();
const _quaternion = /*@__PURE__*/ new _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__["Quaternion"]();




/***/ }),

/***/ "../../node_modules/three/src/math/Vector4.js":
/*!********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/Vector4.js ***!
  \********************************************************************/
/*! exports provided: Vector4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector4", function() { return Vector4; });
class Vector4 {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

	}

	get width() {

		return this.z;

	}

	set width( value ) {

		this.z = value;

	}

	get height() {

		return this.w;

	}

	set height( value ) {

		this.w = value;

	}

	set( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setW( w ) {

		this.w = w;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z, this.w );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		this.w *= v.w;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z, w = this.w;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	setAxisAngleFromQuaternion( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		const s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			this.x = 1;
			this.y = 0;
			this.z = 0;

		} else {

			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;

		}

		return this;

	}

	setAxisAngleFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		let angle, x, y, z; // variables for result
		const epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			const xx = ( m11 + 1 ) / 2;
			const yy = ( m22 + 1 ) / 2;
			const zz = ( m33 + 1 ) / 2;
			const xy = ( m12 + m21 ) / 4;
			const xz = ( m13 + m31 ) / 4;
			const yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			( m13 - m31 ) * ( m13 - m31 ) +
			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
		this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;
		this.w = v1.w + ( v2.w - v1.w ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		this.w = Math.random();

		return this;

	}

}

Vector4.prototype.isVector4 = true;




/***/ }),

/***/ "../../node_modules/three/src/math/interpolants/CubicInterpolant.js":
/*!******************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/interpolants/CubicInterpolant.js ***!
  \******************************************************************************************/
/*! exports provided: CubicInterpolant */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicInterpolant", function() { return CubicInterpolant; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _Interpolant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Interpolant.js */ "../../node_modules/three/src/math/Interpolant.js");




/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */

function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	_Interpolant_js__WEBPACK_IMPORTED_MODULE_1__["Interpolant"].call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	this._weightPrev = - 0;
	this._offsetPrev = - 0;
	this._weightNext = - 0;
	this._offsetNext = - 0;

}

CubicInterpolant.prototype = Object.assign( Object.create( _Interpolant_js__WEBPACK_IMPORTED_MODULE_1__["Interpolant"].prototype ), {

	constructor: CubicInterpolant,

	DefaultSettings_: {

		endingStart: _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroCurvatureEnding"],
		endingEnd: _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroCurvatureEnding"]

	},

	intervalChanged_: function ( i1, t0, t1 ) {

		const pp = this.parameterPositions;
		let iPrev = i1 - 2,
			iNext = i1 + 1,

			tPrev = pp[ iPrev ],
			tNext = pp[ iNext ];

		if ( tPrev === undefined ) {

			switch ( this.getSettings_().endingStart ) {

				case _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroSlopeEnding"]:

					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;

					break;

				case _constants_js__WEBPACK_IMPORTED_MODULE_0__["WrapAroundEnding"]:

					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;

			}

		}

		if ( tNext === undefined ) {

			switch ( this.getSettings_().endingEnd ) {

				case _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroSlopeEnding"]:

					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;

					break;

				case _constants_js__WEBPACK_IMPORTED_MODULE_0__["WrapAroundEnding"]:

					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[ 1 ] - pp[ 0 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;

			}

		}

		const halfDt = ( t1 - t0 ) * 0.5,
			stride = this.valueSize;

		this._weightPrev = halfDt / ( t0 - tPrev );
		this._weightNext = halfDt / ( tNext - t1 );
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;

	},

	interpolate_: function ( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			o1 = i1 * stride,		o0 = o1 - stride,
			oP = this._offsetPrev, 	oN = this._offsetNext,
			wP = this._weightPrev,	wN = this._weightNext,

			p = ( t - t0 ) / ( t1 - t0 ),
			pp = p * p,
			ppp = pp * p;

		// evaluate polynomials

		const sP = - wP * ppp + 2 * wP * pp - wP * p;
		const s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
		const s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
		const sN = wN * ppp - wN * pp;

		// combine data linearly

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					sP * values[ oP + i ] +
					s0 * values[ o0 + i ] +
					s1 * values[ o1 + i ] +
					sN * values[ oN + i ];

		}

		return result;

	}

} );





/***/ }),

/***/ "../../node_modules/three/src/math/interpolants/DiscreteInterpolant.js":
/*!*********************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/interpolants/DiscreteInterpolant.js ***!
  \*********************************************************************************************/
/*! exports provided: DiscreteInterpolant */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiscreteInterpolant", function() { return DiscreteInterpolant; });
/* harmony import */ var _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Interpolant.js */ "../../node_modules/three/src/math/Interpolant.js");


/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 */

function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	_Interpolant_js__WEBPACK_IMPORTED_MODULE_0__["Interpolant"].call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

DiscreteInterpolant.prototype = Object.assign( Object.create( _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__["Interpolant"].prototype ), {

	constructor: DiscreteInterpolant,

	interpolate_: function ( i1 /*, t0, t, t1 */ ) {

		return this.copySampleValue_( i1 - 1 );

	}

} );





/***/ }),

/***/ "../../node_modules/three/src/math/interpolants/LinearInterpolant.js":
/*!*******************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/interpolants/LinearInterpolant.js ***!
  \*******************************************************************************************/
/*! exports provided: LinearInterpolant */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearInterpolant", function() { return LinearInterpolant; });
/* harmony import */ var _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Interpolant.js */ "../../node_modules/three/src/math/Interpolant.js");


function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	_Interpolant_js__WEBPACK_IMPORTED_MODULE_0__["Interpolant"].call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

LinearInterpolant.prototype = Object.assign( Object.create( _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__["Interpolant"].prototype ), {

	constructor: LinearInterpolant,

	interpolate_: function ( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset1 = i1 * stride,
			offset0 = offset1 - stride,

			weight1 = ( t - t0 ) / ( t1 - t0 ),
			weight0 = 1 - weight1;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					values[ offset0 + i ] * weight0 +
					values[ offset1 + i ] * weight1;

		}

		return result;

	}

} );





/***/ }),

/***/ "../../node_modules/three/src/math/interpolants/QuaternionLinearInterpolant.js":
/*!*****************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/math/interpolants/QuaternionLinearInterpolant.js ***!
  \*****************************************************************************************************/
/*! exports provided: QuaternionLinearInterpolant */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionLinearInterpolant", function() { return QuaternionLinearInterpolant; });
/* harmony import */ var _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Interpolant.js */ "../../node_modules/three/src/math/Interpolant.js");
/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Quaternion.js */ "../../node_modules/three/src/math/Quaternion.js");



/**
 * Spherical linear unit quaternion interpolant.
 */

function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	_Interpolant_js__WEBPACK_IMPORTED_MODULE_0__["Interpolant"].call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

QuaternionLinearInterpolant.prototype = Object.assign( Object.create( _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__["Interpolant"].prototype ), {

	constructor: QuaternionLinearInterpolant,

	interpolate_: function ( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			alpha = ( t - t0 ) / ( t1 - t0 );

		let offset = i1 * stride;

		for ( let end = offset + stride; offset !== end; offset += 4 ) {

			_Quaternion_js__WEBPACK_IMPORTED_MODULE_1__["Quaternion"].slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

		}

		return result;

	}

} );





/***/ }),

/***/ "../../node_modules/three/src/objects/Bone.js":
/*!********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/objects/Bone.js ***!
  \********************************************************************/
/*! exports provided: Bone */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bone", function() { return Bone; });
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");


function Bone() {

	_core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__["Object3D"].call( this );

	this.type = 'Bone';

}

Bone.prototype = Object.assign( Object.create( _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__["Object3D"].prototype ), {

	constructor: Bone,

	isBone: true

} );





/***/ }),

/***/ "../../node_modules/three/src/objects/Group.js":
/*!*********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/objects/Group.js ***!
  \*********************************************************************/
/*! exports provided: Group */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Group", function() { return Group; });
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");


class Group extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__["Object3D"] {

	constructor() {

		super();

		this.type = 'Group';

	}

}

Group.prototype.isGroup = true;




/***/ }),

/***/ "../../node_modules/three/src/objects/InstancedMesh.js":
/*!*****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/objects/InstancedMesh.js ***!
  \*****************************************************************************/
/*! exports provided: InstancedMesh */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedMesh", function() { return InstancedMesh; });
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _Mesh_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Mesh.js */ "../../node_modules/three/src/objects/Mesh.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Matrix4.js */ "../../node_modules/three/src/math/Matrix4.js");




const _instanceLocalMatrix = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();
const _instanceWorldMatrix = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();

const _instanceIntersects = [];

const _mesh = new _Mesh_js__WEBPACK_IMPORTED_MODULE_1__["Mesh"]();

function InstancedMesh( geometry, material, count ) {

	_Mesh_js__WEBPACK_IMPORTED_MODULE_1__["Mesh"].call( this, geometry, material );

	this.instanceMatrix = new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0__["BufferAttribute"]( new Float32Array( count * 16 ), 16 );
	this.instanceColor = null;

	this.count = count;

	this.frustumCulled = false;

}

InstancedMesh.prototype = Object.assign( Object.create( _Mesh_js__WEBPACK_IMPORTED_MODULE_1__["Mesh"].prototype ), {

	constructor: InstancedMesh,

	isInstancedMesh: true,

	copy: function ( source ) {

		_Mesh_js__WEBPACK_IMPORTED_MODULE_1__["Mesh"].prototype.copy.call( this, source );

		this.instanceMatrix.copy( source.instanceMatrix );

		if ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();

		this.count = source.count;

		return this;

	},

	getColorAt: function ( index, color ) {

		color.fromArray( this.instanceColor.array, index * 3 );

	},

	getMatrixAt: function ( index, matrix ) {

		matrix.fromArray( this.instanceMatrix.array, index * 16 );

	},

	raycast: function ( raycaster, intersects ) {

		const matrixWorld = this.matrixWorld;
		const raycastTimes = this.count;

		_mesh.geometry = this.geometry;
		_mesh.material = this.material;

		if ( _mesh.material === undefined ) return;

		for ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

			// calculate the world matrix for each instance

			this.getMatrixAt( instanceId, _instanceLocalMatrix );

			_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

			// the mesh represents this single instance

			_mesh.matrixWorld = _instanceWorldMatrix;

			_mesh.raycast( raycaster, _instanceIntersects );

			// process the result of raycast

			for ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {

				const intersect = _instanceIntersects[ i ];
				intersect.instanceId = instanceId;
				intersect.object = this;
				intersects.push( intersect );

			}

			_instanceIntersects.length = 0;

		}

	},

	setColorAt: function ( index, color ) {

		if ( this.instanceColor === null ) {

			this.instanceColor = new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0__["BufferAttribute"]( new Float32Array( this.count * 3 ), 3 );

		}

		color.toArray( this.instanceColor.array, index * 3 );

	},

	setMatrixAt: function ( index, matrix ) {

		matrix.toArray( this.instanceMatrix.array, index * 16 );

	},

	updateMorphTargets: function () {

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );




/***/ }),

/***/ "../../node_modules/three/src/objects/LOD.js":
/*!*******************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/objects/LOD.js ***!
  \*******************************************************************/
/*! exports provided: LOD */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LOD", function() { return LOD; });
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");



const _v1 = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _v2 = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

class LOD extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_1__["Object3D"] {

	constructor() {

		super();

		this._currentLevel = 0;

		this.type = 'LOD';

		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			},
			isLOD: {
				value: true,
			}
		} );

		this.autoUpdate = true;

	}

	copy( source ) {

		super.copy( source, false );

		const levels = source.levels;

		for ( let i = 0, l = levels.length; i < l; i ++ ) {

			const level = levels[ i ];

			this.addLevel( level.object.clone(), level.distance );

		}

		this.autoUpdate = source.autoUpdate;

		return this;

	}

	addLevel( object, distance = 0 ) {

		distance = Math.abs( distance );

		const levels = this.levels;

		let l;

		for ( l = 0; l < levels.length; l ++ ) {

			if ( distance < levels[ l ].distance ) {

				break;

			}

		}

		levels.splice( l, 0, { distance: distance, object: object } );

		this.add( object );

		return this;

	}

	getCurrentLevel() {

		return this._currentLevel;

	}

	getObjectForDistance( distance ) {

		const levels = this.levels;

		if ( levels.length > 0 ) {

			let i, l;

			for ( i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance < levels[ i ].distance ) {

					break;

				}

			}

			return levels[ i - 1 ].object;

		}

		return null;

	}

	raycast( raycaster, intersects ) {

		const levels = this.levels;

		if ( levels.length > 0 ) {

			_v1.setFromMatrixPosition( this.matrixWorld );

			const distance = raycaster.ray.origin.distanceTo( _v1 );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		}

	}

	update( camera ) {

		const levels = this.levels;

		if ( levels.length > 1 ) {

			_v1.setFromMatrixPosition( camera.matrixWorld );
			_v2.setFromMatrixPosition( this.matrixWorld );

			const distance = _v1.distanceTo( _v2 ) / camera.zoom;

			levels[ 0 ].object.visible = true;

			let i, l;

			for ( i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance >= levels[ i ].distance ) {

					levels[ i - 1 ].object.visible = false;
					levels[ i ].object.visible = true;

				} else {

					break;

				}

			}

			this._currentLevel = i - 1;

			for ( ; i < l; i ++ ) {

				levels[ i ].object.visible = false;

			}

		}

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.autoUpdate === false ) data.object.autoUpdate = false;

		data.object.levels = [];

		const levels = this.levels;

		for ( let i = 0, l = levels.length; i < l; i ++ ) {

			const level = levels[ i ];

			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance
			} );

		}

		return data;

	}

}





/***/ }),

/***/ "../../node_modules/three/src/objects/Line.js":
/*!********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/objects/Line.js ***!
  \********************************************************************/
/*! exports provided: Line */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return Line; });
/* harmony import */ var _math_Sphere_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Sphere.js */ "../../node_modules/three/src/math/Sphere.js");
/* harmony import */ var _math_Ray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Ray.js */ "../../node_modules/three/src/math/Ray.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Matrix4.js */ "../../node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../materials/LineBasicMaterial.js */ "../../node_modules/three/src/materials/LineBasicMaterial.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");









const _start = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
const _end = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
const _inverseMatrix = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();
const _ray = new _math_Ray_js__WEBPACK_IMPORTED_MODULE_1__["Ray"]();
const _sphere = new _math_Sphere_js__WEBPACK_IMPORTED_MODULE_0__["Sphere"]();

function Line( geometry = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_6__["BufferGeometry"](), material = new _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_5__["LineBasicMaterial"]() ) {

	_core_Object3D_js__WEBPACK_IMPORTED_MODULE_3__["Object3D"].call( this );

	this.type = 'Line';

	this.geometry = geometry;
	this.material = material;

	this.updateMorphTargets();

}

Line.prototype = Object.assign( Object.create( _core_Object3D_js__WEBPACK_IMPORTED_MODULE_3__["Object3D"].prototype ), {

	constructor: Line,

	isLine: true,

	copy: function ( source ) {

		_core_Object3D_js__WEBPACK_IMPORTED_MODULE_3__["Object3D"].prototype.copy.call( this, source );

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	},

	computeLineDistances: function () {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			// we assume non-indexed geometry

			if ( geometry.index === null ) {

				const positionAttribute = geometry.attributes.position;
				const lineDistances = [ 0 ];

				for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

					_start.fromBufferAttribute( positionAttribute, i - 1 );
					_end.fromBufferAttribute( positionAttribute, i );

					lineDistances[ i ] = lineDistances[ i - 1 ];
					lineDistances[ i ] += _start.distanceTo( _end );

				}

				geometry.setAttribute( 'lineDistance', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_7__["Float32BufferAttribute"]( lineDistances, 1 ) );

			} else {

				console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			}

		} else if ( geometry.isGeometry ) {

			console.error( 'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

		return this;

	},

	raycast: function ( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Line.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );
		_sphere.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		//

		_inverseMatrix.copy( matrixWorld ).invert();
		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const vStart = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
		const vEnd = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
		const interSegment = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
		const interRay = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
		const step = this.isLineSegments ? 2 : 1;

		if ( geometry.isBufferGeometry ) {

			const index = geometry.index;
			const attributes = geometry.attributes;
			const positionAttribute = attributes.position;

			if ( index !== null ) {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, l = end - 1; i < l; i += step ) {

					const a = index.getX( i );
					const b = index.getX( i + 1 );

					vStart.fromBufferAttribute( positionAttribute, a );
					vEnd.fromBufferAttribute( positionAttribute, b );

					const distSq = _ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > localThresholdSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					const distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, l = end - 1; i < l; i += step ) {

					vStart.fromBufferAttribute( positionAttribute, i );
					vEnd.fromBufferAttribute( positionAttribute, i + 1 );

					const distSq = _ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > localThresholdSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					const distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		} else if ( geometry.isGeometry ) {

			console.error( 'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

	},

	updateMorphTargets: function () {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			const morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	}

} );





/***/ }),

/***/ "../../node_modules/three/src/objects/LineLoop.js":
/*!************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/objects/LineLoop.js ***!
  \************************************************************************/
/*! exports provided: LineLoop */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineLoop", function() { return LineLoop; });
/* harmony import */ var _Line_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Line.js */ "../../node_modules/three/src/objects/Line.js");


class LineLoop extends _Line_js__WEBPACK_IMPORTED_MODULE_0__["Line"] {

	constructor( geometry, material ) {

		super( geometry, material );

		this.type = 'LineLoop';

	}

}

LineLoop.prototype.isLineLoop = true;




/***/ }),

/***/ "../../node_modules/three/src/objects/LineSegments.js":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/objects/LineSegments.js ***!
  \****************************************************************************/
/*! exports provided: LineSegments */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineSegments", function() { return LineSegments; });
/* harmony import */ var _Line_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Line.js */ "../../node_modules/three/src/objects/Line.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");




const _start = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
const _end = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

function LineSegments( geometry, material ) {

	_Line_js__WEBPACK_IMPORTED_MODULE_0__["Line"].call( this, geometry, material );

	this.type = 'LineSegments';

}

LineSegments.prototype = Object.assign( Object.create( _Line_js__WEBPACK_IMPORTED_MODULE_0__["Line"].prototype ), {

	constructor: LineSegments,

	isLineSegments: true,

	computeLineDistances: function () {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			// we assume non-indexed geometry

			if ( geometry.index === null ) {

				const positionAttribute = geometry.attributes.position;
				const lineDistances = [];

				for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

					_start.fromBufferAttribute( positionAttribute, i );
					_end.fromBufferAttribute( positionAttribute, i + 1 );

					lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
					lineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );

				}

				geometry.setAttribute( 'lineDistance', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__["Float32BufferAttribute"]( lineDistances, 1 ) );

			} else {

				console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			}

		} else if ( geometry.isGeometry ) {

			console.error( 'THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

		return this;

	}

} );





/***/ }),

/***/ "../../node_modules/three/src/objects/Mesh.js":
/*!********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/objects/Mesh.js ***!
  \********************************************************************/
/*! exports provided: Mesh */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mesh", function() { return Mesh; });
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Sphere_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Sphere.js */ "../../node_modules/three/src/math/Sphere.js");
/* harmony import */ var _math_Ray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Ray.js */ "../../node_modules/three/src/math/Ray.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Matrix4.js */ "../../node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");
/* harmony import */ var _math_Triangle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/Triangle.js */ "../../node_modules/three/src/math/Triangle.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _materials_MeshBasicMaterial_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../materials/MeshBasicMaterial.js */ "../../node_modules/three/src/materials/MeshBasicMaterial.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");











const _inverseMatrix = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_4__["Matrix4"]();
const _ray = new _math_Ray_js__WEBPACK_IMPORTED_MODULE_3__["Ray"]();
const _sphere = new _math_Sphere_js__WEBPACK_IMPORTED_MODULE_2__["Sphere"]();

const _vA = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vB = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vC = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

const _tempA = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _tempB = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _tempC = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

const _morphA = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _morphB = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _morphC = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

const _uvA = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"]();
const _uvB = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"]();
const _uvC = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"]();

const _intersectionPoint = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _intersectionPointWorld = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

function Mesh( geometry = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_9__["BufferGeometry"](), material = new _materials_MeshBasicMaterial_js__WEBPACK_IMPORTED_MODULE_8__["MeshBasicMaterial"]() ) {

	_core_Object3D_js__WEBPACK_IMPORTED_MODULE_5__["Object3D"].call( this );

	this.type = 'Mesh';

	this.geometry = geometry;
	this.material = material;

	this.updateMorphTargets();

}

Mesh.prototype = Object.assign( Object.create( _core_Object3D_js__WEBPACK_IMPORTED_MODULE_5__["Object3D"].prototype ), {

	constructor: Mesh,

	isMesh: true,

	copy: function ( source ) {

		_core_Object3D_js__WEBPACK_IMPORTED_MODULE_5__["Object3D"].prototype.copy.call( this, source );

		if ( source.morphTargetInfluences !== undefined ) {

			this.morphTargetInfluences = source.morphTargetInfluences.slice();

		}

		if ( source.morphTargetDictionary !== undefined ) {

			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

		}

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	},

	updateMorphTargets: function () {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			const morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	},

	raycast: function ( raycaster, intersects ) {

		const geometry = this.geometry;
		const material = this.material;
		const matrixWorld = this.matrixWorld;

		if ( material === undefined ) return;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		//

		_inverseMatrix.copy( matrixWorld ).invert();
		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		// Check boundingBox before continuing

		if ( geometry.boundingBox !== null ) {

			if ( _ray.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		let intersection;

		if ( geometry.isBufferGeometry ) {

			const index = geometry.index;
			const position = geometry.attributes.position;
			const morphPosition = geometry.morphAttributes.position;
			const morphTargetsRelative = geometry.morphTargetsRelative;
			const uv = geometry.attributes.uv;
			const uv2 = geometry.attributes.uv2;
			const groups = geometry.groups;
			const drawRange = geometry.drawRange;

			if ( index !== null ) {

				// indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( let i = 0, il = groups.length; i < il; i ++ ) {

						const group = groups[ i ];
						const groupMaterial = material[ group.materialIndex ];

						const start = Math.max( group.start, drawRange.start );
						const end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

						for ( let j = start, jl = end; j < jl; j += 3 ) {

							const a = index.getX( j );
							const b = index.getX( j + 1 );
							const c = index.getX( j + 2 );

							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, il = end; i < il; i += 3 ) {

						const a = index.getX( i );
						const b = index.getX( i + 1 );
						const c = index.getX( i + 2 );

						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			} else if ( position !== undefined ) {

				// non-indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( let i = 0, il = groups.length; i < il; i ++ ) {

						const group = groups[ i ];
						const groupMaterial = material[ group.materialIndex ];

						const start = Math.max( group.start, drawRange.start );
						const end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

						for ( let j = start, jl = end; j < jl; j += 3 ) {

							const a = j;
							const b = j + 1;
							const c = j + 2;

							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, il = end; i < il; i += 3 ) {

						const a = i;
						const b = i + 1;
						const c = i + 2;

						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			}

		} else if ( geometry.isGeometry ) {

			console.error( 'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

	}

} );

function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

	let intersect;

	if ( material.side === _constants_js__WEBPACK_IMPORTED_MODULE_7__["BackSide"] ) {

		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

	} else {

		intersect = ray.intersectTriangle( pA, pB, pC, material.side !== _constants_js__WEBPACK_IMPORTED_MODULE_7__["DoubleSide"], point );

	}

	if ( intersect === null ) return null;

	_intersectionPointWorld.copy( point );
	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

	const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

	if ( distance < raycaster.near || distance > raycaster.far ) return null;

	return {
		distance: distance,
		point: _intersectionPointWorld.clone(),
		object: object
	};

}

function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {

	_vA.fromBufferAttribute( position, a );
	_vB.fromBufferAttribute( position, b );
	_vC.fromBufferAttribute( position, c );

	const morphInfluences = object.morphTargetInfluences;

	if ( material.morphTargets && morphPosition && morphInfluences ) {

		_morphA.set( 0, 0, 0 );
		_morphB.set( 0, 0, 0 );
		_morphC.set( 0, 0, 0 );

		for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

			const influence = morphInfluences[ i ];
			const morphAttribute = morphPosition[ i ];

			if ( influence === 0 ) continue;

			_tempA.fromBufferAttribute( morphAttribute, a );
			_tempB.fromBufferAttribute( morphAttribute, b );
			_tempC.fromBufferAttribute( morphAttribute, c );

			if ( morphTargetsRelative ) {

				_morphA.addScaledVector( _tempA, influence );
				_morphB.addScaledVector( _tempB, influence );
				_morphC.addScaledVector( _tempC, influence );

			} else {

				_morphA.addScaledVector( _tempA.sub( _vA ), influence );
				_morphB.addScaledVector( _tempB.sub( _vB ), influence );
				_morphC.addScaledVector( _tempC.sub( _vC ), influence );

			}

		}

		_vA.add( _morphA );
		_vB.add( _morphB );
		_vC.add( _morphC );

	}

	if ( object.isSkinnedMesh && material.skinning ) {

		object.boneTransform( a, _vA );
		object.boneTransform( b, _vB );
		object.boneTransform( c, _vC );

	}

	const intersection = checkIntersection( object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint );

	if ( intersection ) {

		if ( uv ) {

			_uvA.fromBufferAttribute( uv, a );
			_uvB.fromBufferAttribute( uv, b );
			_uvC.fromBufferAttribute( uv, c );

			intersection.uv = _math_Triangle_js__WEBPACK_IMPORTED_MODULE_6__["Triangle"].getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"]() );

		}

		if ( uv2 ) {

			_uvA.fromBufferAttribute( uv2, a );
			_uvB.fromBufferAttribute( uv2, b );
			_uvC.fromBufferAttribute( uv2, c );

			intersection.uv2 = _math_Triangle_js__WEBPACK_IMPORTED_MODULE_6__["Triangle"].getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"]() );

		}

		const face = {
			a: a,
			b: b,
			c: c,
			normal: new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
			materialIndex: 0
		};

		_math_Triangle_js__WEBPACK_IMPORTED_MODULE_6__["Triangle"].getNormal( _vA, _vB, _vC, face.normal );

		intersection.face = face;

	}

	return intersection;

}




/***/ }),

/***/ "../../node_modules/three/src/objects/Points.js":
/*!**********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/objects/Points.js ***!
  \**********************************************************************/
/*! exports provided: Points */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Points", function() { return Points; });
/* harmony import */ var _math_Sphere_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Sphere.js */ "../../node_modules/three/src/math/Sphere.js");
/* harmony import */ var _math_Ray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Ray.js */ "../../node_modules/three/src/math/Ray.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Matrix4.js */ "../../node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _materials_PointsMaterial_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../materials/PointsMaterial.js */ "../../node_modules/three/src/materials/PointsMaterial.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");








const _inverseMatrix = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();
const _ray = new _math_Ray_js__WEBPACK_IMPORTED_MODULE_1__["Ray"]();
const _sphere = new _math_Sphere_js__WEBPACK_IMPORTED_MODULE_0__["Sphere"]();
const _position = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();

function Points( geometry = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_6__["BufferGeometry"](), material = new _materials_PointsMaterial_js__WEBPACK_IMPORTED_MODULE_5__["PointsMaterial"]() ) {

	_core_Object3D_js__WEBPACK_IMPORTED_MODULE_3__["Object3D"].call( this );

	this.type = 'Points';

	this.geometry = geometry;
	this.material = material;

	this.updateMorphTargets();

}

Points.prototype = Object.assign( Object.create( _core_Object3D_js__WEBPACK_IMPORTED_MODULE_3__["Object3D"].prototype ), {

	constructor: Points,

	isPoints: true,

	copy: function ( source ) {

		_core_Object3D_js__WEBPACK_IMPORTED_MODULE_3__["Object3D"].prototype.copy.call( this, source );

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	},

	raycast: function ( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Points.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );
		_sphere.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		//

		_inverseMatrix.copy( matrixWorld ).invert();
		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		if ( geometry.isBufferGeometry ) {

			const index = geometry.index;
			const attributes = geometry.attributes;
			const positionAttribute = attributes.position;

			if ( index !== null ) {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i ++ ) {

					const a = index.getX( i );

					_position.fromBufferAttribute( positionAttribute, a );

					testPoint( _position, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, l = end; i < l; i ++ ) {

					_position.fromBufferAttribute( positionAttribute, i );

					testPoint( _position, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

				}

			}

		} else {

			console.error( 'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

	},

	updateMorphTargets: function () {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			const morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	}

} );

function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

	const rayPointDistanceSq = _ray.distanceSqToPoint( point );

	if ( rayPointDistanceSq < localThresholdSq ) {

		const intersectPoint = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();

		_ray.closestPointToPoint( point, intersectPoint );
		intersectPoint.applyMatrix4( matrixWorld );

		const distance = raycaster.ray.origin.distanceTo( intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			distanceToRay: Math.sqrt( rayPointDistanceSq ),
			point: intersectPoint,
			index: index,
			face: null,
			object: object

		} );

	}

}




/***/ }),

/***/ "../../node_modules/three/src/objects/Skeleton.js":
/*!************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/objects/Skeleton.js ***!
  \************************************************************************/
/*! exports provided: Skeleton */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Skeleton", function() { return Skeleton; });
/* harmony import */ var _Bone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bone.js */ "../../node_modules/three/src/objects/Bone.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Matrix4.js */ "../../node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");




const _offsetMatrix = /*@__PURE__*/ new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
const _identityMatrix = /*@__PURE__*/ new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();

class Skeleton {

	constructor( bones = [], boneInverses = [] ) {

		this.uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__["MathUtils"].generateUUID();

		this.bones = bones.slice( 0 );
		this.boneInverses = boneInverses;
		this.boneMatrices = null;

		this.boneTexture = null;
		this.boneTextureSize = 0;

		this.frame = - 1;

		this.init();

	}

	init() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		this.boneMatrices = new Float32Array( bones.length * 16 );

		// calculate inverse bone matrices if necessary

		if ( boneInverses.length === 0 ) {

			this.calculateInverses();

		} else {

			// handle special case

			if ( bones.length !== boneInverses.length ) {

				console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );

				this.boneInverses = [];

				for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

					this.boneInverses.push( new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]() );

				}

			}

		}

	}

	calculateInverses() {

		this.boneInverses.length = 0;

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const inverse = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();

			if ( this.bones[ i ] ) {

				inverse.copy( this.bones[ i ].matrixWorld ).invert();

			}

			this.boneInverses.push( inverse );

		}

	}

	pose() {

		// recover the bind-time world matrices

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				bone.matrixWorld.copy( this.boneInverses[ i ] ).invert();

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				if ( bone.parent && bone.parent.isBone ) {

					bone.matrix.copy( bone.parent.matrixWorld ).invert();
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	}

	update() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;
		const boneMatrices = this.boneMatrices;
		const boneTexture = this.boneTexture;

		// flatten bone matrices to array

		for ( let i = 0, il = bones.length; i < il; i ++ ) {

			// compute the offset between the current and the original transform

			const matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;

			_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
			_offsetMatrix.toArray( boneMatrices, i * 16 );

		}

		if ( boneTexture !== null ) {

			boneTexture.needsUpdate = true;

		}

	}

	clone() {

		return new Skeleton( this.bones, this.boneInverses );

	}

	getBoneByName( name ) {

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone.name === name ) {

				return bone;

			}

		}

		return undefined;

	}

	dispose( ) {

		if ( this.boneTexture !== null ) {

			this.boneTexture.dispose();

			this.boneTexture = null;

		}

	}

	fromJSON( json, bones ) {

		this.uuid = json.uuid;

		for ( let i = 0, l = json.bones.length; i < l; i ++ ) {

			const uuid = json.bones[ i ];
			let bone = bones[ uuid ];

			if ( bone === undefined ) {

				console.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );
				bone = new _Bone_js__WEBPACK_IMPORTED_MODULE_0__["Bone"]();

			}

			this.bones.push( bone );
			this.boneInverses.push( new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]().fromArray( json.boneInverses[ i ] ) );

		}

		this.init();

		return this;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.5,
				type: 'Skeleton',
				generator: 'Skeleton.toJSON'
			},
			bones: [],
			boneInverses: []
		};

		data.uuid = this.uuid;

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		for ( let i = 0, l = bones.length; i < l; i ++ ) {

			const bone = bones[ i ];
			data.bones.push( bone.uuid );

			const boneInverse = boneInverses[ i ];
			data.boneInverses.push( boneInverse.toArray() );

		}

		return data;

	}

}




/***/ }),

/***/ "../../node_modules/three/src/objects/SkinnedMesh.js":
/*!***************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/objects/SkinnedMesh.js ***!
  \***************************************************************************/
/*! exports provided: SkinnedMesh */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkinnedMesh", function() { return SkinnedMesh; });
/* harmony import */ var _Mesh_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Mesh.js */ "../../node_modules/three/src/objects/Mesh.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Matrix4.js */ "../../node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Vector4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector4.js */ "../../node_modules/three/src/math/Vector4.js");





const _basePosition = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

const _skinIndex = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_3__["Vector4"]();
const _skinWeight = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_3__["Vector4"]();

const _vector = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
const _matrix = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();

function SkinnedMesh( geometry, material ) {

	_Mesh_js__WEBPACK_IMPORTED_MODULE_0__["Mesh"].call( this, geometry, material );

	this.type = 'SkinnedMesh';

	this.bindMode = 'attached';
	this.bindMatrix = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
	this.bindMatrixInverse = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();

}

SkinnedMesh.prototype = Object.assign( Object.create( _Mesh_js__WEBPACK_IMPORTED_MODULE_0__["Mesh"].prototype ), {

	constructor: SkinnedMesh,

	isSkinnedMesh: true,

	copy: function ( source ) {

		_Mesh_js__WEBPACK_IMPORTED_MODULE_0__["Mesh"].prototype.copy.call( this, source );

		this.bindMode = source.bindMode;
		this.bindMatrix.copy( source.bindMatrix );
		this.bindMatrixInverse.copy( source.bindMatrixInverse );

		this.skeleton = source.skeleton;

		return this;

	},

	bind: function ( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.copy( bindMatrix ).invert();

	},

	pose: function () {

		this.skeleton.pose();

	},

	normalizeSkinWeights: function () {

		const vector = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_3__["Vector4"]();

		const skinWeight = this.geometry.attributes.skinWeight;

		for ( let i = 0, l = skinWeight.count; i < l; i ++ ) {

			vector.x = skinWeight.getX( i );
			vector.y = skinWeight.getY( i );
			vector.z = skinWeight.getZ( i );
			vector.w = skinWeight.getW( i );

			const scale = 1.0 / vector.manhattanLength();

			if ( scale !== Infinity ) {

				vector.multiplyScalar( scale );

			} else {

				vector.set( 1, 0, 0, 0 ); // do something reasonable

			}

			skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

		}

	},

	updateMatrixWorld: function ( force ) {

		_Mesh_js__WEBPACK_IMPORTED_MODULE_0__["Mesh"].prototype.updateMatrixWorld.call( this, force );

		if ( this.bindMode === 'attached' ) {

			this.bindMatrixInverse.copy( this.matrixWorld ).invert();

		} else if ( this.bindMode === 'detached' ) {

			this.bindMatrixInverse.copy( this.bindMatrix ).invert();

		} else {

			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

		}

	},

	boneTransform: function ( index, target ) {

		const skeleton = this.skeleton;
		const geometry = this.geometry;

		_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
		_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

		_basePosition.fromBufferAttribute( geometry.attributes.position, index ).applyMatrix4( this.bindMatrix );

		target.set( 0, 0, 0 );

		for ( let i = 0; i < 4; i ++ ) {

			const weight = _skinWeight.getComponent( i );

			if ( weight !== 0 ) {

				const boneIndex = _skinIndex.getComponent( i );

				_matrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

				target.addScaledVector( _vector.copy( _basePosition ).applyMatrix4( _matrix ), weight );

			}

		}

		return target.applyMatrix4( this.bindMatrixInverse );

	}

} );





/***/ }),

/***/ "../../node_modules/three/src/objects/Sprite.js":
/*!**********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/objects/Sprite.js ***!
  \**********************************************************************/
/*! exports provided: Sprite */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sprite", function() { return Sprite; });
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Matrix4.js */ "../../node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _math_Triangle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Triangle.js */ "../../node_modules/three/src/math/Triangle.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _core_InterleavedBuffer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/InterleavedBuffer.js */ "../../node_modules/three/src/core/InterleavedBuffer.js");
/* harmony import */ var _core_InterleavedBufferAttribute_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/InterleavedBufferAttribute.js */ "../../node_modules/three/src/core/InterleavedBufferAttribute.js");
/* harmony import */ var _materials_SpriteMaterial_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../materials/SpriteMaterial.js */ "../../node_modules/three/src/materials/SpriteMaterial.js");










let _geometry;

const _intersectPoint = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
const _worldScale = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
const _mvPosition = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

const _alignedPosition = /*@__PURE__*/ new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();
const _rotatedPosition = /*@__PURE__*/ new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();
const _viewWorldMatrix = /*@__PURE__*/ new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();

const _vA = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
const _vB = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
const _vC = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

const _uvA = /*@__PURE__*/ new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();
const _uvB = /*@__PURE__*/ new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();
const _uvC = /*@__PURE__*/ new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]();

class Sprite extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_4__["Object3D"] {

	constructor( material ) {

		super();

		this.type = 'Sprite';

		if ( _geometry === undefined ) {

			_geometry = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_5__["BufferGeometry"]();

			const float32Array = new Float32Array( [
				- 0.5, - 0.5, 0, 0, 0,
				0.5, - 0.5, 0, 1, 0,
				0.5, 0.5, 0, 1, 1,
				- 0.5, 0.5, 0, 0, 1
			] );

			const interleavedBuffer = new _core_InterleavedBuffer_js__WEBPACK_IMPORTED_MODULE_6__["InterleavedBuffer"]( float32Array, 5 );

			_geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
			_geometry.setAttribute( 'position', new _core_InterleavedBufferAttribute_js__WEBPACK_IMPORTED_MODULE_7__["InterleavedBufferAttribute"]( interleavedBuffer, 3, 0, false ) );
			_geometry.setAttribute( 'uv', new _core_InterleavedBufferAttribute_js__WEBPACK_IMPORTED_MODULE_7__["InterleavedBufferAttribute"]( interleavedBuffer, 2, 3, false ) );

		}

		this.geometry = _geometry;
		this.material = ( material !== undefined ) ? material : new _materials_SpriteMaterial_js__WEBPACK_IMPORTED_MODULE_8__["SpriteMaterial"]();

		this.center = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]( 0.5, 0.5 );

	}

	raycast( raycaster, intersects ) {

		if ( raycaster.camera === null ) {

			console.error( 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' );

		}

		_worldScale.setFromMatrixScale( this.matrixWorld );

		_viewWorldMatrix.copy( raycaster.camera.matrixWorld );
		this.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );

		_mvPosition.setFromMatrixPosition( this.modelViewMatrix );

		if ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {

			_worldScale.multiplyScalar( - _mvPosition.z );

		}

		const rotation = this.material.rotation;
		let sin, cos;

		if ( rotation !== 0 ) {

			cos = Math.cos( rotation );
			sin = Math.sin( rotation );

		}

		const center = this.center;

		transformVertex( _vA.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vB.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vC.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );

		_uvA.set( 0, 0 );
		_uvB.set( 1, 0 );
		_uvC.set( 1, 1 );

		// check first triangle
		let intersect = raycaster.ray.intersectTriangle( _vA, _vB, _vC, false, _intersectPoint );

		if ( intersect === null ) {

			// check second triangle
			transformVertex( _vB.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
			_uvB.set( 0, 1 );

			intersect = raycaster.ray.intersectTriangle( _vA, _vC, _vB, false, _intersectPoint );
			if ( intersect === null ) {

				return;

			}

		}

		const distance = raycaster.ray.origin.distanceTo( _intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			point: _intersectPoint.clone(),
			uv: _math_Triangle_js__WEBPACK_IMPORTED_MODULE_3__["Triangle"].getUV( _intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"]() ),
			face: null,
			object: this

		} );

	}

	copy( source ) {

		super.copy( source );

		if ( source.center !== undefined ) this.center.copy( source.center );

		this.material = source.material;

		return this;

	}

}

Sprite.prototype.isSprite = true;

function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

	// compute position in camera space
	_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

	// to check if rotation is not zero
	if ( sin !== undefined ) {

		_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );
		_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );

	} else {

		_rotatedPosition.copy( _alignedPosition );

	}


	vertexPosition.copy( mvPosition );
	vertexPosition.x += _rotatedPosition.x;
	vertexPosition.y += _rotatedPosition.y;

	// transform to world space
	vertexPosition.applyMatrix4( _viewWorldMatrix );

}




/***/ }),

/***/ "../../node_modules/three/src/renderers/WebGL1Renderer.js":
/*!********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/WebGL1Renderer.js ***!
  \********************************************************************************/
/*! exports provided: WebGL1Renderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGL1Renderer", function() { return WebGL1Renderer; });
/* harmony import */ var _WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGLRenderer.js */ "../../node_modules/three/src/renderers/WebGLRenderer.js");


class WebGL1Renderer extends _WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_0__["WebGLRenderer"] {}

WebGL1Renderer.prototype.isWebGL1Renderer = true;




/***/ }),

/***/ "../../node_modules/three/src/renderers/WebGLCubeRenderTarget.js":
/*!***************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/WebGLCubeRenderTarget.js ***!
  \***************************************************************************************/
/*! exports provided: WebGLCubeRenderTarget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLCubeRenderTarget", function() { return WebGLCubeRenderTarget; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../objects/Mesh.js */ "../../node_modules/three/src/objects/Mesh.js");
/* harmony import */ var _geometries_BoxGeometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometries/BoxGeometry.js */ "../../node_modules/three/src/geometries/BoxGeometry.js");
/* harmony import */ var _materials_ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../materials/ShaderMaterial.js */ "../../node_modules/three/src/materials/ShaderMaterial.js");
/* harmony import */ var _shaders_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shaders/UniformsUtils.js */ "../../node_modules/three/src/renderers/shaders/UniformsUtils.js");
/* harmony import */ var _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./WebGLRenderTarget.js */ "../../node_modules/three/src/renderers/WebGLRenderTarget.js");
/* harmony import */ var _cameras_CubeCamera_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../cameras/CubeCamera.js */ "../../node_modules/three/src/cameras/CubeCamera.js");
/* harmony import */ var _textures_CubeTexture_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../textures/CubeTexture.js */ "../../node_modules/three/src/textures/CubeTexture.js");









class WebGLCubeRenderTarget extends _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_5__["WebGLRenderTarget"] {

	constructor( size, options, dummy ) {

		if ( Number.isInteger( options ) ) {

			console.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' );

			options = dummy;

		}

		super( size, size, options );

		options = options || {};

		this.texture = new _textures_CubeTexture_js__WEBPACK_IMPORTED_MODULE_7__["CubeTexture"]( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"];

		this.texture._needsFlipEnvMap = false;

	}

	fromEquirectangularTexture( renderer, texture ) {

		this.texture.type = texture.type;
		this.texture.format = _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"]; // see #18859
		this.texture.encoding = texture.encoding;

		this.texture.generateMipmaps = texture.generateMipmaps;
		this.texture.minFilter = texture.minFilter;
		this.texture.magFilter = texture.magFilter;

		const shader = {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

			fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
		};

		const geometry = new _geometries_BoxGeometry_js__WEBPACK_IMPORTED_MODULE_2__["BoxGeometry"]( 5, 5, 5 );

		const material = new _materials_ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_3__["ShaderMaterial"]( {

			name: 'CubemapFromEquirect',

			uniforms: Object(_shaders_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_4__["cloneUniforms"])( shader.uniforms ),
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			side: _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"],
			blending: _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoBlending"]

		} );

		material.uniforms.tEquirect.value = texture;

		const mesh = new _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_1__["Mesh"]( geometry, material );

		const currentMinFilter = texture.minFilter;

		// Avoid blurred poles
		if ( texture.minFilter === _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearMipmapLinearFilter"] ) texture.minFilter = _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"];

		const camera = new _cameras_CubeCamera_js__WEBPACK_IMPORTED_MODULE_6__["CubeCamera"]( 1, 10, this );
		camera.update( renderer, mesh );

		texture.minFilter = currentMinFilter;

		mesh.geometry.dispose();
		mesh.material.dispose();

		return this;

	}

	clear( renderer, color, depth, stencil ) {

		const currentRenderTarget = renderer.getRenderTarget();

		for ( let i = 0; i < 6; i ++ ) {

			renderer.setRenderTarget( this, i );

			renderer.clear( color, depth, stencil );

		}

		renderer.setRenderTarget( currentRenderTarget );

	}

}

WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;




/***/ }),

/***/ "../../node_modules/three/src/renderers/WebGLMultisampleRenderTarget.js":
/*!**********************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/WebGLMultisampleRenderTarget.js ***!
  \**********************************************************************************************/
/*! exports provided: WebGLMultisampleRenderTarget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLMultisampleRenderTarget", function() { return WebGLMultisampleRenderTarget; });
/* harmony import */ var _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGLRenderTarget.js */ "../../node_modules/three/src/renderers/WebGLRenderTarget.js");


class WebGLMultisampleRenderTarget extends _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_0__["WebGLRenderTarget"] {

	constructor( width, height, options ) {

		super( width, height, options );

		this.samples = 4;

	}

	copy( source ) {

		super.copy.call( this, source );

		this.samples = source.samples;

		return this;

	}

}

WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;




/***/ }),

/***/ "../../node_modules/three/src/renderers/WebGLRenderTarget.js":
/*!***********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/WebGLRenderTarget.js ***!
  \***********************************************************************************/
/*! exports provided: WebGLRenderTarget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTarget", function() { return WebGLRenderTarget; });
/* harmony import */ var _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/EventDispatcher.js */ "../../node_modules/three/src/core/EventDispatcher.js");
/* harmony import */ var _textures_Texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../textures/Texture.js */ "../../node_modules/three/src/textures/Texture.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _math_Vector4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector4.js */ "../../node_modules/three/src/math/Vector4.js");





/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
class WebGLRenderTarget extends _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_0__["EventDispatcher"] {

	constructor( width, height, options ) {

		super();

		this.width = width;
		this.height = height;
		this.depth = 1;

		this.scissor = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_3__["Vector4"]( 0, 0, width, height );
		this.scissorTest = false;

		this.viewport = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_3__["Vector4"]( 0, 0, width, height );

		options = options || {};

		this.texture = new _textures_Texture_js__WEBPACK_IMPORTED_MODULE_1__["Texture"]( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		this.texture.image = {};
		this.texture.image.width = width;
		this.texture.image.height = height;
		this.texture.image.depth = 1;

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : _constants_js__WEBPACK_IMPORTED_MODULE_2__["LinearFilter"];

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

	}

	setTexture( texture ) {

		texture.image = {
			width: this.width,
			height: this.height,
			depth: this.depth
		};

		this.texture = texture;

	}

	setSize( width, height, depth = 1 ) {

		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

			this.width = width;
			this.height = height;
			this.depth = depth;

			this.texture.image.width = width;
			this.texture.image.height = height;
			this.texture.image.depth = depth;

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.width = source.width;
		this.height = source.height;
		this.depth = source.depth;

		this.viewport.copy( source.viewport );

		this.texture = source.texture.clone();

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;
		this.depthTexture = source.depthTexture;

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

WebGLRenderTarget.prototype.isWebGLRenderTarget = true;




/***/ }),

/***/ "../../node_modules/three/src/renderers/WebGLRenderer.js":
/*!*******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/WebGLRenderer.js ***!
  \*******************************************************************************/
/*! exports provided: WebGLRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderer", function() { return WebGLRenderer; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");
/* harmony import */ var _textures_DataTexture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../textures/DataTexture.js */ "../../node_modules/three/src/textures/DataTexture.js");
/* harmony import */ var _math_Frustum_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Frustum.js */ "../../node_modules/three/src/math/Frustum.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Matrix4.js */ "../../node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Vector4_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/Vector4.js */ "../../node_modules/three/src/math/Vector4.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");
/* harmony import */ var _webgl_WebGLAnimation_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./webgl/WebGLAnimation.js */ "../../node_modules/three/src/renderers/webgl/WebGLAnimation.js");
/* harmony import */ var _webgl_WebGLAttributes_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./webgl/WebGLAttributes.js */ "../../node_modules/three/src/renderers/webgl/WebGLAttributes.js");
/* harmony import */ var _webgl_WebGLBackground_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./webgl/WebGLBackground.js */ "../../node_modules/three/src/renderers/webgl/WebGLBackground.js");
/* harmony import */ var _webgl_WebGLBindingStates_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./webgl/WebGLBindingStates.js */ "../../node_modules/three/src/renderers/webgl/WebGLBindingStates.js");
/* harmony import */ var _webgl_WebGLBufferRenderer_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./webgl/WebGLBufferRenderer.js */ "../../node_modules/three/src/renderers/webgl/WebGLBufferRenderer.js");
/* harmony import */ var _webgl_WebGLCapabilities_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./webgl/WebGLCapabilities.js */ "../../node_modules/three/src/renderers/webgl/WebGLCapabilities.js");
/* harmony import */ var _webgl_WebGLClipping_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./webgl/WebGLClipping.js */ "../../node_modules/three/src/renderers/webgl/WebGLClipping.js");
/* harmony import */ var _webgl_WebGLCubeMaps_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./webgl/WebGLCubeMaps.js */ "../../node_modules/three/src/renderers/webgl/WebGLCubeMaps.js");
/* harmony import */ var _webgl_WebGLExtensions_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./webgl/WebGLExtensions.js */ "../../node_modules/three/src/renderers/webgl/WebGLExtensions.js");
/* harmony import */ var _webgl_WebGLGeometries_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./webgl/WebGLGeometries.js */ "../../node_modules/three/src/renderers/webgl/WebGLGeometries.js");
/* harmony import */ var _webgl_WebGLIndexedBufferRenderer_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./webgl/WebGLIndexedBufferRenderer.js */ "../../node_modules/three/src/renderers/webgl/WebGLIndexedBufferRenderer.js");
/* harmony import */ var _webgl_WebGLInfo_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./webgl/WebGLInfo.js */ "../../node_modules/three/src/renderers/webgl/WebGLInfo.js");
/* harmony import */ var _webgl_WebGLMorphtargets_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./webgl/WebGLMorphtargets.js */ "../../node_modules/three/src/renderers/webgl/WebGLMorphtargets.js");
/* harmony import */ var _webgl_WebGLObjects_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./webgl/WebGLObjects.js */ "../../node_modules/three/src/renderers/webgl/WebGLObjects.js");
/* harmony import */ var _webgl_WebGLPrograms_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./webgl/WebGLPrograms.js */ "../../node_modules/three/src/renderers/webgl/WebGLPrograms.js");
/* harmony import */ var _webgl_WebGLProperties_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./webgl/WebGLProperties.js */ "../../node_modules/three/src/renderers/webgl/WebGLProperties.js");
/* harmony import */ var _webgl_WebGLRenderLists_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./webgl/WebGLRenderLists.js */ "../../node_modules/three/src/renderers/webgl/WebGLRenderLists.js");
/* harmony import */ var _webgl_WebGLRenderStates_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./webgl/WebGLRenderStates.js */ "../../node_modules/three/src/renderers/webgl/WebGLRenderStates.js");
/* harmony import */ var _webgl_WebGLShadowMap_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./webgl/WebGLShadowMap.js */ "../../node_modules/three/src/renderers/webgl/WebGLShadowMap.js");
/* harmony import */ var _webgl_WebGLState_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./webgl/WebGLState.js */ "../../node_modules/three/src/renderers/webgl/WebGLState.js");
/* harmony import */ var _webgl_WebGLTextures_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./webgl/WebGLTextures.js */ "../../node_modules/three/src/renderers/webgl/WebGLTextures.js");
/* harmony import */ var _webgl_WebGLUniforms_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./webgl/WebGLUniforms.js */ "../../node_modules/three/src/renderers/webgl/WebGLUniforms.js");
/* harmony import */ var _webgl_WebGLUtils_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./webgl/WebGLUtils.js */ "../../node_modules/three/src/renderers/webgl/WebGLUtils.js");
/* harmony import */ var _webxr_WebXRManager_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./webxr/WebXRManager.js */ "../../node_modules/three/src/renderers/webxr/WebXRManager.js");
/* harmony import */ var _webgl_WebGLMaterials_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./webgl/WebGLMaterials.js */ "../../node_modules/three/src/renderers/webgl/WebGLMaterials.js");



































function createCanvasElement() {

	const canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
	canvas.style.display = 'block';
	return canvas;

}

function WebGLRenderer( parameters ) {

	parameters = parameters || {};

	const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
		_context = parameters.context !== undefined ? parameters.context : null,

		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
		_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
		_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

	let currentRenderList = null;
	let currentRenderState = null;

	// render() can be called from within a callback triggered by another render.
	// We track this so that the nested render call gets its list and state isolated from the parent render call.

	const renderListStack = [];
	const renderStateStack = [];

	// public properties

	this.domElement = _canvas;

	// Debug configuration container
	this.debug = {

		/**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */
		checkShaderErrors: true
	};

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// user-defined clipping

	this.clippingPlanes = [];
	this.localClippingEnabled = false;

	// physically based shading

	this.gammaFactor = 2.0;	// for backwards compatibility
	this.outputEncoding = _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"];

	// physical lights

	this.physicallyCorrectLights = false;

	// tone mapping

	this.toneMapping = _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoToneMapping"];
	this.toneMappingExposure = 1.0;

	// internal properties

	const _this = this;

	let _isContextLost = false;

	// internal state cache

	let _currentActiveCubeFace = 0;
	let _currentActiveMipmapLevel = 0;
	let _currentRenderTarget = null;
	let _currentMaterialId = - 1;

	let _currentCamera = null;

	const _currentViewport = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_7__["Vector4"]();
	const _currentScissor = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_7__["Vector4"]();
	let _currentScissorTest = null;

	//

	let _width = _canvas.width;
	let _height = _canvas.height;

	let _pixelRatio = 1;
	let _opaqueSort = null;
	let _transparentSort = null;

	const _viewport = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_7__["Vector4"]( 0, 0, _width, _height );
	const _scissor = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_7__["Vector4"]( 0, 0, _width, _height );
	let _scissorTest = false;

	// frustum

	const _frustum = new _math_Frustum_js__WEBPACK_IMPORTED_MODULE_3__["Frustum"]();

	// clipping

	let _clippingEnabled = false;
	let _localClippingEnabled = false;

	// camera matrices cache

	const _projScreenMatrix = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_4__["Matrix4"]();

	const _vector3 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_6__["Vector3"]();

	const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

	function getTargetPixelRatio() {

		return _currentRenderTarget === null ? _pixelRatio : 1;

	}

	// initialize

	let _gl = _context;

	function getContext( contextNames, contextAttributes ) {

		for ( let i = 0; i < contextNames.length; i ++ ) {

			const contextName = contextNames[ i ];
			const context = _canvas.getContext( contextName, contextAttributes );
			if ( context !== null ) return context;

		}

		return null;

	}

	try {

		const contextAttributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer,
			powerPreference: _powerPreference,
			failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
		};

		// event listeners must be registered before WebGL context is created, see #12753

		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

		if ( _gl === null ) {

			const contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];

			if ( _this.isWebGL1Renderer === true ) {

				contextNames.shift();

			}

			_gl = getContext( contextNames, contextAttributes );

			if ( _gl === null ) {

				if ( getContext( contextNames ) ) {

					throw new Error( 'Error creating WebGL context with your selected attributes.' );

				} else {

					throw new Error( 'Error creating WebGL context.' );

				}

			}

		}

		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function () {

				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

			};

		}

	} catch ( error ) {

		console.error( 'THREE.WebGLRenderer: ' + error.message );
		throw error;

	}

	let extensions, capabilities, state, info;
	let properties, textures, cubemaps, attributes, geometries, objects;
	let programCache, materials, renderLists, renderStates, clipping, shadowMap;

	let background, morphtargets, bufferRenderer, indexedBufferRenderer;

	let utils, bindingStates;

	function initGLContext() {

		extensions = new _webgl_WebGLExtensions_js__WEBPACK_IMPORTED_MODULE_17__["WebGLExtensions"]( _gl );

		capabilities = new _webgl_WebGLCapabilities_js__WEBPACK_IMPORTED_MODULE_14__["WebGLCapabilities"]( _gl, extensions, parameters );

		extensions.init( capabilities );

		utils = new _webgl_WebGLUtils_js__WEBPACK_IMPORTED_MODULE_31__["WebGLUtils"]( _gl, extensions, capabilities );

		state = new _webgl_WebGLState_js__WEBPACK_IMPORTED_MODULE_28__["WebGLState"]( _gl, extensions, capabilities );

		info = new _webgl_WebGLInfo_js__WEBPACK_IMPORTED_MODULE_20__["WebGLInfo"]( _gl );
		properties = new _webgl_WebGLProperties_js__WEBPACK_IMPORTED_MODULE_24__["WebGLProperties"]();
		textures = new _webgl_WebGLTextures_js__WEBPACK_IMPORTED_MODULE_29__["WebGLTextures"]( _gl, extensions, state, properties, capabilities, utils, info );
		cubemaps = new _webgl_WebGLCubeMaps_js__WEBPACK_IMPORTED_MODULE_16__["WebGLCubeMaps"]( _this );
		attributes = new _webgl_WebGLAttributes_js__WEBPACK_IMPORTED_MODULE_10__["WebGLAttributes"]( _gl, capabilities );
		bindingStates = new _webgl_WebGLBindingStates_js__WEBPACK_IMPORTED_MODULE_12__["WebGLBindingStates"]( _gl, extensions, attributes, capabilities );
		geometries = new _webgl_WebGLGeometries_js__WEBPACK_IMPORTED_MODULE_18__["WebGLGeometries"]( _gl, attributes, info, bindingStates );
		objects = new _webgl_WebGLObjects_js__WEBPACK_IMPORTED_MODULE_22__["WebGLObjects"]( _gl, geometries, attributes, info );
		morphtargets = new _webgl_WebGLMorphtargets_js__WEBPACK_IMPORTED_MODULE_21__["WebGLMorphtargets"]( _gl );
		clipping = new _webgl_WebGLClipping_js__WEBPACK_IMPORTED_MODULE_15__["WebGLClipping"]( properties );
		programCache = new _webgl_WebGLPrograms_js__WEBPACK_IMPORTED_MODULE_23__["WebGLPrograms"]( _this, cubemaps, extensions, capabilities, bindingStates, clipping );
		materials = new _webgl_WebGLMaterials_js__WEBPACK_IMPORTED_MODULE_33__["WebGLMaterials"]( properties );
		renderLists = new _webgl_WebGLRenderLists_js__WEBPACK_IMPORTED_MODULE_25__["WebGLRenderLists"]( properties );
		renderStates = new _webgl_WebGLRenderStates_js__WEBPACK_IMPORTED_MODULE_26__["WebGLRenderStates"]( extensions, capabilities );
		background = new _webgl_WebGLBackground_js__WEBPACK_IMPORTED_MODULE_11__["WebGLBackground"]( _this, cubemaps, state, objects, _premultipliedAlpha );
		shadowMap = new _webgl_WebGLShadowMap_js__WEBPACK_IMPORTED_MODULE_27__["WebGLShadowMap"]( _this, objects, capabilities );

		bufferRenderer = new _webgl_WebGLBufferRenderer_js__WEBPACK_IMPORTED_MODULE_13__["WebGLBufferRenderer"]( _gl, extensions, info, capabilities );
		indexedBufferRenderer = new _webgl_WebGLIndexedBufferRenderer_js__WEBPACK_IMPORTED_MODULE_19__["WebGLIndexedBufferRenderer"]( _gl, extensions, info, capabilities );

		info.programs = programCache.programs;

		_this.capabilities = capabilities;
		_this.extensions = extensions;
		_this.properties = properties;
		_this.renderLists = renderLists;
		_this.shadowMap = shadowMap;
		_this.state = state;
		_this.info = info;

	}

	initGLContext();

	// xr

	const xr = new _webxr_WebXRManager_js__WEBPACK_IMPORTED_MODULE_32__["WebXRManager"]( _this, _gl );

	this.xr = xr;

	// API

	this.getContext = function () {

		return _gl;

	};

	this.getContextAttributes = function () {

		return _gl.getContextAttributes();

	};

	this.forceContextLoss = function () {

		const extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.loseContext();

	};

	this.forceContextRestore = function () {

		const extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.restoreContext();

	};

	this.getPixelRatio = function () {

		return _pixelRatio;

	};

	this.setPixelRatio = function ( value ) {

		if ( value === undefined ) return;

		_pixelRatio = value;

		this.setSize( _width, _height, false );

	};

	this.getSize = function ( target ) {

		if ( target === undefined ) {

			console.warn( 'WebGLRenderer: .getsize() now requires a Vector2 as an argument' );

			target = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_5__["Vector2"]();

		}

		return target.set( _width, _height );

	};

	this.setSize = function ( width, height, updateStyle ) {

		if ( xr.isPresenting ) {

			console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
			return;

		}

		_width = width;
		_height = height;

		_canvas.width = Math.floor( width * _pixelRatio );
		_canvas.height = Math.floor( height * _pixelRatio );

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.getDrawingBufferSize = function ( target ) {

		if ( target === undefined ) {

			console.warn( 'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument' );

			target = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_5__["Vector2"]();

		}

		return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

	};

	this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

		_width = width;
		_height = height;

		_pixelRatio = pixelRatio;

		_canvas.width = Math.floor( width * pixelRatio );
		_canvas.height = Math.floor( height * pixelRatio );

		this.setViewport( 0, 0, width, height );

	};

	this.getCurrentViewport = function ( target ) {

		if ( target === undefined ) {

			console.warn( 'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument' );

			target = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_7__["Vector4"]();

		}

		return target.copy( _currentViewport );

	};

	this.getViewport = function ( target ) {

		return target.copy( _viewport );

	};

	this.setViewport = function ( x, y, width, height ) {

		if ( x.isVector4 ) {

			_viewport.set( x.x, x.y, x.z, x.w );

		} else {

			_viewport.set( x, y, width, height );

		}

		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

	};

	this.getScissor = function ( target ) {

		return target.copy( _scissor );

	};

	this.setScissor = function ( x, y, width, height ) {

		if ( x.isVector4 ) {

			_scissor.set( x.x, x.y, x.z, x.w );

		} else {

			_scissor.set( x, y, width, height );

		}

		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

	};

	this.getScissorTest = function () {

		return _scissorTest;

	};

	this.setScissorTest = function ( boolean ) {

		state.setScissorTest( _scissorTest = boolean );

	};

	this.setOpaqueSort = function ( method ) {

		_opaqueSort = method;

	};

	this.setTransparentSort = function ( method ) {

		_transparentSort = method;

	};

	// Clearing

	this.getClearColor = function ( target ) {

		if ( target === undefined ) {

			console.warn( 'WebGLRenderer: .getClearColor() now requires a Color as an argument' );

			target = new _math_Color_js__WEBPACK_IMPORTED_MODULE_8__["Color"]();

		}

		return target.copy( background.getClearColor() );

	};

	this.setClearColor = function () {

		background.setClearColor.apply( background, arguments );

	};

	this.getClearAlpha = function () {

		return background.getClearAlpha();

	};

	this.setClearAlpha = function () {

		background.setClearAlpha.apply( background, arguments );

	};

	this.clear = function ( color, depth, stencil ) {

		let bits = 0;

		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		this.clear( true, false, false );

	};

	this.clearDepth = function () {

		this.clear( false, true, false );

	};

	this.clearStencil = function () {

		this.clear( false, false, true );

	};

	//

	this.dispose = function () {

		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

		renderLists.dispose();
		renderStates.dispose();
		properties.dispose();
		cubemaps.dispose();
		objects.dispose();
		bindingStates.dispose();

		xr.dispose();

		xr.removeEventListener( 'sessionstart', onXRSessionStart );
		xr.removeEventListener( 'sessionend', onXRSessionEnd );

		animation.stop();

	};

	// Events

	function onContextLost( event ) {

		event.preventDefault();

		console.log( 'THREE.WebGLRenderer: Context Lost.' );

		_isContextLost = true;

	}

	function onContextRestore( /* event */ ) {

		console.log( 'THREE.WebGLRenderer: Context Restored.' );

		_isContextLost = false;

		const infoAutoReset = info.autoReset;
		const shadowMapEnabled = shadowMap.enabled;
		const shadowMapAutoUpdate = shadowMap.autoUpdate;
		const shadowMapNeedsUpdate = shadowMap.needsUpdate;
		const shadowMapType = shadowMap.type;

		initGLContext();

		info.autoReset = infoAutoReset;
		shadowMap.enabled = shadowMapEnabled;
		shadowMap.autoUpdate = shadowMapAutoUpdate;
		shadowMap.needsUpdate = shadowMapNeedsUpdate;
		shadowMap.type = shadowMapType;

	}

	function onMaterialDispose( event ) {

		const material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	}

	// Buffer deallocation

	function deallocateMaterial( material ) {

		releaseMaterialProgramReferences( material );

		properties.remove( material );

	}


	function releaseMaterialProgramReferences( material ) {

		const programs = properties.get( material ).programs;

		if ( programs !== undefined ) {

			programs.forEach( function ( program ) {

				programCache.releaseProgram( program );

			} );

		}

	}

	// Buffer rendering

	function renderObjectImmediate( object, program ) {

		object.render( function ( object ) {

			_this.renderBufferImmediate( object, program );

		} );

	}

	this.renderBufferImmediate = function ( object, program ) {

		bindingStates.initAttributes();

		const buffers = properties.get( object );

		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

		const programAttributes = program.getAttributes();

		if ( object.hasPositions ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

			bindingStates.enableAttribute( programAttributes.position );
			_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

			bindingStates.enableAttribute( programAttributes.normal );
			_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

			bindingStates.enableAttribute( programAttributes.uv );
			_gl.vertexAttribPointer( programAttributes.uv, 2, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

			bindingStates.enableAttribute( programAttributes.color );
			_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );

		}

		bindingStates.disableUnusedAttributes();

		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

		object.count = 0;

	};

	this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

		if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

		const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

		const program = setProgram( camera, scene, material, object );

		state.setMaterial( material, frontFaceCW );

		//

		let index = geometry.index;
		const position = geometry.attributes.position;

		//

		if ( index === null ) {

			if ( position === undefined || position.count === 0 ) return;

		} else if ( index.count === 0 ) {

			return;

		}

		//

		let rangeFactor = 1;

		if ( material.wireframe === true ) {

			index = geometries.getWireframeAttribute( geometry );
			rangeFactor = 2;

		}

		if ( material.morphTargets || material.morphNormals ) {

			morphtargets.update( object, geometry, material, program );

		}

		bindingStates.setup( object, material, program, geometry, index );

		let attribute;
		let renderer = bufferRenderer;

		if ( index !== null ) {

			attribute = attributes.get( index );

			renderer = indexedBufferRenderer;
			renderer.setIndex( attribute );

		}

		//

		const dataCount = ( index !== null ) ? index.count : position.count;

		const rangeStart = geometry.drawRange.start * rangeFactor;
		const rangeCount = geometry.drawRange.count * rangeFactor;

		const groupStart = group !== null ? group.start * rangeFactor : 0;
		const groupCount = group !== null ? group.count * rangeFactor : Infinity;

		const drawStart = Math.max( rangeStart, groupStart );
		const drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

		const drawCount = Math.max( 0, drawEnd - drawStart + 1 );

		if ( drawCount === 0 ) return;

		//

		if ( object.isMesh ) {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
				renderer.setMode( _gl.LINES );

			} else {

				renderer.setMode( _gl.TRIANGLES );

			}

		} else if ( object.isLine ) {

			let lineWidth = material.linewidth;

			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

			state.setLineWidth( lineWidth * getTargetPixelRatio() );

			if ( object.isLineSegments ) {

				renderer.setMode( _gl.LINES );

			} else if ( object.isLineLoop ) {

				renderer.setMode( _gl.LINE_LOOP );

			} else {

				renderer.setMode( _gl.LINE_STRIP );

			}

		} else if ( object.isPoints ) {

			renderer.setMode( _gl.POINTS );

		} else if ( object.isSprite ) {

			renderer.setMode( _gl.TRIANGLES );

		}

		if ( object.isInstancedMesh ) {

			renderer.renderInstances( drawStart, drawCount, object.count );

		} else if ( geometry.isInstancedBufferGeometry ) {

			const instanceCount = Math.min( geometry.instanceCount, geometry._maxInstanceCount );

			renderer.renderInstances( drawStart, drawCount, instanceCount );

		} else {

			renderer.render( drawStart, drawCount );

		}

	};

	// Compile

	this.compile = function ( scene, camera ) {

		currentRenderState = renderStates.get( scene );
		currentRenderState.init();

		scene.traverseVisible( function ( object ) {

			if ( object.isLight && object.layers.test( camera.layers ) ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			}

		} );

		currentRenderState.setupLights();

		scene.traverse( function ( object ) {

			const material = object.material;

			if ( material ) {

				if ( Array.isArray( material ) ) {

					for ( let i = 0; i < material.length; i ++ ) {

						const material2 = material[ i ];

						getProgram( material2, scene, object );

					}

				} else {

					getProgram( material, scene, object );

				}

			}

		} );

	};

	// Animation Loop

	let onAnimationFrameCallback = null;

	function onAnimationFrame( time ) {

		if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

	}

	function onXRSessionStart() {

		animation.stop();

	}

	function onXRSessionEnd() {

		animation.start();

	}

	const animation = new _webgl_WebGLAnimation_js__WEBPACK_IMPORTED_MODULE_9__["WebGLAnimation"]();
	animation.setAnimationLoop( onAnimationFrame );

	if ( typeof window !== 'undefined' ) animation.setContext( window );

	this.setAnimationLoop = function ( callback ) {

		onAnimationFrameCallback = callback;
		xr.setAnimationLoop( callback );

		( callback === null ) ? animation.stop() : animation.start();

	};

	xr.addEventListener( 'sessionstart', onXRSessionStart );
	xr.addEventListener( 'sessionend', onXRSessionEnd );

	// Rendering

	this.render = function ( scene, camera ) {

		let renderTarget, forceClear;

		if ( arguments[ 2 ] !== undefined ) {

			console.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' );
			renderTarget = arguments[ 2 ];

		}

		if ( arguments[ 3 ] !== undefined ) {

			console.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' );
			forceClear = arguments[ 3 ];

		}

		if ( camera !== undefined && camera.isCamera !== true ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		if ( _isContextLost === true ) return;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === null ) camera.updateMatrixWorld();

		if ( xr.enabled === true && xr.isPresenting === true ) {

			camera = xr.getCamera( camera );

		}

		//
		if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, renderTarget || _currentRenderTarget );

		currentRenderState = renderStates.get( scene, renderStateStack.length );
		currentRenderState.init();

		renderStateStack.push( currentRenderState );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromProjectionMatrix( _projScreenMatrix );

		_localClippingEnabled = this.localClippingEnabled;
		_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

		currentRenderList = renderLists.get( scene, renderListStack.length );
		currentRenderList.init();

		renderListStack.push( currentRenderList );

		projectObject( scene, camera, 0, _this.sortObjects );

		currentRenderList.finish();

		if ( _this.sortObjects === true ) {

			currentRenderList.sort( _opaqueSort, _transparentSort );

		}

		//

		if ( _clippingEnabled === true ) clipping.beginShadows();

		const shadowsArray = currentRenderState.state.shadowsArray;

		shadowMap.render( shadowsArray, scene, camera );

		currentRenderState.setupLights();
		currentRenderState.setupLightsView( camera );

		if ( _clippingEnabled === true ) clipping.endShadows();

		//

		if ( this.info.autoReset === true ) this.info.reset();

		if ( renderTarget !== undefined ) {

			this.setRenderTarget( renderTarget );

		}

		//

		background.render( currentRenderList, scene, camera, forceClear );

		// render scene

		const opaqueObjects = currentRenderList.opaque;
		const transparentObjects = currentRenderList.transparent;

		if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
		if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

		//

		if ( _currentRenderTarget !== null ) {

			// Generate mipmap if we're using any kind of mipmap filtering

			textures.updateRenderTargetMipmap( _currentRenderTarget );

			// resolve multisample renderbuffers to a single-sample texture if necessary

			textures.updateMultisampleRenderTarget( _currentRenderTarget );

		}

		//

		if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.buffers.depth.setTest( true );
		state.buffers.depth.setMask( true );
		state.buffers.color.setMask( true );

		state.setPolygonOffset( false );

		// _gl.finish();

		bindingStates.resetDefaultState();
		_currentMaterialId = - 1;
		_currentCamera = null;

		renderStateStack.pop();

		if ( renderStateStack.length > 0 ) {

			currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

		} else {

			currentRenderState = null;

		}

		renderListStack.pop();

		if ( renderListStack.length > 0 ) {

			currentRenderList = renderListStack[ renderListStack.length - 1 ];

		} else {

			currentRenderList = null;

		}

	};

	function projectObject( object, camera, groupOrder, sortObjects ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible ) {

			if ( object.isGroup ) {

				groupOrder = object.renderOrder;

			} else if ( object.isLOD ) {

				if ( object.autoUpdate === true ) object.update( camera );

			} else if ( object.isLight ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			} else if ( object.isSprite ) {

				if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					const geometry = objects.update( object );
					const material = object.material;

					if ( material.visible ) {

						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					}

				}

			} else if ( object.isImmediateRenderObject ) {

				if ( sortObjects ) {

					_vector3.setFromMatrixPosition( object.matrixWorld )
						.applyMatrix4( _projScreenMatrix );

				}

				currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );

			} else if ( object.isMesh || object.isLine || object.isPoints ) {

				if ( object.isSkinnedMesh ) {

					// update skeleton only once in a frame

					if ( object.skeleton.frame !== info.render.frame ) {

						object.skeleton.update();
						object.skeleton.frame = info.render.frame;

					}

				}

				if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					const geometry = objects.update( object );
					const material = object.material;

					if ( Array.isArray( material ) ) {

						const groups = geometry.groups;

						for ( let i = 0, l = groups.length; i < l; i ++ ) {

							const group = groups[ i ];
							const groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

							}

						}

					} else if ( material.visible ) {

						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					}

				}

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera, groupOrder, sortObjects );

		}

	}

	function renderObjects( renderList, scene, camera ) {

		const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

		for ( let i = 0, l = renderList.length; i < l; i ++ ) {

			const renderItem = renderList[ i ];

			const object = renderItem.object;
			const geometry = renderItem.geometry;
			const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
			const group = renderItem.group;

			if ( camera.isArrayCamera ) {

				const cameras = camera.cameras;

				for ( let j = 0, jl = cameras.length; j < jl; j ++ ) {

					const camera2 = cameras[ j ];

					if ( object.layers.test( camera2.layers ) ) {

						state.viewport( _currentViewport.copy( camera2.viewport ) );

						currentRenderState.setupLightsView( camera2 );

						renderObject( object, scene, camera2, geometry, material, group );

					}

				}

			} else {

				renderObject( object, scene, camera, geometry, material, group );

			}

		}

	}

	function renderObject( object, scene, camera, geometry, material, group ) {

		object.onBeforeRender( _this, scene, camera, geometry, material, group );

		object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

		if ( object.isImmediateRenderObject ) {

			const program = setProgram( camera, scene, material, object );

			state.setMaterial( material );

			bindingStates.reset();

			renderObjectImmediate( object, program );

		} else {

			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

		}

		object.onAfterRender( _this, scene, camera, geometry, material, group );

	}

	function getProgram( material, scene, object ) {

		if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		const materialProperties = properties.get( material );

		const lights = currentRenderState.state.lights;
		const shadowsArray = currentRenderState.state.shadowsArray;

		const lightsStateVersion = lights.state.version;

		const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
		const programCacheKey = programCache.getProgramCacheKey( parameters );

		let programs = materialProperties.programs;

		// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

		materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
		materialProperties.fog = scene.fog;
		materialProperties.envMap = cubemaps.get( material.envMap || materialProperties.environment );

		if ( programs === undefined ) {

			// new material

			material.addEventListener( 'dispose', onMaterialDispose );

			programs = new Map();
			materialProperties.programs = programs;

		}

		let program = programs.get( programCacheKey );

		if ( program !== undefined ) {

			// early out if program and light state is identical

			if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {

				updateCommonMaterialProperties( material, parameters );

				return program;

			}

		} else {

			parameters.uniforms = programCache.getUniforms( material );

			material.onBeforeCompile( parameters, _this );

			program = programCache.acquireProgram( parameters, programCacheKey );
			programs.set( programCacheKey, program );

			materialProperties.uniforms = parameters.uniforms;

		}

		const uniforms = materialProperties.uniforms;

		if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {

			uniforms.clippingPlanes = clipping.uniform;

		}

		updateCommonMaterialProperties( material, parameters );

		// store the light setup it was created for

		materialProperties.needsLights = materialNeedsLights( material );
		materialProperties.lightsStateVersion = lightsStateVersion;

		if ( materialProperties.needsLights ) {

			// wire up the material to this renderer's lighting state

			uniforms.ambientLightColor.value = lights.state.ambient;
			uniforms.lightProbe.value = lights.state.probe;
			uniforms.directionalLights.value = lights.state.directional;
			uniforms.directionalLightShadows.value = lights.state.directionalShadow;
			uniforms.spotLights.value = lights.state.spot;
			uniforms.spotLightShadows.value = lights.state.spotShadow;
			uniforms.rectAreaLights.value = lights.state.rectArea;
			uniforms.ltc_1.value = lights.state.rectAreaLTC1;
			uniforms.ltc_2.value = lights.state.rectAreaLTC2;
			uniforms.pointLights.value = lights.state.point;
			uniforms.pointLightShadows.value = lights.state.pointShadow;
			uniforms.hemisphereLights.value = lights.state.hemi;

			uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
			uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
			uniforms.spotShadowMap.value = lights.state.spotShadowMap;
			uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
			uniforms.pointShadowMap.value = lights.state.pointShadowMap;
			uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
			// TODO (abelnation): add area lights shadow info to uniforms

		}

		const progUniforms = program.getUniforms();
		const uniformsList = _webgl_WebGLUniforms_js__WEBPACK_IMPORTED_MODULE_30__["WebGLUniforms"].seqWithValue( progUniforms.seq, uniforms );

		materialProperties.currentProgram = program;
		materialProperties.uniformsList = uniformsList;

		return program;

	}

	function updateCommonMaterialProperties( material, parameters ) {

		const materialProperties = properties.get( material );

		materialProperties.outputEncoding = parameters.outputEncoding;
		materialProperties.instancing = parameters.instancing;
		materialProperties.numClippingPlanes = parameters.numClippingPlanes;
		materialProperties.numIntersection = parameters.numClipIntersection;
		materialProperties.vertexAlphas = parameters.vertexAlphas;

	}

	function setProgram( camera, scene, material, object ) {

		if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		textures.resetTextureUnits();

		const fog = scene.fog;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;
		const encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
		const envMap = cubemaps.get( material.envMap || environment );
		const vertexAlphas = material.vertexColors === true && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;

		const materialProperties = properties.get( material );
		const lights = currentRenderState.state.lights;

		if ( _clippingEnabled === true ) {

			if ( _localClippingEnabled === true || camera !== _currentCamera ) {

				const useCache =
					camera === _currentCamera &&
					material.id === _currentMaterialId;

				// we might want to call this function with some ClippingGroup
				// object instead of the material, once it becomes feasible
				// (#8465, #8379)
				clipping.setState( material, camera, useCache );

			}

		}

		//

		let needsProgramChange = false;

		if ( material.version === materialProperties.__version ) {

			if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

				needsProgramChange = true;

			} else if ( materialProperties.outputEncoding !== encoding ) {

				needsProgramChange = true;

			} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {

				needsProgramChange = true;

			} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {

				needsProgramChange = true;

			} else if ( materialProperties.envMap !== envMap ) {

				needsProgramChange = true;

			} else if ( material.fog && materialProperties.fog !== fog ) {

				needsProgramChange = true;

			} else if ( materialProperties.numClippingPlanes !== undefined &&
				( materialProperties.numClippingPlanes !== clipping.numPlanes ||
				materialProperties.numIntersection !== clipping.numIntersection ) ) {

				needsProgramChange = true;

			} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {

				needsProgramChange = true;

			}

		} else {

			needsProgramChange = true;
			materialProperties.__version = material.version;

		}

		//

		let program = materialProperties.currentProgram;

		if ( needsProgramChange === true ) {

			program = getProgram( material, scene, object );

		}

		let refreshProgram = false;
		let refreshMaterial = false;
		let refreshLights = false;

		const p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.uniforms;

		if ( state.useProgram( program.program ) ) {

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || _currentCamera !== camera ) {

			p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

			if ( capabilities.logarithmicDepthBuffer ) {

				p_uniforms.setValue( _gl, 'logDepthBufFC',
					2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}

			if ( _currentCamera !== camera ) {

				_currentCamera = camera;

				// lighting uniforms depend on the camera so enforce an update
				// now, in case this material supports lights - or later, when
				// the next material that does gets activated:

				refreshMaterial = true;		// set to true on material change
				refreshLights = true;		// remains set until update done

			}

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material.isShaderMaterial ||
				material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshStandardMaterial ||
				material.envMap ) {

				const uCamPos = p_uniforms.map.cameraPosition;

				if ( uCamPos !== undefined ) {

					uCamPos.setValue( _gl,
						_vector3.setFromMatrixPosition( camera.matrixWorld ) );

				}

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ) {

				p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ||
				material.isShadowMaterial ||
				material.skinning ) {

				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

			}

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// otherwise textures used for skinning can take over texture units reserved for other material textures

		if ( material.skinning ) {

			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

			const skeleton = object.skeleton;

			if ( skeleton ) {

				const bones = skeleton.bones;

				if ( capabilities.floatVertexTextures ) {

					if ( skeleton.boneTexture === null ) {

						// layout (1 matrix = 4 pixels)
						//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
						//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
						//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
						//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
						//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


						let size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
						size = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__["MathUtils"].ceilPowerOfTwo( size );
						size = Math.max( size, 4 );

						const boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
						boneMatrices.set( skeleton.boneMatrices ); // copy current values

						const boneTexture = new _textures_DataTexture_js__WEBPACK_IMPORTED_MODULE_2__["DataTexture"]( boneMatrices, size, size, _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"], _constants_js__WEBPACK_IMPORTED_MODULE_0__["FloatType"] );

						skeleton.boneMatrices = boneMatrices;
						skeleton.boneTexture = boneTexture;
						skeleton.boneTextureSize = size;

					}

					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
					p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

				} else {

					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

				}

			}

		}

		if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

			materialProperties.receiveShadow = object.receiveShadow;
			p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

		}

		if ( refreshMaterial ) {

			p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

			if ( materialProperties.needsLights ) {

				// the current material requires lighting info

				// note: all lighting uniforms are always set correctly
				// they simply reference the renderer's state for their
				// values
				//
				// use the current material's .needsUpdate flags to set
				// the GL state when required

				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

			}

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				materials.refreshFogUniforms( m_uniforms, fog );

			}

			materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height );

			_webgl_WebGLUniforms_js__WEBPACK_IMPORTED_MODULE_30__["WebGLUniforms"].upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

		}

		if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

			_webgl_WebGLUniforms_js__WEBPACK_IMPORTED_MODULE_30__["WebGLUniforms"].upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
			material.uniformsNeedUpdate = false;

		}

		if ( material.isSpriteMaterial ) {

			p_uniforms.setValue( _gl, 'center', object.center );

		}

		// common matrices

		p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
		p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

		return program;

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate( uniforms, value ) {

		uniforms.ambientLightColor.needsUpdate = value;
		uniforms.lightProbe.needsUpdate = value;

		uniforms.directionalLights.needsUpdate = value;
		uniforms.directionalLightShadows.needsUpdate = value;
		uniforms.pointLights.needsUpdate = value;
		uniforms.pointLightShadows.needsUpdate = value;
		uniforms.spotLights.needsUpdate = value;
		uniforms.spotLightShadows.needsUpdate = value;
		uniforms.rectAreaLights.needsUpdate = value;
		uniforms.hemisphereLights.needsUpdate = value;

	}

	function materialNeedsLights( material ) {

		return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
			material.isMeshStandardMaterial || material.isShadowMaterial ||
			( material.isShaderMaterial && material.lights === true );

	}

	this.getActiveCubeFace = function () {

		return _currentActiveCubeFace;

	};

	this.getActiveMipmapLevel = function () {

		return _currentActiveMipmapLevel;

	};

	this.getRenderTarget = function () {

		return _currentRenderTarget;

	};

	this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

		_currentRenderTarget = renderTarget;
		_currentActiveCubeFace = activeCubeFace;
		_currentActiveMipmapLevel = activeMipmapLevel;

		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

			textures.setupRenderTarget( renderTarget );

		}

		let framebuffer = null;
		let isCube = false;
		let isRenderTarget3D = false;

		if ( renderTarget ) {

			const texture = renderTarget.texture;

			if ( texture.isDataTexture3D || texture.isDataTexture2DArray ) {

				isRenderTarget3D = true;

			}

			const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( renderTarget.isWebGLCubeRenderTarget ) {

				framebuffer = __webglFramebuffer[ activeCubeFace ];
				isCube = true;

			} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {

				framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

			} else {

				framebuffer = __webglFramebuffer;

			}

			_currentViewport.copy( renderTarget.viewport );
			_currentScissor.copy( renderTarget.scissor );
			_currentScissorTest = renderTarget.scissorTest;

		} else {

			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
			_currentScissorTest = _scissorTest;

		}

		state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

		state.viewport( _currentViewport );
		state.scissor( _currentScissor );
		state.setScissorTest( _currentScissorTest );

		if ( isCube ) {

			const textureProperties = properties.get( renderTarget.texture );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

		} else if ( isRenderTarget3D ) {

			const textureProperties = properties.get( renderTarget.texture );
			const layer = activeCubeFace || 0;
			_gl.framebufferTextureLayer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );

		}

	};

	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

		if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			return;

		}

		let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

		if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

			framebuffer = framebuffer[ activeCubeFaceIndex ];

		}

		if ( framebuffer ) {

			state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

			try {

				const texture = renderTarget.texture;
				const textureFormat = texture.format;
				const textureType = texture.type;

				if ( textureFormat !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"] && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					return;

				}

				const halfFloatSupportedByExt = ( textureType === _constants_js__WEBPACK_IMPORTED_MODULE_0__["HalfFloatType"] ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );

				if ( textureType !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedByteType"] && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // Edge and Chrome Mac < 52 (#9513)
					! ( textureType === _constants_js__WEBPACK_IMPORTED_MODULE_0__["FloatType"] && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
					! halfFloatSupportedByExt ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					return;

				}

				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

						_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

					}

				} else {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				}

			} finally {

				// restore framebuffer of current render target if necessary

				const framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
				state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

			}

		}

	};

	this.copyFramebufferToTexture = function ( position, texture, level = 0 ) {

		const levelScale = Math.pow( 2, - level );
		const width = Math.floor( texture.image.width * levelScale );
		const height = Math.floor( texture.image.height * levelScale );
		const glFormat = utils.convert( texture.format );

		textures.setTexture2D( texture, 0 );

		_gl.copyTexImage2D( _gl.TEXTURE_2D, level, glFormat, position.x, position.y, width, height, 0 );

		state.unbindTexture();

	};

	this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {

		const width = srcTexture.image.width;
		const height = srcTexture.image.height;
		const glFormat = utils.convert( dstTexture.format );
		const glType = utils.convert( dstTexture.type );

		textures.setTexture2D( dstTexture, 0 );

		// As another texture upload may have changed pixelStorei
		// parameters, make sure they are correct for the dstTexture
		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

		if ( srcTexture.isDataTexture ) {

			_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

		} else {

			if ( srcTexture.isCompressedTexture ) {

				_gl.compressedTexSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

			} else {

				_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image );

			}

		}

		// Generate mipmaps only when copying level 0
		if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( _gl.TEXTURE_2D );

		state.unbindTexture();

	};

	this.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {

		if ( _this.isWebGL1Renderer ) {

			console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );
			return;

		}

		const { width, height, data } = srcTexture.image;
		const glFormat = utils.convert( dstTexture.format );
		const glType = utils.convert( dstTexture.type );
		let glTarget;

		if ( dstTexture.isDataTexture3D ) {

			textures.setTexture3D( dstTexture, 0 );
			glTarget = _gl.TEXTURE_3D;

		} else if ( dstTexture.isDataTexture2DArray ) {

			textures.setTexture2DArray( dstTexture, 0 );
			glTarget = _gl.TEXTURE_2D_ARRAY;

		} else {

			console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );
			return;

		}

		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

		const unpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );
		const unpackImageHeight = _gl.getParameter( _gl.UNPACK_IMAGE_HEIGHT );
		const unpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );
		const unpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );
		const unpackSkipImages = _gl.getParameter( _gl.UNPACK_SKIP_IMAGES );

		_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, width );
		_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, height );
		_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, sourceBox.min.x );
		_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, sourceBox.min.y );
		_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, sourceBox.min.z );

		_gl.texSubImage3D(
			glTarget,
			level,
			position.x,
			position.y,
			position.z,
			sourceBox.max.x - sourceBox.min.x + 1,
			sourceBox.max.y - sourceBox.min.y + 1,
			sourceBox.max.z - sourceBox.min.z + 1,
			glFormat,
			glType,
			data
		);

		_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, unpackRowLen );
		_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight );
		_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, unpackSkipPixels );
		_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, unpackSkipRows );
		_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, unpackSkipImages );

		// Generate mipmaps only when copying level 0
		if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );

		state.unbindTexture();

	};

	this.initTexture = function ( texture ) {

		textures.setTexture2D( texture, 0 );

		state.unbindTexture();

	};

	this.resetState = function () {

		_currentActiveCubeFace = 0;
		_currentActiveMipmapLevel = 0;
		_currentRenderTarget = null;

		state.reset();
		bindingStates.reset();

	};

	if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

		__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

	}

}




/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk.js":
/*!*************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk.js ***!
  \*************************************************************************************/
/*! exports provided: ShaderChunk */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderChunk", function() { return ShaderChunk; });
/* harmony import */ var _ShaderChunk_alphamap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ShaderChunk/alphamap_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_alphamap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ShaderChunk/alphamap_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_alphatest_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShaderChunk/alphatest_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_aomap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ShaderChunk/aomap_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/aomap_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_aomap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ShaderChunk/aomap_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_begin_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ShaderChunk/begin_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/begin_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_beginnormal_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ShaderChunk/beginnormal_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_bsdfs_glsl_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ShaderChunk/bsdfs.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/bsdfs.glsl.js");
/* harmony import */ var _ShaderChunk_bumpmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ShaderChunk/bumpmap_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_clipping_planes_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ShaderChunk/clipping_planes_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_clipping_planes_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ShaderChunk/clipping_planes_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_clipping_planes_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ShaderChunk/clipping_planes_pars_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_clipping_planes_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ShaderChunk/clipping_planes_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_color_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./ShaderChunk/color_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/color_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_color_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./ShaderChunk/color_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_color_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./ShaderChunk/color_pars_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_color_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./ShaderChunk/color_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/color_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_common_glsl_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./ShaderChunk/common.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/common.glsl.js");
/* harmony import */ var _ShaderChunk_cube_uv_reflection_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./ShaderChunk/cube_uv_reflection_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_defaultnormal_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./ShaderChunk/defaultnormal_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_displacementmap_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./ShaderChunk/displacementmap_pars_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_displacementmap_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./ShaderChunk/displacementmap_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_emissivemap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./ShaderChunk/emissivemap_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_emissivemap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./ShaderChunk/emissivemap_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_encodings_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./ShaderChunk/encodings_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/encodings_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_encodings_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./ShaderChunk/encodings_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_envmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./ShaderChunk/envmap_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/envmap_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_envmap_common_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./ShaderChunk/envmap_common_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/envmap_common_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_envmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./ShaderChunk/envmap_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_envmap_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./ShaderChunk/envmap_pars_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_envmap_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./ShaderChunk/envmap_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/envmap_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_fog_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./ShaderChunk/fog_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/fog_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_fog_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./ShaderChunk/fog_pars_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/fog_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_fog_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./ShaderChunk/fog_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/fog_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_fog_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./ShaderChunk/fog_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_gradientmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./ShaderChunk/gradientmap_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/gradientmap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_lightmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./ShaderChunk/lightmap_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_lightmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./ShaderChunk/lightmap_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_lights_lambert_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./ShaderChunk/lights_lambert_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_lights_pars_begin_glsl_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./ShaderChunk/lights_pars_begin.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_pars_begin.glsl.js");
/* harmony import */ var _ShaderChunk_envmap_physical_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./ShaderChunk/envmap_physical_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/envmap_physical_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_lights_toon_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./ShaderChunk/lights_toon_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_toon_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_lights_toon_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./ShaderChunk/lights_toon_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_toon_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_lights_phong_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./ShaderChunk/lights_phong_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_lights_phong_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./ShaderChunk/lights_phong_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_lights_physical_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./ShaderChunk/lights_physical_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_lights_physical_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./ShaderChunk/lights_physical_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_lights_fragment_begin_glsl_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./ShaderChunk/lights_fragment_begin.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_fragment_begin.glsl.js");
/* harmony import */ var _ShaderChunk_lights_fragment_maps_glsl_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./ShaderChunk/lights_fragment_maps.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_fragment_maps.glsl.js");
/* harmony import */ var _ShaderChunk_lights_fragment_end_glsl_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./ShaderChunk/lights_fragment_end.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_fragment_end.glsl.js");
/* harmony import */ var _ShaderChunk_logdepthbuf_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./ShaderChunk/logdepthbuf_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_logdepthbuf_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./ShaderChunk/logdepthbuf_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_logdepthbuf_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./ShaderChunk/logdepthbuf_pars_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_logdepthbuf_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./ShaderChunk/logdepthbuf_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_map_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./ShaderChunk/map_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/map_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_map_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./ShaderChunk/map_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_map_particle_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./ShaderChunk/map_particle_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_map_particle_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./ShaderChunk/map_particle_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_metalnessmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./ShaderChunk/metalnessmap_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_metalnessmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./ShaderChunk/metalnessmap_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_morphnormal_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./ShaderChunk/morphnormal_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_morphtarget_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./ShaderChunk/morphtarget_pars_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_morphtarget_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./ShaderChunk/morphtarget_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_normal_fragment_begin_glsl_js__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./ShaderChunk/normal_fragment_begin.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/normal_fragment_begin.glsl.js");
/* harmony import */ var _ShaderChunk_normal_fragment_maps_glsl_js__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./ShaderChunk/normal_fragment_maps.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/normal_fragment_maps.glsl.js");
/* harmony import */ var _ShaderChunk_normalmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./ShaderChunk/normalmap_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_clearcoat_normal_fragment_begin_glsl_js__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./ShaderChunk/clearcoat_normal_fragment_begin.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/clearcoat_normal_fragment_begin.glsl.js");
/* harmony import */ var _ShaderChunk_clearcoat_normal_fragment_maps_glsl_js__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./ShaderChunk/clearcoat_normal_fragment_maps.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/clearcoat_normal_fragment_maps.glsl.js");
/* harmony import */ var _ShaderChunk_clearcoat_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./ShaderChunk/clearcoat_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/clearcoat_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_packing_glsl_js__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./ShaderChunk/packing.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/packing.glsl.js");
/* harmony import */ var _ShaderChunk_premultiplied_alpha_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./ShaderChunk/premultiplied_alpha_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_project_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./ShaderChunk/project_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/project_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_dithering_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./ShaderChunk/dithering_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/dithering_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_dithering_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./ShaderChunk/dithering_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/dithering_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_roughnessmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./ShaderChunk/roughnessmap_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_roughnessmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./ShaderChunk/roughnessmap_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_shadowmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./ShaderChunk/shadowmap_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_shadowmap_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./ShaderChunk/shadowmap_pars_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_shadowmap_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./ShaderChunk/shadowmap_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_shadowmask_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./ShaderChunk/shadowmask_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_skinbase_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./ShaderChunk/skinbase_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_skinning_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./ShaderChunk/skinning_pars_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_skinning_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./ShaderChunk/skinning_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/skinning_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_skinnormal_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./ShaderChunk/skinnormal_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_specularmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./ShaderChunk/specularmap_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_specularmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./ShaderChunk/specularmap_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_tonemapping_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./ShaderChunk/tonemapping_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_tonemapping_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./ShaderChunk/tonemapping_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_transmissionmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./ShaderChunk/transmissionmap_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/transmissionmap_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_transmissionmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./ShaderChunk/transmissionmap_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/transmissionmap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_uv_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./ShaderChunk/uv_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_uv_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./ShaderChunk/uv_pars_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_uv_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./ShaderChunk/uv_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/uv_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_uv2_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./ShaderChunk/uv2_pars_fragment.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_uv2_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./ShaderChunk/uv2_pars_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_uv2_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./ShaderChunk/uv2_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/uv2_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_worldpos_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./ShaderChunk/worldpos_vertex.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl.js");
/* harmony import */ var _ShaderLib_background_frag_glsl_js__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./ShaderLib/background_frag.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/background_frag.glsl.js");
/* harmony import */ var _ShaderLib_background_vert_glsl_js__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./ShaderLib/background_vert.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/background_vert.glsl.js");
/* harmony import */ var _ShaderLib_cube_frag_glsl_js__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./ShaderLib/cube_frag.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/cube_frag.glsl.js");
/* harmony import */ var _ShaderLib_cube_vert_glsl_js__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./ShaderLib/cube_vert.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/cube_vert.glsl.js");
/* harmony import */ var _ShaderLib_depth_frag_glsl_js__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./ShaderLib/depth_frag.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/depth_frag.glsl.js");
/* harmony import */ var _ShaderLib_depth_vert_glsl_js__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./ShaderLib/depth_vert.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/depth_vert.glsl.js");
/* harmony import */ var _ShaderLib_distanceRGBA_frag_glsl_js__WEBPACK_IMPORTED_MODULE_103__ = __webpack_require__(/*! ./ShaderLib/distanceRGBA_frag.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl.js");
/* harmony import */ var _ShaderLib_distanceRGBA_vert_glsl_js__WEBPACK_IMPORTED_MODULE_104__ = __webpack_require__(/*! ./ShaderLib/distanceRGBA_vert.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl.js");
/* harmony import */ var _ShaderLib_equirect_frag_glsl_js__WEBPACK_IMPORTED_MODULE_105__ = __webpack_require__(/*! ./ShaderLib/equirect_frag.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/equirect_frag.glsl.js");
/* harmony import */ var _ShaderLib_equirect_vert_glsl_js__WEBPACK_IMPORTED_MODULE_106__ = __webpack_require__(/*! ./ShaderLib/equirect_vert.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/equirect_vert.glsl.js");
/* harmony import */ var _ShaderLib_linedashed_frag_glsl_js__WEBPACK_IMPORTED_MODULE_107__ = __webpack_require__(/*! ./ShaderLib/linedashed_frag.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/linedashed_frag.glsl.js");
/* harmony import */ var _ShaderLib_linedashed_vert_glsl_js__WEBPACK_IMPORTED_MODULE_108__ = __webpack_require__(/*! ./ShaderLib/linedashed_vert.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/linedashed_vert.glsl.js");
/* harmony import */ var _ShaderLib_meshbasic_frag_glsl_js__WEBPACK_IMPORTED_MODULE_109__ = __webpack_require__(/*! ./ShaderLib/meshbasic_frag.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshbasic_frag.glsl.js");
/* harmony import */ var _ShaderLib_meshbasic_vert_glsl_js__WEBPACK_IMPORTED_MODULE_110__ = __webpack_require__(/*! ./ShaderLib/meshbasic_vert.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshbasic_vert.glsl.js");
/* harmony import */ var _ShaderLib_meshlambert_frag_glsl_js__WEBPACK_IMPORTED_MODULE_111__ = __webpack_require__(/*! ./ShaderLib/meshlambert_frag.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshlambert_frag.glsl.js");
/* harmony import */ var _ShaderLib_meshlambert_vert_glsl_js__WEBPACK_IMPORTED_MODULE_112__ = __webpack_require__(/*! ./ShaderLib/meshlambert_vert.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshlambert_vert.glsl.js");
/* harmony import */ var _ShaderLib_meshmatcap_frag_glsl_js__WEBPACK_IMPORTED_MODULE_113__ = __webpack_require__(/*! ./ShaderLib/meshmatcap_frag.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshmatcap_frag.glsl.js");
/* harmony import */ var _ShaderLib_meshmatcap_vert_glsl_js__WEBPACK_IMPORTED_MODULE_114__ = __webpack_require__(/*! ./ShaderLib/meshmatcap_vert.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshmatcap_vert.glsl.js");
/* harmony import */ var _ShaderLib_meshtoon_frag_glsl_js__WEBPACK_IMPORTED_MODULE_115__ = __webpack_require__(/*! ./ShaderLib/meshtoon_frag.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshtoon_frag.glsl.js");
/* harmony import */ var _ShaderLib_meshtoon_vert_glsl_js__WEBPACK_IMPORTED_MODULE_116__ = __webpack_require__(/*! ./ShaderLib/meshtoon_vert.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshtoon_vert.glsl.js");
/* harmony import */ var _ShaderLib_meshphong_frag_glsl_js__WEBPACK_IMPORTED_MODULE_117__ = __webpack_require__(/*! ./ShaderLib/meshphong_frag.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshphong_frag.glsl.js");
/* harmony import */ var _ShaderLib_meshphong_vert_glsl_js__WEBPACK_IMPORTED_MODULE_118__ = __webpack_require__(/*! ./ShaderLib/meshphong_vert.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshphong_vert.glsl.js");
/* harmony import */ var _ShaderLib_meshphysical_frag_glsl_js__WEBPACK_IMPORTED_MODULE_119__ = __webpack_require__(/*! ./ShaderLib/meshphysical_frag.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshphysical_frag.glsl.js");
/* harmony import */ var _ShaderLib_meshphysical_vert_glsl_js__WEBPACK_IMPORTED_MODULE_120__ = __webpack_require__(/*! ./ShaderLib/meshphysical_vert.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshphysical_vert.glsl.js");
/* harmony import */ var _ShaderLib_normal_frag_glsl_js__WEBPACK_IMPORTED_MODULE_121__ = __webpack_require__(/*! ./ShaderLib/normal_frag.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/normal_frag.glsl.js");
/* harmony import */ var _ShaderLib_normal_vert_glsl_js__WEBPACK_IMPORTED_MODULE_122__ = __webpack_require__(/*! ./ShaderLib/normal_vert.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/normal_vert.glsl.js");
/* harmony import */ var _ShaderLib_points_frag_glsl_js__WEBPACK_IMPORTED_MODULE_123__ = __webpack_require__(/*! ./ShaderLib/points_frag.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/points_frag.glsl.js");
/* harmony import */ var _ShaderLib_points_vert_glsl_js__WEBPACK_IMPORTED_MODULE_124__ = __webpack_require__(/*! ./ShaderLib/points_vert.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/points_vert.glsl.js");
/* harmony import */ var _ShaderLib_shadow_frag_glsl_js__WEBPACK_IMPORTED_MODULE_125__ = __webpack_require__(/*! ./ShaderLib/shadow_frag.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/shadow_frag.glsl.js");
/* harmony import */ var _ShaderLib_shadow_vert_glsl_js__WEBPACK_IMPORTED_MODULE_126__ = __webpack_require__(/*! ./ShaderLib/shadow_vert.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/shadow_vert.glsl.js");
/* harmony import */ var _ShaderLib_sprite_frag_glsl_js__WEBPACK_IMPORTED_MODULE_127__ = __webpack_require__(/*! ./ShaderLib/sprite_frag.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/sprite_frag.glsl.js");
/* harmony import */ var _ShaderLib_sprite_vert_glsl_js__WEBPACK_IMPORTED_MODULE_128__ = __webpack_require__(/*! ./ShaderLib/sprite_vert.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/sprite_vert.glsl.js");



































































































































const ShaderChunk = {
	alphamap_fragment: _ShaderChunk_alphamap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_0__["default"],
	alphamap_pars_fragment: _ShaderChunk_alphamap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_1__["default"],
	alphatest_fragment: _ShaderChunk_alphatest_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_2__["default"],
	aomap_fragment: _ShaderChunk_aomap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_3__["default"],
	aomap_pars_fragment: _ShaderChunk_aomap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_4__["default"],
	begin_vertex: _ShaderChunk_begin_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_5__["default"],
	beginnormal_vertex: _ShaderChunk_beginnormal_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_6__["default"],
	bsdfs: _ShaderChunk_bsdfs_glsl_js__WEBPACK_IMPORTED_MODULE_7__["default"],
	bumpmap_pars_fragment: _ShaderChunk_bumpmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_8__["default"],
	clipping_planes_fragment: _ShaderChunk_clipping_planes_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_9__["default"],
	clipping_planes_pars_fragment: _ShaderChunk_clipping_planes_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_10__["default"],
	clipping_planes_pars_vertex: _ShaderChunk_clipping_planes_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_11__["default"],
	clipping_planes_vertex: _ShaderChunk_clipping_planes_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_12__["default"],
	color_fragment: _ShaderChunk_color_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_13__["default"],
	color_pars_fragment: _ShaderChunk_color_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_14__["default"],
	color_pars_vertex: _ShaderChunk_color_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_15__["default"],
	color_vertex: _ShaderChunk_color_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_16__["default"],
	common: _ShaderChunk_common_glsl_js__WEBPACK_IMPORTED_MODULE_17__["default"],
	cube_uv_reflection_fragment: _ShaderChunk_cube_uv_reflection_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_18__["default"],
	defaultnormal_vertex: _ShaderChunk_defaultnormal_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_19__["default"],
	displacementmap_pars_vertex: _ShaderChunk_displacementmap_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_20__["default"],
	displacementmap_vertex: _ShaderChunk_displacementmap_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_21__["default"],
	emissivemap_fragment: _ShaderChunk_emissivemap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_22__["default"],
	emissivemap_pars_fragment: _ShaderChunk_emissivemap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_23__["default"],
	encodings_fragment: _ShaderChunk_encodings_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_24__["default"],
	encodings_pars_fragment: _ShaderChunk_encodings_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_25__["default"],
	envmap_fragment: _ShaderChunk_envmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_26__["default"],
	envmap_common_pars_fragment: _ShaderChunk_envmap_common_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_27__["default"],
	envmap_pars_fragment: _ShaderChunk_envmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_28__["default"],
	envmap_pars_vertex: _ShaderChunk_envmap_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_29__["default"],
	envmap_physical_pars_fragment: _ShaderChunk_envmap_physical_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_40__["default"],
	envmap_vertex: _ShaderChunk_envmap_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_30__["default"],
	fog_vertex: _ShaderChunk_fog_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_31__["default"],
	fog_pars_vertex: _ShaderChunk_fog_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_32__["default"],
	fog_fragment: _ShaderChunk_fog_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_33__["default"],
	fog_pars_fragment: _ShaderChunk_fog_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_34__["default"],
	gradientmap_pars_fragment: _ShaderChunk_gradientmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_35__["default"],
	lightmap_fragment: _ShaderChunk_lightmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_36__["default"],
	lightmap_pars_fragment: _ShaderChunk_lightmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_37__["default"],
	lights_lambert_vertex: _ShaderChunk_lights_lambert_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_38__["default"],
	lights_pars_begin: _ShaderChunk_lights_pars_begin_glsl_js__WEBPACK_IMPORTED_MODULE_39__["default"],
	lights_toon_fragment: _ShaderChunk_lights_toon_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_41__["default"],
	lights_toon_pars_fragment: _ShaderChunk_lights_toon_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_42__["default"],
	lights_phong_fragment: _ShaderChunk_lights_phong_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_43__["default"],
	lights_phong_pars_fragment: _ShaderChunk_lights_phong_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_44__["default"],
	lights_physical_fragment: _ShaderChunk_lights_physical_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_45__["default"],
	lights_physical_pars_fragment: _ShaderChunk_lights_physical_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_46__["default"],
	lights_fragment_begin: _ShaderChunk_lights_fragment_begin_glsl_js__WEBPACK_IMPORTED_MODULE_47__["default"],
	lights_fragment_maps: _ShaderChunk_lights_fragment_maps_glsl_js__WEBPACK_IMPORTED_MODULE_48__["default"],
	lights_fragment_end: _ShaderChunk_lights_fragment_end_glsl_js__WEBPACK_IMPORTED_MODULE_49__["default"],
	logdepthbuf_fragment: _ShaderChunk_logdepthbuf_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_50__["default"],
	logdepthbuf_pars_fragment: _ShaderChunk_logdepthbuf_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_51__["default"],
	logdepthbuf_pars_vertex: _ShaderChunk_logdepthbuf_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_52__["default"],
	logdepthbuf_vertex: _ShaderChunk_logdepthbuf_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_53__["default"],
	map_fragment: _ShaderChunk_map_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_54__["default"],
	map_pars_fragment: _ShaderChunk_map_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_55__["default"],
	map_particle_fragment: _ShaderChunk_map_particle_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_56__["default"],
	map_particle_pars_fragment: _ShaderChunk_map_particle_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_57__["default"],
	metalnessmap_fragment: _ShaderChunk_metalnessmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_58__["default"],
	metalnessmap_pars_fragment: _ShaderChunk_metalnessmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_59__["default"],
	morphnormal_vertex: _ShaderChunk_morphnormal_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_60__["default"],
	morphtarget_pars_vertex: _ShaderChunk_morphtarget_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_61__["default"],
	morphtarget_vertex: _ShaderChunk_morphtarget_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_62__["default"],
	normal_fragment_begin: _ShaderChunk_normal_fragment_begin_glsl_js__WEBPACK_IMPORTED_MODULE_63__["default"],
	normal_fragment_maps: _ShaderChunk_normal_fragment_maps_glsl_js__WEBPACK_IMPORTED_MODULE_64__["default"],
	normalmap_pars_fragment: _ShaderChunk_normalmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_65__["default"],
	clearcoat_normal_fragment_begin: _ShaderChunk_clearcoat_normal_fragment_begin_glsl_js__WEBPACK_IMPORTED_MODULE_66__["default"],
	clearcoat_normal_fragment_maps: _ShaderChunk_clearcoat_normal_fragment_maps_glsl_js__WEBPACK_IMPORTED_MODULE_67__["default"],
	clearcoat_pars_fragment: _ShaderChunk_clearcoat_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_68__["default"],
	packing: _ShaderChunk_packing_glsl_js__WEBPACK_IMPORTED_MODULE_69__["default"],
	premultiplied_alpha_fragment: _ShaderChunk_premultiplied_alpha_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_70__["default"],
	project_vertex: _ShaderChunk_project_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_71__["default"],
	dithering_fragment: _ShaderChunk_dithering_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_72__["default"],
	dithering_pars_fragment: _ShaderChunk_dithering_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_73__["default"],
	roughnessmap_fragment: _ShaderChunk_roughnessmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_74__["default"],
	roughnessmap_pars_fragment: _ShaderChunk_roughnessmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_75__["default"],
	shadowmap_pars_fragment: _ShaderChunk_shadowmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_76__["default"],
	shadowmap_pars_vertex: _ShaderChunk_shadowmap_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_77__["default"],
	shadowmap_vertex: _ShaderChunk_shadowmap_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_78__["default"],
	shadowmask_pars_fragment: _ShaderChunk_shadowmask_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_79__["default"],
	skinbase_vertex: _ShaderChunk_skinbase_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_80__["default"],
	skinning_pars_vertex: _ShaderChunk_skinning_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_81__["default"],
	skinning_vertex: _ShaderChunk_skinning_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_82__["default"],
	skinnormal_vertex: _ShaderChunk_skinnormal_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_83__["default"],
	specularmap_fragment: _ShaderChunk_specularmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_84__["default"],
	specularmap_pars_fragment: _ShaderChunk_specularmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_85__["default"],
	tonemapping_fragment: _ShaderChunk_tonemapping_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_86__["default"],
	tonemapping_pars_fragment: _ShaderChunk_tonemapping_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_87__["default"],
	transmissionmap_fragment: _ShaderChunk_transmissionmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_88__["default"],
	transmissionmap_pars_fragment: _ShaderChunk_transmissionmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_89__["default"],
	uv_pars_fragment: _ShaderChunk_uv_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_90__["default"],
	uv_pars_vertex: _ShaderChunk_uv_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_91__["default"],
	uv_vertex: _ShaderChunk_uv_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_92__["default"],
	uv2_pars_fragment: _ShaderChunk_uv2_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_93__["default"],
	uv2_pars_vertex: _ShaderChunk_uv2_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_94__["default"],
	uv2_vertex: _ShaderChunk_uv2_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_95__["default"],
	worldpos_vertex: _ShaderChunk_worldpos_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_96__["default"],

	background_frag: _ShaderLib_background_frag_glsl_js__WEBPACK_IMPORTED_MODULE_97__["default"],
	background_vert: _ShaderLib_background_vert_glsl_js__WEBPACK_IMPORTED_MODULE_98__["default"],
	cube_frag: _ShaderLib_cube_frag_glsl_js__WEBPACK_IMPORTED_MODULE_99__["default"],
	cube_vert: _ShaderLib_cube_vert_glsl_js__WEBPACK_IMPORTED_MODULE_100__["default"],
	depth_frag: _ShaderLib_depth_frag_glsl_js__WEBPACK_IMPORTED_MODULE_101__["default"],
	depth_vert: _ShaderLib_depth_vert_glsl_js__WEBPACK_IMPORTED_MODULE_102__["default"],
	distanceRGBA_frag: _ShaderLib_distanceRGBA_frag_glsl_js__WEBPACK_IMPORTED_MODULE_103__["default"],
	distanceRGBA_vert: _ShaderLib_distanceRGBA_vert_glsl_js__WEBPACK_IMPORTED_MODULE_104__["default"],
	equirect_frag: _ShaderLib_equirect_frag_glsl_js__WEBPACK_IMPORTED_MODULE_105__["default"],
	equirect_vert: _ShaderLib_equirect_vert_glsl_js__WEBPACK_IMPORTED_MODULE_106__["default"],
	linedashed_frag: _ShaderLib_linedashed_frag_glsl_js__WEBPACK_IMPORTED_MODULE_107__["default"],
	linedashed_vert: _ShaderLib_linedashed_vert_glsl_js__WEBPACK_IMPORTED_MODULE_108__["default"],
	meshbasic_frag: _ShaderLib_meshbasic_frag_glsl_js__WEBPACK_IMPORTED_MODULE_109__["default"],
	meshbasic_vert: _ShaderLib_meshbasic_vert_glsl_js__WEBPACK_IMPORTED_MODULE_110__["default"],
	meshlambert_frag: _ShaderLib_meshlambert_frag_glsl_js__WEBPACK_IMPORTED_MODULE_111__["default"],
	meshlambert_vert: _ShaderLib_meshlambert_vert_glsl_js__WEBPACK_IMPORTED_MODULE_112__["default"],
	meshmatcap_frag: _ShaderLib_meshmatcap_frag_glsl_js__WEBPACK_IMPORTED_MODULE_113__["default"],
	meshmatcap_vert: _ShaderLib_meshmatcap_vert_glsl_js__WEBPACK_IMPORTED_MODULE_114__["default"],
	meshtoon_frag: _ShaderLib_meshtoon_frag_glsl_js__WEBPACK_IMPORTED_MODULE_115__["default"],
	meshtoon_vert: _ShaderLib_meshtoon_vert_glsl_js__WEBPACK_IMPORTED_MODULE_116__["default"],
	meshphong_frag: _ShaderLib_meshphong_frag_glsl_js__WEBPACK_IMPORTED_MODULE_117__["default"],
	meshphong_vert: _ShaderLib_meshphong_vert_glsl_js__WEBPACK_IMPORTED_MODULE_118__["default"],
	meshphysical_frag: _ShaderLib_meshphysical_frag_glsl_js__WEBPACK_IMPORTED_MODULE_119__["default"],
	meshphysical_vert: _ShaderLib_meshphysical_vert_glsl_js__WEBPACK_IMPORTED_MODULE_120__["default"],
	normal_frag: _ShaderLib_normal_frag_glsl_js__WEBPACK_IMPORTED_MODULE_121__["default"],
	normal_vert: _ShaderLib_normal_vert_glsl_js__WEBPACK_IMPORTED_MODULE_122__["default"],
	points_frag: _ShaderLib_points_frag_glsl_js__WEBPACK_IMPORTED_MODULE_123__["default"],
	points_vert: _ShaderLib_points_vert_glsl_js__WEBPACK_IMPORTED_MODULE_124__["default"],
	shadow_frag: _ShaderLib_shadow_frag_glsl_js__WEBPACK_IMPORTED_MODULE_125__["default"],
	shadow_vert: _ShaderLib_shadow_vert_glsl_js__WEBPACK_IMPORTED_MODULE_126__["default"],
	sprite_frag: _ShaderLib_sprite_frag_glsl_js__WEBPACK_IMPORTED_MODULE_127__["default"],
	sprite_vert: _ShaderLib_sprite_vert_glsl_js__WEBPACK_IMPORTED_MODULE_128__["default"]
};


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl.js":
/*!************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, vUv ).g;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl.js":
/*!*****************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl.js ***!
  \*****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl.js":
/*!*************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl.js ***!
  \*************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef ALPHATEST

	if ( diffuseColor.a < ALPHATEST ) discard;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/aomap_fragment.glsl.js":
/*!*********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/aomap_fragment.glsl.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_AOMAP

	// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;

	reflectedLight.indirectDiffuse *= ambientOcclusion;

	#if defined( USE_ENVMAP ) && defined( STANDARD )

		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );

		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );

	#endif

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl.js":
/*!**************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl.js ***!
  \**************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_AOMAP

	uniform sampler2D aoMap;
	uniform float aoMapIntensity;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/begin_vertex.glsl.js":
/*!*******************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/begin_vertex.glsl.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
vec3 transformed = vec3( position );
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl.js":
/*!*************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl.js ***!
  \*************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
vec3 objectNormal = vec3( normal );

#ifdef USE_TANGENT

	vec3 objectTangent = vec3( tangent.xyz );

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/bsdfs.glsl.js":
/*!************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/bsdfs.glsl.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`

// Analytical approximation of the DFG LUT, one half of the
// split-sum approximation used in indirect specular lighting.
// via 'environmentBRDF' from "Physically Based Shading on Mobile"
// https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile
vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );

	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );

	vec4 r = roughness * c0 + c1;

	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;

	return vec2( -1.04, 1.04 ) * a004 + r.zw;

}

float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {

#if defined ( PHYSICALLY_CORRECT_LIGHTS )

	// based upon Frostbite 3 Moving to Physically-based Rendering
	// page 32, equation 26: E[window1]
	// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
	// this is intended to be used on spot and point lights who are represented as luminous intensity
	// but who must be converted to luminous irradiance for surface lighting calculation
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );

	if( cutoffDistance > 0.0 ) {

		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );

	}

	return distanceFalloff;

#else

	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {

		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

	}

	return 1.0;

#endif

}

vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {

	return RECIPROCAL_PI * diffuseColor;

} // validated

vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {

	// Original approximation by Christophe Schlick '94
	// float fresnel = pow( 1.0 - dotLH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH '13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );

	return ( 1.0 - specularColor ) * fresnel + specularColor;

} // validated

vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {

	// See F_Schlick
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;

	return Fr * fresnel + F0;

}


// Microfacet Models for Refraction through Rough Surfaces - equation (34)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disney’s reparameterization
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {

	// geometry term (normalized) = G(l)⋅G(v) / 4(n⋅l)(n⋅v)
	// also see #12151

	float a2 = pow2( alpha );

	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );

	return 1.0 / ( gl * gv );

} // validated

// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {

	float a2 = pow2( alpha );

	// dotNL and dotNV are explicitly swapped. This is not a mistake.
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );

	return 0.5 / max( gv + gl, EPSILON );

}

// Microfacet Models for Refraction through Rough Surfaces - equation (33)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disney’s reparameterization
float D_GGX( const in float alpha, const in float dotNH ) {

	float a2 = pow2( alpha );

	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1

	return RECIPROCAL_PI * a2 / pow2( denom );

}

// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {

	float alpha = pow2( roughness ); // UE4's roughness

	vec3 halfDir = normalize( incidentLight.direction + viewDir );

	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );

	vec3 F = F_Schlick( specularColor, dotLH );

	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );

	float D = D_GGX( alpha, dotNH );

	return F * ( G * D );

} // validated

// Rect Area Light

// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/

vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {

	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;

	float dotNV = saturate( dot( N, V ) );

	// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );

	uv = uv * LUT_SCALE + LUT_BIAS;

	return uv;

}

float LTC_ClippedSphereFormFactor( const in vec3 f ) {

	// Real-Time Area Lighting: a Journey from Research to Production (p.102)
	// An approximation of the form factor of a horizon-clipped rectangle.

	float l = length( f );

	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );

}

vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {

	float x = dot( v1, v2 );

	float y = abs( x );

	// rational polynomial approximation to theta / sin( theta ) / 2PI
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;

	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;

	return cross( v1, v2 ) * theta_sintheta;

}

vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {

	// bail if point is on back side of plane of light
	// assumes ccw winding order of light vertices
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );

	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );

	// construct orthonormal basis around N
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system

	// compute transform
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );

	// transform rect
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );

	// project rect onto sphere
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );

	// calculate vector form factor
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );

	// adjust for horizon clipping
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );

/*
	// alternate method of adjusting for horizon clipping (see referece)
	// refactoring required
	float len = length( vectorFormFactor );
	float z = vectorFormFactor.z / len;

	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;

	// tabulated horizon-clipped sphere, apparently...
	vec2 uv = vec2( z * 0.5 + 0.5, len );
	uv = uv * LUT_SCALE + LUT_BIAS;

	float scale = texture2D( ltc_2, uv ).w;

	float result = len * scale;
*/

	return vec3( result );

}

// End Rect Area Light

// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {

	float dotNV = saturate( dot( normal, viewDir ) );

	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );

	return specularColor * brdf.x + brdf.y;

} // validated

// Fdez-Agüera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
// Approximates multiscattering in order to preserve energy.
// http://www.jcgt.org/published/0008/01/03/
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {

	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );

	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;

	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;

	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21
	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );

	singleScatter += FssEss;
	multiScatter += Fms * Ems;

}

float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {

	// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)
	return 0.25;

}

float D_BlinnPhong( const in float shininess, const in float dotNH ) {

	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {

	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );

	//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
	//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );

	vec3 F = F_Schlick( specularColor, dotLH );

	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

	float D = D_BlinnPhong( shininess, dotNH );

	return F * ( G * D );

} // validated

// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}

float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}

#if defined( USE_SHEEN )

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L94
float D_Charlie(float roughness, float NoH) {
	// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125); // 2^(-14/2), so sin2h^2 > 0 in fp16
	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L136
float V_Neubelt(float NoV, float NoL) {
	// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}

vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {

	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;

	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );

	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );

}

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl.js":
/*!****************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl.js ***!
  \****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_BUMPMAP

	uniform sampler2D bumpMap;
	uniform float bumpScale;

	// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
	// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf

	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

	vec2 dHdxy_fwd() {

		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );

		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;

		return vec2( dBx, dBy );

	}

	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {

		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;		// normalized

		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );

		float fDet = dot( vSigmaX, R1 ) * faceDirection;

		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );

	}

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/clearcoat_normal_fragment_begin.glsl.js":
/*!**************************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/clearcoat_normal_fragment_begin.glsl.js ***!
  \**************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef CLEARCOAT

	vec3 clearcoatNormal = geometryNormal;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/clearcoat_normal_fragment_maps.glsl.js":
/*!*************************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/clearcoat_normal_fragment_maps.glsl.js ***!
  \*************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_CLEARCOAT_NORMALMAP

	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;

	#ifdef USE_TANGENT

		clearcoatNormal = normalize( vTBN * clearcoatMapN );

	#else

		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );

	#endif

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/clearcoat_pars_fragment.glsl.js":
/*!******************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/clearcoat_pars_fragment.glsl.js ***!
  \******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`

#ifdef USE_CLEARCOATMAP

	uniform sampler2D clearcoatMap;

#endif

#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	uniform sampler2D clearcoatRoughnessMap;

#endif

#ifdef USE_CLEARCOAT_NORMALMAP

	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl.js":
/*!*******************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl.js ***!
  \*******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if NUM_CLIPPING_PLANES > 0

	vec4 plane;

	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {

		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;

	}
	#pragma unroll_loop_end

	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES

		bool clipped = true;

		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {

			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;

		}
		#pragma unroll_loop_end

		if ( clipped ) discard;

	#endif

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl.js":
/*!************************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl.js ***!
  \************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl.js":
/*!**********************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl.js ***!
  \**********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl.js":
/*!*****************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl.js ***!
  \*****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if NUM_CLIPPING_PLANES > 0

	vClipPosition = - mvPosition.xyz;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/color_fragment.glsl.js":
/*!*********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/color_fragment.glsl.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_COLOR_ALPHA )

	diffuseColor *= vColor;

#elif defined( USE_COLOR )

	diffuseColor.rgb *= vColor;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl.js":
/*!**************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl.js ***!
  \**************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_COLOR_ALPHA )

	varying vec4 vColor;

#elif defined( USE_COLOR )

	varying vec3 vColor;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl.js":
/*!************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_COLOR_ALPHA )

	varying vec4 vColor;

#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )

	varying vec3 vColor;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/color_vertex.glsl.js":
/*!*******************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/color_vertex.glsl.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_COLOR_ALPHA )

	vColor = vec4( 1.0 );

#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )

	vColor = vec3( 1.0 );

#endif

#ifdef USE_COLOR

	vColor *= color;

#endif

#ifdef USE_INSTANCING_COLOR

	vColor.xyz *= instanceColor.xyz;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/common.glsl.js":
/*!*************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/common.glsl.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6

#ifndef saturate
// <tonemapping_pars_fragment> may have defined saturate() already
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )

float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.
// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}

#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif

struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};

struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};

struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};

vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

}

vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {

	// dir can be either a direction vector or a normal vector
	// upper-left 3x3 of matrix is assumed to be orthogonal

	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

	float distance = dot( planeNormal, point - pointOnPlane );

	return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

	return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

mat3 transposeMat3( const in mat3 m ) {

	mat3 tmp;

	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );

	return tmp;

}

// https://en.wikipedia.org/wiki/Relative_luminance
float linearToRelativeLuminance( const in vec3 color ) {

	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );

	return dot( weights, color.rgb );

}

bool isPerspectiveMatrix( mat4 m ) {

	return m[ 2 ][ 3 ] == - 1.0;

}

vec2 equirectUv( in vec3 dir ) {

	// dir is assumed to be unit length

	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;

	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;

	return vec2( u, v );

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl.js":
/*!**********************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl.js ***!
  \**********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef ENVMAP_TYPE_CUBE_UV

	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0

	// These shader functions convert between the UV coordinates of a single face of
	// a cubemap, the 0-5 integer index of a cube face, and the direction vector for
	// sampling a textureCube (not generally normalized ).

	float getFace( vec3 direction ) {

		vec3 absDirection = abs( direction );

		float face = - 1.0;

		if ( absDirection.x > absDirection.z ) {

			if ( absDirection.x > absDirection.y )

				face = direction.x > 0.0 ? 0.0 : 3.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		} else {

			if ( absDirection.z > absDirection.y )

				face = direction.z > 0.0 ? 2.0 : 5.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		}

		return face;

	}

	// RH coordinate system; PMREM face-indexing convention
	vec2 getUV( vec3 direction, float face ) {

		vec2 uv;

		if ( face == 0.0 ) {

			uv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x

		} else if ( face == 1.0 ) {

			uv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y

		} else if ( face == 2.0 ) {

			uv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z

		} else if ( face == 3.0 ) {

			uv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x

		} else if ( face == 4.0 ) {

			uv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y

		} else {

			uv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z

		}

		return 0.5 * ( uv + 1.0 );

	}

	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {

		float face = getFace( direction );

		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );

		mipInt = max( mipInt, cubeUV_minMipLevel );

		float faceSize = exp2( mipInt );

		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );

		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );

		vec2 f = fract( uv );

		uv += 0.5 - f;

		if ( face > 2.0 ) {

			uv.y += faceSize;

			face -= 3.0;

		}

		uv.x += face * faceSize;

		if ( mipInt < cubeUV_maxMipLevel ) {

			uv.y += 2.0 * cubeUV_maxTileSize;

		}

		uv.y += filterInt * 2.0 * cubeUV_minTileSize;

		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );

		uv *= texelSize;

		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		uv.x += texelSize;

		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		uv.y += texelSize;

		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		uv.x -= texelSize;

		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		vec3 tm = mix( tl, tr, f.x );

		vec3 bm = mix( bl, br, f.x );

		return mix( tm, bm, f.y );

	}

	// These defines must match with PMREMGenerator

	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0

	float roughnessToMip( float roughness ) {

		float mip = 0.0;

		if ( roughness >= r1 ) {

			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;

		} else if ( roughness >= r4 ) {

			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;

		} else if ( roughness >= r5 ) {

			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;

		} else if ( roughness >= r6 ) {

			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;

		} else {

			mip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25
		}

		return mip;

	}

	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {

		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );

		float mipF = fract( mip );

		float mipInt = floor( mip );

		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );

		if ( mipF == 0.0 ) {

			return vec4( color0, 1.0 );

		} else {

			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );

			return vec4( mix( color0, color1, mipF ), 1.0 );

		}

	}

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/default_fragment.glsl.js":
/*!***********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/default_fragment.glsl.js ***!
  \***********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/default_vertex.glsl.js":
/*!*********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/default_vertex.glsl.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl.js":
/*!***************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl.js ***!
  \***************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
vec3 transformedNormal = objectNormal;

#ifdef USE_INSTANCING

	// this is in lieu of a per-instance normal-matrix
	// shear transforms in the instance matrix are not supported

	mat3 m = mat3( instanceMatrix );

	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );

	transformedNormal = m * transformedNormal;

#endif

transformedNormal = normalMatrix * transformedNormal;

#ifdef FLIP_SIDED

	transformedNormal = - transformedNormal;

#endif

#ifdef USE_TANGENT

	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#ifdef FLIP_SIDED

		transformedTangent = - transformedTangent;

	#endif

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl.js":
/*!**********************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl.js ***!
  \**********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_DISPLACEMENTMAP

	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl.js":
/*!*****************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl.js ***!
  \*****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_DISPLACEMENTMAP

	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/dithering_fragment.glsl.js":
/*!*************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/dithering_fragment.glsl.js ***!
  \*************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef DITHERING

	gl_FragColor.rgb = dithering( gl_FragColor.rgb );

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/dithering_pars_fragment.glsl.js":
/*!******************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/dithering_pars_fragment.glsl.js ***!
  \******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef DITHERING

	// based on https://www.shadertoy.com/view/MslGR8
	vec3 dithering( vec3 color ) {
		//Calculate grid position
		float grid_position = rand( gl_FragCoord.xy );

		//Shift the individual colors differently, thus making it even harder to see the dithering pattern
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );

		//modify shift acording to grid position.
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );

		//shift the color by dither_shift
		return color + dither_shift_RGB;
	}

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl.js":
/*!***************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl.js ***!
  \***************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_EMISSIVEMAP

	vec4 emissiveColor = texture2D( emissiveMap, vUv );

	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;

	totalEmissiveRadiance *= emissiveColor.rgb;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl.js":
/*!********************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl.js ***!
  \********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_EMISSIVEMAP

	uniform sampler2D emissiveMap;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/encodings_fragment.glsl.js":
/*!*************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/encodings_fragment.glsl.js ***!
  \*************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
gl_FragColor = linearToOutputTexel( gl_FragColor );
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl.js":
/*!******************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl.js ***!
  \******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/

vec4 LinearToLinear( in vec4 value ) {
	return value;
}

vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}

vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}

vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}

vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}

vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}

vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
	// return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );
}

// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}

vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}

// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}

vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	// NOTE: The implementation with min causes the shader to not compile on
	// a common Alcatel A502DL in Chrome 78/Android 8.1. Some research suggests 
	// that the chipset is Mediatek MT6739 w/ IMG PowerVR GE8100 GPU.
	// D = min( floor( D ) / 255.0, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}

// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html

// M matrix, for encoding
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}

// Inverse M matrix, for decoding
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/envmap_common_pars_fragment.glsl.js":
/*!**********************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/envmap_common_pars_fragment.glsl.js ***!
  \**********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_ENVMAP

	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;

	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/envmap_fragment.glsl.js":
/*!**********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/envmap_fragment.glsl.js ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vec3 cameraToFrag;

		if ( isOrthographic ) {

			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToFrag = normalize( vWorldPosition - cameraPosition );

		}

		// Transforming Normal Vectors with the Inverse Transformation
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vec3 reflectVec = reflect( cameraToFrag, worldNormal );

		#else

			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );

		#endif

	#else

		vec3 reflectVec = vReflect;

	#endif

	#ifdef ENVMAP_TYPE_CUBE

		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );

	#elif defined( ENVMAP_TYPE_CUBE_UV )

		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );

	#else

		vec4 envColor = vec4( 0.0 );

	#endif

	#ifndef ENVMAP_TYPE_CUBE_UV

		envColor = envMapTexelToLinear( envColor );

	#endif

	#ifdef ENVMAP_BLENDING_MULTIPLY

		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_MIX )

		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_ADD )

		outgoingLight += envColor.xyz * specularStrength * reflectivity;

	#endif

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl.js":
/*!***************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl.js ***!
  \***************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_ENVMAP

	uniform float reflectivity;

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS

		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl.js":
/*!*************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl.js ***!
  \*************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_ENVMAP

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;

	#else

		varying vec3 vReflect;
		uniform float refractionRatio;

	#endif

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/envmap_physical_pars_fragment.glsl.js":
/*!************************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/envmap_physical_pars_fragment.glsl.js ***!
  \************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_ENVMAP )

	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif

	vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {

		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );

		#ifdef ENVMAP_TYPE_CUBE

			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );

			// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level
			// of a specular cubemap, or just the default level of a specially created irradiance cubemap.

			#ifdef TEXTURE_LOD_EXT

				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );

			#else

				// force the bias high to get the last LOD level as it is the most blurred.
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );

			#endif

			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

		#elif defined( ENVMAP_TYPE_CUBE_UV )

			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );

		#else

			vec4 envMapColor = vec4( 0.0 );

		#endif

		return PI * envMapColor.rgb * envMapIntensity;

	}

	// Trowbridge-Reitz distribution to Mip level, following the logic of http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {

		float maxMIPLevelScalar = float( maxMIPLevel );

		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );

		// clamp to allowable LOD ranges.
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );

	}

	vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {

		#ifdef ENVMAP_MODE_REFLECTION

			vec3 reflectVec = reflect( -viewDir, normal );

			// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );

		#else

			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );

		#endif

		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );

		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );

		#ifdef ENVMAP_TYPE_CUBE

			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );

			#ifdef TEXTURE_LOD_EXT

				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );

			#else

				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );

			#endif

			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

		#elif defined( ENVMAP_TYPE_CUBE_UV )

			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );

		#endif

		return envMapColor.rgb * envMapIntensity;

	}

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/envmap_vertex.glsl.js":
/*!********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/envmap_vertex.glsl.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vWorldPosition = worldPosition.xyz;

	#else

		vec3 cameraToVertex;

		if ( isOrthographic ) {

			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );

		}

		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vReflect = reflect( cameraToVertex, worldNormal );

		#else

			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );

		#endif

	#endif

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/fog_fragment.glsl.js":
/*!*******************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/fog_fragment.glsl.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_FOG

	#ifdef FOG_EXP2

		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );

	#else

		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );

	#endif

	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl.js":
/*!************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_FOG

	uniform vec3 fogColor;
	varying float fogDepth;

	#ifdef FOG_EXP2

		uniform float fogDensity;

	#else

		uniform float fogNear;
		uniform float fogFar;

	#endif

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/fog_pars_vertex.glsl.js":
/*!**********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/fog_pars_vertex.glsl.js ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_FOG

	varying float fogDepth;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/fog_vertex.glsl.js":
/*!*****************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/fog_vertex.glsl.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_FOG

	fogDepth = - mvPosition.z;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/gradientmap_pars_fragment.glsl.js":
/*!********************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/gradientmap_pars_fragment.glsl.js ***!
  \********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`

#ifdef USE_GRADIENTMAP

	uniform sampler2D gradientMap;

#endif

vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {

	// dotNL will be from -1.0 to 1.0
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );

	#ifdef USE_GRADIENTMAP

		return texture2D( gradientMap, coord ).rgb;

	#else

		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );

	#endif

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl.js":
/*!************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_LIGHTMAP

	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl.js":
/*!*****************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl.js ***!
  \*****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_LIGHTMAP

	uniform sampler2D lightMap;
	uniform float lightMapIntensity;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_fragment_begin.glsl.js":
/*!****************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/lights_fragment_begin.glsl.js ***!
  \****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
/**
 * This is a template that can be used to light a material, it uses pluggable
 * RenderEquations (RE)for specific lighting scenarios.
 *
 * Instructions for use:
 * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined
 * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???
 * - Create a material parameter that is to be passed as the third parameter to your lighting functions.
 *
 * TODO:
 * - Add area light support.
 * - Add sphere light support.
 * - Add diffuse light probe (irradiance cubemap) support.
 */

GeometricContext geometry;

geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

#ifdef CLEARCOAT

	geometry.clearcoatNormal = clearcoatNormal;

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointDirectLightIrradiance( pointLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotDirectLightIrradiance( spotLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	irradiance += getLightProbeIrradiance( lightProbe, geometry );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_fragment_end.glsl.js":
/*!**************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/lights_fragment_end.glsl.js ***!
  \**************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( RE_IndirectDiffuse )

	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_fragment_maps.glsl.js":
/*!***************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/lights_fragment_maps.glsl.js ***!
  \***************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( RE_IndirectDiffuse )

	#ifdef USE_LIGHTMAP

		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage

		#endif

		irradiance += lightMapIrradiance;

	#endif

	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )

		iblIrradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );

	#endif

#endif

#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )

	radiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );

	#ifdef CLEARCOAT

		clearcoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );

	#endif

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl.js":
/*!****************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl.js ***!
  \****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
vec3 diffuse = vec3( 1.0 );

GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );

GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;

vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif

IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;

vIndirectFront += getAmbientLightIrradiance( ambientLightColor );

vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );

#ifdef DOUBLE_SIDED

	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );

	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );

#endif

#if NUM_POINT_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif

	}
	#pragma unroll_loop_end

#endif

#if NUM_SPOT_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif
	}
	#pragma unroll_loop_end

#endif

/*
#if NUM_RECT_AREA_LIGHTS > 0

	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		// TODO (abelnation): implement

	}

#endif
*/

#if NUM_DIR_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif

	}
	#pragma unroll_loop_end

#endif

#if NUM_HEMI_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		#ifdef DOUBLE_SIDED

			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );

		#endif

	}
	#pragma unroll_loop_end

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_pars_begin.glsl.js":
/*!************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/lights_pars_begin.glsl.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];

// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere
// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {

	// normal is assumed to have unit length

	float x = normal.x, y = normal.y, z = normal.z;

	// band 0
	vec3 result = shCoefficients[ 0 ] * 0.886227;

	// band 1
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;

	// band 2
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );

	return result;

}

vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {

	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );

	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );

	return irradiance;

}

vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {

	vec3 irradiance = ambientLightColor;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI;

	#endif

	return irradiance;

}

#if NUM_DIR_LIGHTS > 0

	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};

	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];

	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {

		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;

	}

#endif


#if NUM_POINT_LIGHTS > 0

	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};

	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];

	// directLight is an out parameter as having it as a return value caused compiler errors on some devices
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {

		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );

		float lightDistance = length( lVector );

		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );

	}

#endif


#if NUM_SPOT_LIGHTS > 0

	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};

	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];

	// directLight is an out parameter as having it as a return value caused compiler errors on some devices
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {

		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );

		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );

		if ( angleCos > spotLight.coneCos ) {

			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );

			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;

		} else {

			directLight.color = vec3( 0.0 );
			directLight.visible = false;

		}
	}

#endif


#if NUM_RECT_AREA_LIGHTS > 0

	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};

	// Pre-computed values of LinearTransformedCosine approximation of BRDF
	// BRDF approximation Texture is 64x64
	uniform sampler2D ltc_1; // RGBA Float
	uniform sampler2D ltc_2; // RGBA Float

	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];

#endif


#if NUM_HEMI_LIGHTS > 0

	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};

	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];

	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {

		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;

		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			irradiance *= PI;

		#endif

		return irradiance;

	}

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl.js":
/*!****************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl.js ***!
  \****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl.js":
/*!*********************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl.js ***!
  \*********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif


struct BlinnPhongMaterial {

	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;

};

void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;

}

void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong

#define Material_LightProbeLOD( material )	(0)
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl.js":
/*!*******************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl.js ***!
  \*******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );

vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );

material.specularRoughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.
material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );

#ifdef REFLECTIVITY

	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );

#else

	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );

#endif

#ifdef CLEARCOAT

	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;

	#ifdef USE_CLEARCOATMAP

		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;

	#endif

	#ifdef USE_CLEARCOAT_ROUGHNESSMAP

		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;

	#endif

	material.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model
	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );

#endif

#ifdef USE_SHEEN

	material.sheenColor = sheen;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl.js":
/*!************************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl.js ***!
  \************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
struct PhysicalMaterial {

	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;

#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif

};

#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04

// Clear coat directional hemishperical reflectance (this approximation should be improved)
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {

	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );

}

#if NUM_RECT_AREA_LIGHTS > 0

	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;

		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction
		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;

		vec2 uv = LTC_Uv( normal, viewDir, roughness );

		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );

		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);

		// LTC Fresnel Approximation by Stephen Hill
		// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );

		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );

		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );

	}

#endif

void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );

	vec3 irradiance = dotNL * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	#ifdef CLEARCOAT

		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );

		vec3 ccIrradiance = ccDotNL * directLight.color;

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			ccIrradiance *= PI; // punctual light

		#endif

		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );

		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );

	#else

		float clearcoatDHR = 0.0;

	#endif

	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif

	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}

void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {

	#ifdef CLEARCOAT

		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );

		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );

		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );

	#else

		float clearcoatDHR = 0.0;

	#endif

	float clearcoatInv = 1.0 - clearcoatDHR;

	// Both indirect specular and indirect diffuse light accumulate here

	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;

	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );

	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );

	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;

	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;

}

#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical

// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {

	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_toon_fragment.glsl.js":
/*!***************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/lights_toon_fragment.glsl.js ***!
  \***************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/lights_toon_pars_fragment.glsl.js":
/*!********************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/lights_toon_pars_fragment.glsl.js ***!
  \********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif


struct ToonMaterial {

	vec3 diffuseColor;

};

void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon

#define Material_LightProbeLOD( material )	(0)
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl.js":
/*!***************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl.js ***!
  \***************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	// Doing a strict comparison with == 1.0 can cause noise artifacts
	// on some platforms. See issue #17623.
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl.js":
/*!********************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl.js ***!
  \********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl.js":
/*!******************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl.js ***!
  \******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		varying float vFragDepth;
		varying float vIsPerspective;

	#else

		uniform float logDepthBufFC;

	#endif

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl.js":
/*!*************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl.js ***!
  \*************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );

	#else

		if ( isPerspectiveMatrix( projectionMatrix ) ) {

			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;

			gl_Position.z *= gl_Position.w;

		}

	#endif

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/map_fragment.glsl.js":
/*!*******************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/map_fragment.glsl.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_MAP

	vec4 texelColor = texture2D( map, vUv );

	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl.js":
/*!************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_MAP

	uniform sampler2D map;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl.js":
/*!****************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl.js ***!
  \****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;

#endif

#ifdef USE_MAP

	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );

#endif

#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, uv ).g;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl.js":
/*!*********************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl.js ***!
  \*********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	uniform mat3 uvTransform;

#endif

#ifdef USE_MAP

	uniform sampler2D map;

#endif

#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl.js":
/*!****************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl.js ***!
  \****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
float metalnessFactor = metalness;

#ifdef USE_METALNESSMAP

	vec4 texelMetalness = texture2D( metalnessMap, vUv );

	// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	metalnessFactor *= texelMetalness.b;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl.js":
/*!*********************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl.js ***!
  \*********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_METALNESSMAP

	uniform sampler2D metalnessMap;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl.js":
/*!*************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl.js ***!
  \*************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_MORPHNORMALS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl.js":
/*!******************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl.js ***!
  \******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_MORPHTARGETS

	uniform float morphTargetBaseInfluence;

	#ifndef USE_MORPHNORMALS

		uniform float morphTargetInfluences[ 8 ];

	#else

		uniform float morphTargetInfluences[ 4 ];

	#endif

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl.js":
/*!*************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl.js ***!
  \*************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_MORPHTARGETS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];

	#ifndef USE_MORPHNORMALS

		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];

	#endif

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/normal_fragment_begin.glsl.js":
/*!****************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/normal_fragment_begin.glsl.js ***!
  \****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;

#ifdef FLAT_SHADED

	// Workaround for Adreno GPUs not able to do dFdx( vViewPosition )

	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );

#else

	vec3 normal = normalize( vNormal );

	#ifdef DOUBLE_SIDED

		normal = normal * faceDirection;

	#endif

	#ifdef USE_TANGENT

		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );

		#ifdef DOUBLE_SIDED

			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;

		#endif

		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )

			mat3 vTBN = mat3( tangent, bitangent, normal );

		#endif

	#endif

#endif

// non perturbed normal for clearcoat among others

vec3 geometryNormal = normal;

`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/normal_fragment_maps.glsl.js":
/*!***************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/normal_fragment_maps.glsl.js ***!
  \***************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`

#ifdef OBJECTSPACE_NORMALMAP

	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

	#ifdef FLIP_SIDED

		normal = - normal;

	#endif

	#ifdef DOUBLE_SIDED

		normal = normal * faceDirection;

	#endif

	normal = normalize( normalMatrix * normal );

#elif defined( TANGENTSPACE_NORMALMAP )

	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;

	#ifdef USE_TANGENT

		normal = normalize( vTBN * mapN );

	#else

		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );

	#endif

#elif defined( USE_BUMPMAP )

	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl.js":
/*!******************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl.js ***!
  \******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_NORMALMAP

	uniform sampler2D normalMap;
	uniform vec2 normalScale;

#endif

#ifdef OBJECTSPACE_NORMALMAP

	uniform mat3 normalMatrix;

#endif

#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )

	// Normal Mapping Without Precomputed Tangents
	// http://www.thetenthplanet.de/archives/1180

	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {

		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );

		vec3 N = surf_norm; // normalized

		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );

		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;

		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );

		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );

	}

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/packing.glsl.js":
/*!**************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/packing.glsl.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}

vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}

const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)
const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)

const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );

const float ShiftRight8 = 1. / 256.;

vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8; // tidy overflow
	return r * PackUpscale;
}

float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}

vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}

// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions

float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}

float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl.js":
/*!***********************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl.js ***!
  \***********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef PREMULTIPLIED_ALPHA

	// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.
	gl_FragColor.rgb *= gl_FragColor.a;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/project_vertex.glsl.js":
/*!*********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/project_vertex.glsl.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
vec4 mvPosition = vec4( transformed, 1.0 );

#ifdef USE_INSTANCING

	mvPosition = instanceMatrix * mvPosition;

#endif

mvPosition = modelViewMatrix * mvPosition;

gl_Position = projectionMatrix * mvPosition;
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl.js":
/*!****************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl.js ***!
  \****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
float roughnessFactor = roughness;

#ifdef USE_ROUGHNESSMAP

	vec4 texelRoughness = texture2D( roughnessMap, vUv );

	// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	roughnessFactor *= texelRoughness.g;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl.js":
/*!*********************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl.js ***!
  \*********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_ROUGHNESSMAP

	uniform sampler2D roughnessMap;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl.js":
/*!******************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl.js ***!
  \******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];

		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): create uniforms for area light shadows

	#endif
	*/

	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );

	}

	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {

		return unpackRGBATo2Half( texture2D( shadow, uv ) );

	}

	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){

		float occlusion = 1.0;

		vec2 distribution = texture2DDistribution( shadow, uv );

		float hard_shadow = step( compare , distribution.x ); // Hard Shadow

		if (hard_shadow != 1.0 ) {

			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality
			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed
			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );

		}
		return occlusion;

	}

	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

		float shadow = 1.0;

		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;

		// if ( something && something ) breaks ATI OpenGL shader compiler
		// if ( all( something, something ) ) using this instead

		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );

		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );

		bool frustumTest = all( frustumTestVec );

		if ( frustumTest ) {

		#if defined( SHADOWMAP_TYPE_PCF )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;

			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;

			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );

		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;

			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;

			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );

		#elif defined( SHADOWMAP_TYPE_VSM )

			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );

		#else // no percentage-closer filtering:

			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

		#endif

		}

		return shadow;

	}

	// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
	// vector suitable for 2D texture mapping. This code uses the following layout for the
	// 2D texture:
	//
	// xzXZ
	//  y Y
	//
	// Y - Positive y direction
	// y - Negative y direction
	// X - Positive x direction
	// x - Negative x direction
	// Z - Positive z direction
	// z - Negative z direction
	//
	// Source and test bed:
	// https://gist.github.com/tschw/da10c43c467ce8afd0c4

	vec2 cubeToUV( vec3 v, float texelSizeY ) {

		// Number of texels to avoid at the edge of each square

		vec3 absV = abs( v );

		// Intersect unit cube

		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;

		// Apply scale to avoid seams

		// two texels less per square (one texel will do for NEAREST)
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

		// Unwrap

		// space: -1 ... 1 range for each square
		//
		// #X##		dim    := ( 4 , 2 )
		//  # #		center := ( 1 , 1 )

		vec2 planar = v.xy;

		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;

		if ( absV.z >= almostOne ) {

			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;

		} else if ( absV.x >= almostOne ) {

			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;

		} else if ( absV.y >= almostOne ) {

			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;

		}

		// Transform to UV space

		// scale := 0.5 / dim
		// translate := ( center + 0.5 ) / dim
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

	}

	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

		// for point lights, the uniform @vShadowCoord is re-purposed to hold
		// the vector from the light to the world-space position of the fragment.
		vec3 lightToPosition = shadowCoord.xyz;

		// dp = normalized distance from light to fragment position
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
		dp += shadowBias;

		// bd3D = base direction 3D
		vec3 bd3D = normalize( lightToPosition );

		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )

			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;

			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );

		#else // no percentage-closer filtering

			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );

		#endif

	}

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl.js":
/*!****************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl.js ***!
  \****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];

		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): uniforms for area light shadows

	#endif
	*/

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl.js":
/*!***********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl.js ***!
  \***********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0

		// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;

	#endif

	#if NUM_DIR_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update vAreaShadowCoord with area light info

	#endif
	*/

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl.js":
/*!*******************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl.js ***!
  \*******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
float getShadowMask() {

	float shadow = 1.0;

	#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

	DirectionalLightShadow directionalLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

	SpotLightShadow spotLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

	PointLightShadow pointLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update shadow for Area light

	#endif
	*/

	#endif

	return shadow;

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl.js":
/*!**********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl.js ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_SKINNING

	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl.js":
/*!***************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl.js ***!
  \***************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_SKINNING

	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;

	#ifdef BONE_TEXTURE

		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;

		mat4 getBoneMatrix( const in float i ) {

			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );

			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );

			y = dy * ( y + 0.5 );

			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

			mat4 bone = mat4( v1, v2, v3, v4 );

			return bone;

		}

	#else

		uniform mat4 boneMatrices[ MAX_BONES ];

		mat4 getBoneMatrix( const in float i ) {

			mat4 bone = boneMatrices[ int(i) ];
			return bone;

		}

	#endif

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/skinning_vertex.glsl.js":
/*!**********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/skinning_vertex.glsl.js ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_SKINNING

	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );

	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;

	transformed = ( bindMatrixInverse * skinned ).xyz;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl.js":
/*!************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_SKINNING

	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;

	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;

	#ifdef USE_TANGENT

		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#endif

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl.js":
/*!***************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl.js ***!
  \***************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
float specularStrength;

#ifdef USE_SPECULARMAP

	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;

#else

	specularStrength = 1.0;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl.js":
/*!********************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl.js ***!
  \********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_SPECULARMAP

	uniform sampler2D specularMap;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl.js":
/*!***************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl.js ***!
  \***************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( TONE_MAPPING )

	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl.js":
/*!********************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl.js ***!
  \********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifndef saturate
// <common> may have defined saturate() already
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif

uniform float toneMappingExposure;

// exposure only
vec3 LinearToneMapping( vec3 color ) {

	return toneMappingExposure * color;

}

// source: https://www.cs.utah.edu/~reinhard/cdrom/
vec3 ReinhardToneMapping( vec3 color ) {

	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );

}

// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/
vec3 OptimizedCineonToneMapping( vec3 color ) {

	// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );

}

// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs
vec3 RRTAndODTFit( vec3 v ) {

	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;

}

// this implementation of ACES is modified to accommodate a brighter viewing environment.
// the scale factor of 1/0.6 is subjective. see discussion in #19621.

vec3 ACESFilmicToneMapping( vec3 color ) {

	// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ), // transposed from source
		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);

	// ODT_SAT => XYZ => D60_2_D65 => sRGB
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ), // transposed from source
		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);

	color *= toneMappingExposure / 0.6;

	color = ACESInputMat * color;

	// Apply RRT and ODT
	color = RRTAndODTFit( color );

	color = ACESOutputMat * color;

	// Clamp to [0, 1]
	return saturate( color );

}

vec3 CustomToneMapping( vec3 color ) { return color; }
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/transmissionmap_fragment.glsl.js":
/*!*******************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/transmissionmap_fragment.glsl.js ***!
  \*******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_TRANSMISSIONMAP

	totalTransmission *= texture2D( transmissionMap, vUv ).r;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/transmissionmap_pars_fragment.glsl.js":
/*!************************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/transmissionmap_pars_fragment.glsl.js ***!
  \************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_TRANSMISSIONMAP

	uniform sampler2D transmissionMap;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl.js":
/*!************************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	varying vec2 vUv2;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl.js":
/*!**********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl.js ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	attribute vec2 uv2;
	varying vec2 vUv2;

	uniform mat3 uv2Transform;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/uv2_vertex.glsl.js":
/*!*****************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/uv2_vertex.glsl.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl.js":
/*!***********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl.js ***!
  \***********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )

	varying vec2 vUv;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl.js":
/*!*********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_UV

	#ifdef UVS_VERTEX_ONLY

		vec2 vUv;

	#else

		varying vec2 vUv;

	#endif

	uniform mat3 uvTransform;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/uv_vertex.glsl.js":
/*!****************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/uv_vertex.glsl.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_UV

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl.js":
/*!**********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl.js ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )

	vec4 worldPosition = vec4( transformed, 1.0 );

	#ifdef USE_INSTANCING

		worldPosition = instanceMatrix * worldPosition;

	#endif

	worldPosition = modelMatrix * worldPosition;

#endif
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib.js":
/*!***********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib.js ***!
  \***********************************************************************************/
/*! exports provided: ShaderLib */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderLib", function() { return ShaderLib; });
/* harmony import */ var _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ShaderChunk.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk.js");
/* harmony import */ var _UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UniformsUtils.js */ "../../node_modules/three/src/renderers/shaders/UniformsUtils.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UniformsLib.js */ "../../node_modules/three/src/renderers/shaders/UniformsLib.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../math/Color.js */ "../../node_modules/three/src/math/Color.js");
/* harmony import */ var _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../math/Matrix3.js */ "../../node_modules/three/src/math/Matrix3.js");








const ShaderLib = {

	basic: {

		uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])( [
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].common,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].specularmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].envmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].aomap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].lightmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].fog
		] ),

		vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshbasic_vert,
		fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshbasic_frag

	},

	lambert: {

		uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])( [
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].common,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].specularmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].envmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].aomap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].lightmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].emissivemap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].fog,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].lights,
			{
				emissive: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_5__["Color"]( 0x000000 ) }
			}
		] ),

		vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshlambert_vert,
		fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshlambert_frag

	},

	phong: {

		uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])( [
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].common,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].specularmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].envmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].aomap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].lightmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].emissivemap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].bumpmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].normalmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].displacementmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].fog,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].lights,
			{
				emissive: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_5__["Color"]( 0x000000 ) },
				specular: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_5__["Color"]( 0x111111 ) },
				shininess: { value: 30 }
			}
		] ),

		vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshphong_vert,
		fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshphong_frag

	},

	standard: {

		uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])( [
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].common,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].envmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].aomap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].lightmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].emissivemap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].bumpmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].normalmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].displacementmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].roughnessmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].metalnessmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].fog,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].lights,
			{
				emissive: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_5__["Color"]( 0x000000 ) },
				roughness: { value: 1.0 },
				metalness: { value: 0.0 },
				envMapIntensity: { value: 1 } // temporary
			}
		] ),

		vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshphysical_vert,
		fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshphysical_frag

	},

	toon: {

		uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])( [
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].common,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].aomap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].lightmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].emissivemap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].bumpmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].normalmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].displacementmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].gradientmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].fog,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].lights,
			{
				emissive: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_5__["Color"]( 0x000000 ) }
			}
		] ),

		vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshtoon_vert,
		fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshtoon_frag

	},

	matcap: {

		uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])( [
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].common,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].bumpmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].normalmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].displacementmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].fog,
			{
				matcap: { value: null }
			}
		] ),

		vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshmatcap_vert,
		fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshmatcap_frag

	},

	points: {

		uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])( [
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].points,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].fog
		] ),

		vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].points_vert,
		fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].points_frag

	},

	dashed: {

		uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])( [
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].common,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].fog,
			{
				scale: { value: 1 },
				dashSize: { value: 1 },
				totalSize: { value: 2 }
			}
		] ),

		vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].linedashed_vert,
		fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].linedashed_frag

	},

	depth: {

		uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])( [
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].common,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].displacementmap
		] ),

		vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].depth_vert,
		fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].depth_frag

	},

	normal: {

		uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])( [
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].common,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].bumpmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].normalmap,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].displacementmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].normal_vert,
		fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].normal_frag

	},

	sprite: {

		uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])( [
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].sprite,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].fog
		] ),

		vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].sprite_vert,
		fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].sprite_frag

	},

	background: {

		uniforms: {
			uvTransform: { value: new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__["Matrix3"]() },
			t2D: { value: null },
		},

		vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].background_vert,
		fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].background_frag

	},
	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	cube: {

		uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])( [
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].envmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].cube_vert,
		fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].cube_frag

	},

	equirect: {

		uniforms: {
			tEquirect: { value: null },
		},

		vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].equirect_vert,
		fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].equirect_frag

	},

	distanceRGBA: {

		uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])( [
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].common,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].displacementmap,
			{
				referencePosition: { value: new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"]() },
				nearDistance: { value: 1 },
				farDistance: { value: 1000 }
			}
		] ),

		vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].distanceRGBA_vert,
		fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].distanceRGBA_frag

	},

	shadow: {

		uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])( [
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].lights,
			_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].fog,
			{
				color: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_5__["Color"]( 0x00000 ) },
				opacity: { value: 1.0 }
			},
		] ),

		vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].shadow_vert,
		fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].shadow_frag

	}

};

ShaderLib.physical = {

	uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])( [
		ShaderLib.standard.uniforms,
		{
			clearcoat: { value: 0 },
			clearcoatMap: { value: null },
			clearcoatRoughness: { value: 0 },
			clearcoatRoughnessMap: { value: null },
			clearcoatNormalScale: { value: new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]( 1, 1 ) },
			clearcoatNormalMap: { value: null },
			sheen: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_5__["Color"]( 0x000000 ) },
			transmission: { value: 0 },
			transmissionMap: { value: null },
		}
	] ),

	vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshphysical_vert,
	fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshphysical_frag

};





/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/background_frag.glsl.js":
/*!********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/background_frag.glsl.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
uniform sampler2D t2D;

varying vec2 vUv;

void main() {

	vec4 texColor = texture2D( t2D, vUv );

	gl_FragColor = mapTexelToLinear( texColor );

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/background_vert.glsl.js":
/*!********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/background_vert.glsl.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
varying vec2 vUv;
uniform mat3 uvTransform;

void main() {

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

	gl_Position = vec4( position.xy, 1.0, 1.0 );

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/cube_frag.glsl.js":
/*!**************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/cube_frag.glsl.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#include <envmap_common_pars_fragment>
uniform float opacity;

varying vec3 vWorldDirection;

#include <cube_uv_reflection_fragment>

void main() {

	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>

	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/cube_vert.glsl.js":
/*!**************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/cube_vert.glsl.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

	gl_Position.z = gl_Position.w; // set z to camera.far

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/depth_frag.glsl.js":
/*!***************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/depth_frag.glsl.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if DEPTH_PACKING == 3200

	uniform float opacity;

#endif

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

varying vec2 vHighPrecisionZW;

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#if DEPTH_PACKING == 3200

		diffuseColor.a = opacity;

	#endif

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	#include <logdepthbuf_fragment>

	// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;

	#if DEPTH_PACKING == 3200

		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );

	#elif DEPTH_PACKING == 3201

		gl_FragColor = packDepthToRGBA( fragCoordZ );

	#endif

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/depth_vert.glsl.js":
/*!***************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/depth_vert.glsl.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.
// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for
// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.
varying vec2 vHighPrecisionZW;

void main() {

	#include <uv_vertex>

	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vHighPrecisionZW = gl_Position.zw;

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl.js":
/*!**********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl.js ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#define DISTANCE

uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>

void main () {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist ); // clamp to [ 0, 1 ]

	gl_FragColor = packDepthToRGBA( dist );

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl.js":
/*!**********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl.js ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#define DISTANCE

varying vec3 vWorldPosition;

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>

	vWorldPosition = worldPosition.xyz;

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/equirect_frag.glsl.js":
/*!******************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/equirect_frag.glsl.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
uniform sampler2D tEquirect;

varying vec3 vWorldDirection;

#include <common>

void main() {

	vec3 direction = normalize( vWorldDirection );

	vec2 sampleUV = equirectUv( direction );

	vec4 texColor = texture2D( tEquirect, sampleUV );

	gl_FragColor = mapTexelToLinear( texColor );

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/equirect_vert.glsl.js":
/*!******************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/equirect_vert.glsl.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/linedashed_frag.glsl.js":
/*!********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/linedashed_frag.glsl.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
uniform vec3 diffuse;
uniform float opacity;

uniform float dashSize;
uniform float totalSize;

varying float vLineDistance;

#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	if ( mod( vLineDistance, totalSize ) > dashSize ) {

		discard;

	}

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <color_fragment>

	outgoingLight = diffuseColor.rgb; // simple shader

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/linedashed_vert.glsl.js":
/*!********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/linedashed_vert.glsl.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
uniform float scale;
attribute float lineDistance;

varying float vLineDistance;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	vLineDistance = scale * lineDistance;

	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshbasic_frag.glsl.js":
/*!*******************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/meshbasic_frag.glsl.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
uniform vec3 diffuse;
uniform float opacity;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );

	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;

	#else

		reflectedLight.indirectDiffuse += vec3( 1.0 );

	#endif

	// modulation
	#include <aomap_fragment>

	reflectedLight.indirectDiffuse *= diffuseColor.rgb;

	vec3 outgoingLight = reflectedLight.indirectDiffuse;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshbasic_vert.glsl.js":
/*!*******************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/meshbasic_vert.glsl.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>

	#ifdef USE_ENVMAP

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>

	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshlambert_frag.glsl.js":
/*!*********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/meshlambert_frag.glsl.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

varying vec3 vLightFront;
varying vec3 vIndirectFront;

#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif


#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>

	// accumulation

	#ifdef DOUBLE_SIDED

		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;

	#else

		reflectedLight.indirectDiffuse += vIndirectFront;

	#endif

	#include <lightmap_fragment>

	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );

	#ifdef DOUBLE_SIDED

		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;

	#else

		reflectedLight.directDiffuse = vLightFront;

	#endif

	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();

	// modulation

	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshlambert_vert.glsl.js":
/*!*********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/meshlambert_vert.glsl.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#define LAMBERT

varying vec3 vLightFront;
varying vec3 vIndirectFront;

#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshmatcap_frag.glsl.js":
/*!********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/meshmatcap_frag.glsl.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#define MATCAP

uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>

#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks

	#ifdef USE_MATCAP

		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );

	#else

		vec4 matcapColor = vec4( 1.0 );

	#endif

	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshmatcap_vert.glsl.js":
/*!********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/meshmatcap_vert.glsl.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#define MATCAP

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>

#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

		vNormal = normalize( transformedNormal );

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

	vViewPosition = - mvPosition.xyz;

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshphong_frag.glsl.js":
/*!*******************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/meshphong_frag.glsl.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#define PHONG

uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshphong_vert.glsl.js":
/*!*******************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/meshphong_vert.glsl.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#define PHONG

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshphysical_frag.glsl.js":
/*!**********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/meshphysical_frag.glsl.js ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#define STANDARD

#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef TRANSMISSION
	uniform float transmission;
#endif

#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif

#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif

#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>

	// accumulation
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

	// this is a stub for the transmission model
	#ifdef TRANSMISSION
		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );
	#endif

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshphysical_vert.glsl.js":
/*!**********************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/meshphysical_vert.glsl.js ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#define STANDARD

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

	#ifdef USE_TANGENT

		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

	#endif

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshtoon_frag.glsl.js":
/*!******************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/meshtoon_frag.glsl.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#define TOON

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/meshtoon_vert.glsl.js":
/*!******************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/meshtoon_vert.glsl.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#define TOON

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/normal_frag.glsl.js":
/*!****************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/normal_frag.glsl.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#define NORMAL

uniform float opacity;

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	varying vec3 vViewPosition;

#endif

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/normal_vert.glsl.js":
/*!****************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/normal_vert.glsl.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#define NORMAL

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	varying vec3 vViewPosition;

#endif

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

	#ifdef USE_TANGENT

		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

	#endif

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	vViewPosition = - mvPosition.xyz;

#endif

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/points_frag.glsl.js":
/*!****************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/points_frag.glsl.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/points_vert.glsl.js":
/*!****************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/points_vert.glsl.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
uniform float size;
uniform float scale;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>

	gl_PointSize = size;

	#ifdef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );

	#endif

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/shadow_frag.glsl.js":
/*!****************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/shadow_frag.glsl.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
uniform vec3 color;
uniform float opacity;

#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>

void main() {

	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/shadow_vert.glsl.js":
/*!****************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/shadow_vert.glsl.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>

void main() {

	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/sprite_frag.glsl.js":
/*!****************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/sprite_frag.glsl.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/sprite_vert.glsl.js":
/*!****************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/sprite_vert.glsl.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
uniform float rotation;
uniform vec2 center;

#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	#ifndef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) scale *= - mvPosition.z;

	#endif

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/vsm_frag.glsl.js":
/*!*************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/vsm_frag.glsl.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;

#include <packing>

void main() {

	float mean = 0.0;
	float squared_mean = 0.0;

	// This seems totally useless but it's a crazy work around for a Adreno compiler bug
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );

	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {

		#ifdef HORIZONTAL_PASS

			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;

		#else

			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;

		#endif

	}

	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;

	float std_dev = sqrt( squared_mean - mean * mean );

	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/ShaderLib/vsm_vert.glsl.js":
/*!*************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/ShaderLib/vsm_vert.glsl.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
void main() {

	gl_Position = vec4( position, 1.0 );

}
`);


/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/UniformsLib.js":
/*!*************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/UniformsLib.js ***!
  \*************************************************************************************/
/*! exports provided: UniformsLib */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsLib", function() { return UniformsLib; });
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/Color.js */ "../../node_modules/three/src/math/Color.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Matrix3.js */ "../../node_modules/three/src/math/Matrix3.js");




/**
 * Uniforms library for shared webgl shaders
 */

const UniformsLib = {

	common: {

		diffuse: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"]( 0xeeeeee ) },
		opacity: { value: 1.0 },

		map: { value: null },
		uvTransform: { value: new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_2__["Matrix3"]() },
		uv2Transform: { value: new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_2__["Matrix3"]() },

		alphaMap: { value: null },

	},

	specularmap: {

		specularMap: { value: null },

	},

	envmap: {

		envMap: { value: null },
		flipEnvMap: { value: - 1 },
		reflectivity: { value: 1.0 },
		refractionRatio: { value: 0.98 },
		maxMipLevel: { value: 0 }

	},

	aomap: {

		aoMap: { value: null },
		aoMapIntensity: { value: 1 }

	},

	lightmap: {

		lightMap: { value: null },
		lightMapIntensity: { value: 1 }

	},

	emissivemap: {

		emissiveMap: { value: null }

	},

	bumpmap: {

		bumpMap: { value: null },
		bumpScale: { value: 1 }

	},

	normalmap: {

		normalMap: { value: null },
		normalScale: { value: new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"]( 1, 1 ) }

	},

	displacementmap: {

		displacementMap: { value: null },
		displacementScale: { value: 1 },
		displacementBias: { value: 0 }

	},

	roughnessmap: {

		roughnessMap: { value: null }

	},

	metalnessmap: {

		metalnessMap: { value: null }

	},

	gradientmap: {

		gradientMap: { value: null }

	},

	fog: {

		fogDensity: { value: 0.00025 },
		fogNear: { value: 1 },
		fogFar: { value: 2000 },
		fogColor: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"]( 0xffffff ) }

	},

	lights: {

		ambientLightColor: { value: [] },

		lightProbe: { value: [] },

		directionalLights: { value: [], properties: {
			direction: {},
			color: {}
		} },

		directionalLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		directionalShadowMap: { value: [] },
		directionalShadowMatrix: { value: [] },

		spotLights: { value: [], properties: {
			color: {},
			position: {},
			direction: {},
			distance: {},
			coneCos: {},
			penumbraCos: {},
			decay: {}
		} },

		spotLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		spotShadowMap: { value: [] },
		spotShadowMatrix: { value: [] },

		pointLights: { value: [], properties: {
			color: {},
			position: {},
			decay: {},
			distance: {}
		} },

		pointLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {},
			shadowCameraNear: {},
			shadowCameraFar: {}
		} },

		pointShadowMap: { value: [] },
		pointShadowMatrix: { value: [] },

		hemisphereLights: { value: [], properties: {
			direction: {},
			skyColor: {},
			groundColor: {}
		} },

		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		rectAreaLights: { value: [], properties: {
			color: {},
			position: {},
			width: {},
			height: {}
		} },

		ltc_1: { value: null },
		ltc_2: { value: null }

	},

	points: {

		diffuse: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"]( 0xeeeeee ) },
		opacity: { value: 1.0 },
		size: { value: 1.0 },
		scale: { value: 1.0 },
		map: { value: null },
		alphaMap: { value: null },
		uvTransform: { value: new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_2__["Matrix3"]() }

	},

	sprite: {

		diffuse: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"]( 0xeeeeee ) },
		opacity: { value: 1.0 },
		center: { value: new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"]( 0.5, 0.5 ) },
		rotation: { value: 0.0 },
		map: { value: null },
		alphaMap: { value: null },
		uvTransform: { value: new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_2__["Matrix3"]() }

	}

};




/***/ }),

/***/ "../../node_modules/three/src/renderers/shaders/UniformsUtils.js":
/*!***************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/shaders/UniformsUtils.js ***!
  \***************************************************************************************/
/*! exports provided: cloneUniforms, mergeUniforms, UniformsUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneUniforms", function() { return cloneUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeUniforms", function() { return mergeUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsUtils", function() { return UniformsUtils; });
/**
 * Uniform Utilities
 */

function cloneUniforms( src ) {

	const dst = {};

	for ( const u in src ) {

		dst[ u ] = {};

		for ( const p in src[ u ] ) {

			const property = src[ u ][ p ];

			if ( property && ( property.isColor ||
				property.isMatrix3 || property.isMatrix4 ||
				property.isVector2 || property.isVector3 || property.isVector4 ||
				property.isTexture || property.isQuaternion ) ) {

				dst[ u ][ p ] = property.clone();

			} else if ( Array.isArray( property ) ) {

				dst[ u ][ p ] = property.slice();

			} else {

				dst[ u ][ p ] = property;

			}

		}

	}

	return dst;

}

function mergeUniforms( uniforms ) {

	const merged = {};

	for ( let u = 0; u < uniforms.length; u ++ ) {

		const tmp = cloneUniforms( uniforms[ u ] );

		for ( const p in tmp ) {

			merged[ p ] = tmp[ p ];

		}

	}

	return merged;

}

// Legacy

const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };




/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLAnimation.js":
/*!**************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLAnimation.js ***!
  \**************************************************************************************/
/*! exports provided: WebGLAnimation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLAnimation", function() { return WebGLAnimation; });
function WebGLAnimation() {

	let context = null;
	let isAnimating = false;
	let animationLoop = null;
	let requestId = null;

	function onAnimationFrame( time, frame ) {

		animationLoop( time, frame );

		requestId = context.requestAnimationFrame( onAnimationFrame );

	}

	return {

		start: function () {

			if ( isAnimating === true ) return;
			if ( animationLoop === null ) return;

			requestId = context.requestAnimationFrame( onAnimationFrame );

			isAnimating = true;

		},

		stop: function () {

			context.cancelAnimationFrame( requestId );

			isAnimating = false;

		},

		setAnimationLoop: function ( callback ) {

			animationLoop = callback;

		},

		setContext: function ( value ) {

			context = value;

		}

	};

}




/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLAttributes.js":
/*!***************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLAttributes.js ***!
  \***************************************************************************************/
/*! exports provided: WebGLAttributes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLAttributes", function() { return WebGLAttributes; });
function WebGLAttributes( gl, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	const buffers = new WeakMap();

	function createBuffer( attribute, bufferType ) {

		const array = attribute.array;
		const usage = attribute.usage;

		const buffer = gl.createBuffer();

		gl.bindBuffer( bufferType, buffer );
		gl.bufferData( bufferType, array, usage );

		attribute.onUploadCallback();

		let type = gl.FLOAT;

		if ( array instanceof Float32Array ) {

			type = gl.FLOAT;

		} else if ( array instanceof Float64Array ) {

			console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

		} else if ( array instanceof Uint16Array ) {

			if ( attribute.isFloat16BufferAttribute ) {

				if ( isWebGL2 ) {

					type = gl.HALF_FLOAT;

				} else {

					console.warn( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );

				}

			} else {

				type = gl.UNSIGNED_SHORT;

			}

		} else if ( array instanceof Int16Array ) {

			type = gl.SHORT;

		} else if ( array instanceof Uint32Array ) {

			type = gl.UNSIGNED_INT;

		} else if ( array instanceof Int32Array ) {

			type = gl.INT;

		} else if ( array instanceof Int8Array ) {

			type = gl.BYTE;

		} else if ( array instanceof Uint8Array ) {

			type = gl.UNSIGNED_BYTE;

		}

		return {
			buffer: buffer,
			type: type,
			bytesPerElement: array.BYTES_PER_ELEMENT,
			version: attribute.version
		};

	}

	function updateBuffer( buffer, attribute, bufferType ) {

		const array = attribute.array;
		const updateRange = attribute.updateRange;

		gl.bindBuffer( bufferType, buffer );

		if ( updateRange.count === - 1 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, array );

		} else {

			if ( isWebGL2 ) {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array, updateRange.offset, updateRange.count );

			} else {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

			}

			updateRange.count = - 1; // reset range

		}

	}

	//

	function get( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		return buffers.get( attribute );

	}

	function remove( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		const data = buffers.get( attribute );

		if ( data ) {

			gl.deleteBuffer( data.buffer );

			buffers.delete( attribute );

		}

	}

	function update( attribute, bufferType ) {

		if ( attribute.isGLBufferAttribute ) {

			const cached = buffers.get( attribute );

			if ( ! cached || cached.version < attribute.version ) {

				buffers.set( attribute, {
					buffer: attribute.buffer,
					type: attribute.type,
					bytesPerElement: attribute.elementSize,
					version: attribute.version
				} );

			}

			return;

		}

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		const data = buffers.get( attribute );

		if ( data === undefined ) {

			buffers.set( attribute, createBuffer( attribute, bufferType ) );

		} else if ( data.version < attribute.version ) {

			updateBuffer( data.buffer, attribute, bufferType );

			data.version = attribute.version;

		}

	}

	return {

		get: get,
		remove: remove,
		update: update

	};

}





/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLBackground.js":
/*!***************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLBackground.js ***!
  \***************************************************************************************/
/*! exports provided: WebGLBackground */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLBackground", function() { return WebGLBackground; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _geometries_BoxGeometry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometries/BoxGeometry.js */ "../../node_modules/three/src/geometries/BoxGeometry.js");
/* harmony import */ var _geometries_PlaneGeometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../geometries/PlaneGeometry.js */ "../../node_modules/three/src/geometries/PlaneGeometry.js");
/* harmony import */ var _materials_ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../materials/ShaderMaterial.js */ "../../node_modules/three/src/materials/ShaderMaterial.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../math/Color.js */ "../../node_modules/three/src/math/Color.js");
/* harmony import */ var _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../objects/Mesh.js */ "../../node_modules/three/src/objects/Mesh.js");
/* harmony import */ var _shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../shaders/ShaderLib.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib.js");
/* harmony import */ var _shaders_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../shaders/UniformsUtils.js */ "../../node_modules/three/src/renderers/shaders/UniformsUtils.js");









function WebGLBackground( renderer, cubemaps, state, objects, premultipliedAlpha ) {

	const clearColor = new _math_Color_js__WEBPACK_IMPORTED_MODULE_4__["Color"]( 0x000000 );
	let clearAlpha = 0;

	let planeMesh;
	let boxMesh;

	let currentBackground = null;
	let currentBackgroundVersion = 0;
	let currentTonemapping = null;

	function render( renderList, scene, camera, forceClear ) {

		let background = scene.isScene === true ? scene.background : null;

		if ( background && background.isTexture ) {

			background = cubemaps.get( background );

		}

		// Ignore background in AR
		// TODO: Reconsider this.

		const xr = renderer.xr;
		const session = xr.getSession && xr.getSession();

		if ( session && session.environmentBlendMode === 'additive' ) {

			background = null;

		}

		if ( background === null ) {

			setClear( clearColor, clearAlpha );

		} else if ( background && background.isColor ) {

			setClear( background, 1 );
			forceClear = true;

		}

		if ( renderer.autoClear || forceClear ) {

			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

		}

		if ( background && ( background.isCubeTexture || background.mapping === _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeUVReflectionMapping"] ) ) {

			if ( boxMesh === undefined ) {

				boxMesh = new _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_5__["Mesh"](
					new _geometries_BoxGeometry_js__WEBPACK_IMPORTED_MODULE_1__["BoxGeometry"]( 1, 1, 1 ),
					new _materials_ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_3__["ShaderMaterial"]( {
						name: 'BackgroundCubeMaterial',
						uniforms: Object(_shaders_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_7__["cloneUniforms"])( _shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_6__["ShaderLib"].cube.uniforms ),
						vertexShader: _shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_6__["ShaderLib"].cube.vertexShader,
						fragmentShader: _shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_6__["ShaderLib"].cube.fragmentShader,
						side: _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"],
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				boxMesh.geometry.deleteAttribute( 'normal' );
				boxMesh.geometry.deleteAttribute( 'uv' );

				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

					this.matrixWorld.copyPosition( camera.matrixWorld );

				};

				// enable code injection for non-built-in material
				Object.defineProperty( boxMesh.material, 'envMap', {

					get: function () {

						return this.uniforms.envMap.value;

					}

				} );

				objects.update( boxMesh );

			}

			boxMesh.material.uniforms.envMap.value = background;
			boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background._needsFlipEnvMap ) ? - 1 : 1;

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				boxMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}

			// push to the pre-sorted opaque render list
			renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

		} else if ( background && background.isTexture ) {

			if ( planeMesh === undefined ) {

				planeMesh = new _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_5__["Mesh"](
					new _geometries_PlaneGeometry_js__WEBPACK_IMPORTED_MODULE_2__["PlaneGeometry"]( 2, 2 ),
					new _materials_ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_3__["ShaderMaterial"]( {
						name: 'BackgroundMaterial',
						uniforms: Object(_shaders_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_7__["cloneUniforms"])( _shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_6__["ShaderLib"].background.uniforms ),
						vertexShader: _shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_6__["ShaderLib"].background.vertexShader,
						fragmentShader: _shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_6__["ShaderLib"].background.fragmentShader,
						side: _constants_js__WEBPACK_IMPORTED_MODULE_0__["FrontSide"],
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				planeMesh.geometry.deleteAttribute( 'normal' );

				// enable code injection for non-built-in material
				Object.defineProperty( planeMesh.material, 'map', {

					get: function () {

						return this.uniforms.t2D.value;

					}

				} );

				objects.update( planeMesh );

			}

			planeMesh.material.uniforms.t2D.value = background;

			if ( background.matrixAutoUpdate === true ) {

				background.updateMatrix();

			}

			planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				planeMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}


			// push to the pre-sorted opaque render list
			renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

		}

	}

	function setClear( color, alpha ) {

		state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

	}

	return {

		getClearColor: function () {

			return clearColor;

		},
		setClearColor: function ( color, alpha = 1 ) {

			clearColor.set( color );
			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		getClearAlpha: function () {

			return clearAlpha;

		},
		setClearAlpha: function ( alpha ) {

			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		render: render

	};

}





/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLBindingStates.js":
/*!******************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLBindingStates.js ***!
  \******************************************************************************************/
/*! exports provided: WebGLBindingStates */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLBindingStates", function() { return WebGLBindingStates; });
function WebGLBindingStates( gl, extensions, attributes, capabilities ) {

	const maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );

	const extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );
	const vaoAvailable = capabilities.isWebGL2 || extension !== null;

	const bindingStates = {};

	const defaultState = createBindingState( null );
	let currentState = defaultState;

	function setup( object, material, program, geometry, index ) {

		let updateBuffers = false;

		if ( vaoAvailable ) {

			const state = getBindingState( geometry, program, material );

			if ( currentState !== state ) {

				currentState = state;
				bindVertexArrayObject( currentState.object );

			}

			updateBuffers = needsUpdate( geometry, index );

			if ( updateBuffers ) saveCache( geometry, index );

		} else {

			const wireframe = ( material.wireframe === true );

			if ( currentState.geometry !== geometry.id ||
				currentState.program !== program.id ||
				currentState.wireframe !== wireframe ) {

				currentState.geometry = geometry.id;
				currentState.program = program.id;
				currentState.wireframe = wireframe;

				updateBuffers = true;

			}

		}

		if ( object.isInstancedMesh === true ) {

			updateBuffers = true;

		}

		if ( index !== null ) {

			attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );

		}

		if ( updateBuffers ) {

			setupVertexAttributes( object, material, program, geometry );

			if ( index !== null ) {

				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, attributes.get( index ).buffer );

			}

		}

	}

	function createVertexArrayObject() {

		if ( capabilities.isWebGL2 ) return gl.createVertexArray();

		return extension.createVertexArrayOES();

	}

	function bindVertexArrayObject( vao ) {

		if ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );

		return extension.bindVertexArrayOES( vao );

	}

	function deleteVertexArrayObject( vao ) {

		if ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );

		return extension.deleteVertexArrayOES( vao );

	}

	function getBindingState( geometry, program, material ) {

		const wireframe = ( material.wireframe === true );

		let programMap = bindingStates[ geometry.id ];

		if ( programMap === undefined ) {

			programMap = {};
			bindingStates[ geometry.id ] = programMap;

		}

		let stateMap = programMap[ program.id ];

		if ( stateMap === undefined ) {

			stateMap = {};
			programMap[ program.id ] = stateMap;

		}

		let state = stateMap[ wireframe ];

		if ( state === undefined ) {

			state = createBindingState( createVertexArrayObject() );
			stateMap[ wireframe ] = state;

		}

		return state;

	}

	function createBindingState( vao ) {

		const newAttributes = [];
		const enabledAttributes = [];
		const attributeDivisors = [];

		for ( let i = 0; i < maxVertexAttributes; i ++ ) {

			newAttributes[ i ] = 0;
			enabledAttributes[ i ] = 0;
			attributeDivisors[ i ] = 0;

		}

		return {

			// for backward compatibility on non-VAO support browser
			geometry: null,
			program: null,
			wireframe: false,

			newAttributes: newAttributes,
			enabledAttributes: enabledAttributes,
			attributeDivisors: attributeDivisors,
			object: vao,
			attributes: {},
			index: null

		};

	}

	function needsUpdate( geometry, index ) {

		const cachedAttributes = currentState.attributes;
		const geometryAttributes = geometry.attributes;

		let attributesNum = 0;

		for ( const key in geometryAttributes ) {

			const cachedAttribute = cachedAttributes[ key ];
			const geometryAttribute = geometryAttributes[ key ];

			if ( cachedAttribute === undefined ) return true;

			if ( cachedAttribute.attribute !== geometryAttribute ) return true;

			if ( cachedAttribute.data !== geometryAttribute.data ) return true;

			attributesNum ++;

		}

		if ( currentState.attributesNum !== attributesNum ) return true;

		if ( currentState.index !== index ) return true;

		return false;

	}

	function saveCache( geometry, index ) {

		const cache = {};
		const attributes = geometry.attributes;
		let attributesNum = 0;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];

			const data = {};
			data.attribute = attribute;

			if ( attribute.data ) {

				data.data = attribute.data;

			}

			cache[ key ] = data;

			attributesNum ++;

		}

		currentState.attributes = cache;
		currentState.attributesNum = attributesNum;

		currentState.index = index;

	}

	function initAttributes() {

		const newAttributes = currentState.newAttributes;

		for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

			newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		enableAttributeAndDivisor( attribute, 0 );

	}

	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;
		const attributeDivisors = currentState.attributeDivisors;

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			const extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

			extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	}

	function disableUnusedAttributes() {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;

		for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	}

	function vertexAttribPointer( index, size, type, normalized, stride, offset ) {

		if ( capabilities.isWebGL2 === true && ( type === gl.INT || type === gl.UNSIGNED_INT ) ) {

			gl.vertexAttribIPointer( index, size, type, stride, offset );

		} else {

			gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

		}

	}

	function setupVertexAttributes( object, material, program, geometry ) {

		if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

			if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;

		}

		initAttributes();

		const geometryAttributes = geometry.attributes;

		const programAttributes = program.getAttributes();

		const materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( const name in programAttributes ) {

			const programAttribute = programAttributes[ name ];

			if ( programAttribute >= 0 ) {

				const geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute !== undefined ) {

					const normalized = geometryAttribute.normalized;
					const size = geometryAttribute.itemSize;

					const attribute = attributes.get( geometryAttribute );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					const buffer = attribute.buffer;
					const type = attribute.type;
					const bytesPerElement = attribute.bytesPerElement;

					if ( geometryAttribute.isInterleavedBufferAttribute ) {

						const data = geometryAttribute.data;
						const stride = data.stride;
						const offset = geometryAttribute.offset;

						if ( data && data.isInstancedInterleavedBuffer ) {

							enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

							if ( geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = data.meshPerAttribute * data.count;

							}

						} else {

							enableAttribute( programAttribute );

						}

						gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
						vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );

					} else {

						if ( geometryAttribute.isInstancedBufferAttribute ) {

							enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

							if ( geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							enableAttribute( programAttribute );

						}

						gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
						vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );

					}

				} else if ( name === 'instanceMatrix' ) {

					const attribute = attributes.get( object.instanceMatrix );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					const buffer = attribute.buffer;
					const type = attribute.type;

					enableAttributeAndDivisor( programAttribute + 0, 1 );
					enableAttributeAndDivisor( programAttribute + 1, 1 );
					enableAttributeAndDivisor( programAttribute + 2, 1 );
					enableAttributeAndDivisor( programAttribute + 3, 1 );

					gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

					gl.vertexAttribPointer( programAttribute + 0, 4, type, false, 64, 0 );
					gl.vertexAttribPointer( programAttribute + 1, 4, type, false, 64, 16 );
					gl.vertexAttribPointer( programAttribute + 2, 4, type, false, 64, 32 );
					gl.vertexAttribPointer( programAttribute + 3, 4, type, false, 64, 48 );

				} else if ( name === 'instanceColor' ) {

					const attribute = attributes.get( object.instanceColor );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					const buffer = attribute.buffer;
					const type = attribute.type;

					enableAttributeAndDivisor( programAttribute, 1 );

					gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

					gl.vertexAttribPointer( programAttribute, 3, type, false, 12, 0 );

				} else if ( materialDefaultAttributeValues !== undefined ) {

					const value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								gl.vertexAttrib2fv( programAttribute, value );
								break;

							case 3:
								gl.vertexAttrib3fv( programAttribute, value );
								break;

							case 4:
								gl.vertexAttrib4fv( programAttribute, value );
								break;

							default:
								gl.vertexAttrib1fv( programAttribute, value );

						}

					}

				}

			}

		}

		disableUnusedAttributes();

	}

	function dispose() {

		reset();

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			for ( const programId in programMap ) {

				const stateMap = programMap[ programId ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ programId ];

			}

			delete bindingStates[ geometryId ];

		}

	}

	function releaseStatesOfGeometry( geometry ) {

		if ( bindingStates[ geometry.id ] === undefined ) return;

		const programMap = bindingStates[ geometry.id ];

		for ( const programId in programMap ) {

			const stateMap = programMap[ programId ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ programId ];

		}

		delete bindingStates[ geometry.id ];

	}

	function releaseStatesOfProgram( program ) {

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			if ( programMap[ program.id ] === undefined ) continue;

			const stateMap = programMap[ program.id ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ program.id ];

		}

	}

	function reset() {

		resetDefaultState();

		if ( currentState === defaultState ) return;

		currentState = defaultState;
		bindVertexArrayObject( currentState.object );

	}

	// for backward-compatilibity

	function resetDefaultState() {

		defaultState.geometry = null;
		defaultState.program = null;
		defaultState.wireframe = false;

	}

	return {

		setup: setup,
		reset: reset,
		resetDefaultState: resetDefaultState,
		dispose: dispose,
		releaseStatesOfGeometry: releaseStatesOfGeometry,
		releaseStatesOfProgram: releaseStatesOfProgram,

		initAttributes: initAttributes,
		enableAttribute: enableAttribute,
		disableUnusedAttributes: disableUnusedAttributes

	};

}





/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLBufferRenderer.js":
/*!*******************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLBufferRenderer.js ***!
  \*******************************************************************************************/
/*! exports provided: WebGLBufferRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLBufferRenderer", function() { return WebGLBufferRenderer; });
function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	let mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		gl.drawArrays( mode, start, count );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		let extension, methodName;

		if ( isWebGL2 ) {

			extension = gl;
			methodName = 'drawArraysInstanced';

		} else {

			extension = extensions.get( 'ANGLE_instanced_arrays' );
			methodName = 'drawArraysInstancedANGLE';

			if ( extension === null ) {

				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ methodName ]( mode, start, count, primcount );

		info.update( count, mode, primcount );

	}

	//

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;

}





/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLCapabilities.js":
/*!*****************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLCapabilities.js ***!
  \*****************************************************************************************/
/*! exports provided: WebGLCapabilities */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLCapabilities", function() { return WebGLCapabilities; });
function WebGLCapabilities( gl, extensions, parameters ) {

	let maxAnisotropy;

	function getMaxAnisotropy() {

		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		} else {

			maxAnisotropy = 0;

		}

		return maxAnisotropy;

	}

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
				gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
				gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	/* eslint-disable no-undef */
	const isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||
		( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );
	/* eslint-enable no-undef */

	let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	const maxPrecision = getMaxPrecision( precision );

	if ( maxPrecision !== precision ) {

		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
		precision = maxPrecision;

	}

	const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

	const maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	const maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	const maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
	const maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	const maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
	const maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
	const maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
	const maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

	const vertexTextures = maxVertexTextures > 0;
	const floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );
	const floatVertexTextures = vertexTextures && floatFragmentTextures;

	const maxSamples = isWebGL2 ? gl.getParameter( gl.MAX_SAMPLES ) : 0;

	return {

		isWebGL2: isWebGL2,

		getMaxAnisotropy: getMaxAnisotropy,
		getMaxPrecision: getMaxPrecision,

		precision: precision,
		logarithmicDepthBuffer: logarithmicDepthBuffer,

		maxTextures: maxTextures,
		maxVertexTextures: maxVertexTextures,
		maxTextureSize: maxTextureSize,
		maxCubemapSize: maxCubemapSize,

		maxAttributes: maxAttributes,
		maxVertexUniforms: maxVertexUniforms,
		maxVaryings: maxVaryings,
		maxFragmentUniforms: maxFragmentUniforms,

		vertexTextures: vertexTextures,
		floatFragmentTextures: floatFragmentTextures,
		floatVertexTextures: floatVertexTextures,

		maxSamples: maxSamples

	};

}





/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLClipping.js":
/*!*************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLClipping.js ***!
  \*************************************************************************************/
/*! exports provided: WebGLClipping */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLClipping", function() { return WebGLClipping; });
/* harmony import */ var _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/Matrix3.js */ "../../node_modules/three/src/math/Matrix3.js");
/* harmony import */ var _math_Plane_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/Plane.js */ "../../node_modules/three/src/math/Plane.js");



function WebGLClipping( properties ) {

	const scope = this;

	let globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = false,
		renderingShadows = false;

	const plane = new _math_Plane_js__WEBPACK_IMPORTED_MODULE_1__["Plane"](),
		viewNormalMatrix = new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_0__["Matrix3"](),

		uniform = { value: null, needsUpdate: false };

	this.uniform = uniform;
	this.numPlanes = 0;
	this.numIntersection = 0;

	this.init = function ( planes, enableLocalClipping, camera ) {

		const enabled =
			planes.length !== 0 ||
			enableLocalClipping ||
			// enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 ||
			localClippingEnabled;

		localClippingEnabled = enableLocalClipping;

		globalState = projectPlanes( planes, camera, 0 );
		numGlobalPlanes = planes.length;

		return enabled;

	};

	this.beginShadows = function () {

		renderingShadows = true;
		projectPlanes( null );

	};

	this.endShadows = function () {

		renderingShadows = false;
		resetGlobalState();

	};

	this.setState = function ( material, camera, useCache ) {

		const planes = material.clippingPlanes,
			clipIntersection = material.clipIntersection,
			clipShadows = material.clipShadows;

		const materialProperties = properties.get( material );

		if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

			// there's no local clipping

			if ( renderingShadows ) {

				// there's no global clipping

				projectPlanes( null );

			} else {

				resetGlobalState();

			}

		} else {

			const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = nGlobal * 4;

			let dstArray = materialProperties.clippingState || null;

			uniform.value = dstArray; // ensure unique state

			dstArray = projectPlanes( planes, camera, lGlobal, useCache );

			for ( let i = 0; i !== lGlobal; ++ i ) {

				dstArray[ i ] = globalState[ i ];

			}

			materialProperties.clippingState = dstArray;
			this.numIntersection = clipIntersection ? this.numPlanes : 0;
			this.numPlanes += nGlobal;

		}


	};

	function resetGlobalState() {

		if ( uniform.value !== globalState ) {

			uniform.value = globalState;
			uniform.needsUpdate = numGlobalPlanes > 0;

		}

		scope.numPlanes = numGlobalPlanes;
		scope.numIntersection = 0;

	}

	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

		const nPlanes = planes !== null ? planes.length : 0;
		let dstArray = null;

		if ( nPlanes !== 0 ) {

			dstArray = uniform.value;

			if ( skipTransform !== true || dstArray === null ) {

				const flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse;

				viewNormalMatrix.getNormalMatrix( viewMatrix );

				if ( dstArray === null || dstArray.length < flatSize ) {

					dstArray = new Float32Array( flatSize );

				}

				for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

					plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

					plane.normal.toArray( dstArray, i4 );
					dstArray[ i4 + 3 ] = plane.constant;

				}

			}

			uniform.value = dstArray;
			uniform.needsUpdate = true;

		}

		scope.numPlanes = nPlanes;
		scope.numIntersection = 0;

		return dstArray;

	}

}





/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLCubeMaps.js":
/*!*************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLCubeMaps.js ***!
  \*************************************************************************************/
/*! exports provided: WebGLCubeMaps */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLCubeMaps", function() { return WebGLCubeMaps; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _WebGLCubeRenderTarget_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../WebGLCubeRenderTarget.js */ "../../node_modules/three/src/renderers/WebGLCubeRenderTarget.js");



function WebGLCubeMaps( renderer ) {

	let cubemaps = new WeakMap();

	function mapTextureMapping( texture, mapping ) {

		if ( mapping === _constants_js__WEBPACK_IMPORTED_MODULE_0__["EquirectangularReflectionMapping"] ) {

			texture.mapping = _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeReflectionMapping"];

		} else if ( mapping === _constants_js__WEBPACK_IMPORTED_MODULE_0__["EquirectangularRefractionMapping"] ) {

			texture.mapping = _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeRefractionMapping"];

		}

		return texture;

	}

	function get( texture ) {

		if ( texture && texture.isTexture ) {

			const mapping = texture.mapping;

			if ( mapping === _constants_js__WEBPACK_IMPORTED_MODULE_0__["EquirectangularReflectionMapping"] || mapping === _constants_js__WEBPACK_IMPORTED_MODULE_0__["EquirectangularRefractionMapping"] ) {

				if ( cubemaps.has( texture ) ) {

					const cubemap = cubemaps.get( texture ).texture;
					return mapTextureMapping( cubemap, texture.mapping );

				} else {

					const image = texture.image;

					if ( image && image.height > 0 ) {

						const currentRenderTarget = renderer.getRenderTarget();

						const renderTarget = new _WebGLCubeRenderTarget_js__WEBPACK_IMPORTED_MODULE_1__["WebGLCubeRenderTarget"]( image.height / 2 );
						renderTarget.fromEquirectangularTexture( renderer, texture );
						cubemaps.set( texture, renderTarget );

						renderer.setRenderTarget( currentRenderTarget );

						texture.addEventListener( 'dispose', onTextureDispose );

						return mapTextureMapping( renderTarget.texture, texture.mapping );

					} else {

						// image not yet ready. try the conversion next frame

						return null;

					}

				}

			}

		}

		return texture;

	}

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		const cubemap = cubemaps.get( texture );

		if ( cubemap !== undefined ) {

			cubemaps.delete( texture );
			cubemap.dispose();

		}

	}

	function dispose() {

		cubemaps = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}




/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLExtensions.js":
/*!***************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLExtensions.js ***!
  \***************************************************************************************/
/*! exports provided: WebGLExtensions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLExtensions", function() { return WebGLExtensions; });
function WebGLExtensions( gl ) {

	const extensions = {};

	function getExtension( name ) {

		if ( extensions[ name ] !== undefined ) {

			return extensions[ name ];

		}

		let extension;

		switch ( name ) {

			case 'WEBGL_depth_texture':
				extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
				break;

			case 'EXT_texture_filter_anisotropic':
				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
				break;

			case 'WEBGL_compressed_texture_s3tc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
				break;

			case 'WEBGL_compressed_texture_pvrtc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
				break;

			default:
				extension = gl.getExtension( name );

		}

		extensions[ name ] = extension;

		return extension;

	}

	return {

		has: function ( name ) {

			return getExtension( name ) !== null;

		},

		init: function ( capabilities ) {

			if ( capabilities.isWebGL2 ) {

				getExtension( 'EXT_color_buffer_float' );

			} else {

				getExtension( 'WEBGL_depth_texture' );
				getExtension( 'OES_texture_float' );
				getExtension( 'OES_texture_half_float' );
				getExtension( 'OES_texture_half_float_linear' );
				getExtension( 'OES_standard_derivatives' );
				getExtension( 'OES_element_index_uint' );
				getExtension( 'OES_vertex_array_object' );
				getExtension( 'ANGLE_instanced_arrays' );

			}

			getExtension( 'OES_texture_float_linear' );
			getExtension( 'EXT_color_buffer_half_float' );

		},

		get: function ( name ) {

			const extension = getExtension( name );

			if ( extension === null ) {

				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			return extension;

		}

	};

}





/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLGeometries.js":
/*!***************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLGeometries.js ***!
  \***************************************************************************************/
/*! exports provided: WebGLGeometries */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLGeometries", function() { return WebGLGeometries; });
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils.js */ "../../node_modules/three/src/utils.js");



function WebGLGeometries( gl, attributes, info, bindingStates ) {

	const geometries = {};
	const wireframeAttributes = new WeakMap();

	function onGeometryDispose( event ) {

		const geometry = event.target;

		if ( geometry.index !== null ) {

			attributes.remove( geometry.index );

		}

		for ( const name in geometry.attributes ) {

			attributes.remove( geometry.attributes[ name ] );

		}

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		delete geometries[ geometry.id ];

		const attribute = wireframeAttributes.get( geometry );

		if ( attribute ) {

			attributes.remove( attribute );
			wireframeAttributes.delete( geometry );

		}

		bindingStates.releaseStatesOfGeometry( geometry );

		if ( geometry.isInstancedBufferGeometry === true ) {

			delete geometry._maxInstanceCount;

		}

		//

		info.memory.geometries --;

	}

	function get( object, geometry ) {

		if ( geometries[ geometry.id ] === true ) return geometry;

		geometry.addEventListener( 'dispose', onGeometryDispose );

		geometries[ geometry.id ] = true;

		info.memory.geometries ++;

		return geometry;

	}

	function update( geometry ) {

		const geometryAttributes = geometry.attributes;

		// Updating index buffer in VAO now. See WebGLBindingStates.

		for ( const name in geometryAttributes ) {

			attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );

		}

		// morph targets

		const morphAttributes = geometry.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = morphAttributes[ name ];

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				attributes.update( array[ i ], gl.ARRAY_BUFFER );

			}

		}

	}

	function updateWireframeAttribute( geometry ) {

		const indices = [];

		const geometryIndex = geometry.index;
		const geometryPosition = geometry.attributes.position;
		let version = 0;

		if ( geometryIndex !== null ) {

			const array = geometryIndex.array;
			version = geometryIndex.version;

			for ( let i = 0, l = array.length; i < l; i += 3 ) {

				const a = array[ i + 0 ];
				const b = array[ i + 1 ];
				const c = array[ i + 2 ];

				indices.push( a, b, b, c, c, a );

			}

		} else {

			const array = geometryPosition.array;
			version = geometryPosition.version;

			for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				const a = i + 0;
				const b = i + 1;
				const c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		}

		const attribute = new ( Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__["arrayMax"])( indices ) > 65535 ? _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0__["Uint32BufferAttribute"] : _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0__["Uint16BufferAttribute"] )( indices, 1 );
		attribute.version = version;

		// Updating index buffer in VAO now. See WebGLBindingStates

		//

		const previousAttribute = wireframeAttributes.get( geometry );

		if ( previousAttribute ) attributes.remove( previousAttribute );

		//

		wireframeAttributes.set( geometry, attribute );

	}

	function getWireframeAttribute( geometry ) {

		const currentAttribute = wireframeAttributes.get( geometry );

		if ( currentAttribute ) {

			const geometryIndex = geometry.index;

			if ( geometryIndex !== null ) {

				// if the attribute is obsolete, create a new one

				if ( currentAttribute.version < geometryIndex.version ) {

					updateWireframeAttribute( geometry );

				}

			}

		} else {

			updateWireframeAttribute( geometry );

		}

		return wireframeAttributes.get( geometry );

	}

	return {

		get: get,
		update: update,

		getWireframeAttribute: getWireframeAttribute

	};

}





/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLIndexedBufferRenderer.js":
/*!**************************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLIndexedBufferRenderer.js ***!
  \**************************************************************************************************/
/*! exports provided: WebGLIndexedBufferRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLIndexedBufferRenderer", function() { return WebGLIndexedBufferRenderer; });
function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	let mode;

	function setMode( value ) {

		mode = value;

	}

	let type, bytesPerElement;

	function setIndex( value ) {

		type = value.type;
		bytesPerElement = value.bytesPerElement;

	}

	function render( start, count ) {

		gl.drawElements( mode, count, type, start * bytesPerElement );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		let extension, methodName;

		if ( isWebGL2 ) {

			extension = gl;
			methodName = 'drawElementsInstanced';

		} else {

			extension = extensions.get( 'ANGLE_instanced_arrays' );
			methodName = 'drawElementsInstancedANGLE';

			if ( extension === null ) {

				console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

		info.update( count, mode, primcount );

	}

	//

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;

}





/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLInfo.js":
/*!*********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLInfo.js ***!
  \*********************************************************************************/
/*! exports provided: WebGLInfo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLInfo", function() { return WebGLInfo; });
function WebGLInfo( gl ) {

	const memory = {
		geometries: 0,
		textures: 0
	};

	const render = {
		frame: 0,
		calls: 0,
		triangles: 0,
		points: 0,
		lines: 0
	};

	function update( count, mode, instanceCount ) {

		render.calls ++;

		switch ( mode ) {

			case gl.TRIANGLES:
				render.triangles += instanceCount * ( count / 3 );
				break;

			case gl.LINES:
				render.lines += instanceCount * ( count / 2 );
				break;

			case gl.LINE_STRIP:
				render.lines += instanceCount * ( count - 1 );
				break;

			case gl.LINE_LOOP:
				render.lines += instanceCount * count;
				break;

			case gl.POINTS:
				render.points += instanceCount * count;
				break;

			default:
				console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
				break;

		}

	}

	function reset() {

		render.frame ++;
		render.calls = 0;
		render.triangles = 0;
		render.points = 0;
		render.lines = 0;

	}

	return {
		memory: memory,
		render: render,
		programs: null,
		autoReset: true,
		reset: reset,
		update: update
	};

}





/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLLights.js":
/*!***********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLLights.js ***!
  \***********************************************************************************/
/*! exports provided: WebGLLights */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLLights", function() { return WebGLLights; });
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/Color.js */ "../../node_modules/three/src/math/Color.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/Matrix4.js */ "../../node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _shaders_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shaders/UniformsLib.js */ "../../node_modules/three/src/renderers/shaders/UniformsLib.js");






function UniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						direction: new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"](),
						color: new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"]()
					};
					break;

				case 'SpotLight':
					uniforms = {
						position: new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"](),
						direction: new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"](),
						color: new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"](),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0
					};
					break;

				case 'PointLight':
					uniforms = {
						position: new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"](),
						color: new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"](),
						distance: 0,
						decay: 0
					};
					break;

				case 'HemisphereLight':
					uniforms = {
						direction: new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"](),
						skyColor: new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"](),
						groundColor: new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"]()
					};
					break;

				case 'RectAreaLight':
					uniforms = {
						color: new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"](),
						position: new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"](),
						halfWidth: new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"](),
						halfHeight: new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"]()
					};
					break;

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}

function ShadowUniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]()
					};
					break;

				case 'SpotLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]()
					};
					break;

				case 'PointLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"](),
						shadowCameraNear: 1,
						shadowCameraFar: 1000
					};
					break;

				// TODO (abelnation): set RectAreaLight shadow uniforms

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}



let nextVersion = 0;

function shadowCastingLightsFirst( lightA, lightB ) {

	return ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );

}

function WebGLLights( extensions, capabilities ) {

	const cache = new UniformsCache();

	const shadowCache = ShadowUniformsCache();

	const state = {

		version: 0,

		hash: {
			directionalLength: - 1,
			pointLength: - 1,
			spotLength: - 1,
			rectAreaLength: - 1,
			hemiLength: - 1,

			numDirectionalShadows: - 1,
			numPointShadows: - 1,
			numSpotShadows: - 1
		},

		ambient: [ 0, 0, 0 ],
		probe: [],
		directional: [],
		directionalShadow: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotShadow: [],
		spotShadowMap: [],
		spotShadowMatrix: [],
		rectArea: [],
		rectAreaLTC1: null,
		rectAreaLTC2: null,
		point: [],
		pointShadow: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: []

	};

	for ( let i = 0; i < 9; i ++ ) state.probe.push( new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"]() );

	const vector3 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();
	const matrix4 = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
	const matrix42 = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();

	function setup( lights ) {

		let r = 0, g = 0, b = 0;

		for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;

		let numDirectionalShadows = 0;
		let numPointShadows = 0;
		let numSpotShadows = 0;

		lights.sort( shadowCastingLightsFirst );

		for ( let i = 0, l = lights.length; i < l; i ++ ) {

			const light = lights[ i ];

			const color = light.color;
			const intensity = light.intensity;
			const distance = light.distance;

			const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

			if ( light.isAmbientLight ) {

				r += color.r * intensity;
				g += color.g * intensity;
				b += color.b * intensity;

			} else if ( light.isLightProbe ) {

				for ( let j = 0; j < 9; j ++ ) {

					state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

				}

			} else if ( light.isDirectionalLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.directionalShadow[ directionalLength ] = shadowUniforms;
					state.directionalShadowMap[ directionalLength ] = shadowMap;
					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

					numDirectionalShadows ++;

				}

				state.directional[ directionalLength ] = uniforms;

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				const uniforms = cache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );

				uniforms.color.copy( color ).multiplyScalar( intensity );
				uniforms.distance = distance;

				uniforms.coneCos = Math.cos( light.angle );
				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.spotShadow[ spotLength ] = shadowUniforms;
					state.spotShadowMap[ spotLength ] = shadowMap;
					state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;

					numSpotShadows ++;

				}

				state.spot[ spotLength ] = uniforms;

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				const uniforms = cache.get( light );

				// (a) intensity is the total visible light emitted
				//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

				// (b) intensity is the brightness of the light
				uniforms.color.copy( color ).multiplyScalar( intensity );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				state.rectArea[ rectAreaLength ] = uniforms;

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.distance = light.distance;
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;
					shadowUniforms.shadowCameraNear = shadow.camera.near;
					shadowUniforms.shadowCameraFar = shadow.camera.far;

					state.pointShadow[ pointLength ] = shadowUniforms;
					state.pointShadowMap[ pointLength ] = shadowMap;
					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

					numPointShadows ++;

				}

				state.point[ pointLength ] = uniforms;

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				const uniforms = cache.get( light );

				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

				state.hemi[ hemiLength ] = uniforms;

				hemiLength ++;

			}

		}

		if ( rectAreaLength > 0 ) {

			if ( capabilities.isWebGL2 ) {

				// WebGL 2

				state.rectAreaLTC1 = _shaders_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].LTC_FLOAT_1;
				state.rectAreaLTC2 = _shaders_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].LTC_FLOAT_2;

			} else {

				// WebGL 1

				if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

					state.rectAreaLTC1 = _shaders_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].LTC_FLOAT_1;
					state.rectAreaLTC2 = _shaders_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].LTC_FLOAT_2;

				} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {

					state.rectAreaLTC1 = _shaders_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].LTC_HALF_1;
					state.rectAreaLTC2 = _shaders_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].LTC_HALF_2;

				} else {

					console.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );

				}

			}

		}

		state.ambient[ 0 ] = r;
		state.ambient[ 1 ] = g;
		state.ambient[ 2 ] = b;

		const hash = state.hash;

		if ( hash.directionalLength !== directionalLength ||
			hash.pointLength !== pointLength ||
			hash.spotLength !== spotLength ||
			hash.rectAreaLength !== rectAreaLength ||
			hash.hemiLength !== hemiLength ||
			hash.numDirectionalShadows !== numDirectionalShadows ||
			hash.numPointShadows !== numPointShadows ||
			hash.numSpotShadows !== numSpotShadows ) {

			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;

			state.directionalShadow.length = numDirectionalShadows;
			state.directionalShadowMap.length = numDirectionalShadows;
			state.pointShadow.length = numPointShadows;
			state.pointShadowMap.length = numPointShadows;
			state.spotShadow.length = numSpotShadows;
			state.spotShadowMap.length = numSpotShadows;
			state.directionalShadowMatrix.length = numDirectionalShadows;
			state.pointShadowMatrix.length = numPointShadows;
			state.spotShadowMatrix.length = numSpotShadows;

			hash.directionalLength = directionalLength;
			hash.pointLength = pointLength;
			hash.spotLength = spotLength;
			hash.rectAreaLength = rectAreaLength;
			hash.hemiLength = hemiLength;

			hash.numDirectionalShadows = numDirectionalShadows;
			hash.numPointShadows = numPointShadows;
			hash.numSpotShadows = numSpotShadows;

			state.version = nextVersion ++;

		}

	}

	function setupView( lights, camera ) {

		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;

		const viewMatrix = camera.matrixWorldInverse;

		for ( let i = 0, l = lights.length; i < l; i ++ ) {

			const light = lights[ i ];

			if ( light.isDirectionalLight ) {

				const uniforms = state.directional[ directionalLength ];

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				const uniforms = state.spot[ spotLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				const uniforms = state.rectArea[ rectAreaLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				// extract local rotation of light to derive width/height half vectors
				matrix42.identity();
				matrix4.copy( light.matrixWorld );
				matrix4.premultiply( viewMatrix );
				matrix42.extractRotation( matrix4 );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				uniforms.halfWidth.applyMatrix4( matrix42 );
				uniforms.halfHeight.applyMatrix4( matrix42 );

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				const uniforms = state.point[ pointLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				const uniforms = state.hemi[ hemiLength ];

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				uniforms.direction.transformDirection( viewMatrix );
				uniforms.direction.normalize();

				hemiLength ++;

			}

		}

	}

	return {
		setup: setup,
		setupView: setupView,
		state: state
	};

}





/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLMaterials.js":
/*!**************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLMaterials.js ***!
  \**************************************************************************************/
/*! exports provided: WebGLMaterials */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLMaterials", function() { return WebGLMaterials; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "../../node_modules/three/src/constants.js");


function WebGLMaterials( properties ) {

	function refreshFogUniforms( uniforms, fog ) {

		uniforms.fogColor.value.copy( fog.color );

		if ( fog.isFog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog.isFogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshMaterialUniforms( uniforms, material, pixelRatio, height ) {

		if ( material.isMeshBasicMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshLambertMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsLambert( uniforms, material );

		} else if ( material.isMeshToonMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsToon( uniforms, material );

		} else if ( material.isMeshPhongMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsPhong( uniforms, material );

		} else if ( material.isMeshStandardMaterial ) {

			refreshUniformsCommon( uniforms, material );

			if ( material.isMeshPhysicalMaterial ) {

				refreshUniformsPhysical( uniforms, material );

			} else {

				refreshUniformsStandard( uniforms, material );

			}

		} else if ( material.isMeshMatcapMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsMatcap( uniforms, material );

		} else if ( material.isMeshDepthMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsDepth( uniforms, material );

		} else if ( material.isMeshDistanceMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsDistance( uniforms, material );

		} else if ( material.isMeshNormalMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsNormal( uniforms, material );

		} else if ( material.isLineBasicMaterial ) {

			refreshUniformsLine( uniforms, material );

			if ( material.isLineDashedMaterial ) {

				refreshUniformsDash( uniforms, material );

			}

		} else if ( material.isPointsMaterial ) {

			refreshUniformsPoints( uniforms, material, pixelRatio, height );

		} else if ( material.isSpriteMaterial ) {

			refreshUniformsSprites( uniforms, material );

		} else if ( material.isShadowMaterial ) {

			uniforms.color.value.copy( material.color );
			uniforms.opacity.value = material.opacity;

		} else if ( material.isShaderMaterial ) {

			material.uniformsNeedUpdate = false; // #15581

		}

	}

	function refreshUniformsCommon( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( material.color ) {

			uniforms.diffuse.value.copy( material.color );

		}

		if ( material.emissive ) {

			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

		}

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		if ( material.specularMap ) {

			uniforms.specularMap.value = material.specularMap;

		}

		const envMap = properties.get( material ).envMap;

		if ( envMap ) {

			uniforms.envMap.value = envMap;

			uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap._needsFlipEnvMap ) ? - 1 : 1;

			uniforms.reflectivity.value = material.reflectivity;
			uniforms.refractionRatio.value = material.refractionRatio;

			const maxMipLevel = properties.get( envMap ).__maxMipLevel;

			if ( maxMipLevel !== undefined ) {

				uniforms.maxMipLevel.value = maxMipLevel;

			}

		}

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

		}

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. specular map
		// 3. displacementMap map
		// 4. normal map
		// 5. bump map
		// 6. roughnessMap map
		// 7. metalnessMap map
		// 8. alphaMap map
		// 9. emissiveMap map
		// 10. clearcoat map
		// 11. clearcoat normal map
		// 12. clearcoat roughnessMap map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.displacementMap ) {

			uvScaleMap = material.displacementMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.roughnessMap ) {

			uvScaleMap = material.roughnessMap;

		} else if ( material.metalnessMap ) {

			uvScaleMap = material.metalnessMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		} else if ( material.emissiveMap ) {

			uvScaleMap = material.emissiveMap;

		} else if ( material.clearcoatMap ) {

			uvScaleMap = material.clearcoatMap;

		} else if ( material.clearcoatNormalMap ) {

			uvScaleMap = material.clearcoatNormalMap;

		} else if ( material.clearcoatRoughnessMap ) {

			uvScaleMap = material.clearcoatRoughnessMap;

		}

		if ( uvScaleMap !== undefined ) {

			// backwards compatibility
			if ( uvScaleMap.isWebGLRenderTarget ) {

				uvScaleMap = uvScaleMap.texture;

			}

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

		// uv repeat and offset setting priorities for uv2
		// 1. ao map
		// 2. light map

		let uv2ScaleMap;

		if ( material.aoMap ) {

			uv2ScaleMap = material.aoMap;

		} else if ( material.lightMap ) {

			uv2ScaleMap = material.lightMap;

		}

		if ( uv2ScaleMap !== undefined ) {

			// backwards compatibility
			if ( uv2ScaleMap.isWebGLRenderTarget ) {

				uv2ScaleMap = uv2ScaleMap.texture;

			}

			if ( uv2ScaleMap.matrixAutoUpdate === true ) {

				uv2ScaleMap.updateMatrix();

			}

			uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );

		}

	}

	function refreshUniformsLine( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * pixelRatio;
		uniforms.scale.value = height * 0.5;

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

	}

	function refreshUniformsSprites( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.rotation.value = material.rotation;

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

	}

	function refreshUniformsLambert( uniforms, material ) {

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

	}

	function refreshUniformsPhong( uniforms, material ) {

		uniforms.specular.value.copy( material.specular );
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"] ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"] ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsToon( uniforms, material ) {

		if ( material.gradientMap ) {

			uniforms.gradientMap.value = material.gradientMap;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"] ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"] ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsStandard( uniforms, material ) {

		uniforms.roughness.value = material.roughness;
		uniforms.metalness.value = material.metalness;

		if ( material.roughnessMap ) {

			uniforms.roughnessMap.value = material.roughnessMap;

		}

		if ( material.metalnessMap ) {

			uniforms.metalnessMap.value = material.metalnessMap;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"] ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"] ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		const envMap = properties.get( material ).envMap;

		if ( envMap ) {

			//uniforms.envMap.value = material.envMap; // part of uniforms common
			uniforms.envMapIntensity.value = material.envMapIntensity;

		}

	}

	function refreshUniformsPhysical( uniforms, material ) {

		refreshUniformsStandard( uniforms, material );

		uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

		uniforms.clearcoat.value = material.clearcoat;
		uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
		if ( material.sheen ) uniforms.sheen.value.copy( material.sheen );

		if ( material.clearcoatMap ) {

			uniforms.clearcoatMap.value = material.clearcoatMap;

		}

		if ( material.clearcoatRoughnessMap ) {

			uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

		}

		if ( material.clearcoatNormalMap ) {

			uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
			uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

			if ( material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"] ) {

				uniforms.clearcoatNormalScale.value.negate();

			}

		}

		uniforms.transmission.value = material.transmission;

		if ( material.transmissionMap ) {

			uniforms.transmissionMap.value = material.transmissionMap;

		}

	}

	function refreshUniformsMatcap( uniforms, material ) {

		if ( material.matcap ) {

			uniforms.matcap.value = material.matcap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"] ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"] ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsDepth( uniforms, material ) {

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsDistance( uniforms, material ) {

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		uniforms.referencePosition.value.copy( material.referencePosition );
		uniforms.nearDistance.value = material.nearDistance;
		uniforms.farDistance.value = material.farDistance;

	}

	function refreshUniformsNormal( uniforms, material ) {

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"] ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"] ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	return {
		refreshFogUniforms: refreshFogUniforms,
		refreshMaterialUniforms: refreshMaterialUniforms
	};

}




/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLMorphtargets.js":
/*!*****************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLMorphtargets.js ***!
  \*****************************************************************************************/
/*! exports provided: WebGLMorphtargets */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLMorphtargets", function() { return WebGLMorphtargets; });
function numericalSort( a, b ) {

	return a[ 0 ] - b[ 0 ];

}

function absNumericalSort( a, b ) {

	return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

}

function WebGLMorphtargets( gl ) {

	const influencesList = {};
	const morphInfluences = new Float32Array( 8 );

	const workInfluences = [];

	for ( let i = 0; i < 8; i ++ ) {

		workInfluences[ i ] = [ i, 0 ];

	}

	function update( object, geometry, material, program ) {

		const objectInfluences = object.morphTargetInfluences;

		// When object doesn't have morph target influences defined, we treat it as a 0-length array
		// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

		const length = objectInfluences === undefined ? 0 : objectInfluences.length;

		let influences = influencesList[ geometry.id ];

		if ( influences === undefined ) {

			// initialise list

			influences = [];

			for ( let i = 0; i < length; i ++ ) {

				influences[ i ] = [ i, 0 ];

			}

			influencesList[ geometry.id ] = influences;

		}

		// Collect influences

		for ( let i = 0; i < length; i ++ ) {

			const influence = influences[ i ];

			influence[ 0 ] = i;
			influence[ 1 ] = objectInfluences[ i ];

		}

		influences.sort( absNumericalSort );

		for ( let i = 0; i < 8; i ++ ) {

			if ( i < length && influences[ i ][ 1 ] ) {

				workInfluences[ i ][ 0 ] = influences[ i ][ 0 ];
				workInfluences[ i ][ 1 ] = influences[ i ][ 1 ];

			} else {

				workInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;
				workInfluences[ i ][ 1 ] = 0;

			}

		}

		workInfluences.sort( numericalSort );

		const morphTargets = material.morphTargets && geometry.morphAttributes.position;
		const morphNormals = material.morphNormals && geometry.morphAttributes.normal;

		let morphInfluencesSum = 0;

		for ( let i = 0; i < 8; i ++ ) {

			const influence = workInfluences[ i ];
			const index = influence[ 0 ];
			const value = influence[ 1 ];

			if ( index !== Number.MAX_SAFE_INTEGER && value ) {

				if ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {

					geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );

				}

				if ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {

					geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

				}

				morphInfluences[ i ] = value;
				morphInfluencesSum += value;

			} else {

				if ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {

					geometry.deleteAttribute( 'morphTarget' + i );

				}

				if ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {

					geometry.deleteAttribute( 'morphNormal' + i );

				}

				morphInfluences[ i ] = 0;

			}

		}

		// GLSL shader uses formula baseinfluence * base + sum(target * influence)
		// This allows us to switch between absolute morphs and relative morphs without changing shader code
		// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
		const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

		program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
		program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

	}

	return {

		update: update

	};

}





/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLObjects.js":
/*!************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLObjects.js ***!
  \************************************************************************************/
/*! exports provided: WebGLObjects */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLObjects", function() { return WebGLObjects; });
function WebGLObjects( gl, geometries, attributes, info ) {

	let updateMap = new WeakMap();

	function update( object ) {

		const frame = info.render.frame;

		const geometry = object.geometry;
		const buffergeometry = geometries.get( object, geometry );

		// Update once per frame

		if ( updateMap.get( buffergeometry ) !== frame ) {

			geometries.update( buffergeometry );

			updateMap.set( buffergeometry, frame );

		}

		if ( object.isInstancedMesh ) {

			if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

				object.addEventListener( 'dispose', onInstancedMeshDispose );

			}

			attributes.update( object.instanceMatrix, gl.ARRAY_BUFFER );

			if ( object.instanceColor !== null ) {

				attributes.update( object.instanceColor, gl.ARRAY_BUFFER );

			}

		}

		return buffergeometry;

	}

	function dispose() {

		updateMap = new WeakMap();

	}

	function onInstancedMeshDispose( event ) {

		const instancedMesh = event.target;

		instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

		attributes.remove( instancedMesh.instanceMatrix );

		if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

	}

	return {

		update: update,
		dispose: dispose

	};

}





/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLProgram.js":
/*!************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLProgram.js ***!
  \************************************************************************************/
/*! exports provided: WebGLProgram */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLProgram", function() { return WebGLProgram; });
/* harmony import */ var _WebGLUniforms_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGLUniforms.js */ "../../node_modules/three/src/renderers/webgl/WebGLUniforms.js");
/* harmony import */ var _WebGLShader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebGLShader.js */ "../../node_modules/three/src/renderers/webgl/WebGLShader.js");
/* harmony import */ var _shaders_ShaderChunk_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shaders/ShaderChunk.js */ "../../node_modules/three/src/renderers/shaders/ShaderChunk.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../constants.js */ "../../node_modules/three/src/constants.js");





let programIdCount = 0;

function addLineNumbers( string ) {

	const lines = string.split( '\n' );

	for ( let i = 0; i < lines.length; i ++ ) {

		lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

	}

	return lines.join( '\n' );

}

function getEncodingComponents( encoding ) {

	switch ( encoding ) {

		case _constants_js__WEBPACK_IMPORTED_MODULE_3__["LinearEncoding"]:
			return [ 'Linear', '( value )' ];
		case _constants_js__WEBPACK_IMPORTED_MODULE_3__["sRGBEncoding"]:
			return [ 'sRGB', '( value )' ];
		case _constants_js__WEBPACK_IMPORTED_MODULE_3__["RGBEEncoding"]:
			return [ 'RGBE', '( value )' ];
		case _constants_js__WEBPACK_IMPORTED_MODULE_3__["RGBM7Encoding"]:
			return [ 'RGBM', '( value, 7.0 )' ];
		case _constants_js__WEBPACK_IMPORTED_MODULE_3__["RGBM16Encoding"]:
			return [ 'RGBM', '( value, 16.0 )' ];
		case _constants_js__WEBPACK_IMPORTED_MODULE_3__["RGBDEncoding"]:
			return [ 'RGBD', '( value, 256.0 )' ];
		case _constants_js__WEBPACK_IMPORTED_MODULE_3__["GammaEncoding"]:
			return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
		case _constants_js__WEBPACK_IMPORTED_MODULE_3__["LogLuvEncoding"]:
			return [ 'LogLuv', '( value )' ];
		default:
			console.warn( 'THREE.WebGLProgram: Unsupported encoding:', encoding );
			return [ 'Linear', '( value )' ];

	}

}

function getShaderErrors( gl, shader, type ) {

	const status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );
	const log = gl.getShaderInfoLog( shader ).trim();

	if ( status && log === '' ) return '';

	// --enable-privileged-webgl-extension
	// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

	const source = gl.getShaderSource( shader );

	return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers( source );

}

function getTexelDecodingFunction( functionName, encoding ) {

	const components = getEncodingComponents( encoding );
	return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

}

function getTexelEncodingFunction( functionName, encoding ) {

	const components = getEncodingComponents( encoding );
	return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

}

function getToneMappingFunction( functionName, toneMapping ) {

	let toneMappingName;

	switch ( toneMapping ) {

		case _constants_js__WEBPACK_IMPORTED_MODULE_3__["LinearToneMapping"]:
			toneMappingName = 'Linear';
			break;

		case _constants_js__WEBPACK_IMPORTED_MODULE_3__["ReinhardToneMapping"]:
			toneMappingName = 'Reinhard';
			break;

		case _constants_js__WEBPACK_IMPORTED_MODULE_3__["CineonToneMapping"]:
			toneMappingName = 'OptimizedCineon';
			break;

		case _constants_js__WEBPACK_IMPORTED_MODULE_3__["ACESFilmicToneMapping"]:
			toneMappingName = 'ACESFilmic';
			break;

		case _constants_js__WEBPACK_IMPORTED_MODULE_3__["CustomToneMapping"]:
			toneMappingName = 'Custom';
			break;

		default:
			console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
			toneMappingName = 'Linear';

	}

	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

}

function generateExtensions( parameters ) {

	const chunks = [
		( parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
		( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
		( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
		( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
	];

	return chunks.filter( filterEmptyLine ).join( '\n' );

}

function generateDefines( defines ) {

	const chunks = [];

	for ( const name in defines ) {

		const value = defines[ name ];

		if ( value === false ) continue;

		chunks.push( '#define ' + name + ' ' + value );

	}

	return chunks.join( '\n' );

}

function fetchAttributeLocations( gl, program ) {

	const attributes = {};

	const n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

	for ( let i = 0; i < n; i ++ ) {

		const info = gl.getActiveAttrib( program, i );
		const name = info.name;

		// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

		attributes[ name ] = gl.getAttribLocation( program, name );

	}

	return attributes;

}

function filterEmptyLine( string ) {

	return string !== '';

}

function replaceLightNums( string, parameters ) {

	return string
		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
		.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
		.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
		.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

}

function replaceClippingPlaneNums( string, parameters ) {

	return string
		.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
		.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

}

// Resolve Includes

const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

function resolveIncludes( string ) {

	return string.replace( includePattern, includeReplacer );

}

function includeReplacer( match, include ) {

	const string = _shaders_ShaderChunk_js__WEBPACK_IMPORTED_MODULE_2__["ShaderChunk"][ include ];

	if ( string === undefined ) {

		throw new Error( 'Can not resolve #include <' + include + '>' );

	}

	return resolveIncludes( string );

}

// Unroll Loops

const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function unrollLoops( string ) {

	return string
		.replace( unrollLoopPattern, loopReplacer )
		.replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );

}

function deprecatedLoopReplacer( match, start, end, snippet ) {

	console.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );
	return loopReplacer( match, start, end, snippet );

}

function loopReplacer( match, start, end, snippet ) {

	let string = '';

	for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

		string += snippet
			.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
			.replace( /UNROLLED_LOOP_INDEX/g, i );

	}

	return string;

}

//

function generatePrecision( parameters ) {

	let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

	if ( parameters.precision === 'highp' ) {

		precisionstring += '\n#define HIGH_PRECISION';

	} else if ( parameters.precision === 'mediump' ) {

		precisionstring += '\n#define MEDIUM_PRECISION';

	} else if ( parameters.precision === 'lowp' ) {

		precisionstring += '\n#define LOW_PRECISION';

	}

	return precisionstring;

}

function generateShadowMapTypeDefine( parameters ) {

	let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

	if ( parameters.shadowMapType === _constants_js__WEBPACK_IMPORTED_MODULE_3__["PCFShadowMap"] ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

	} else if ( parameters.shadowMapType === _constants_js__WEBPACK_IMPORTED_MODULE_3__["PCFSoftShadowMap"] ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

	} else if ( parameters.shadowMapType === _constants_js__WEBPACK_IMPORTED_MODULE_3__["VSMShadowMap"] ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

	}

	return shadowMapTypeDefine;

}

function generateEnvMapTypeDefine( parameters ) {

	let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case _constants_js__WEBPACK_IMPORTED_MODULE_3__["CubeReflectionMapping"]:
			case _constants_js__WEBPACK_IMPORTED_MODULE_3__["CubeRefractionMapping"]:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;

			case _constants_js__WEBPACK_IMPORTED_MODULE_3__["CubeUVReflectionMapping"]:
			case _constants_js__WEBPACK_IMPORTED_MODULE_3__["CubeUVRefractionMapping"]:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;

		}

	}

	return envMapTypeDefine;

}

function generateEnvMapModeDefine( parameters ) {

	let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case _constants_js__WEBPACK_IMPORTED_MODULE_3__["CubeRefractionMapping"]:
			case _constants_js__WEBPACK_IMPORTED_MODULE_3__["CubeUVRefractionMapping"]:

				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;

		}

	}

	return envMapModeDefine;

}

function generateEnvMapBlendingDefine( parameters ) {

	let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

	if ( parameters.envMap ) {

		switch ( parameters.combine ) {

			case _constants_js__WEBPACK_IMPORTED_MODULE_3__["MultiplyOperation"]:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;

			case _constants_js__WEBPACK_IMPORTED_MODULE_3__["MixOperation"]:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;

			case _constants_js__WEBPACK_IMPORTED_MODULE_3__["AddOperation"]:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;

		}

	}

	return envMapBlendingDefine;

}

function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

	const gl = renderer.getContext();

	const defines = parameters.defines;

	let vertexShader = parameters.vertexShader;
	let fragmentShader = parameters.fragmentShader;

	const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
	const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
	const envMapModeDefine = generateEnvMapModeDefine( parameters );
	const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );


	const gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

	const customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

	const customDefines = generateDefines( defines );

	const program = gl.createProgram();

	let prefixVertex, prefixFragment;
	let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

	if ( parameters.isRawShaderMaterial ) {

		prefixVertex = [

			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixVertex.length > 0 ) {

			prefixVertex += '\n';

		}

		prefixFragment = [

			customExtensions,
			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixFragment.length > 0 ) {

			prefixFragment += '\n';

		}

	} else {

		prefixVertex = [

			generatePrecision( parameters ),

			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.instancing ? '#define USE_INSTANCING' : '',
			parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			'#define MAX_BONES ' + parameters.maxBones,
			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',

			parameters.vertexTangents ? '#define USE_TANGENT' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',
			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			parameters.vertexUvs ? '#define USE_UV' : '',
			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.skinning ? '#define USE_SKINNING' : '',
			parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			'uniform mat4 modelMatrix;',
			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat3 normalMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			'#ifdef USE_INSTANCING',

			'	attribute mat4 instanceMatrix;',

			'#endif',

			'#ifdef USE_INSTANCING_COLOR',

			'	attribute vec3 instanceColor;',

			'#endif',

			'attribute vec3 position;',
			'attribute vec3 normal;',
			'attribute vec2 uv;',

			'#ifdef USE_TANGENT',

			'	attribute vec4 tangent;',

			'#endif',

			'#if defined( USE_COLOR_ALPHA )',

			'	attribute vec4 color;',

			'#elif defined( USE_COLOR )',

			'	attribute vec3 color;',

			'#endif',

			'#ifdef USE_MORPHTARGETS',

			'	attribute vec3 morphTarget0;',
			'	attribute vec3 morphTarget1;',
			'	attribute vec3 morphTarget2;',
			'	attribute vec3 morphTarget3;',

			'	#ifdef USE_MORPHNORMALS',

			'		attribute vec3 morphNormal0;',
			'		attribute vec3 morphNormal1;',
			'		attribute vec3 morphNormal2;',
			'		attribute vec3 morphNormal3;',

			'	#else',

			'		attribute vec3 morphTarget4;',
			'		attribute vec3 morphTarget5;',
			'		attribute vec3 morphTarget6;',
			'		attribute vec3 morphTarget7;',

			'	#endif',

			'#endif',

			'#ifdef USE_SKINNING',

			'	attribute vec4 skinIndex;',
			'	attribute vec4 skinWeight;',

			'#endif',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

		prefixFragment = [

			customExtensions,

			generatePrecision( parameters ),

			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.matcap ? '#define USE_MATCAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapTypeDefine : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',
			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

			parameters.sheen ? '#define USE_SHEEN' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',

			parameters.vertexTangents ? '#define USE_TANGENT' : '',
			parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
			parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
			parameters.vertexUvs ? '#define USE_UV' : '',
			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

			parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			( ( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ) ? '#define TEXTURE_LOD_EXT' : '',

			'uniform mat4 viewMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			( parameters.toneMapping !== _constants_js__WEBPACK_IMPORTED_MODULE_3__["NoToneMapping"] ) ? '#define TONE_MAPPING' : '',
			( parameters.toneMapping !== _constants_js__WEBPACK_IMPORTED_MODULE_3__["NoToneMapping"] ) ? _shaders_ShaderChunk_js__WEBPACK_IMPORTED_MODULE_2__["ShaderChunk"][ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
			( parameters.toneMapping !== _constants_js__WEBPACK_IMPORTED_MODULE_3__["NoToneMapping"] ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

			parameters.dithering ? '#define DITHERING' : '',

			_shaders_ShaderChunk_js__WEBPACK_IMPORTED_MODULE_2__["ShaderChunk"][ 'encodings_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
			parameters.map ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
			parameters.matcap ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',
			parameters.envMap ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
			parameters.emissiveMap ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
			parameters.lightMap ? getTexelDecodingFunction( 'lightMapTexelToLinear', parameters.lightMapEncoding ) : '',
			getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ),

			parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

	}

	vertexShader = resolveIncludes( vertexShader );
	vertexShader = replaceLightNums( vertexShader, parameters );
	vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

	fragmentShader = resolveIncludes( fragmentShader );
	fragmentShader = replaceLightNums( fragmentShader, parameters );
	fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

	vertexShader = unrollLoops( vertexShader );
	fragmentShader = unrollLoops( fragmentShader );

	if ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {

		// GLSL 3.0 conversion for built-in materials and ShaderMaterial

		versionString = '#version 300 es\n';

		prefixVertex = [
			'#define attribute in',
			'#define varying out',
			'#define texture2D texture'
		].join( '\n' ) + '\n' + prefixVertex;

		prefixFragment = [
			'#define varying in',
			( parameters.glslVersion === _constants_js__WEBPACK_IMPORTED_MODULE_3__["GLSL3"] ) ? '' : 'out highp vec4 pc_fragColor;',
			( parameters.glslVersion === _constants_js__WEBPACK_IMPORTED_MODULE_3__["GLSL3"] ) ? '' : '#define gl_FragColor pc_fragColor',
			'#define gl_FragDepthEXT gl_FragDepth',
			'#define texture2D texture',
			'#define textureCube texture',
			'#define texture2DProj textureProj',
			'#define texture2DLodEXT textureLod',
			'#define texture2DProjLodEXT textureProjLod',
			'#define textureCubeLodEXT textureLod',
			'#define texture2DGradEXT textureGrad',
			'#define texture2DProjGradEXT textureProjGrad',
			'#define textureCubeGradEXT textureGrad'
		].join( '\n' ) + '\n' + prefixFragment;

	}

	const vertexGlsl = versionString + prefixVertex + vertexShader;
	const fragmentGlsl = versionString + prefixFragment + fragmentShader;

	// console.log( '*VERTEX*', vertexGlsl );
	// console.log( '*FRAGMENT*', fragmentGlsl );

	const glVertexShader = Object(_WebGLShader_js__WEBPACK_IMPORTED_MODULE_1__["WebGLShader"])( gl, gl.VERTEX_SHADER, vertexGlsl );
	const glFragmentShader = Object(_WebGLShader_js__WEBPACK_IMPORTED_MODULE_1__["WebGLShader"])( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

	gl.attachShader( program, glVertexShader );
	gl.attachShader( program, glFragmentShader );

	// Force a particular attribute to index 0.

	if ( parameters.index0AttributeName !== undefined ) {

		gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

	} else if ( parameters.morphTargets === true ) {

		// programs with morphTargets displace position out of attribute 0
		gl.bindAttribLocation( program, 0, 'position' );

	}

	gl.linkProgram( program );

	// check for link errors
	if ( renderer.debug.checkShaderErrors ) {

		const programLog = gl.getProgramInfoLog( program ).trim();
		const vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
		const fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

		let runnable = true;
		let haveDiagnostics = true;

		if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

			runnable = false;

			const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
			const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

			console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors );

		} else if ( programLog !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

		} else if ( vertexLog === '' || fragmentLog === '' ) {

			haveDiagnostics = false;

		}

		if ( haveDiagnostics ) {

			this.diagnostics = {

				runnable: runnable,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};

		}

	}

	// Clean up

	// Crashes in iOS9 and iOS10. #18402
	// gl.detachShader( program, glVertexShader );
	// gl.detachShader( program, glFragmentShader );

	gl.deleteShader( glVertexShader );
	gl.deleteShader( glFragmentShader );

	// set up caching for uniform locations

	let cachedUniforms;

	this.getUniforms = function () {

		if ( cachedUniforms === undefined ) {

			cachedUniforms = new _WebGLUniforms_js__WEBPACK_IMPORTED_MODULE_0__["WebGLUniforms"]( gl, program );

		}

		return cachedUniforms;

	};

	// set up caching for attribute locations

	let cachedAttributes;

	this.getAttributes = function () {

		if ( cachedAttributes === undefined ) {

			cachedAttributes = fetchAttributeLocations( gl, program );

		}

		return cachedAttributes;

	};

	// free resource

	this.destroy = function () {

		bindingStates.releaseStatesOfProgram( this );

		gl.deleteProgram( program );
		this.program = undefined;

	};

	//

	this.name = parameters.shaderName;
	this.id = programIdCount ++;
	this.cacheKey = cacheKey;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;

	return this;

}




/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLPrograms.js":
/*!*************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLPrograms.js ***!
  \*************************************************************************************/
/*! exports provided: WebGLPrograms */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLPrograms", function() { return WebGLPrograms; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _WebGLProgram_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebGLProgram.js */ "../../node_modules/three/src/renderers/webgl/WebGLProgram.js");
/* harmony import */ var _shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shaders/ShaderLib.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib.js");
/* harmony import */ var _shaders_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shaders/UniformsUtils.js */ "../../node_modules/three/src/renderers/shaders/UniformsUtils.js");





function WebGLPrograms( renderer, cubemaps, extensions, capabilities, bindingStates, clipping ) {

	const programs = [];

	const isWebGL2 = capabilities.isWebGL2;
	const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
	const floatVertexTextures = capabilities.floatVertexTextures;
	const maxVertexUniforms = capabilities.maxVertexUniforms;
	const vertexTextures = capabilities.vertexTextures;

	let precision = capabilities.precision;

	const shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshDistanceMaterial: 'distanceRGBA',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'toon',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		MeshMatcapMaterial: 'matcap',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points',
		ShadowMaterial: 'shadow',
		SpriteMaterial: 'sprite'
	};

	const parameterNames = [
		'precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor',
		'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV',
		'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap',
		'roughnessMap', 'metalnessMap', 'gradientMap',
		'alphaMap', 'combine', 'vertexColors', 'vertexAlphas', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2',
		'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning',
		'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'premultipliedAlpha',
		'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights',
		'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows',
		'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights',
		'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering',
		'sheen', 'transmissionMap'
	];

	function getMaxBones( object ) {

		const skeleton = object.skeleton;
		const bones = skeleton.bones;

		if ( floatVertexTextures ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			const nVertexUniforms = maxVertexUniforms;
			const nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			const maxBones = Math.min( nVertexMatrices, bones.length );

			if ( maxBones < bones.length ) {

				console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
				return 0;

			}

			return maxBones;

		}

	}

	function getTextureEncodingFromMap( map ) {

		let encoding;

		if ( map && map.isTexture ) {

			encoding = map.encoding;

		} else if ( map && map.isWebGLRenderTarget ) {

			console.warn( 'THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.' );
			encoding = map.texture.encoding;

		} else {

			encoding = _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"];

		}

		return encoding;

	}

	function getParameters( material, lights, shadows, scene, object ) {

		const fog = scene.fog;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;

		const envMap = cubemaps.get( material.envMap || environment );

		const shaderID = shaderIDs[ material.type ];

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		const maxBones = object.isSkinnedMesh ? getMaxBones( object ) : 0;

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		let vertexShader, fragmentShader;

		if ( shaderID ) {

			const shader = _shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_2__["ShaderLib"][ shaderID ];

			vertexShader = shader.vertexShader;
			fragmentShader = shader.fragmentShader;

		} else {

			vertexShader = material.vertexShader;
			fragmentShader = material.fragmentShader;

		}

		const currentRenderTarget = renderer.getRenderTarget();

		const parameters = {

			isWebGL2: isWebGL2,

			shaderID: shaderID,
			shaderName: material.type,

			vertexShader: vertexShader,
			fragmentShader: fragmentShader,
			defines: material.defines,

			isRawShaderMaterial: material.isRawShaderMaterial === true,
			glslVersion: material.glslVersion,

			precision: precision,

			instancing: object.isInstancedMesh === true,
			instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,

			supportsVertexTextures: vertexTextures,
			outputEncoding: ( currentRenderTarget !== null ) ? getTextureEncodingFromMap( currentRenderTarget.texture ) : renderer.outputEncoding,
			map: !! material.map,
			mapEncoding: getTextureEncodingFromMap( material.map ),
			matcap: !! material.matcap,
			matcapEncoding: getTextureEncodingFromMap( material.matcap ),
			envMap: !! envMap,
			envMapMode: envMap && envMap.mapping,
			envMapEncoding: getTextureEncodingFromMap( envMap ),
			envMapCubeUV: ( !! envMap ) && ( ( envMap.mapping === _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeUVReflectionMapping"] ) || ( envMap.mapping === _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeUVRefractionMapping"] ) ),
			lightMap: !! material.lightMap,
			lightMapEncoding: getTextureEncodingFromMap( material.lightMap ),
			aoMap: !! material.aoMap,
			emissiveMap: !! material.emissiveMap,
			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap ),
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			objectSpaceNormalMap: material.normalMapType === _constants_js__WEBPACK_IMPORTED_MODULE_0__["ObjectSpaceNormalMap"],
			tangentSpaceNormalMap: material.normalMapType === _constants_js__WEBPACK_IMPORTED_MODULE_0__["TangentSpaceNormalMap"],
			clearcoatMap: !! material.clearcoatMap,
			clearcoatRoughnessMap: !! material.clearcoatRoughnessMap,
			clearcoatNormalMap: !! material.clearcoatNormalMap,
			displacementMap: !! material.displacementMap,
			roughnessMap: !! material.roughnessMap,
			metalnessMap: !! material.metalnessMap,
			specularMap: !! material.specularMap,
			alphaMap: !! material.alphaMap,

			gradientMap: !! material.gradientMap,

			sheen: !! material.sheen,

			transmissionMap: !! material.transmissionMap,

			combine: material.combine,

			vertexTangents: ( material.normalMap && material.vertexTangents ),
			vertexColors: material.vertexColors,
			vertexAlphas: material.vertexColors === true && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
			vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.displacementMap || !! material.transmissionMap,
			uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap || !! material.transmissionMap ) && !! material.displacementMap,

			fog: !! fog,
			useFog: material.fog,
			fogExp2: ( fog && fog.isFogExp2 ),

			flatShading: !! material.flatShading,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			skinning: material.skinning && maxBones > 0,
			maxBones: maxBones,
			useVertexTexture: floatVertexTextures,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,

			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numRectAreaLights: lights.rectArea.length,
			numHemiLights: lights.hemi.length,

			numDirLightShadows: lights.directionalShadowMap.length,
			numPointLightShadows: lights.pointShadowMap.length,
			numSpotLightShadows: lights.spotShadowMap.length,

			numClippingPlanes: clipping.numPlanes,
			numClipIntersection: clipping.numIntersection,

			dithering: material.dithering,

			shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,

			toneMapping: material.toneMapped ? renderer.toneMapping : _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoToneMapping"],
			physicallyCorrectLights: renderer.physicallyCorrectLights,

			premultipliedAlpha: material.premultipliedAlpha,

			alphaTest: material.alphaTest,
			doubleSided: material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"],
			flipSided: material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"],

			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,

			index0AttributeName: material.index0AttributeName,

			extensionDerivatives: material.extensions && material.extensions.derivatives,
			extensionFragDepth: material.extensions && material.extensions.fragDepth,
			extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
			extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

			rendererExtensionFragDepth: isWebGL2 || extensions.has( 'EXT_frag_depth' ),
			rendererExtensionDrawBuffers: isWebGL2 || extensions.has( 'WEBGL_draw_buffers' ),
			rendererExtensionShaderTextureLod: isWebGL2 || extensions.has( 'EXT_shader_texture_lod' ),

			customProgramCacheKey: material.customProgramCacheKey()

		};

		return parameters;

	}

	function getProgramCacheKey( parameters ) {

		const array = [];

		if ( parameters.shaderID ) {

			array.push( parameters.shaderID );

		} else {

			array.push( parameters.fragmentShader );
			array.push( parameters.vertexShader );

		}

		if ( parameters.defines !== undefined ) {

			for ( const name in parameters.defines ) {

				array.push( name );
				array.push( parameters.defines[ name ] );

			}

		}

		if ( parameters.isRawShaderMaterial === false ) {

			for ( let i = 0; i < parameterNames.length; i ++ ) {

				array.push( parameters[ parameterNames[ i ] ] );

			}

			array.push( renderer.outputEncoding );
			array.push( renderer.gammaFactor );

		}

		array.push( parameters.customProgramCacheKey );

		return array.join();

	}

	function getUniforms( material ) {

		const shaderID = shaderIDs[ material.type ];
		let uniforms;

		if ( shaderID ) {

			const shader = _shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_2__["ShaderLib"][ shaderID ];
			uniforms = _shaders_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_3__["UniformsUtils"].clone( shader.uniforms );

		} else {

			uniforms = material.uniforms;

		}

		return uniforms;

	}

	function acquireProgram( parameters, cacheKey ) {

		let program;

		// Check if code has been already compiled
		for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

			const preexistingProgram = programs[ p ];

			if ( preexistingProgram.cacheKey === cacheKey ) {

				program = preexistingProgram;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new _WebGLProgram_js__WEBPACK_IMPORTED_MODULE_1__["WebGLProgram"]( renderer, cacheKey, parameters, bindingStates );
			programs.push( program );

		}

		return program;

	}

	function releaseProgram( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			const i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	}

	return {
		getParameters: getParameters,
		getProgramCacheKey: getProgramCacheKey,
		getUniforms: getUniforms,
		acquireProgram: acquireProgram,
		releaseProgram: releaseProgram,
		// Exposed for resource monitoring & error feedback via renderer.info:
		programs: programs
	};

}





/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLProperties.js":
/*!***************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLProperties.js ***!
  \***************************************************************************************/
/*! exports provided: WebGLProperties */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLProperties", function() { return WebGLProperties; });
function WebGLProperties() {

	let properties = new WeakMap();

	function get( object ) {

		let map = properties.get( object );

		if ( map === undefined ) {

			map = {};
			properties.set( object, map );

		}

		return map;

	}

	function remove( object ) {

		properties.delete( object );

	}

	function update( object, key, value ) {

		properties.get( object )[ key ] = value;

	}

	function dispose() {

		properties = new WeakMap();

	}

	return {
		get: get,
		remove: remove,
		update: update,
		dispose: dispose
	};

}





/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLRenderLists.js":
/*!****************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLRenderLists.js ***!
  \****************************************************************************************/
/*! exports provided: WebGLRenderLists, WebGLRenderList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderLists", function() { return WebGLRenderLists; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderList", function() { return WebGLRenderList; });
function painterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.program !== b.program ) {

		return a.program.id - b.program.id;

	} else if ( a.material.id !== b.material.id ) {

		return a.material.id - b.material.id;

	} else if ( a.z !== b.z ) {

		return a.z - b.z;

	} else {

		return a.id - b.id;

	}

}

function reversePainterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.z !== b.z ) {

		return b.z - a.z;

	} else {

		return a.id - b.id;

	}

}


function WebGLRenderList( properties ) {

	const renderItems = [];
	let renderItemsIndex = 0;

	const opaque = [];
	const transparent = [];

	const defaultProgram = { id: - 1 };

	function init() {

		renderItemsIndex = 0;

		opaque.length = 0;
		transparent.length = 0;

	}

	function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

		let renderItem = renderItems[ renderItemsIndex ];
		const materialProperties = properties.get( material );

		if ( renderItem === undefined ) {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				program: materialProperties.program || defaultProgram,
				groupOrder: groupOrder,
				renderOrder: object.renderOrder,
				z: z,
				group: group
			};

			renderItems[ renderItemsIndex ] = renderItem;

		} else {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.program = materialProperties.program || defaultProgram;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;

		}

		renderItemsIndex ++;

		return renderItem;

	}

	function push( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		( material.transparent === true ? transparent : opaque ).push( renderItem );

	}

	function unshift( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		( material.transparent === true ? transparent : opaque ).unshift( renderItem );

	}

	function sort( customOpaqueSort, customTransparentSort ) {

		if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
		if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

	}

	function finish() {

		// Clear references from inactive renderItems in the list

		for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

			const renderItem = renderItems[ i ];

			if ( renderItem.id === null ) break;

			renderItem.id = null;
			renderItem.object = null;
			renderItem.geometry = null;
			renderItem.material = null;
			renderItem.program = null;
			renderItem.group = null;

		}

	}

	return {

		opaque: opaque,
		transparent: transparent,

		init: init,
		push: push,
		unshift: unshift,
		finish: finish,

		sort: sort
	};

}

function WebGLRenderLists( properties ) {

	let lists = new WeakMap();

	function get( scene, renderCallDepth ) {

		let list;

		if ( lists.has( scene ) === false ) {

			list = new WebGLRenderList( properties );
			lists.set( scene, [ list ] );

		} else {

			if ( renderCallDepth >= lists.get( scene ).length ) {

				list = new WebGLRenderList( properties );
				lists.get( scene ).push( list );

			} else {

				list = lists.get( scene )[ renderCallDepth ];

			}

		}

		return list;

	}

	function dispose() {

		lists = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}





/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLRenderStates.js":
/*!*****************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLRenderStates.js ***!
  \*****************************************************************************************/
/*! exports provided: WebGLRenderStates */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderStates", function() { return WebGLRenderStates; });
/* harmony import */ var _WebGLLights_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGLLights.js */ "../../node_modules/three/src/renderers/webgl/WebGLLights.js");


function WebGLRenderState( extensions, capabilities ) {

	const lights = new _WebGLLights_js__WEBPACK_IMPORTED_MODULE_0__["WebGLLights"]( extensions, capabilities );

	const lightsArray = [];
	const shadowsArray = [];

	function init() {

		lightsArray.length = 0;
		shadowsArray.length = 0;

	}

	function pushLight( light ) {

		lightsArray.push( light );

	}

	function pushShadow( shadowLight ) {

		shadowsArray.push( shadowLight );

	}

	function setupLights() {

		lights.setup( lightsArray );

	}

	function setupLightsView( camera ) {

		lights.setupView( lightsArray, camera );

	}

	const state = {
		lightsArray: lightsArray,
		shadowsArray: shadowsArray,

		lights: lights
	};

	return {
		init: init,
		state: state,
		setupLights: setupLights,
		setupLightsView: setupLightsView,

		pushLight: pushLight,
		pushShadow: pushShadow
	};

}

function WebGLRenderStates( extensions, capabilities ) {

	let renderStates = new WeakMap();

	function get( scene, renderCallDepth = 0 ) {

		let renderState;

		if ( renderStates.has( scene ) === false ) {

			renderState = new WebGLRenderState( extensions, capabilities );
			renderStates.set( scene, [ renderState ] );

		} else {

			if ( renderCallDepth >= renderStates.get( scene ).length ) {

				renderState = new WebGLRenderState( extensions, capabilities );
				renderStates.get( scene ).push( renderState );

			} else {

				renderState = renderStates.get( scene )[ renderCallDepth ];

			}

		}

		return renderState;

	}

	function dispose() {

		renderStates = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}





/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLShader.js":
/*!***********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLShader.js ***!
  \***********************************************************************************/
/*! exports provided: WebGLShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLShader", function() { return WebGLShader; });
function WebGLShader( gl, type, string ) {

	const shader = gl.createShader( type );

	gl.shaderSource( shader, string );
	gl.compileShader( shader );

	return shader;

}




/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLShadowMap.js":
/*!**************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLShadowMap.js ***!
  \**************************************************************************************/
/*! exports provided: WebGLShadowMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLShadowMap", function() { return WebGLShadowMap; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../WebGLRenderTarget.js */ "../../node_modules/three/src/renderers/WebGLRenderTarget.js");
/* harmony import */ var _materials_MeshDepthMaterial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../materials/MeshDepthMaterial.js */ "../../node_modules/three/src/materials/MeshDepthMaterial.js");
/* harmony import */ var _materials_MeshDistanceMaterial_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../materials/MeshDistanceMaterial.js */ "../../node_modules/three/src/materials/MeshDistanceMaterial.js");
/* harmony import */ var _materials_ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../materials/ShaderMaterial.js */ "../../node_modules/three/src/materials/ShaderMaterial.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/BufferAttribute.js */ "../../node_modules/three/src/core/BufferAttribute.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/BufferGeometry.js */ "../../node_modules/three/src/core/BufferGeometry.js");
/* harmony import */ var _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../objects/Mesh.js */ "../../node_modules/three/src/objects/Mesh.js");
/* harmony import */ var _math_Vector4_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../math/Vector4.js */ "../../node_modules/three/src/math/Vector4.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Frustum_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../math/Frustum.js */ "../../node_modules/three/src/math/Frustum.js");
/* harmony import */ var _shaders_ShaderLib_vsm_frag_glsl_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../shaders/ShaderLib/vsm_frag.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/vsm_frag.glsl.js");
/* harmony import */ var _shaders_ShaderLib_vsm_vert_glsl_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../shaders/ShaderLib/vsm_vert.glsl.js */ "../../node_modules/three/src/renderers/shaders/ShaderLib/vsm_vert.glsl.js");















function WebGLShadowMap( _renderer, _objects, _capabilities ) {

	let _frustum = new _math_Frustum_js__WEBPACK_IMPORTED_MODULE_10__["Frustum"]();

	const _shadowMapSize = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_9__["Vector2"](),
		_viewportSize = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_9__["Vector2"](),

		_viewport = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_8__["Vector4"](),

		_depthMaterials = [],
		_distanceMaterials = [],

		_materialCache = {},

		_maxTextureSize = _capabilities.maxTextureSize;

	const shadowSide = { 0: _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"], 1: _constants_js__WEBPACK_IMPORTED_MODULE_0__["FrontSide"], 2: _constants_js__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"] };

	const shadowMaterialVertical = new _materials_ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_4__["ShaderMaterial"]( {

		defines: {
			SAMPLE_RATE: 2.0 / 8.0,
			HALF_SAMPLE_RATE: 1.0 / 8.0
		},

		uniforms: {
			shadow_pass: { value: null },
			resolution: { value: new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_9__["Vector2"]() },
			radius: { value: 4.0 }
		},

		vertexShader: _shaders_ShaderLib_vsm_vert_glsl_js__WEBPACK_IMPORTED_MODULE_12__["default"],

		fragmentShader: _shaders_ShaderLib_vsm_frag_glsl_js__WEBPACK_IMPORTED_MODULE_11__["default"]

	} );

	const shadowMaterialHorizontal = shadowMaterialVertical.clone();
	shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

	const fullScreenTri = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_6__["BufferGeometry"]();
	fullScreenTri.setAttribute(
		'position',
		new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_5__["BufferAttribute"](
			new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
			3
		)
	);

	const fullScreenMesh = new _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_7__["Mesh"]( fullScreenTri, shadowMaterialVertical );

	const scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = _constants_js__WEBPACK_IMPORTED_MODULE_0__["PCFShadowMap"];

	this.render = function ( lights, scene, camera ) {

		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		if ( lights.length === 0 ) return;

		const currentRenderTarget = _renderer.getRenderTarget();
		const activeCubeFace = _renderer.getActiveCubeFace();
		const activeMipmapLevel = _renderer.getActiveMipmapLevel();

		const _state = _renderer.state;

		// Set GL state for depth map.
		_state.setBlending( _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoBlending"] );
		_state.buffers.color.setClear( 1, 1, 1, 1 );
		_state.buffers.depth.setTest( true );
		_state.setScissorTest( false );

		// render depth map

		for ( let i = 0, il = lights.length; i < il; i ++ ) {

			const light = lights[ i ];
			const shadow = light.shadow;

			if ( shadow === undefined ) {

				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
				continue;

			}

			if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

			_shadowMapSize.copy( shadow.mapSize );

			const shadowFrameExtents = shadow.getFrameExtents();

			_shadowMapSize.multiply( shadowFrameExtents );

			_viewportSize.copy( shadow.mapSize );

			if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {

				if ( _shadowMapSize.x > _maxTextureSize ) {

					_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
					_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
					shadow.mapSize.x = _viewportSize.x;

				}

				if ( _shadowMapSize.y > _maxTextureSize ) {

					_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
					_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
					shadow.mapSize.y = _viewportSize.y;

				}

			}

			if ( shadow.map === null && ! shadow.isPointLightShadow && this.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["VSMShadowMap"] ) {

				const pars = { minFilter: _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"], magFilter: _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"], format: _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"] };

				shadow.map = new _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_1__["WebGLRenderTarget"]( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + '.shadowMap';

				shadow.mapPass = new _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_1__["WebGLRenderTarget"]( _shadowMapSize.x, _shadowMapSize.y, pars );

				shadow.camera.updateProjectionMatrix();

			}

			if ( shadow.map === null ) {

				const pars = { minFilter: _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"], magFilter: _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"], format: _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"] };

				shadow.map = new _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_1__["WebGLRenderTarget"]( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + '.shadowMap';

				shadow.camera.updateProjectionMatrix();

			}

			_renderer.setRenderTarget( shadow.map );
			_renderer.clear();

			const viewportCount = shadow.getViewportCount();

			for ( let vp = 0; vp < viewportCount; vp ++ ) {

				const viewport = shadow.getViewport( vp );

				_viewport.set(
					_viewportSize.x * viewport.x,
					_viewportSize.y * viewport.y,
					_viewportSize.x * viewport.z,
					_viewportSize.y * viewport.w
				);

				_state.viewport( _viewport );

				shadow.updateMatrices( light, vp );

				_frustum = shadow.getFrustum();

				renderObject( scene, camera, shadow.camera, light, this.type );

			}

			// do blur pass for VSM

			if ( ! shadow.isPointLightShadow && this.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["VSMShadowMap"] ) {

				VSMPass( shadow, camera );

			}

			shadow.needsUpdate = false;

		}

		scope.needsUpdate = false;

		_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

	};

	function VSMPass( shadow, camera ) {

		const geometry = _objects.update( fullScreenMesh );

		// vertical pass

		shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
		shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialVertical.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget( shadow.mapPass );
		_renderer.clear();
		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

		// horizontal pass

		shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
		shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget( shadow.map );
		_renderer.clear();
		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

	}

	function getDepthMaterialVariant( useMorphing, useSkinning, useInstancing ) {

		const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

		let material = _depthMaterials[ index ];

		if ( material === undefined ) {

			material = new _materials_MeshDepthMaterial_js__WEBPACK_IMPORTED_MODULE_2__["MeshDepthMaterial"]( {

				depthPacking: _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBADepthPacking"],

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_depthMaterials[ index ] = material;

		}

		return material;

	}

	function getDistanceMaterialVariant( useMorphing, useSkinning, useInstancing ) {

		const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

		let material = _distanceMaterials[ index ];

		if ( material === undefined ) {

			material = new _materials_MeshDistanceMaterial_js__WEBPACK_IMPORTED_MODULE_3__["MeshDistanceMaterial"]( {

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_distanceMaterials[ index ] = material;

		}

		return material;

	}

	function getDepthMaterial( object, geometry, material, light, shadowCameraNear, shadowCameraFar, type ) {

		let result = null;

		let getMaterialVariant = getDepthMaterialVariant;
		let customMaterial = object.customDepthMaterial;

		if ( light.isPointLight === true ) {

			getMaterialVariant = getDistanceMaterialVariant;
			customMaterial = object.customDistanceMaterial;

		}

		if ( customMaterial === undefined ) {

			let useMorphing = false;

			if ( material.morphTargets === true ) {

				useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

			}

			let useSkinning = false;

			if ( object.isSkinnedMesh === true ) {

				if ( material.skinning === true ) {

					useSkinning = true;

				} else {

					console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

				}

			}

			const useInstancing = object.isInstancedMesh === true;

			result = getMaterialVariant( useMorphing, useSkinning, useInstancing );

		} else {

			result = customMaterial;

		}

		if ( _renderer.localClippingEnabled &&
				material.clipShadows === true &&
				material.clippingPlanes.length !== 0 ) {

			// in this case we need a unique material instance reflecting the
			// appropriate state

			const keyA = result.uuid, keyB = material.uuid;

			let materialsForVariant = _materialCache[ keyA ];

			if ( materialsForVariant === undefined ) {

				materialsForVariant = {};
				_materialCache[ keyA ] = materialsForVariant;

			}

			let cachedMaterial = materialsForVariant[ keyB ];

			if ( cachedMaterial === undefined ) {

				cachedMaterial = result.clone();
				materialsForVariant[ keyB ] = cachedMaterial;

			}

			result = cachedMaterial;

		}

		result.visible = material.visible;
		result.wireframe = material.wireframe;

		if ( type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["VSMShadowMap"] ) {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

		} else {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

		}

		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;
		result.clipIntersection = material.clipIntersection;

		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;

		if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

			result.referencePosition.setFromMatrixPosition( light.matrixWorld );
			result.nearDistance = shadowCameraNear;
			result.farDistance = shadowCameraFar;

		}

		return result;

	}

	function renderObject( object, camera, shadowCamera, light, type ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

			if ( ( object.castShadow || ( object.receiveShadow && type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["VSMShadowMap"] ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

				const geometry = _objects.update( object );
				const material = object.material;

				if ( Array.isArray( material ) ) {

					const groups = geometry.groups;

					for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

						const group = groups[ k ];
						const groupMaterial = material[ group.materialIndex ];

						if ( groupMaterial && groupMaterial.visible ) {

							const depthMaterial = getDepthMaterial( object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );

							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

						}

					}

				} else if ( material.visible ) {

					const depthMaterial = getDepthMaterial( object, geometry, material, light, shadowCamera.near, shadowCamera.far, type );

					_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

				}

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			renderObject( children[ i ], camera, shadowCamera, light, type );

		}

	}

}





/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLState.js":
/*!**********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLState.js ***!
  \**********************************************************************************/
/*! exports provided: WebGLState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLState", function() { return WebGLState; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _math_Vector4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/Vector4.js */ "../../node_modules/three/src/math/Vector4.js");



function WebGLState( gl, extensions, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	function ColorBuffer() {

		let locked = false;

		const color = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_1__["Vector4"]();
		let currentColorMask = null;
		const currentColorClear = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_1__["Vector4"]( 0, 0, 0, 0 );

		return {

			setMask: function ( colorMask ) {

				if ( currentColorMask !== colorMask && ! locked ) {

					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
					currentColorMask = colorMask;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( r, g, b, a, premultipliedAlpha ) {

				if ( premultipliedAlpha === true ) {

					r *= a; g *= a; b *= a;

				}

				color.set( r, g, b, a );

				if ( currentColorClear.equals( color ) === false ) {

					gl.clearColor( r, g, b, a );
					currentColorClear.copy( color );

				}

			},

			reset: function () {

				locked = false;

				currentColorMask = null;
				currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

			}

		};

	}

	function DepthBuffer() {

		let locked = false;

		let currentDepthMask = null;
		let currentDepthFunc = null;
		let currentDepthClear = null;

		return {

			setTest: function ( depthTest ) {

				if ( depthTest ) {

					enable( gl.DEPTH_TEST );

				} else {

					disable( gl.DEPTH_TEST );

				}

			},

			setMask: function ( depthMask ) {

				if ( currentDepthMask !== depthMask && ! locked ) {

					gl.depthMask( depthMask );
					currentDepthMask = depthMask;

				}

			},

			setFunc: function ( depthFunc ) {

				if ( currentDepthFunc !== depthFunc ) {

					if ( depthFunc ) {

						switch ( depthFunc ) {

							case _constants_js__WEBPACK_IMPORTED_MODULE_0__["NeverDepth"]:

								gl.depthFunc( gl.NEVER );
								break;

							case _constants_js__WEBPACK_IMPORTED_MODULE_0__["AlwaysDepth"]:

								gl.depthFunc( gl.ALWAYS );
								break;

							case _constants_js__WEBPACK_IMPORTED_MODULE_0__["LessDepth"]:

								gl.depthFunc( gl.LESS );
								break;

							case _constants_js__WEBPACK_IMPORTED_MODULE_0__["LessEqualDepth"]:

								gl.depthFunc( gl.LEQUAL );
								break;

							case _constants_js__WEBPACK_IMPORTED_MODULE_0__["EqualDepth"]:

								gl.depthFunc( gl.EQUAL );
								break;

							case _constants_js__WEBPACK_IMPORTED_MODULE_0__["GreaterEqualDepth"]:

								gl.depthFunc( gl.GEQUAL );
								break;

							case _constants_js__WEBPACK_IMPORTED_MODULE_0__["GreaterDepth"]:

								gl.depthFunc( gl.GREATER );
								break;

							case _constants_js__WEBPACK_IMPORTED_MODULE_0__["NotEqualDepth"]:

								gl.depthFunc( gl.NOTEQUAL );
								break;

							default:

								gl.depthFunc( gl.LEQUAL );

						}

					} else {

						gl.depthFunc( gl.LEQUAL );

					}

					currentDepthFunc = depthFunc;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( depth ) {

				if ( currentDepthClear !== depth ) {

					gl.clearDepth( depth );
					currentDepthClear = depth;

				}

			},

			reset: function () {

				locked = false;

				currentDepthMask = null;
				currentDepthFunc = null;
				currentDepthClear = null;

			}

		};

	}

	function StencilBuffer() {

		let locked = false;

		let currentStencilMask = null;
		let currentStencilFunc = null;
		let currentStencilRef = null;
		let currentStencilFuncMask = null;
		let currentStencilFail = null;
		let currentStencilZFail = null;
		let currentStencilZPass = null;
		let currentStencilClear = null;

		return {

			setTest: function ( stencilTest ) {

				if ( ! locked ) {

					if ( stencilTest ) {

						enable( gl.STENCIL_TEST );

					} else {

						disable( gl.STENCIL_TEST );

					}

				}

			},

			setMask: function ( stencilMask ) {

				if ( currentStencilMask !== stencilMask && ! locked ) {

					gl.stencilMask( stencilMask );
					currentStencilMask = stencilMask;

				}

			},

			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

				if ( currentStencilFunc !== stencilFunc ||
				     currentStencilRef !== stencilRef ||
				     currentStencilFuncMask !== stencilMask ) {

					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

					currentStencilFunc = stencilFunc;
					currentStencilRef = stencilRef;
					currentStencilFuncMask = stencilMask;

				}

			},

			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

				if ( currentStencilFail !== stencilFail ||
				     currentStencilZFail !== stencilZFail ||
				     currentStencilZPass !== stencilZPass ) {

					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

					currentStencilFail = stencilFail;
					currentStencilZFail = stencilZFail;
					currentStencilZPass = stencilZPass;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( stencil ) {

				if ( currentStencilClear !== stencil ) {

					gl.clearStencil( stencil );
					currentStencilClear = stencil;

				}

			},

			reset: function () {

				locked = false;

				currentStencilMask = null;
				currentStencilFunc = null;
				currentStencilRef = null;
				currentStencilFuncMask = null;
				currentStencilFail = null;
				currentStencilZFail = null;
				currentStencilZPass = null;
				currentStencilClear = null;

			}

		};

	}

	//

	const colorBuffer = new ColorBuffer();
	const depthBuffer = new DepthBuffer();
	const stencilBuffer = new StencilBuffer();

	let enabledCapabilities = {};

	let xrFramebuffer = null;
	let currentBoundFramebuffers = {};

	let currentProgram = null;

	let currentBlendingEnabled = false;
	let currentBlending = null;
	let currentBlendEquation = null;
	let currentBlendSrc = null;
	let currentBlendDst = null;
	let currentBlendEquationAlpha = null;
	let currentBlendSrcAlpha = null;
	let currentBlendDstAlpha = null;
	let currentPremultipledAlpha = false;

	let currentFlipSided = null;
	let currentCullFace = null;

	let currentLineWidth = null;

	let currentPolygonOffsetFactor = null;
	let currentPolygonOffsetUnits = null;

	const maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );

	let lineWidthAvailable = false;
	let version = 0;
	const glVersion = gl.getParameter( gl.VERSION );

	if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

		version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 1.0 );

	} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

		version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 2.0 );

	}

	let currentTextureSlot = null;
	let currentBoundTextures = {};

	const currentScissor = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_1__["Vector4"]( 0, 0, gl.canvas.width, gl.canvas.height );
	const currentViewport = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_1__["Vector4"]( 0, 0, gl.canvas.width, gl.canvas.height );

	function createTexture( type, target, count ) {

		const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
		const texture = gl.createTexture();

		gl.bindTexture( type, texture );
		gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
		gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

		for ( let i = 0; i < count; i ++ ) {

			gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

		}

		return texture;

	}

	const emptyTextures = {};
	emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
	emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

	// init

	colorBuffer.setClear( 0, 0, 0, 1 );
	depthBuffer.setClear( 1 );
	stencilBuffer.setClear( 0 );

	enable( gl.DEPTH_TEST );
	depthBuffer.setFunc( _constants_js__WEBPACK_IMPORTED_MODULE_0__["LessEqualDepth"] );

	setFlipSided( false );
	setCullFace( _constants_js__WEBPACK_IMPORTED_MODULE_0__["CullFaceBack"] );
	enable( gl.CULL_FACE );

	setBlending( _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoBlending"] );

	//

	function enable( id ) {

		if ( enabledCapabilities[ id ] !== true ) {

			gl.enable( id );
			enabledCapabilities[ id ] = true;

		}

	}

	function disable( id ) {

		if ( enabledCapabilities[ id ] !== false ) {

			gl.disable( id );
			enabledCapabilities[ id ] = false;

		}

	}

	function bindXRFramebuffer( framebuffer ) {

		if ( framebuffer !== xrFramebuffer ) {

			gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );

			xrFramebuffer = framebuffer;

		}

	}

	function bindFramebuffer( target, framebuffer ) {

		if ( framebuffer === null && xrFramebuffer !== null ) framebuffer = xrFramebuffer; // use active XR framebuffer if available

		if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

			gl.bindFramebuffer( target, framebuffer );

			currentBoundFramebuffers[ target ] = framebuffer;

		}

	}

	function useProgram( program ) {

		if ( currentProgram !== program ) {

			gl.useProgram( program );

			currentProgram = program;

			return true;

		}

		return false;

	}

	const equationToGL = {
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["AddEquation"] ]: gl.FUNC_ADD,
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["SubtractEquation"] ]: gl.FUNC_SUBTRACT,
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["ReverseSubtractEquation"] ]: gl.FUNC_REVERSE_SUBTRACT
	};

	if ( isWebGL2 ) {

		equationToGL[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["MinEquation"] ] = gl.MIN;
		equationToGL[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["MaxEquation"] ] = gl.MAX;

	} else {

		const extension = extensions.get( 'EXT_blend_minmax' );

		if ( extension !== null ) {

			equationToGL[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["MinEquation"] ] = extension.MIN_EXT;
			equationToGL[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["MaxEquation"] ] = extension.MAX_EXT;

		}

	}

	const factorToGL = {
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroFactor"] ]: gl.ZERO,
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["OneFactor"] ]: gl.ONE,
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["SrcColorFactor"] ]: gl.SRC_COLOR,
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["SrcAlphaFactor"] ]: gl.SRC_ALPHA,
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["SrcAlphaSaturateFactor"] ]: gl.SRC_ALPHA_SATURATE,
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["DstColorFactor"] ]: gl.DST_COLOR,
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["DstAlphaFactor"] ]: gl.DST_ALPHA,
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["OneMinusSrcColorFactor"] ]: gl.ONE_MINUS_SRC_COLOR,
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["OneMinusSrcAlphaFactor"] ]: gl.ONE_MINUS_SRC_ALPHA,
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["OneMinusDstColorFactor"] ]: gl.ONE_MINUS_DST_COLOR,
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["OneMinusDstAlphaFactor"] ]: gl.ONE_MINUS_DST_ALPHA
	};

	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

		if ( blending === _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoBlending"] ) {

			if ( currentBlendingEnabled === true ) {

				disable( gl.BLEND );
				currentBlendingEnabled = false;

			}

			return;

		}

		if ( currentBlendingEnabled === false ) {

			enable( gl.BLEND );
			currentBlendingEnabled = true;

		}

		if ( blending !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["CustomBlending"] ) {

			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

				if ( currentBlendEquation !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["AddEquation"] || currentBlendEquationAlpha !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["AddEquation"] ) {

					gl.blendEquation( gl.FUNC_ADD );

					currentBlendEquation = _constants_js__WEBPACK_IMPORTED_MODULE_0__["AddEquation"];
					currentBlendEquationAlpha = _constants_js__WEBPACK_IMPORTED_MODULE_0__["AddEquation"];

				}

				if ( premultipliedAlpha ) {

					switch ( blending ) {

						case _constants_js__WEBPACK_IMPORTED_MODULE_0__["NormalBlending"]:
							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
							break;

						case _constants_js__WEBPACK_IMPORTED_MODULE_0__["AdditiveBlending"]:
							gl.blendFunc( gl.ONE, gl.ONE );
							break;

						case _constants_js__WEBPACK_IMPORTED_MODULE_0__["SubtractiveBlending"]:
							gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );
							break;

						case _constants_js__WEBPACK_IMPORTED_MODULE_0__["MultiplyBlending"]:
							gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				} else {

					switch ( blending ) {

						case _constants_js__WEBPACK_IMPORTED_MODULE_0__["NormalBlending"]:
							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
							break;

						case _constants_js__WEBPACK_IMPORTED_MODULE_0__["AdditiveBlending"]:
							gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
							break;

						case _constants_js__WEBPACK_IMPORTED_MODULE_0__["SubtractiveBlending"]:
							gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );
							break;

						case _constants_js__WEBPACK_IMPORTED_MODULE_0__["MultiplyBlending"]:
							gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				}

				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;

				currentBlending = blending;
				currentPremultipledAlpha = premultipliedAlpha;

			}

			return;

		}

		// custom blending

		blendEquationAlpha = blendEquationAlpha || blendEquation;
		blendSrcAlpha = blendSrcAlpha || blendSrc;
		blendDstAlpha = blendDstAlpha || blendDst;

		if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

			currentBlendEquation = blendEquation;
			currentBlendEquationAlpha = blendEquationAlpha;

		}

		if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

			currentBlendSrc = blendSrc;
			currentBlendDst = blendDst;
			currentBlendSrcAlpha = blendSrcAlpha;
			currentBlendDstAlpha = blendDstAlpha;

		}

		currentBlending = blending;
		currentPremultipledAlpha = null;

	}

	function setMaterial( material, frontFaceCW ) {

		material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"]
			? disable( gl.CULL_FACE )
			: enable( gl.CULL_FACE );

		let flipSided = ( material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"] );
		if ( frontFaceCW ) flipSided = ! flipSided;

		setFlipSided( flipSided );

		( material.blending === _constants_js__WEBPACK_IMPORTED_MODULE_0__["NormalBlending"] && material.transparent === false )
			? setBlending( _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoBlending"] )
			: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

		depthBuffer.setFunc( material.depthFunc );
		depthBuffer.setTest( material.depthTest );
		depthBuffer.setMask( material.depthWrite );
		colorBuffer.setMask( material.colorWrite );

		const stencilWrite = material.stencilWrite;
		stencilBuffer.setTest( stencilWrite );
		if ( stencilWrite ) {

			stencilBuffer.setMask( material.stencilWriteMask );
			stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
			stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

		}

		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		material.alphaToCoverage === true
			? enable( gl.SAMPLE_ALPHA_TO_COVERAGE )
			: disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

	}

	//

	function setFlipSided( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( gl.CW );

			} else {

				gl.frontFace( gl.CCW );

			}

			currentFlipSided = flipSided;

		}

	}

	function setCullFace( cullFace ) {

		if ( cullFace !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["CullFaceNone"] ) {

			enable( gl.CULL_FACE );

			if ( cullFace !== currentCullFace ) {

				if ( cullFace === _constants_js__WEBPACK_IMPORTED_MODULE_0__["CullFaceBack"] ) {

					gl.cullFace( gl.BACK );

				} else if ( cullFace === _constants_js__WEBPACK_IMPORTED_MODULE_0__["CullFaceFront"] ) {

					gl.cullFace( gl.FRONT );

				} else {

					gl.cullFace( gl.FRONT_AND_BACK );

				}

			}

		} else {

			disable( gl.CULL_FACE );

		}

		currentCullFace = cullFace;

	}

	function setLineWidth( width ) {

		if ( width !== currentLineWidth ) {

			if ( lineWidthAvailable ) gl.lineWidth( width );

			currentLineWidth = width;

		}

	}

	function setPolygonOffset( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			enable( gl.POLYGON_OFFSET_FILL );

			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		} else {

			disable( gl.POLYGON_OFFSET_FILL );

		}

	}

	function setScissorTest( scissorTest ) {

		if ( scissorTest ) {

			enable( gl.SCISSOR_TEST );

		} else {

			disable( gl.SCISSOR_TEST );

		}

	}

	// texture

	function activeTexture( webglSlot ) {

		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	}

	function bindTexture( webglType, webglTexture ) {

		if ( currentTextureSlot === null ) {

			activeTexture();

		}

		let boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ currentTextureSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	}

	function unbindTexture() {

		const boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

			gl.bindTexture( boundTexture.type, null );

			boundTexture.type = undefined;
			boundTexture.texture = undefined;

		}

	}

	function compressedTexImage2D() {

		try {

			gl.compressedTexImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage2D() {

		try {

			gl.texImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage3D() {

		try {

			gl.texImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	//

	function scissor( scissor ) {

		if ( currentScissor.equals( scissor ) === false ) {

			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			currentScissor.copy( scissor );

		}

	}

	function viewport( viewport ) {

		if ( currentViewport.equals( viewport ) === false ) {

			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			currentViewport.copy( viewport );

		}

	}

	//

	function reset() {

		// reset state

		gl.disable( gl.BLEND );
		gl.disable( gl.CULL_FACE );
		gl.disable( gl.DEPTH_TEST );
		gl.disable( gl.POLYGON_OFFSET_FILL );
		gl.disable( gl.SCISSOR_TEST );
		gl.disable( gl.STENCIL_TEST );
		gl.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

		gl.blendEquation( gl.FUNC_ADD );
		gl.blendFunc( gl.ONE, gl.ZERO );
		gl.blendFuncSeparate( gl.ONE, gl.ZERO, gl.ONE, gl.ZERO );

		gl.colorMask( true, true, true, true );
		gl.clearColor( 0, 0, 0, 0 );

		gl.depthMask( true );
		gl.depthFunc( gl.LESS );
		gl.clearDepth( 1 );

		gl.stencilMask( 0xffffffff );
		gl.stencilFunc( gl.ALWAYS, 0, 0xffffffff );
		gl.stencilOp( gl.KEEP, gl.KEEP, gl.KEEP );
		gl.clearStencil( 0 );

		gl.cullFace( gl.BACK );
		gl.frontFace( gl.CCW );

		gl.polygonOffset( 0, 0 );

		gl.activeTexture( gl.TEXTURE0 );

		gl.bindFramebuffer( gl.FRAMEBUFFER, null );

		if ( isWebGL2 === true ) {

			gl.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );
			gl.bindFramebuffer( gl.READ_FRAMEBUFFER, null );

		}

		gl.useProgram( null );

		gl.lineWidth( 1 );

		gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
		gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

		// reset internals

		enabledCapabilities = {};

		currentTextureSlot = null;
		currentBoundTextures = {};

		xrFramebuffer = null;
		currentBoundFramebuffers = {};

		currentProgram = null;

		currentBlendingEnabled = false;
		currentBlending = null;
		currentBlendEquation = null;
		currentBlendSrc = null;
		currentBlendDst = null;
		currentBlendEquationAlpha = null;
		currentBlendSrcAlpha = null;
		currentBlendDstAlpha = null;
		currentPremultipledAlpha = false;

		currentFlipSided = null;
		currentCullFace = null;

		currentLineWidth = null;

		currentPolygonOffsetFactor = null;
		currentPolygonOffsetUnits = null;

		currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
		currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );

		colorBuffer.reset();
		depthBuffer.reset();
		stencilBuffer.reset();

	}

	return {

		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},

		enable: enable,
		disable: disable,

		bindFramebuffer: bindFramebuffer,
		bindXRFramebuffer: bindXRFramebuffer,

		useProgram: useProgram,

		setBlending: setBlending,
		setMaterial: setMaterial,

		setFlipSided: setFlipSided,
		setCullFace: setCullFace,

		setLineWidth: setLineWidth,
		setPolygonOffset: setPolygonOffset,

		setScissorTest: setScissorTest,

		activeTexture: activeTexture,
		bindTexture: bindTexture,
		unbindTexture: unbindTexture,
		compressedTexImage2D: compressedTexImage2D,
		texImage2D: texImage2D,
		texImage3D: texImage3D,

		scissor: scissor,
		viewport: viewport,

		reset: reset

	};

}




/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLTextures.js":
/*!*************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLTextures.js ***!
  \*************************************************************************************/
/*! exports provided: WebGLTextures */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLTextures", function() { return WebGLTextures; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");



function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

	const isWebGL2 = capabilities.isWebGL2;
	const maxTextures = capabilities.maxTextures;
	const maxCubemapSize = capabilities.maxCubemapSize;
	const maxTextureSize = capabilities.maxTextureSize;
	const maxSamples = capabilities.maxSamples;

	const _videoTextures = new WeakMap();
	let _canvas;

	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
	// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

	let useOffscreenCanvas = false;

	try {

		useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
			&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

	} catch ( err ) {

		// Ignore any errors

	}

	function createCanvas( width, height ) {

		// Use OffscreenCanvas when available. Specially needed in web workers

		return useOffscreenCanvas ?
			new OffscreenCanvas( width, height ) :
			document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

	}

	function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

		let scale = 1;

		// handle case if texture exceeds max size

		if ( image.width > maxSize || image.height > maxSize ) {

			scale = maxSize / Math.max( image.width, image.height );

		}

		// only perform resize if necessary

		if ( scale < 1 || needsPowerOfTwo === true ) {

			// only perform resize for certain image types

			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

				const floor = needsPowerOfTwo ? _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__["MathUtils"].floorPowerOfTwo : Math.floor;

				const width = floor( scale * image.width );
				const height = floor( scale * image.height );

				if ( _canvas === undefined ) _canvas = createCanvas( width, height );

				// cube textures can't reuse the same canvas

				const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

				canvas.width = width;
				canvas.height = height;

				const context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, width, height );

				console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

				return canvas;

			} else {

				if ( 'data' in image ) {

					console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

				}

				return image;

			}

		}

		return image;

	}

	function isPowerOfTwo( image ) {

		return _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__["MathUtils"].isPowerOfTwo( image.width ) && _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__["MathUtils"].isPowerOfTwo( image.height );

	}

	function textureNeedsPowerOfTwo( texture ) {

		if ( isWebGL2 ) return false;

		return ( texture.wrapS !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["ClampToEdgeWrapping"] || texture.wrapT !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["ClampToEdgeWrapping"] ) ||
			( texture.minFilter !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"] && texture.minFilter !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"] );

	}

	function textureNeedsGenerateMipmaps( texture, supportsMips ) {

		return texture.generateMipmaps && supportsMips &&
			texture.minFilter !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"] && texture.minFilter !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"];

	}

	function generateMipmap( target, texture, width, height ) {

		_gl.generateMipmap( target );

		const textureProperties = properties.get( texture );

		textureProperties.__maxMipLevel = Math.log2( Math.max( width, height ) );

	}

	function getInternalFormat( internalFormatName, glFormat, glType ) {

		if ( isWebGL2 === false ) return glFormat;

		if ( internalFormatName !== null ) {

			if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

			console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

		}

		let internalFormat = glFormat;

		if ( glFormat === _gl.RED ) {

			if ( glType === _gl.FLOAT ) internalFormat = _gl.R32F;
			if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.R16F;
			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8;

		}

		if ( glFormat === _gl.RGB ) {

			if ( glType === _gl.FLOAT ) internalFormat = _gl.RGB32F;
			if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RGB16F;
			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RGB8;

		}

		if ( glFormat === _gl.RGBA ) {

			if ( glType === _gl.FLOAT ) internalFormat = _gl.RGBA32F;
			if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RGBA16F;
			if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RGBA8;

		}

		if ( internalFormat === _gl.R16F || internalFormat === _gl.R32F ||
			internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F ) {

			extensions.get( 'EXT_color_buffer_float' );

		}

		return internalFormat;

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback( f ) {

		if ( f === _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"] || f === _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestMipmapNearestFilter"] || f === _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestMipmapLinearFilter"] ) {

			return _gl.NEAREST;

		}

		return _gl.LINEAR;

	}

	//

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		if ( texture.isVideoTexture ) {

			_videoTextures.delete( texture );

		}

		info.memory.textures --;

	}

	function onRenderTargetDispose( event ) {

		const renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		info.memory.textures --;

	}

	//

	function deallocateTexture( texture ) {

		const textureProperties = properties.get( texture );

		if ( textureProperties.__webglInit === undefined ) return;

		_gl.deleteTexture( textureProperties.__webglTexture );

		properties.remove( texture );

	}

	function deallocateRenderTarget( renderTarget ) {

		const texture = renderTarget.texture;

		const renderTargetProperties = properties.get( renderTarget );
		const textureProperties = properties.get( texture );

		if ( ! renderTarget ) return;

		if ( textureProperties.__webglTexture !== undefined ) {

			_gl.deleteTexture( textureProperties.__webglTexture );

		}

		if ( renderTarget.depthTexture ) {

			renderTarget.depthTexture.dispose();

		}

		if ( renderTarget.isWebGLCubeRenderTarget ) {

			for ( let i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
			if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );
			if ( renderTargetProperties.__webglColorRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer );
			if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

		}

		properties.remove( texture );
		properties.remove( renderTarget );

	}

	//

	let textureUnits = 0;

	function resetTextureUnits() {

		textureUnits = 0;

	}

	function allocateTextureUnit() {

		const textureUnit = textureUnits;

		if ( textureUnit >= maxTextures ) {

			console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

		}

		textureUnits += 1;

		return textureUnit;

	}

	//

	function setTexture2D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.isVideoTexture ) updateVideoTexture( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			const image = texture.image;

			if ( image === undefined ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );

			} else if ( image.complete === false ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

			} else {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

	}

	function setTexture2DArray( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture );

	}

	function setTexture3D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_3D, textureProperties.__webglTexture );

	}

	function setTextureCube( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadCubeTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );

	}

	const wrappingToGL = {
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["RepeatWrapping"] ]: _gl.REPEAT,
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["ClampToEdgeWrapping"] ]: _gl.CLAMP_TO_EDGE,
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["MirroredRepeatWrapping"] ]: _gl.MIRRORED_REPEAT
	};

	const filterToGL = {
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"] ]: _gl.NEAREST,
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestMipmapNearestFilter"] ]: _gl.NEAREST_MIPMAP_NEAREST,
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestMipmapLinearFilter"] ]: _gl.NEAREST_MIPMAP_LINEAR,

		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"] ]: _gl.LINEAR,
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearMipmapNearestFilter"] ]: _gl.LINEAR_MIPMAP_NEAREST,
		[ _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearMipmapLinearFilter"] ]: _gl.LINEAR_MIPMAP_LINEAR
	};

	function setTextureParameters( textureType, texture, supportsMips ) {

		if ( supportsMips ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );

			if ( textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY ) {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );

			}

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[ texture.minFilter ] );

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			if ( textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY ) {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE );

			}

			if ( texture.wrapS !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["ClampToEdgeWrapping"] || texture.wrapT !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["ClampToEdgeWrapping"] ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

			}

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

			if ( texture.minFilter !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"] && texture.minFilter !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"] ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

			}

		}

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( texture.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["FloatType"] && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2
			if ( isWebGL2 === false && ( texture.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["HalfFloatType"] && extensions.has( 'OES_texture_half_float_linear' ) === false ) ) return; // verify extension for WebGL 1 only

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function initTexture( textureProperties, texture ) {

		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			info.memory.textures ++;

		}

	}

	function uploadTexture( textureProperties, texture, slot ) {

		let textureType = _gl.TEXTURE_2D;

		if ( texture.isDataTexture2DArray ) textureType = _gl.TEXTURE_2D_ARRAY;
		if ( texture.isDataTexture3D ) textureType = _gl.TEXTURE_3D;

		initTexture( textureProperties, texture );

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( textureType, textureProperties.__webglTexture );

		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
		_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE );

		const needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;
		const image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );

		const supportsMips = isPowerOfTwo( image ) || isWebGL2,
			glFormat = utils.convert( texture.format );

		let glType = utils.convert( texture.type ),
			glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

		setTextureParameters( textureType, texture, supportsMips );

		let mipmap;
		const mipmaps = texture.mipmaps;

		if ( texture.isDepthTexture ) {

			// populate depth texture with dummy data

			glInternalFormat = _gl.DEPTH_COMPONENT;

			if ( isWebGL2 ) {

				if ( texture.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["FloatType"] ) {

					glInternalFormat = _gl.DEPTH_COMPONENT32F;

				} else if ( texture.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedIntType"] ) {

					glInternalFormat = _gl.DEPTH_COMPONENT24;

				} else if ( texture.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedInt248Type"] ) {

					glInternalFormat = _gl.DEPTH24_STENCIL8;

				} else {

					glInternalFormat = _gl.DEPTH_COMPONENT16; // WebGL2 requires sized internalformat for glTexImage2D

				}

			} else {

				if ( texture.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["FloatType"] ) {

					console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

				}

			}

			// validation checks for WebGL 1

			if ( texture.format === _constants_js__WEBPACK_IMPORTED_MODULE_0__["DepthFormat"] && glInternalFormat === _gl.DEPTH_COMPONENT ) {

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedShortType"] && texture.type !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedIntType"] ) {

					console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

					texture.type = _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedShortType"];
					glType = utils.convert( texture.type );

				}

			}

			if ( texture.format === _constants_js__WEBPACK_IMPORTED_MODULE_0__["DepthStencilFormat"] && glInternalFormat === _gl.DEPTH_COMPONENT ) {

				// Depth stencil textures need the DEPTH_STENCIL internal format
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				glInternalFormat = _gl.DEPTH_STENCIL;

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedInt248Type"] ) {

					console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

					texture.type = _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedInt248Type"];
					glType = utils.convert( texture.type );

				}

			}

			//

			state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

		} else if ( texture.isDataTexture ) {

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && supportsMips ) {

				for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

				texture.generateMipmaps = false;
				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;

			}

		} else if ( texture.isCompressedTexture ) {

			for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

				mipmap = mipmaps[ i ];

				if ( texture.format !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"] && texture.format !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBFormat"] ) {

					if ( glFormat !== null ) {

						state.compressedTexImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					} else {

						console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

					}

				} else {

					state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

			}

			textureProperties.__maxMipLevel = mipmaps.length - 1;

		} else if ( texture.isDataTexture2DArray ) {

			state.texImage3D( _gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
			textureProperties.__maxMipLevel = 0;

		} else if ( texture.isDataTexture3D ) {

			state.texImage3D( _gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
			textureProperties.__maxMipLevel = 0;

		} else {

			// regular Texture (image, video, canvas)

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && supportsMips ) {

				for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap );

				}

				texture.generateMipmaps = false;
				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image );
				textureProperties.__maxMipLevel = 0;

			}

		}

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			generateMipmap( textureType, texture, image.width, image.height );

		}

		textureProperties.__version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	function uploadCubeTexture( textureProperties, texture, slot ) {

		if ( texture.image.length !== 6 ) return;

		initTexture( textureProperties, texture );

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );

		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
		_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE );

		const isCompressed = ( texture && ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture ) );
		const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

		const cubeImage = [];

		for ( let i = 0; i < 6; i ++ ) {

			if ( ! isCompressed && ! isDataTexture ) {

				cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

			} else {

				cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

			}

		}

		const image = cubeImage[ 0 ],
			supportsMips = isPowerOfTwo( image ) || isWebGL2,
			glFormat = utils.convert( texture.format ),
			glType = utils.convert( texture.type ),
			glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

		setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, supportsMips );

		let mipmaps;

		if ( isCompressed ) {

			for ( let i = 0; i < 6; i ++ ) {

				mipmaps = cubeImage[ i ].mipmaps;

				for ( let j = 0; j < mipmaps.length; j ++ ) {

					const mipmap = mipmaps[ j ];

					if ( texture.format !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"] && texture.format !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBFormat"] ) {

						if ( glFormat !== null ) {

							state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						} else {

							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

						}

					} else {

						state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

				}

			}

			textureProperties.__maxMipLevel = mipmaps.length - 1;

		} else {

			mipmaps = texture.mipmaps;

			for ( let i = 0; i < 6; i ++ ) {

				if ( isDataTexture ) {

					state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

					for ( let j = 0; j < mipmaps.length; j ++ ) {

						const mipmap = mipmaps[ j ];
						const mipmapImage = mipmap.image[ i ].image;

						state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

					}

				} else {

					state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

					for ( let j = 0; j < mipmaps.length; j ++ ) {

						const mipmap = mipmaps[ j ];

						state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

					}

				}

			}

			textureProperties.__maxMipLevel = mipmaps.length;

		}

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			// We assume images for cube map have the same size.
			generateMipmap( _gl.TEXTURE_CUBE_MAP, texture, image.width, image.height );

		}

		textureProperties.__version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	// Render targets

	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

		const texture = renderTarget.texture;

		const glFormat = utils.convert( texture.format );
		const glType = utils.convert( texture.type );
		const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

		if ( textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY ) {

			state.texImage3D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null );

		} else {

			state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

		}

		state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( texture ).__webglTexture, 0 );
		state.bindFramebuffer( _gl.FRAMEBUFFER, null );

	}

	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			let glInternalFormat = _gl.DEPTH_COMPONENT16;

			if ( isMultisample ) {

				const depthTexture = renderTarget.depthTexture;

				if ( depthTexture && depthTexture.isDepthTexture ) {

					if ( depthTexture.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["FloatType"] ) {

						glInternalFormat = _gl.DEPTH_COMPONENT32F;

					} else if ( depthTexture.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedIntType"] ) {

						glInternalFormat = _gl.DEPTH_COMPONENT24;

					}

				}

				const samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

			}

			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			if ( isMultisample ) {

				const samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );

			}


			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			const texture = renderTarget.texture;

			const glFormat = utils.convert( texture.format );
			const glType = utils.convert( texture.type );
			const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

			if ( isMultisample ) {

				const samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

			}

		}

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

	}

	// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture( framebuffer, renderTarget ) {

		const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
		if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

		state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

		if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

			throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

		}

		// upload an empty depth texture with framebuffer size
		if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height ) {

			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;

		}

		setTexture2D( renderTarget.depthTexture, 0 );

		const webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

		if ( renderTarget.depthTexture.format === _constants_js__WEBPACK_IMPORTED_MODULE_0__["DepthFormat"] ) {

			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

		} else if ( renderTarget.depthTexture.format === _constants_js__WEBPACK_IMPORTED_MODULE_0__["DepthStencilFormat"] ) {

			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

		} else {

			throw new Error( 'Unknown depthTexture format' );

		}

	}

	// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );

		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

		if ( renderTarget.depthTexture ) {

			if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

		} else {

			if ( isCube ) {

				renderTargetProperties.__webglDepthbuffer = [];

				for ( let i = 0; i < 6; i ++ ) {

					state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

				}

			} else {

				state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

			}

		}

		state.bindFramebuffer( _gl.FRAMEBUFFER, null );

	}

	// Set up GL resources for the render target
	function setupRenderTarget( renderTarget ) {

		const texture = renderTarget.texture;

		const renderTargetProperties = properties.get( renderTarget );
		const textureProperties = properties.get( texture );

		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

		textureProperties.__webglTexture = _gl.createTexture();
		textureProperties.__version = texture.version;

		info.memory.textures ++;

		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
		const isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
		const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
		const supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

		// Handles WebGL2 RGBFormat fallback - #18858

		if ( isWebGL2 && texture.format === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBFormat"] && ( texture.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["FloatType"] || texture.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["HalfFloatType"] ) ) {

			texture.format = _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"];

			console.warn( 'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.' );

		}

		// Setup framebuffer

		if ( isCube ) {

			renderTargetProperties.__webglFramebuffer = [];

			for ( let i = 0; i < 6; i ++ ) {

				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

			}

		} else {

			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			if ( isMultisample ) {

				if ( isWebGL2 ) {

					renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
					renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

					_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer );

					const glFormat = utils.convert( texture.format );
					const glType = utils.convert( texture.type );
					const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );
					const samples = getRenderTargetSamples( renderTarget );
					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer );
					_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

					if ( renderTarget.depthBuffer ) {

						renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

					}

					state.bindFramebuffer( _gl.FRAMEBUFFER, null );


				} else {

					console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

				}

			}

		}

		// Setup color buffer

		if ( isCube ) {

			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
			setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, supportsMips );

			for ( let i = 0; i < 6; i ++ ) {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( _gl.TEXTURE_CUBE_MAP, texture, renderTarget.width, renderTarget.height );

			}

			state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

		} else {

			let glTextureType = _gl.TEXTURE_2D;

			if ( isRenderTarget3D ) {

				// Render targets containing layers, i.e: Texture 3D and 2d arrays

				if ( isWebGL2 ) {

					const isTexture3D = texture.isDataTexture3D;
					glTextureType = isTexture3D ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;

				} else {

					console.warn( 'THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.' );

				}

			}

			state.bindTexture( glTextureType, textureProperties.__webglTexture );
			setTextureParameters( glTextureType, texture, supportsMips );
			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, glTextureType );

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( _gl.TEXTURE_2D, texture, renderTarget.width, renderTarget.height );

			}

			state.bindTexture( _gl.TEXTURE_2D, null );

		}

		// Setup depth and stencil buffers

		if ( renderTarget.depthBuffer ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	function updateRenderTargetMipmap( renderTarget ) {

		const texture = renderTarget.texture;

		const supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
			const webglTexture = properties.get( texture ).__webglTexture;

			state.bindTexture( target, webglTexture );
			generateMipmap( target, texture, renderTarget.width, renderTarget.height );
			state.bindTexture( target, null );

		}

	}

	function updateMultisampleRenderTarget( renderTarget ) {

		if ( renderTarget.isWebGLMultisampleRenderTarget ) {

			if ( isWebGL2 ) {

				const renderTargetProperties = properties.get( renderTarget );

				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );

				const width = renderTarget.width;
				const height = renderTarget.height;
				let mask = _gl.COLOR_BUFFER_BIT;

				if ( renderTarget.depthBuffer ) mask |= _gl.DEPTH_BUFFER_BIT;
				if ( renderTarget.stencilBuffer ) mask |= _gl.STENCIL_BUFFER_BIT;

				_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST );

				state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer ); // see #18905

			} else {

				console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

			}

		}

	}

	function getRenderTargetSamples( renderTarget ) {

		return ( isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
			Math.min( maxSamples, renderTarget.samples ) : 0;

	}

	function updateVideoTexture( texture ) {

		const frame = info.render.frame;

		// Check the last frame we updated the VideoTexture

		if ( _videoTextures.get( texture ) !== frame ) {

			_videoTextures.set( texture, frame );
			texture.update();

		}

	}

	// backwards compatibility

	let warnedTexture2D = false;
	let warnedTextureCube = false;

	function safeSetTexture2D( texture, slot ) {

		if ( texture && texture.isWebGLRenderTarget ) {

			if ( warnedTexture2D === false ) {

				console.warn( 'THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.' );
				warnedTexture2D = true;

			}

			texture = texture.texture;

		}

		setTexture2D( texture, slot );

	}

	function safeSetTextureCube( texture, slot ) {

		if ( texture && texture.isWebGLCubeRenderTarget ) {

			if ( warnedTextureCube === false ) {

				console.warn( 'THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.' );
				warnedTextureCube = true;

			}

			texture = texture.texture;

		}


		setTextureCube( texture, slot );

	}

	//

	this.allocateTextureUnit = allocateTextureUnit;
	this.resetTextureUnits = resetTextureUnits;

	this.setTexture2D = setTexture2D;
	this.setTexture2DArray = setTexture2DArray;
	this.setTexture3D = setTexture3D;
	this.setTextureCube = setTextureCube;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

	this.safeSetTexture2D = safeSetTexture2D;
	this.safeSetTextureCube = safeSetTextureCube;

}




/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLUniforms.js":
/*!*************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLUniforms.js ***!
  \*************************************************************************************/
/*! exports provided: WebGLUniforms */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLUniforms", function() { return WebGLUniforms; });
/* harmony import */ var _textures_CubeTexture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../textures/CubeTexture.js */ "../../node_modules/three/src/textures/CubeTexture.js");
/* harmony import */ var _textures_Texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../textures/Texture.js */ "../../node_modules/three/src/textures/Texture.js");
/* harmony import */ var _textures_DataTexture2DArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../textures/DataTexture2DArray.js */ "../../node_modules/three/src/textures/DataTexture2DArray.js");
/* harmony import */ var _textures_DataTexture3D_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../textures/DataTexture3D.js */ "../../node_modules/three/src/textures/DataTexture3D.js");
/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */






const emptyTexture = new _textures_Texture_js__WEBPACK_IMPORTED_MODULE_1__["Texture"]();
const emptyTexture2dArray = new _textures_DataTexture2DArray_js__WEBPACK_IMPORTED_MODULE_2__["DataTexture2DArray"]();
const emptyTexture3d = new _textures_DataTexture3D_js__WEBPACK_IMPORTED_MODULE_3__["DataTexture3D"]();
const emptyCubeTexture = new _textures_CubeTexture_js__WEBPACK_IMPORTED_MODULE_0__["CubeTexture"]();

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

const arrayCacheF32 = [];
const arrayCacheI32 = [];

// Float32Array caches used for uploading Matrix uniforms

const mat4array = new Float32Array( 16 );
const mat3array = new Float32Array( 9 );
const mat2array = new Float32Array( 4 );

// Flattening for arrays of vectors and matrices

function flatten( array, nBlocks, blockSize ) {

	const firstElem = array[ 0 ];

	if ( firstElem <= 0 || firstElem > 0 ) return array;
	// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983

	const n = nBlocks * blockSize;
	let r = arrayCacheF32[ n ];

	if ( r === undefined ) {

		r = new Float32Array( n );
		arrayCacheF32[ n ] = r;

	}

	if ( nBlocks !== 0 ) {

		firstElem.toArray( r, 0 );

		for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

			offset += blockSize;
			array[ i ].toArray( r, offset );

		}

	}

	return r;

}

function arraysEqual( a, b ) {

	if ( a.length !== b.length ) return false;

	for ( let i = 0, l = a.length; i < l; i ++ ) {

		if ( a[ i ] !== b[ i ] ) return false;

	}

	return true;

}

function copyArray( a, b ) {

	for ( let i = 0, l = b.length; i < l; i ++ ) {

		a[ i ] = b[ i ];

	}

}

// Texture unit allocation

function allocTexUnits( textures, n ) {

	let r = arrayCacheI32[ n ];

	if ( r === undefined ) {

		r = new Int32Array( n );
		arrayCacheI32[ n ] = r;

	}

	for ( let i = 0; i !== n; ++ i ) {

		r[ i ] = textures.allocateTextureUnit();

	}

	return r;

}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValueV1f( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1f( this.addr, v );

	cache[ 0 ] = v;

}

// Single float vector (from flat array or THREE.VectorN)

function setValueV2f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2f( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV3f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3f( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else if ( v.r !== undefined ) {

		if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

			gl.uniform3f( this.addr, v.r, v.g, v.b );

			cache[ 0 ] = v.r;
			cache[ 1 ] = v.g;
			cache[ 2 ] = v.b;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV4f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4fv( this.addr, v );

		copyArray( cache, v );

	}

}

// Single matrix (from flat array or THREE.MatrixN)

function setValueM2( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix2fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat2array.set( elements );

		gl.uniformMatrix2fv( this.addr, false, mat2array );

		copyArray( cache, elements );

	}

}

function setValueM3( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix3fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat3array.set( elements );

		gl.uniformMatrix3fv( this.addr, false, mat3array );

		copyArray( cache, elements );

	}

}

function setValueM4( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix4fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat4array.set( elements );

		gl.uniformMatrix4fv( this.addr, false, mat4array );

		copyArray( cache, elements );

	}

}

// Single integer / boolean

function setValueV1i( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1i( this.addr, v );

	cache[ 0 ] = v;

}

// Single integer / boolean vector (from flat array)

function setValueV2i( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform2iv( this.addr, v );

	copyArray( cache, v );

}

function setValueV3i( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform3iv( this.addr, v );

	copyArray( cache, v );

}

function setValueV4i( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform4iv( this.addr, v );

	copyArray( cache, v );

}

// Single unsigned integer

function setValueV1ui( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1ui( this.addr, v );

	cache[ 0 ] = v;

}

// Single unsigned integer vector (from flat array)

function setValueV2ui( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform2uiv( this.addr, v );

	copyArray( cache, v );

}

function setValueV3ui( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform3uiv( this.addr, v );

	copyArray( cache, v );

}

function setValueV4ui( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform4uiv( this.addr, v );

	copyArray( cache, v );

}


// Single texture (2D / Cube)

function setValueT1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.safeSetTexture2D( v || emptyTexture, unit );

}

function setValueT3D1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture3D( v || emptyTexture3d, unit );

}

function setValueT6( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.safeSetTextureCube( v || emptyCubeTexture, unit );

}

function setValueT2DArray1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture2DArray( v || emptyTexture2dArray, unit );

}

// Helper to pick the right setter for the singular case

function getSingularSetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1f; // FLOAT
		case 0x8b50: return setValueV2f; // _VEC2
		case 0x8b51: return setValueV3f; // _VEC3
		case 0x8b52: return setValueV4f; // _VEC4

		case 0x8b5a: return setValueM2; // _MAT2
		case 0x8b5b: return setValueM3; // _MAT3
		case 0x8b5c: return setValueM4; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

		case 0x1405: return setValueV1ui; // UINT
		case 0x8dc6: return setValueV2ui; // _VEC2
		case 0x8dc7: return setValueV3ui; // _VEC3
		case 0x8dc8: return setValueV4ui; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1;

		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
			return setValueT3D1;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6;

		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArray1;

	}

}


// Array of scalars

function setValueV1fArray( gl, v ) {

	gl.uniform1fv( this.addr, v );

}

// Array of vectors (from flat array or array of THREE.VectorN)

function setValueV2fArray( gl, v ) {

	const data = flatten( v, this.size, 2 );

	gl.uniform2fv( this.addr, data );

}

function setValueV3fArray( gl, v ) {

	const data = flatten( v, this.size, 3 );

	gl.uniform3fv( this.addr, data );

}

function setValueV4fArray( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniform4fv( this.addr, data );

}

// Array of matrices (from flat array or array of THREE.MatrixN)

function setValueM2Array( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniformMatrix2fv( this.addr, false, data );

}

function setValueM3Array( gl, v ) {

	const data = flatten( v, this.size, 9 );

	gl.uniformMatrix3fv( this.addr, false, data );

}

function setValueM4Array( gl, v ) {

	const data = flatten( v, this.size, 16 );

	gl.uniformMatrix4fv( this.addr, false, data );

}

// Array of integer / boolean

function setValueV1iArray( gl, v ) {

	gl.uniform1iv( this.addr, v );

}

// Array of integer / boolean vectors (from flat array)

function setValueV2iArray( gl, v ) {

	gl.uniform2iv( this.addr, v );

}

function setValueV3iArray( gl, v ) {

	gl.uniform3iv( this.addr, v );

}

function setValueV4iArray( gl, v ) {

	gl.uniform4iv( this.addr, v );

}

// Array of unsigned integer

function setValueV1uiArray( gl, v ) {

	gl.uniform1uiv( this.addr, v );

}

// Array of unsigned integer vectors (from flat array)

function setValueV2uiArray( gl, v ) {

	gl.uniform2uiv( this.addr, v );

}

function setValueV3uiArray( gl, v ) {

	gl.uniform3uiv( this.addr, v );

}

function setValueV4uiArray( gl, v ) {

	gl.uniform4uiv( this.addr, v );

}


// Array of textures (2D / Cube)

function setValueT1Array( gl, v, textures ) {

	const n = v.length;

	const units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( let i = 0; i !== n; ++ i ) {

		textures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );

	}

}

function setValueT6Array( gl, v, textures ) {

	const n = v.length;

	const units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( let i = 0; i !== n; ++ i ) {

		textures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

	}

}

// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1fArray; // FLOAT
		case 0x8b50: return setValueV2fArray; // _VEC2
		case 0x8b51: return setValueV3fArray; // _VEC3
		case 0x8b52: return setValueV4fArray; // _VEC4

		case 0x8b5a: return setValueM2Array; // _MAT2
		case 0x8b5b: return setValueM3Array; // _MAT3
		case 0x8b5c: return setValueM4Array; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

		case 0x1405: return setValueV1uiArray; // UINT
		case 0x8dc6: return setValueV2uiArray; // _VEC2
		case 0x8dc7: return setValueV3uiArray; // _VEC3
		case 0x8dc8: return setValueV4uiArray; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1Array;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6Array;

	}

}

// --- Uniform Classes ---

function SingleUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.cache = [];
	this.setValue = getSingularSetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

function PureArrayUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.cache = [];
	this.size = activeInfo.size;
	this.setValue = getPureArraySetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

PureArrayUniform.prototype.updateCache = function ( data ) {

	const cache = this.cache;

	if ( data instanceof Float32Array && cache.length !== data.length ) {

		this.cache = new Float32Array( data.length );

	}

	copyArray( cache, data );

};

function StructuredUniform( id ) {

	this.id = id;

	this.seq = [];
	this.map = {};

}

StructuredUniform.prototype.setValue = function ( gl, value, textures ) {

	const seq = this.seq;

	for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		const u = seq[ i ];
		u.setValue( gl, value[ u.id ], textures );

	}

};

// --- Top-level ---

// Parser - builds up the property tree from the path strings

const RePathPart = /(\w+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform( container, uniformObject ) {

	container.seq.push( uniformObject );
	container.map[ uniformObject.id ] = uniformObject;

}

function parseUniform( activeInfo, addr, container ) {

	const path = activeInfo.name,
		pathLength = path.length;

	// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex = 0;

	while ( true ) {

		const match = RePathPart.exec( path ),
			matchEnd = RePathPart.lastIndex;

		let id = match[ 1 ];
		const idIsIndex = match[ 2 ] === ']',
			subscript = match[ 3 ];

		if ( idIsIndex ) id = id | 0; // convert to integer

		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

			// bare name or "pure" bottom-level array "[0]" suffix

			addUniform( container, subscript === undefined ?
				new SingleUniform( id, activeInfo, addr ) :
				new PureArrayUniform( id, activeInfo, addr ) );

			break;

		} else {

			// step into inner node / create it in case it doesn't exist

			const map = container.map;
			let next = map[ id ];

			if ( next === undefined ) {

				next = new StructuredUniform( id );
				addUniform( container, next );

			}

			container = next;

		}

	}

}

// Root Container

function WebGLUniforms( gl, program ) {

	this.seq = [];
	this.map = {};

	const n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

	for ( let i = 0; i < n; ++ i ) {

		const info = gl.getActiveUniform( program, i ),
			addr = gl.getUniformLocation( program, info.name );

		parseUniform( info, addr, this );

	}

}

WebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {

	const u = this.map[ name ];

	if ( u !== undefined ) u.setValue( gl, value, textures );

};

WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

	const v = object[ name ];

	if ( v !== undefined ) this.setValue( gl, name, v );

};


// Static interface

WebGLUniforms.upload = function ( gl, seq, values, textures ) {

	for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		const u = seq[ i ],
			v = values[ u.id ];

		if ( v.needsUpdate !== false ) {

			// note: always updating when .needsUpdate is undefined
			u.setValue( gl, v.value, textures );

		}

	}

};

WebGLUniforms.seqWithValue = function ( seq, values ) {

	const r = [];

	for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		const u = seq[ i ];
		if ( u.id in values ) r.push( u );

	}

	return r;

};




/***/ }),

/***/ "../../node_modules/three/src/renderers/webgl/WebGLUtils.js":
/*!**********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webgl/WebGLUtils.js ***!
  \**********************************************************************************/
/*! exports provided: WebGLUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLUtils", function() { return WebGLUtils; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "../../node_modules/three/src/constants.js");


function WebGLUtils( gl, extensions, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	function convert( p ) {

		let extension;

		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedByteType"] ) return gl.UNSIGNED_BYTE;
		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedShort4444Type"] ) return gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedShort5551Type"] ) return gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedShort565Type"] ) return gl.UNSIGNED_SHORT_5_6_5;

		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["ByteType"] ) return gl.BYTE;
		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["ShortType"] ) return gl.SHORT;
		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedShortType"] ) return gl.UNSIGNED_SHORT;
		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["IntType"] ) return gl.INT;
		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedIntType"] ) return gl.UNSIGNED_INT;
		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["FloatType"] ) return gl.FLOAT;

		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["HalfFloatType"] ) {

			if ( isWebGL2 ) return gl.HALF_FLOAT;

			extension = extensions.get( 'OES_texture_half_float' );

			if ( extension !== null ) {

				return extension.HALF_FLOAT_OES;

			} else {

				return null;

			}

		}

		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["AlphaFormat"] ) return gl.ALPHA;
		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBFormat"] ) return gl.RGB;
		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"] ) return gl.RGBA;
		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["LuminanceFormat"] ) return gl.LUMINANCE;
		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["LuminanceAlphaFormat"] ) return gl.LUMINANCE_ALPHA;
		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["DepthFormat"] ) return gl.DEPTH_COMPONENT;
		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["DepthStencilFormat"] ) return gl.DEPTH_STENCIL;
		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RedFormat"] ) return gl.RED;

		// WebGL2 formats.

		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RedIntegerFormat"] ) return gl.RED_INTEGER;
		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGFormat"] ) return gl.RG;
		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGIntegerFormat"] ) return gl.RG_INTEGER;
		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBIntegerFormat"] ) return gl.RGB_INTEGER;
		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAIntegerFormat"] ) return gl.RGBA_INTEGER;

		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_S3TC_DXT1_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_S3TC_DXT1_Format"] ||
			p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_S3TC_DXT3_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_S3TC_DXT5_Format"] ) {

			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

			if ( extension !== null ) {

				if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_S3TC_DXT1_Format"] ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_S3TC_DXT1_Format"] ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_S3TC_DXT3_Format"] ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_S3TC_DXT5_Format"] ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

			} else {

				return null;

			}

		}

		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_PVRTC_4BPPV1_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_PVRTC_2BPPV1_Format"] ||
			p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_PVRTC_4BPPV1_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_PVRTC_2BPPV1_Format"] ) {

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_PVRTC_4BPPV1_Format"] ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_PVRTC_2BPPV1_Format"] ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_PVRTC_4BPPV1_Format"] ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_PVRTC_2BPPV1_Format"] ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			} else {

				return null;

			}

		}

		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_ETC1_Format"] ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

			if ( extension !== null ) {

				return extension.COMPRESSED_RGB_ETC1_WEBGL;

			} else {

				return null;

			}

		}

		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_ETC2_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ETC2_EAC_Format"] ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

			if ( extension !== null ) {

				if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_ETC2_Format"] ) return extension.COMPRESSED_RGB8_ETC2;
				if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ETC2_EAC_Format"] ) return extension.COMPRESSED_RGBA8_ETC2_EAC;

			}

		}

		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_4x4_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_5x4_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_5x5_Format"] ||
			p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_6x5_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_6x6_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_8x5_Format"] ||
			p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_8x6_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_8x8_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_10x5_Format"] ||
			p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_10x6_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_10x8_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_10x10_Format"] ||
			p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_12x10_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_12x12_Format"] ||
			p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_4x4_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_5x4_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_5x5_Format"] ||
			p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_6x5_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_6x6_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_8x5_Format"] ||
			p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_8x6_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_8x8_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_10x5_Format"] ||
			p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_10x6_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_10x8_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_10x10_Format"] ||
			p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_12x10_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_12x12_Format"] ) {

			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

			if ( extension !== null ) {

				// TODO Complete?

				return p;

			} else {

				return null;

			}

		}

		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_BPTC_Format"] ) {

			extension = extensions.get( 'EXT_texture_compression_bptc' );

			if ( extension !== null ) {

				// TODO Complete?

				return p;

			} else {

				return null;

			}

		}

		if ( p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedInt248Type"] ) {

			if ( isWebGL2 ) return gl.UNSIGNED_INT_24_8;

			extension = extensions.get( 'WEBGL_depth_texture' );

			if ( extension !== null ) {

				return extension.UNSIGNED_INT_24_8_WEBGL;

			} else {

				return null;

			}

		}

	}

	return { convert: convert };

}





/***/ }),

/***/ "../../node_modules/three/src/renderers/webxr/WebXRController.js":
/*!***************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webxr/WebXRController.js ***!
  \***************************************************************************************/
/*! exports provided: WebXRController */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebXRController", function() { return WebXRController; });
/* harmony import */ var _objects_Group_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../objects/Group.js */ "../../node_modules/three/src/objects/Group.js");


function WebXRController() {

	this._targetRay = null;
	this._grip = null;
	this._hand = null;

}

Object.assign( WebXRController.prototype, {

	constructor: WebXRController,

	getHandSpace: function () {

		if ( this._hand === null ) {

			this._hand = new _objects_Group_js__WEBPACK_IMPORTED_MODULE_0__["Group"]();
			this._hand.matrixAutoUpdate = false;
			this._hand.visible = false;

			this._hand.joints = {};
			this._hand.inputState = { pinching: false };

		}

		return this._hand;

	},

	getTargetRaySpace: function () {

		if ( this._targetRay === null ) {

			this._targetRay = new _objects_Group_js__WEBPACK_IMPORTED_MODULE_0__["Group"]();
			this._targetRay.matrixAutoUpdate = false;
			this._targetRay.visible = false;

		}

		return this._targetRay;

	},

	getGripSpace: function () {

		if ( this._grip === null ) {

			this._grip = new _objects_Group_js__WEBPACK_IMPORTED_MODULE_0__["Group"]();
			this._grip.matrixAutoUpdate = false;
			this._grip.visible = false;

		}

		return this._grip;

	},

	dispatchEvent: function ( event ) {

		if ( this._targetRay !== null ) {

			this._targetRay.dispatchEvent( event );

		}

		if ( this._grip !== null ) {

			this._grip.dispatchEvent( event );

		}

		if ( this._hand !== null ) {

			this._hand.dispatchEvent( event );

		}

		return this;

	},

	disconnect: function ( inputSource ) {

		this.dispatchEvent( { type: 'disconnected', data: inputSource } );

		if ( this._targetRay !== null ) {

			this._targetRay.visible = false;

		}

		if ( this._grip !== null ) {

			this._grip.visible = false;

		}

		if ( this._hand !== null ) {

			this._hand.visible = false;

		}

		return this;

	},

	update: function ( inputSource, frame, referenceSpace ) {

		let inputPose = null;
		let gripPose = null;
		let handPose = null;

		const targetRay = this._targetRay;
		const grip = this._grip;
		const hand = this._hand;

		if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

			if ( targetRay !== null ) {

				inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

				if ( inputPose !== null ) {

					targetRay.matrix.fromArray( inputPose.transform.matrix );
					targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );

				}

			}

			if ( hand && inputSource.hand ) {

				handPose = true;

				for ( const inputjoint of inputSource.hand.values() ) {

					// Update the joints groups with the XRJoint poses
					const jointPose = frame.getJointPose( inputjoint, referenceSpace );

					if ( hand.joints[ inputjoint.jointName ] === undefined ) {

						// The transform of this joint will be updated with the joint pose on each frame
						const joint = new _objects_Group_js__WEBPACK_IMPORTED_MODULE_0__["Group"]();
						joint.matrixAutoUpdate = false;
						joint.visible = false;
						hand.joints[ inputjoint.jointName ] = joint;
						// ??
						hand.add( joint );

					}

					const joint = hand.joints[ inputjoint.jointName ];

					if ( jointPose !== null ) {

						joint.matrix.fromArray( jointPose.transform.matrix );
						joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
						joint.jointRadius = jointPose.radius;

					}

					joint.visible = jointPose !== null;

				}

				// Custom events

				// Check pinchz
				const indexTip = hand.joints[ 'index-finger-tip' ];
				const thumbTip = hand.joints[ 'thumb-tip' ];
				const distance = indexTip.position.distanceTo( thumbTip.position );

				const distanceToPinch = 0.02;
				const threshold = 0.005;

				if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

					hand.inputState.pinching = false;
					this.dispatchEvent( {
						type: 'pinchend',
						handedness: inputSource.handedness,
						target: this
					} );

				} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

					hand.inputState.pinching = true;
					this.dispatchEvent( {
						type: 'pinchstart',
						handedness: inputSource.handedness,
						target: this
					} );

				}

			} else {

				if ( grip !== null && inputSource.gripSpace ) {

					gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

					if ( gripPose !== null ) {

						grip.matrix.fromArray( gripPose.transform.matrix );
						grip.matrix.decompose( grip.position, grip.rotation, grip.scale );

					}

				}

			}

		}

		if ( targetRay !== null ) {

			targetRay.visible = ( inputPose !== null );

		}

		if ( grip !== null ) {

			grip.visible = ( gripPose !== null );

		}

		if ( hand !== null ) {

			hand.visible = ( handPose !== null );

		}

		return this;

	}

} );





/***/ }),

/***/ "../../node_modules/three/src/renderers/webxr/WebXRManager.js":
/*!************************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/renderers/webxr/WebXRManager.js ***!
  \************************************************************************************/
/*! exports provided: WebXRManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebXRManager", function() { return WebXRManager; });
/* harmony import */ var _cameras_ArrayCamera_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../cameras/ArrayCamera.js */ "../../node_modules/three/src/cameras/ArrayCamera.js");
/* harmony import */ var _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/EventDispatcher.js */ "../../node_modules/three/src/core/EventDispatcher.js");
/* harmony import */ var _cameras_PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../cameras/PerspectiveCamera.js */ "../../node_modules/three/src/cameras/PerspectiveCamera.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/Vector3.js */ "../../node_modules/three/src/math/Vector3.js");
/* harmony import */ var _math_Vector4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../math/Vector4.js */ "../../node_modules/three/src/math/Vector4.js");
/* harmony import */ var _webgl_WebGLAnimation_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../webgl/WebGLAnimation.js */ "../../node_modules/three/src/renderers/webgl/WebGLAnimation.js");
/* harmony import */ var _WebXRController_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./WebXRController.js */ "../../node_modules/three/src/renderers/webxr/WebXRController.js");








function WebXRManager( renderer, gl ) {

	const scope = this;
	const state = renderer.state;

	let session = null;

	let framebufferScaleFactor = 1.0;

	let referenceSpace = null;
	let referenceSpaceType = 'local-floor';

	let pose = null;

	const controllers = [];
	const inputSourcesMap = new Map();

	//

	const cameraL = new _cameras_PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__["PerspectiveCamera"]();
	cameraL.layers.enable( 1 );
	cameraL.viewport = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_4__["Vector4"]();

	const cameraR = new _cameras_PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__["PerspectiveCamera"]();
	cameraR.layers.enable( 2 );
	cameraR.viewport = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_4__["Vector4"]();

	const cameras = [ cameraL, cameraR ];

	const cameraVR = new _cameras_ArrayCamera_js__WEBPACK_IMPORTED_MODULE_0__["ArrayCamera"]();
	cameraVR.layers.enable( 1 );
	cameraVR.layers.enable( 2 );

	let _currentDepthNear = null;
	let _currentDepthFar = null;

	//

	this.enabled = false;

	this.isPresenting = false;

	this.getController = function ( index ) {

		let controller = controllers[ index ];

		if ( controller === undefined ) {

			controller = new _WebXRController_js__WEBPACK_IMPORTED_MODULE_6__["WebXRController"]();
			controllers[ index ] = controller;

		}

		return controller.getTargetRaySpace();

	};

	this.getControllerGrip = function ( index ) {

		let controller = controllers[ index ];

		if ( controller === undefined ) {

			controller = new _WebXRController_js__WEBPACK_IMPORTED_MODULE_6__["WebXRController"]();
			controllers[ index ] = controller;

		}

		return controller.getGripSpace();

	};

	this.getHand = function ( index ) {

		let controller = controllers[ index ];

		if ( controller === undefined ) {

			controller = new _WebXRController_js__WEBPACK_IMPORTED_MODULE_6__["WebXRController"]();
			controllers[ index ] = controller;

		}

		return controller.getHandSpace();

	};

	//

	function onSessionEvent( event ) {

		const controller = inputSourcesMap.get( event.inputSource );

		if ( controller ) {

			controller.dispatchEvent( { type: event.type, data: event.inputSource } );

		}

	}

	function onSessionEnd() {

		inputSourcesMap.forEach( function ( controller, inputSource ) {

			controller.disconnect( inputSource );

		} );

		inputSourcesMap.clear();

		_currentDepthNear = null;
		_currentDepthFar = null;

		// restore framebuffer/rendering state

		state.bindXRFramebuffer( null );
		renderer.setRenderTarget( renderer.getRenderTarget() );

		//

		animation.stop();

		scope.isPresenting = false;

		scope.dispatchEvent( { type: 'sessionend' } );

	}

	this.setFramebufferScaleFactor = function ( value ) {

		framebufferScaleFactor = value;

		if ( scope.isPresenting === true ) {

			console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

		}

	};

	this.setReferenceSpaceType = function ( value ) {

		referenceSpaceType = value;

		if ( scope.isPresenting === true ) {

			console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

		}

	};

	this.getReferenceSpace = function () {

		return referenceSpace;

	};

	this.getSession = function () {

		return session;

	};

	this.setSession = async function ( value ) {

		session = value;

		if ( session !== null ) {

			session.addEventListener( 'select', onSessionEvent );
			session.addEventListener( 'selectstart', onSessionEvent );
			session.addEventListener( 'selectend', onSessionEvent );
			session.addEventListener( 'squeeze', onSessionEvent );
			session.addEventListener( 'squeezestart', onSessionEvent );
			session.addEventListener( 'squeezeend', onSessionEvent );
			session.addEventListener( 'end', onSessionEnd );
			session.addEventListener( 'inputsourceschange', onInputSourcesChange );

			const attributes = gl.getContextAttributes();

			if ( attributes.xrCompatible !== true ) {

				await gl.makeXRCompatible();

			}

			const layerInit = {
				antialias: attributes.antialias,
				alpha: attributes.alpha,
				depth: attributes.depth,
				stencil: attributes.stencil,
				framebufferScaleFactor: framebufferScaleFactor
			};

			// eslint-disable-next-line no-undef
			const baseLayer = new XRWebGLLayer( session, gl, layerInit );

			session.updateRenderState( { baseLayer: baseLayer } );

			referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

			animation.setContext( session );
			animation.start();

			scope.isPresenting = true;

			scope.dispatchEvent( { type: 'sessionstart' } );

		}

	};

	function onInputSourcesChange( event ) {

		const inputSources = session.inputSources;

		// Assign inputSources to available controllers

		for ( let i = 0; i < controllers.length; i ++ ) {

			inputSourcesMap.set( inputSources[ i ], controllers[ i ] );

		}

		// Notify disconnected

		for ( let i = 0; i < event.removed.length; i ++ ) {

			const inputSource = event.removed[ i ];
			const controller = inputSourcesMap.get( inputSource );

			if ( controller ) {

				controller.dispatchEvent( { type: 'disconnected', data: inputSource } );
				inputSourcesMap.delete( inputSource );

			}

		}

		// Notify connected

		for ( let i = 0; i < event.added.length; i ++ ) {

			const inputSource = event.added[ i ];
			const controller = inputSourcesMap.get( inputSource );

			if ( controller ) {

				controller.dispatchEvent( { type: 'connected', data: inputSource } );

			}

		}

	}

	//

	const cameraLPos = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();
	const cameraRPos = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();

	/**
	 * Assumes 2 cameras that are parallel and share an X-axis, and that
	 * the cameras' projection and world matrices have already been set.
	 * And that near and far planes are identical for both cameras.
	 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
	 */
	function setProjectionFromUnion( camera, cameraL, cameraR ) {

		cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
		cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

		const ipd = cameraLPos.distanceTo( cameraRPos );

		const projL = cameraL.projectionMatrix.elements;
		const projR = cameraR.projectionMatrix.elements;

		// VR systems will have identical far and near planes, and
		// most likely identical top and bottom frustum extents.
		// Use the left camera for these values.
		const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
		const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
		const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
		const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

		const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
		const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
		const left = near * leftFov;
		const right = near * rightFov;

		// Calculate the new camera's position offset from the
		// left camera. xOffset should be roughly half `ipd`.
		const zOffset = ipd / ( - leftFov + rightFov );
		const xOffset = zOffset * - leftFov;

		// TODO: Better way to apply this offset?
		cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
		camera.translateX( xOffset );
		camera.translateZ( zOffset );
		camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
		camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

		// Find the union of the frustum values of the cameras and scale
		// the values so that the near plane's position does not change in world space,
		// although must now be relative to the new union camera.
		const near2 = near + zOffset;
		const far2 = far + zOffset;
		const left2 = left - xOffset;
		const right2 = right + ( ipd - xOffset );
		const top2 = topFov * far / far2 * near2;
		const bottom2 = bottomFov * far / far2 * near2;

		camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

	}

	function updateCamera( camera, parent ) {

		if ( parent === null ) {

			camera.matrixWorld.copy( camera.matrix );

		} else {

			camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

		}

		camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

	}

	this.getCamera = function ( camera ) {

		cameraVR.near = cameraR.near = cameraL.near = camera.near;
		cameraVR.far = cameraR.far = cameraL.far = camera.far;

		if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {

			// Note that the new renderState won't apply until the next frame. See #18320

			session.updateRenderState( {
				depthNear: cameraVR.near,
				depthFar: cameraVR.far
			} );

			_currentDepthNear = cameraVR.near;
			_currentDepthFar = cameraVR.far;

		}

		const parent = camera.parent;
		const cameras = cameraVR.cameras;

		updateCamera( cameraVR, parent );

		for ( let i = 0; i < cameras.length; i ++ ) {

			updateCamera( cameras[ i ], parent );

		}

		// update camera and its children

		camera.matrixWorld.copy( cameraVR.matrixWorld );
		camera.matrix.copy( cameraVR.matrix );
		camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );

		const children = camera.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( true );

		}

		// update projection matrix for proper view frustum culling

		if ( cameras.length === 2 ) {

			setProjectionFromUnion( cameraVR, cameraL, cameraR );

		} else {

			// assume single camera setup (AR)

			cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

		}

		return cameraVR;

	};

	// Animation Loop

	let onAnimationFrameCallback = null;

	function onAnimationFrame( time, frame ) {

		pose = frame.getViewerPose( referenceSpace );

		if ( pose !== null ) {

			const views = pose.views;
			const baseLayer = session.renderState.baseLayer;

			state.bindXRFramebuffer( baseLayer.framebuffer );

			let cameraVRNeedsUpdate = false;

			// check if it's necessary to rebuild cameraVR's camera list

			if ( views.length !== cameraVR.cameras.length ) {

				cameraVR.cameras.length = 0;
				cameraVRNeedsUpdate = true;

			}

			for ( let i = 0; i < views.length; i ++ ) {

				const view = views[ i ];
				const viewport = baseLayer.getViewport( view );

				const camera = cameras[ i ];
				camera.matrix.fromArray( view.transform.matrix );
				camera.projectionMatrix.fromArray( view.projectionMatrix );
				camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

				if ( i === 0 ) {

					cameraVR.matrix.copy( camera.matrix );

				}

				if ( cameraVRNeedsUpdate === true ) {

					cameraVR.cameras.push( camera );

				}

			}

		}

		//

		const inputSources = session.inputSources;

		for ( let i = 0; i < controllers.length; i ++ ) {

			const controller = controllers[ i ];
			const inputSource = inputSources[ i ];

			controller.update( inputSource, frame, referenceSpace );

		}

		if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

	}

	const animation = new _webgl_WebGLAnimation_js__WEBPACK_IMPORTED_MODULE_5__["WebGLAnimation"]();
	animation.setAnimationLoop( onAnimationFrame );

	this.setAnimationLoop = function ( callback ) {

		onAnimationFrameCallback = callback;

	};

	this.dispose = function () {};

}

Object.assign( WebXRManager.prototype, _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_1__["EventDispatcher"].prototype );




/***/ }),

/***/ "../../node_modules/three/src/scenes/Fog.js":
/*!******************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/scenes/Fog.js ***!
  \******************************************************************/
/*! exports provided: Fog */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fog", function() { return Fog; });
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");


class Fog {

	constructor( color, near = 1, far = 1000 ) {

		this.name = '';

		this.color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"]( color );

		this.near = near;
		this.far = far;

	}

	clone() {

		return new Fog( this.color, this.near, this.far );

	}

	toJSON( /* meta */ ) {

		return {
			type: 'Fog',
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};

	}

}

Fog.prototype.isFog = true;




/***/ }),

/***/ "../../node_modules/three/src/scenes/FogExp2.js":
/*!**********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/scenes/FogExp2.js ***!
  \**********************************************************************/
/*! exports provided: FogExp2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FogExp2", function() { return FogExp2; });
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Color.js */ "../../node_modules/three/src/math/Color.js");


class FogExp2 {

	constructor( color, density = 0.00025 ) {

		this.name = '';

		this.color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"]( color );
		this.density = density;

	}

	clone() {

		return new FogExp2( this.color, this.density );

	}

	toJSON( /* meta */ ) {

		return {
			type: 'FogExp2',
			color: this.color.getHex(),
			density: this.density
		};

	}

}

FogExp2.prototype.isFogExp2 = true;




/***/ }),

/***/ "../../node_modules/three/src/scenes/Scene.js":
/*!********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/scenes/Scene.js ***!
  \********************************************************************/
/*! exports provided: Scene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scene", function() { return Scene; });
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Object3D.js */ "../../node_modules/three/src/core/Object3D.js");


class Scene extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__["Object3D"] {

	constructor() {

		super();

		this.type = 'Scene';

		this.background = null;
		this.environment = null;
		this.fog = null;

		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

		}

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.background !== null ) this.background = source.background.clone();
		if ( source.environment !== null ) this.environment = source.environment.clone();
		if ( source.fog !== null ) this.fog = source.fog.clone();

		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

		this.autoUpdate = source.autoUpdate;
		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
		if ( this.environment !== null ) data.object.environment = this.environment.toJSON( meta );
		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

		return data;

	}

}

Scene.prototype.isScene = true;




/***/ }),

/***/ "../../node_modules/three/src/textures/CanvasTexture.js":
/*!******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/textures/CanvasTexture.js ***!
  \******************************************************************************/
/*! exports provided: CanvasTexture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasTexture", function() { return CanvasTexture; });
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Texture.js */ "../../node_modules/three/src/textures/Texture.js");


class CanvasTexture extends _Texture_js__WEBPACK_IMPORTED_MODULE_0__["Texture"] {

	constructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		super( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.needsUpdate = true;

	}

}

CanvasTexture.prototype.isCanvasTexture = true;




/***/ }),

/***/ "../../node_modules/three/src/textures/CompressedTexture.js":
/*!**********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/textures/CompressedTexture.js ***!
  \**********************************************************************************/
/*! exports provided: CompressedTexture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedTexture", function() { return CompressedTexture; });
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Texture.js */ "../../node_modules/three/src/textures/Texture.js");


class CompressedTexture extends _Texture_js__WEBPACK_IMPORTED_MODULE_0__["Texture"] {

	constructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	}

}

CompressedTexture.prototype.isCompressedTexture = true;




/***/ }),

/***/ "../../node_modules/three/src/textures/CubeTexture.js":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/textures/CubeTexture.js ***!
  \****************************************************************************/
/*! exports provided: CubeTexture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeTexture", function() { return CubeTexture; });
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Texture.js */ "../../node_modules/three/src/textures/Texture.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");



class CubeTexture extends _Texture_js__WEBPACK_IMPORTED_MODULE_0__["Texture"] {

	constructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : _constants_js__WEBPACK_IMPORTED_MODULE_1__["CubeReflectionMapping"];
		format = format !== undefined ? format : _constants_js__WEBPACK_IMPORTED_MODULE_1__["RGBFormat"];

		super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		// Why CubeTexture._needsFlipEnvMap is necessary:
		//
		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
		// and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)
		// when using WebGLCubeRenderTarget.texture as a cube texture.

		this._needsFlipEnvMap = true;

		this.flipY = false;

	}

	get images() {

		return this.image;

	}

	set images( value ) {

		this.image = value;

	}

}

CubeTexture.prototype.isCubeTexture = true;




/***/ }),

/***/ "../../node_modules/three/src/textures/DataTexture.js":
/*!****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/textures/DataTexture.js ***!
  \****************************************************************************/
/*! exports provided: DataTexture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture", function() { return DataTexture; });
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Texture.js */ "../../node_modules/three/src/textures/Texture.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");



class DataTexture extends _Texture_js__WEBPACK_IMPORTED_MODULE_0__["Texture"] {

	constructor( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { data: data || null, width: width || 1, height: height || 1 };

		this.magFilter = magFilter !== undefined ? magFilter : _constants_js__WEBPACK_IMPORTED_MODULE_1__["NearestFilter"];
		this.minFilter = minFilter !== undefined ? minFilter : _constants_js__WEBPACK_IMPORTED_MODULE_1__["NearestFilter"];

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

		this.needsUpdate = true;

	}

}

DataTexture.prototype.isDataTexture = true;




/***/ }),

/***/ "../../node_modules/three/src/textures/DataTexture2DArray.js":
/*!***********************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/textures/DataTexture2DArray.js ***!
  \***********************************************************************************/
/*! exports provided: DataTexture2DArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture2DArray", function() { return DataTexture2DArray; });
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Texture.js */ "../../node_modules/three/src/textures/Texture.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");



class DataTexture2DArray extends _Texture_js__WEBPACK_IMPORTED_MODULE_0__["Texture"] {

	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		super( null );

		this.image = { data, width, height, depth };

		this.magFilter = _constants_js__WEBPACK_IMPORTED_MODULE_1__["NearestFilter"];
		this.minFilter = _constants_js__WEBPACK_IMPORTED_MODULE_1__["NearestFilter"];

		this.wrapR = _constants_js__WEBPACK_IMPORTED_MODULE_1__["ClampToEdgeWrapping"];

		this.generateMipmaps = false;
		this.flipY = false;

		this.needsUpdate = true;

	}

}

DataTexture2DArray.prototype.isDataTexture2DArray = true;




/***/ }),

/***/ "../../node_modules/three/src/textures/DataTexture3D.js":
/*!******************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/textures/DataTexture3D.js ***!
  \******************************************************************************/
/*! exports provided: DataTexture3D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture3D", function() { return DataTexture3D; });
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Texture.js */ "../../node_modules/three/src/textures/Texture.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");



class DataTexture3D extends _Texture_js__WEBPACK_IMPORTED_MODULE_0__["Texture"] {

	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		// We're going to add .setXXX() methods for setting properties later.
		// Users can still set in DataTexture3D directly.
		//
		//	const texture = new THREE.DataTexture3D( data, width, height, depth );
		// 	texture.anisotropy = 16;
		//
		// See #14839

		super( null );

		this.image = { data, width, height, depth };

		this.magFilter = _constants_js__WEBPACK_IMPORTED_MODULE_1__["NearestFilter"];
		this.minFilter = _constants_js__WEBPACK_IMPORTED_MODULE_1__["NearestFilter"];

		this.wrapR = _constants_js__WEBPACK_IMPORTED_MODULE_1__["ClampToEdgeWrapping"];

		this.generateMipmaps = false;
		this.flipY = false;

		this.needsUpdate = true;

	}

}

DataTexture3D.prototype.isDataTexture3D = true;




/***/ }),

/***/ "../../node_modules/three/src/textures/DepthTexture.js":
/*!*****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/textures/DepthTexture.js ***!
  \*****************************************************************************/
/*! exports provided: DepthTexture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthTexture", function() { return DepthTexture; });
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Texture.js */ "../../node_modules/three/src/textures/Texture.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");



class DepthTexture extends _Texture_js__WEBPACK_IMPORTED_MODULE_0__["Texture"] {

	constructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

		format = format !== undefined ? format : _constants_js__WEBPACK_IMPORTED_MODULE_1__["DepthFormat"];

		if ( format !== _constants_js__WEBPACK_IMPORTED_MODULE_1__["DepthFormat"] && format !== _constants_js__WEBPACK_IMPORTED_MODULE_1__["DepthStencilFormat"] ) {

			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

		}

		if ( type === undefined && format === _constants_js__WEBPACK_IMPORTED_MODULE_1__["DepthFormat"] ) type = _constants_js__WEBPACK_IMPORTED_MODULE_1__["UnsignedShortType"];
		if ( type === undefined && format === _constants_js__WEBPACK_IMPORTED_MODULE_1__["DepthStencilFormat"] ) type = _constants_js__WEBPACK_IMPORTED_MODULE_1__["UnsignedInt248Type"];

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : _constants_js__WEBPACK_IMPORTED_MODULE_1__["NearestFilter"];
		this.minFilter = minFilter !== undefined ? minFilter : _constants_js__WEBPACK_IMPORTED_MODULE_1__["NearestFilter"];

		this.flipY = false;
		this.generateMipmaps	= false;

	}


}

DepthTexture.prototype.isDepthTexture = true;




/***/ }),

/***/ "../../node_modules/three/src/textures/Texture.js":
/*!************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/textures/Texture.js ***!
  \************************************************************************/
/*! exports provided: Texture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Texture", function() { return Texture; });
/* harmony import */ var _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/EventDispatcher.js */ "../../node_modules/three/src/core/EventDispatcher.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/MathUtils.js */ "../../node_modules/three/src/math/MathUtils.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector2.js */ "../../node_modules/three/src/math/Vector2.js");
/* harmony import */ var _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Matrix3.js */ "../../node_modules/three/src/math/Matrix3.js");
/* harmony import */ var _extras_ImageUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extras/ImageUtils.js */ "../../node_modules/three/src/extras/ImageUtils.js");







let textureId = 0;

class Texture extends _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_0__["EventDispatcher"] {

	constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = _constants_js__WEBPACK_IMPORTED_MODULE_1__["ClampToEdgeWrapping"], wrapT = _constants_js__WEBPACK_IMPORTED_MODULE_1__["ClampToEdgeWrapping"], magFilter = _constants_js__WEBPACK_IMPORTED_MODULE_1__["LinearFilter"], minFilter = _constants_js__WEBPACK_IMPORTED_MODULE_1__["LinearMipmapLinearFilter"], format = _constants_js__WEBPACK_IMPORTED_MODULE_1__["RGBAFormat"], type = _constants_js__WEBPACK_IMPORTED_MODULE_1__["UnsignedByteType"], anisotropy = 1, encoding = _constants_js__WEBPACK_IMPORTED_MODULE_1__["LinearEncoding"] ) {

		super();

		Object.defineProperty( this, 'id', { value: textureId ++ } );

		this.uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__["MathUtils"].generateUUID();

		this.name = '';

		this.image = image;
		this.mipmaps = [];

		this.mapping = mapping;

		this.wrapS = wrapS;
		this.wrapT = wrapT;

		this.magFilter = magFilter;
		this.minFilter = minFilter;

		this.anisotropy = anisotropy;

		this.format = format;
		this.internalFormat = null;
		this.type = type;

		this.offset = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__["Vector2"]( 0, 0 );
		this.repeat = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__["Vector2"]( 1, 1 );
		this.center = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__["Vector2"]( 0, 0 );
		this.rotation = 0;

		this.matrixAutoUpdate = true;
		this.matrix = new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_4__["Matrix3"]();

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding;

		this.version = 0;
		this.onUpdate = null;

	}

	updateMatrix() {

		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.name = source.name;

		this.image = source.image;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.internalFormat = source.internalFormat;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );
		this.center.copy( source.center );
		this.rotation = source.rotation;

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy( source.matrix );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;

		return this;

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		const output = {

			metadata: {
				version: 4.5,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			center: [ this.center.x, this.center.y ],
			rotation: this.rotation,

			wrap: [ this.wrapS, this.wrapT ],

			format: this.format,
			type: this.type,
			encoding: this.encoding,

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY,

			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment

		};

		if ( this.image !== undefined ) {

			// TODO: Move to THREE.Image

			const image = this.image;

			if ( image.uuid === undefined ) {

				image.uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__["MathUtils"].generateUUID(); // UGH

			}

			if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

				let url;

				if ( Array.isArray( image ) ) {

					// process array of images e.g. CubeTexture

					url = [];

					for ( let i = 0, l = image.length; i < l; i ++ ) {

						// check cube texture with data textures

						if ( image[ i ].isDataTexture ) {

							url.push( serializeImage( image[ i ].image ) );

						} else {

							url.push( serializeImage( image[ i ] ) );

						}

					}

				} else {

					// process single image

					url = serializeImage( image );

				}

				meta.images[ image.uuid ] = {
					uuid: image.uuid,
					url: url
				};

			}

			output.image = image.uuid;

		}

		if ( ! isRootObject ) {

			meta.textures[ this.uuid ] = output;

		}

		return output;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	transformUv( uv ) {

		if ( this.mapping !== _constants_js__WEBPACK_IMPORTED_MODULE_1__["UVMapping"] ) return uv;

		uv.applyMatrix3( this.matrix );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case _constants_js__WEBPACK_IMPORTED_MODULE_1__["RepeatWrapping"]:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case _constants_js__WEBPACK_IMPORTED_MODULE_1__["ClampToEdgeWrapping"]:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case _constants_js__WEBPACK_IMPORTED_MODULE_1__["MirroredRepeatWrapping"]:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}

					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case _constants_js__WEBPACK_IMPORTED_MODULE_1__["RepeatWrapping"]:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case _constants_js__WEBPACK_IMPORTED_MODULE_1__["ClampToEdgeWrapping"]:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case _constants_js__WEBPACK_IMPORTED_MODULE_1__["MirroredRepeatWrapping"]:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}

					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

		return uv;

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

}

Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = _constants_js__WEBPACK_IMPORTED_MODULE_1__["UVMapping"];

Texture.prototype.isTexture = true;

function serializeImage( image ) {

	if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
		( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
		( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

		// default images

		return _extras_ImageUtils_js__WEBPACK_IMPORTED_MODULE_5__["ImageUtils"].getDataURL( image );

	} else {

		if ( image.data ) {

			// images of DataTexture

			return {
				data: Array.prototype.slice.call( image.data ),
				width: image.width,
				height: image.height,
				type: image.data.constructor.name
			};

		} else {

			console.warn( 'THREE.Texture: Unable to serialize Texture.' );
			return {};

		}

	}

}




/***/ }),

/***/ "../../node_modules/three/src/textures/VideoTexture.js":
/*!*****************************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/textures/VideoTexture.js ***!
  \*****************************************************************************/
/*! exports provided: VideoTexture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VideoTexture", function() { return VideoTexture; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "../../node_modules/three/src/constants.js");
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Texture.js */ "../../node_modules/three/src/textures/Texture.js");



class VideoTexture extends _Texture_js__WEBPACK_IMPORTED_MODULE_1__["Texture"] {

	constructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		super( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.format = format !== undefined ? format : _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBFormat"];

		this.minFilter = minFilter !== undefined ? minFilter : _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"];
		this.magFilter = magFilter !== undefined ? magFilter : _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"];

		this.generateMipmaps = false;

		const scope = this;

		function updateVideo() {

			scope.needsUpdate = true;
			video.requestVideoFrameCallback( updateVideo );

		}

		if ( 'requestVideoFrameCallback' in video ) {

			video.requestVideoFrameCallback( updateVideo );

		}

	}

	clone() {

		return new this.constructor( this.image ).copy( this );

	}

	update() {

		const video = this.image;
		const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;

		if ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {

			this.needsUpdate = true;

		}

	}

}

VideoTexture.prototype.isVideoTexture = true;




/***/ }),

/***/ "../../node_modules/three/src/utils.js":
/*!*************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/three/src/utils.js ***!
  \*************************************************************/
/*! exports provided: arrayMin, arrayMax, getTypedArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayMin", function() { return arrayMin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayMax", function() { return arrayMax; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTypedArray", function() { return getTypedArray; });
function arrayMin( array ) {

	if ( array.length === 0 ) return Infinity;

	let min = array[ 0 ];

	for ( let i = 1, l = array.length; i < l; ++ i ) {

		if ( array[ i ] < min ) min = array[ i ];

	}

	return min;

}

function arrayMax( array ) {

	if ( array.length === 0 ) return - Infinity;

	let max = array[ 0 ];

	for ( let i = 1, l = array.length; i < l; ++ i ) {

		if ( array[ i ] > max ) max = array[ i ];

	}

	return max;

}

const TYPED_ARRAYS = {
	Int8Array: Int8Array,
	Uint8Array: Uint8Array,
	Uint8ClampedArray: Uint8ClampedArray,
	Int16Array: Int16Array,
	Uint16Array: Uint16Array,
	Int32Array: Int32Array,
	Uint32Array: Uint32Array,
	Float32Array: Float32Array,
	Float64Array: Float64Array
};

function getTypedArray( type, buffer ) {

	return new TYPED_ARRAYS[ type ]( buffer );

}




/***/ }),

/***/ "../../node_modules/uri-js/dist/es5/uri.all.js":
/*!*********************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/uri-js/dist/es5/uri.all.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/** @license URI.js v4.2.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function (global, factory) {
	 true ? factory(exports) :
	undefined;
}(this, (function (exports) { 'use strict';

function merge() {
    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
    }

    if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join('');
    } else {
        return sets[0];
    }
}
function subexp(str) {
    return "(?:" + str + ")";
}
function typeOf(o) {
    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
}
function toUpperCase(str) {
    return str.toUpperCase();
}
function toArray(obj) {
    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
}
function assign(target, source) {
    var obj = target;
    if (source) {
        for (var key in source) {
            obj[key] = source[key];
        }
    }
    return obj;
}

function buildExps(isIRI) {
    var ALPHA$$ = "[A-Za-z]",
        CR$ = "[\\x0D]",
        DIGIT$$ = "[0-9]",
        DQUOTE$$ = "[\\x22]",
        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
        //case-insensitive
    LF$$ = "[\\x0A]",
        SP$$ = "[\\x20]",
        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
        //expanded
    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
        UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
        //subset, excludes bidi control characters
    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
        //subset
    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$),
        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"),
        USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"),
        DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$),
        DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
        //relaxed parsing rules
    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
        H16$ = subexp(HEXDIG$$ + "{1,4}"),
        LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
        //                           6( h16 ":" ) ls32
    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
        //                      "::" 5( h16 ":" ) ls32
    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
        //[               h16 ] "::" 4( h16 ":" ) ls32
    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
        //[ *4( h16 ":" ) h16 ] "::"              ls32
    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
        //[ *5( h16 ":" ) h16 ] "::"              h16
    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
        //[ *6( h16 ":" ) h16 ] "::"
    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"),
        //RFC 6874
    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$),
        //RFC 6874
    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$),
        //RFC 6874, with relaxed parsing rules
    IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"),
        IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"),
        //RFC 6874
    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"),
        HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$),
        PORT$ = subexp(DIGIT$$ + "*"),
        AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"),
        PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")),
        SEGMENT$ = subexp(PCHAR$ + "*"),
        SEGMENT_NZ$ = subexp(PCHAR$ + "+"),
        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"),
        PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"),
        PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"),
        //simplified
    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),
        //simplified
    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),
        //simplified
    PATH_EMPTY$ = "(?!" + PCHAR$ + ")",
        PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"),
        FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"),
        HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$),
        RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$),
        ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"),
        GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$",
        SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
    return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
    };
}
var URI_PROTOCOL = buildExps(false);

var IRI_PROTOCOL = buildExps(true);

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/** Highest positive signed 32-bit float value */

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'

/** Regular expressions */
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
var errors = {
	'overflow': 'Overflow: input needs wider integers to process',
	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error$1(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	var result = [];
	var length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	var parts = string.split('@');
	var result = '';
	if (parts.length > 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = parts[0] + '@';
		string = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, '\x2E');
	var labels = string.split('.');
	var encoded = map(labels, fn).join('.');
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	while (counter < length) {
		var value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// It's a high surrogate, and there is a next character.
			var extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) {
				// Low surrogate.
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// It's an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
var ucs2encode = function ucs2encode(array) {
	return String.fromCodePoint.apply(String, toConsumableArray(array));
};

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
var basicToDigit = function basicToDigit(codePoint) {
	if (codePoint - 0x30 < 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 < 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 < 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
var digitToBasic = function digitToBasic(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
var adapt = function adapt(delta, numPoints, firstTime) {
	var k = 0;
	delta = firstTime ? floor(delta / damp) : delta >> 1;
	delta += floor(delta / numPoints);
	for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
var decode = function decode(input) {
	// Don't use UCS-2.
	var output = [];
	var inputLength = input.length;
	var i = 0;
	var n = initialN;
	var bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	var basic = input.lastIndexOf(delimiter);
	if (basic < 0) {
		basic = 0;
	}

	for (var j = 0; j < basic; ++j) {
		// if it's not a basic code point
		if (input.charCodeAt(j) >= 0x80) {
			error$1('not-basic');
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		var oldi = i;
		for (var w = 1, k = base;; /* no condition */k += base) {

			if (index >= inputLength) {
				error$1('invalid-input');
			}

			var digit = basicToDigit(input.charCodeAt(index++));

			if (digit >= base || digit > floor((maxInt - i) / w)) {
				error$1('overflow');
			}

			i += digit * w;
			var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

			if (digit < t) {
				break;
			}

			var baseMinusT = base - t;
			if (w > floor(maxInt / baseMinusT)) {
				error$1('overflow');
			}

			w *= baseMinusT;
		}

		var out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we'll fix that now:
		if (floor(i / out) > maxInt - n) {
			error$1('overflow');
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);
	}

	return String.fromCodePoint.apply(String, output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
var encode = function encode(input) {
	var output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	var inputLength = input.length;

	// Initialize the state.
	var n = initialN;
	var delta = 0;
	var bias = initialBias;

	// Handle the basic code points.
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var _currentValue2 = _step.value;

			if (_currentValue2 < 0x80) {
				output.push(stringFromCharCode(_currentValue2));
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	var basicLength = output.length;
	var handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it's empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount < inputLength) {

		// All non-basic code points < n have been handled already. Find the next
		// larger one:
		var m = maxInt;
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var currentValue = _step2.value;

				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow.
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		var handledCPCountPlusOne = handledCPCount + 1;
		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
			error$1('overflow');
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;

		try {
			for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var _currentValue = _step3.value;

				if (_currentValue < n && ++delta > maxInt) {
					error$1('overflow');
				}
				if (_currentValue == n) {
					// Represent delta as a generalized variable-length integer.
					var q = delta;
					for (var k = base;; /* no condition */k += base) {
						var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						var qMinusT = q - t;
						var baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}

		++delta;
		++n;
	}
	return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
var toUnicode = function toUnicode(input) {
	return mapDomain(input, function (string) {
		return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
var toASCII = function toASCII(input) {
	return mapDomain(input, function (string) {
		return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
var punycode = {
	/**
  * A string representing the current Punycode.js version number.
  * @memberOf punycode
  * @type String
  */
	'version': '2.1.0',
	/**
  * An object of methods to convert from JavaScript's internal character
  * representation (UCS-2) to Unicode code points, and back.
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode
  * @type Object
  */
	'ucs2': {
		'decode': ucs2decode,
		'encode': ucs2encode
	},
	'decode': decode,
	'encode': encode,
	'toASCII': toASCII,
	'toUnicode': toUnicode
};

/**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/uri-js
 */
/**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */
var SCHEMES = {};
function pctEncChar(chr) {
    var c = chr.charCodeAt(0);
    var e = void 0;
    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
    return e;
}
function pctDecChars(str) {
    var newStr = "";
    var i = 0;
    var il = str.length;
    while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
        } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
                var c2 = parseInt(str.substr(i + 4, 2), 16);
                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
                newStr += str.substr(i, 6);
            }
            i += 6;
        } else if (c >= 224) {
            if (il - i >= 9) {
                var _c = parseInt(str.substr(i + 4, 2), 16);
                var c3 = parseInt(str.substr(i + 7, 2), 16);
                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
                newStr += str.substr(i, 9);
            }
            i += 9;
        } else {
            newStr += str.substr(i, 3);
            i += 3;
        }
    }
    return newStr;
}
function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
    }
    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
}

function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, "$1") || "0";
}
function _normalizeIPv4(host, protocol) {
    var matches = host.match(protocol.IPV4ADDRESS) || [];

    var _matches = slicedToArray(matches, 2),
        address = _matches[1];

    if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
    } else {
        return host;
    }
}
function _normalizeIPv6(host, protocol) {
    var matches = host.match(protocol.IPV6ADDRESS) || [];

    var _matches2 = slicedToArray(matches, 3),
        address = _matches2[1],
        zone = _matches2[2];

    if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
            last = _address$toLowerCase$2[0],
            first = _address$toLowerCase$2[1];

        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
        }
        if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function (acc, field, index) {
            if (!field || field === "0") {
                var lastLongest = acc[acc.length - 1];
                if (lastLongest && lastLongest.index + lastLongest.length === index) {
                    lastLongest.length++;
                } else {
                    acc.push({ index: index, length: 1 });
                }
            }
            return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function (a, b) {
            return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
            newHost = fields.join(":");
        }
        if (zone) {
            newHost += "%" + zone;
        }
        return newHost;
    } else {
        return host;
    }
}
var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
function parse(uriString) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var components = {};
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
    var matches = uriString.match(URI_PARSE);
    if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
            //store each component
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            //fix port number
            if (isNaN(components.port)) {
                components.port = matches[5];
            }
        } else {
            //IE FIX for improper RegExp matching
            //store each component
            components.scheme = matches[1] || undefined;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
            //fix port number
            if (isNaN(components.port)) {
                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
            }
        }
        if (components.host) {
            //normalize IP hosts
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        //determine reference type
        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
            components.reference = "same-document";
        } else if (components.scheme === undefined) {
            components.reference = "relative";
        } else if (components.fragment === undefined) {
            components.reference = "absolute";
        } else {
            components.reference = "uri";
        }
        //check for reference errors
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        //check if scheme can't handle IRIs
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            //if host component is a domain name
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                }
            }
            //convert IRI -> URI
            _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
            //normalize encodings
            _normalizeComponentEncoding(components, protocol);
        }
        //perform scheme specific parsing
        if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
        }
    } else {
        components.error = components.error || "URI can not be parsed.";
    }
    return components;
}

function _recomposeAuthority(components, options) {
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    if (components.userinfo !== undefined) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
    }
    if (components.host !== undefined) {
        //normalize IP hosts, add brackets and escape zone separator for IPv6
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
    }
    if (typeof components.port === "number") {
        uriTokens.push(":");
        uriTokens.push(components.port.toString(10));
    }
    return uriTokens.length ? uriTokens.join("") : undefined;
}

var RDS1 = /^\.\.?\//;
var RDS2 = /^\/\.(\/|$)/;
var RDS3 = /^\/\.\.(\/|$)/;
var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
function removeDotSegments(input) {
    var output = [];
    while (input.length) {
        if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
        } else if (input === "." || input === "..") {
            input = "";
        } else {
            var im = input.match(RDS5);
            if (im) {
                var s = im[0];
                input = input.slice(s.length);
                output.push(s);
            } else {
                throw new Error("Unexpected dot segment condition");
            }
        }
    }
    return output.join("");
}

function serialize(components) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    //find scheme handler
    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
    //perform scheme specific serialization
    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
    if (components.host) {
        //if host component is an IPv6 address
        if (protocol.IPV6ADDRESS.test(components.host)) {}
        //TODO: normalize IPv6 address as per RFC 5952

        //if host component is a domain name
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
                //convert IDN via punycode
                try {
                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
            }
    }
    //normalize encoding
    _normalizeComponentEncoding(components, protocol);
    if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
    }
    var authority = _recomposeAuthority(components, options);
    if (authority !== undefined) {
        if (options.reference !== "suffix") {
            uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
        }
    }
    if (components.path !== undefined) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
        }
        if (authority === undefined) {
            s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
        }
        uriTokens.push(s);
    }
    if (components.query !== undefined) {
        uriTokens.push("?");
        uriTokens.push(components.query);
    }
    if (components.fragment !== undefined) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
    }
    return uriTokens.join(""); //merge tokens into a string
}

function resolveComponents(base, relative) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var skipNormalization = arguments[3];

    var target = {};
    if (!skipNormalization) {
        base = parse(serialize(base, options), options); //normalize base components
        relative = parse(serialize(relative, options), options); //normalize relative components
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        //target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
    } else {
        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
        } else {
            if (!relative.path) {
                target.path = base.path;
                if (relative.query !== undefined) {
                    target.query = relative.query;
                } else {
                    target.query = base.query;
                }
            } else {
                if (relative.path.charAt(0) === "/") {
                    target.path = removeDotSegments(relative.path);
                } else {
                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                        target.path = "/" + relative.path;
                    } else if (!base.path) {
                        target.path = relative.path;
                    } else {
                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                    }
                    target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
            }
            //target.authority = base.authority;
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
        }
        target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
}

function resolve(baseURI, relativeURI, options) {
    var schemelessOptions = assign({ scheme: 'null' }, options);
    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
}

function normalize(uri, options) {
    if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
    } else if (typeOf(uri) === "object") {
        uri = parse(serialize(uri, options), options);
    }
    return uri;
}

function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
        uriA = serialize(parse(uriA, options), options);
    } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
    }
    if (typeof uriB === "string") {
        uriB = serialize(parse(uriB, options), options);
    } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
    }
    return uriA === uriB;
}

function escapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
}

function unescapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
}

var handler = {
    scheme: "http",
    domainHost: true,
    parse: function parse(components, options) {
        //report missing host
        if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
    },
    serialize: function serialize(components, options) {
        //normalize the default port
        if (components.port === (String(components.scheme).toLowerCase() !== "https" ? 80 : 443) || components.port === "") {
            components.port = undefined;
        }
        //normalize the empty path
        if (!components.path) {
            components.path = "/";
        }
        //NOTE: We do not parse query strings for HTTP URIs
        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
        //and not the HTTP spec.
        return components;
    }
};

var handler$1 = {
    scheme: "https",
    domainHost: handler.domainHost,
    parse: handler.parse,
    serialize: handler.serialize
};

var O = {};
var isIRI = true;
//RFC 3986
var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
//const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
//const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
//const VCHAR$$ = "[\\x21-\\x7E]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
//const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
//const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
//const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
var UNRESERVED = new RegExp(UNRESERVED$$, "g");
var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
var NOT_HFVALUE = NOT_HFNAME;
function decodeUnreserved(str) {
    var decStr = pctDecChars(str);
    return !decStr.match(UNRESERVED) ? str : decStr;
}
var handler$2 = {
    scheme: "mailto",
    parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = undefined;
        if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
                var hfield = hfields[x].split("=");
                switch (hfield[0]) {
                    case "to":
                        var toAddrs = hfield[1].split(",");
                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                            to.push(toAddrs[_x]);
                        }
                        break;
                    case "subject":
                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
                        break;
                    case "body":
                        mailtoComponents.body = unescapeComponent(hfield[1], options);
                        break;
                    default:
                        unknownHeaders = true;
                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                        break;
                }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
        }
        mailtoComponents.query = undefined;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e) {
                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                }
            } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
        }
        return mailtoComponents;
    },
    serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
                var toAddr = String(to[x]);
                var atIdx = toAddr.lastIndexOf("@");
                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                var domain = toAddr.slice(atIdx + 1);
                //convert IDN via punycode
                try {
                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                } catch (e) {
                    components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
                to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
            if (headers[name] !== O[name]) {
                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
        }
        if (fields.length) {
            components.query = fields.join("&");
        }
        return components;
    }
};

var URN_PARSE = /^([^\:]+)\:(.*)/;
//RFC 2141
var handler$3 = {
    scheme: "urn",
    parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = undefined;
            if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options);
            }
        } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
    },
    serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
    }
};

var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
//RFC 4122
var handler$4 = {
    scheme: "urn:uuid",
    parse: function parse(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = undefined;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
    },
    serialize: function serialize(uuidComponents, options) {
        var urnComponents = uuidComponents;
        //normalize UUID
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
    }
};

SCHEMES[handler.scheme] = handler;
SCHEMES[handler$1.scheme] = handler$1;
SCHEMES[handler$2.scheme] = handler$2;
SCHEMES[handler$3.scheme] = handler$3;
SCHEMES[handler$4.scheme] = handler$4;

exports.SCHEMES = SCHEMES;
exports.pctEncChar = pctEncChar;
exports.pctDecChars = pctDecChars;
exports.parse = parse;
exports.removeDotSegments = removeDotSegments;
exports.serialize = serialize;
exports.resolveComponents = resolveComponents;
exports.resolve = resolve;
exports.normalize = normalize;
exports.equal = equal;
exports.escapeComponent = escapeComponent;
exports.unescapeComponent = unescapeComponent;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ "../../node_modules/word-wrapper/index.js":
/*!****************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/word-wrapper/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var newline = /\n/
var newlineChar = '\n'
var whitespace = /\s/

module.exports = function(text, opt) {
    var lines = module.exports.lines(text, opt)
    return lines.map(function(line) {
        return text.substring(line.start, line.end)
    }).join('\n')
}

module.exports.lines = function wordwrap(text, opt) {
    opt = opt||{}

    //zero width results in nothing visible
    if (opt.width === 0 && opt.mode !== 'nowrap') 
        return []

    text = text||''
    var width = typeof opt.width === 'number' ? opt.width : Number.MAX_VALUE
    var start = Math.max(0, opt.start||0)
    var end = typeof opt.end === 'number' ? opt.end : text.length
    var mode = opt.mode

    var measure = opt.measure || monospace
    if (mode === 'pre')
        return pre(measure, text, start, end, width)
    else
        return greedy(measure, text, start, end, width, mode)
}

function idxOf(text, chr, start, end) {
    var idx = text.indexOf(chr, start)
    if (idx === -1 || idx > end)
        return end
    return idx
}

function isWhitespace(chr) {
    return whitespace.test(chr)
}

function pre(measure, text, start, end, width) {
    var lines = []
    var lineStart = start
    for (var i=start; i<end && i<text.length; i++) {
        var chr = text.charAt(i)
        var isNewline = newline.test(chr)

        //If we've reached a newline, then step down a line
        //Or if we've reached the EOF
        if (isNewline || i===end-1) {
            var lineEnd = isNewline ? i : i+1
            var measured = measure(text, lineStart, lineEnd, width)
            lines.push(measured)
            
            lineStart = i+1
        }
    }
    return lines
}

function greedy(measure, text, start, end, width, mode) {
    //A greedy word wrapper based on LibGDX algorithm
    //https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java
    var lines = []

    var testWidth = width
    //if 'nowrap' is specified, we only wrap on newline chars
    if (mode === 'nowrap')
        testWidth = Number.MAX_VALUE

    while (start < end && start < text.length) {
        //get next newline position
        var newLine = idxOf(text, newlineChar, start, end)

        //eat whitespace at start of line
        while (start < newLine) {
            if (!isWhitespace( text.charAt(start) ))
                break
            start++
        }

        //determine visible # of glyphs for the available width
        var measured = measure(text, start, newLine, testWidth)

        var lineEnd = start + (measured.end-measured.start)
        var nextStart = lineEnd + newlineChar.length

        //if we had to cut the line before the next newline...
        if (lineEnd < newLine) {
            //find char to break on
            while (lineEnd > start) {
                if (isWhitespace(text.charAt(lineEnd)))
                    break
                lineEnd--
            }
            if (lineEnd === start) {
                if (nextStart > start + newlineChar.length) nextStart--
                lineEnd = nextStart // If no characters to break, show all.
            } else {
                nextStart = lineEnd
                //eat whitespace at end of line
                while (lineEnd > start) {
                    if (!isWhitespace(text.charAt(lineEnd - newlineChar.length)))
                        break
                    lineEnd--
                }
            }
        }
        if (lineEnd >= start) {
            var result = measure(text, start, lineEnd, testWidth)
            lines.push(result)
        }
        start = nextStart
    }
    return lines
}

//determines the visible number of glyphs within a given width
function monospace(text, start, end, width) {
    var glyphs = Math.min(width, end-start)
    return {
        start: start,
        end: start+glyphs
    }
}

/***/ }),

/***/ "../../node_modules/xtend/immutable.js":
/*!*************************************************************!*\
  !*** /var/node/dpo-voyager/node_modules/xtend/immutable.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}


/***/ }),

/***/ "./annotations/AnnotationFactory.ts":
/*!******************************************!*\
  !*** ./annotations/AnnotationFactory.ts ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnnotationFactory; });
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
////////////////////////////////////////////////////////////////////////////////
class AnnotationFactory {
    static registerType(type) {
        if (this.types[type.typeName]) {
            throw new Error(`Annotation type '${type.typeName}' already registered.`);
        }
        this.types[type.typeName] = type;
    }
    static registerDefaultType(type) {
        this.defaultType = type;
    }
    static get typeNames() {
        return [this.defaultTypeName, ...Object.keys(this.types).sort()];
    }
    static get defaultTypeName() {
        return this.defaultType.typeName;
    }
    static getType(typeName) {
        const type = this.types[typeName] || this.defaultType;
        if (!type) {
            throw new Error(`type '${typeName}' not registered and no default type set.`);
        }
        return type;
    }
    static createInstance(annotation, typeName, assetReader) {
        typeName = typeName || annotation.data.style;
        // TODO: Combine when font loading is centralized
        return typeName === "Circle" ? new (this.getType(typeName))(annotation, assetReader) : new (this.getType(typeName))(annotation);
    }
}
AnnotationFactory.types = {};
AnnotationFactory.defaultType = null;


/***/ }),

/***/ "./annotations/AnnotationSprite.ts":
/*!*****************************************!*\
  !*** ./annotations/AnnotationSprite.ts ***!
  \*****************************************/
/*! exports provided: Annotation, html, default, AnnotationElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnnotationSprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnnotationElement", function() { return AnnotationElement; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_three_HTMLSprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/three/HTMLSprite */ "../../libs/ff-three/source/HTMLSprite.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "html", function() { return _ff_three_HTMLSprite__WEBPACK_IMPORTED_MODULE_1__["html"]; });

/* harmony import */ var _models_Annotation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../models/Annotation */ "./models/Annotation.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Annotation", function() { return _models_Annotation__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



////////////////////////////////////////////////////////////////////////////////
const _vec3up = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 1, 0);
const _vec3dir = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vec3a = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vec3b = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

/**
 * Defines the visual appearance of an annotation.
 * An annotation consists of a 3D (WebGL) part and a 2D (HTML) part.
 *
 * ### Events
 * - *"click"* Emitted if the user clicks on the annotation.
 * - *"link"* Emitted if the user activates a link on the annotation.
 */
class AnnotationSprite extends _ff_three_HTMLSprite__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(annotation, assetReader) {
        super();
        this.isAdaptive = true;
        this.annotation = annotation;
        this.matrixAutoUpdate = false;
    }
    /**
     * Returns the type name of this annotation object.
     * @returns {string}
     */
    get typeName() {
        return this.constructor.typeName;
    }
    update() {
        super.update();
        const annotation = this.annotation.data;
        this.position.fromArray(annotation.position);
        _vec3dir.fromArray(annotation.direction).normalize();
        this.quaternion.setFromUnitVectors(_vec3up, _vec3dir);
        this.updateMatrix();
    }
    emitClickEvent() {
        const event = { type: "click", annotation: this.annotation, sprite: this };
        this.dispatchEvent(event);
    }
    emitLinkEvent(link) {
        const event = { type: "link", annotation: this.annotation, sprite: this, link };
        this.dispatchEvent(event);
    }
    isBehindCamera(anchor, camera) {
        let matrixCamera = null;
        if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__["ArrayCamera"] && camera.cameras.length > 0) {
            matrixCamera = camera.cameras[0];
        }
        else {
            matrixCamera = camera;
        }
        const e = matrixCamera.matrixWorld.elements;
        anchor.updateMatrixWorld();
        _vec3a.setFromMatrixPosition(anchor.matrixWorld);
        _vec3b.setFromMatrixPosition(matrixCamera.matrixWorld);
        _vec3dir.set(-e[8], -e[9], -e[10]).normalize();
        _vec3b.addScaledVector(_vec3dir, matrixCamera.near); // add clip plane offset
        _vec3b.sub(_vec3a);
        return _vec3b.angleTo(_vec3dir) <= Math.PI / 2;
    }
}
AnnotationSprite.typeName = "Annotation";
////////////////////////////////////////////////////////////////////////////////
class AnnotationElement extends _ff_three_HTMLSprite__WEBPACK_IMPORTED_MODULE_1__["SpriteElement"] {
    constructor(sprite) {
        super();
        this.sprite = sprite;
        //this.onClick = this.onClick.bind(this);
        this.discardEvent = this.discardEvent.bind(this);
        this.addEventListener("pointerdown", this.discardEvent);
        //this.addEventListener("pointermove", this.discardEvent);
        //this.addEventListener("pointerup", this.discardEvent);
        this.addEventListener("pointercancel", this.discardEvent);
        this.addEventListener("click", this.discardEvent);
    }
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-annotation");
    }
    discardEvent(event) {
        event.stopPropagation();
    }
}


/***/ }),

/***/ "./annotations/CircleSprite.ts":
/*!*************************************!*\
  !*** ./annotations/CircleSprite.ts ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CircleSprite; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var three_bmfont_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three-bmfont-text */ "../../node_modules/three-bmfont-text/index.js");
/* harmony import */ var three_bmfont_text_shaders_msdf__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three-bmfont-text/shaders/msdf */ "../../node_modules/three-bmfont-text/shaders/msdf.js");
/* harmony import */ var _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ff/ui/CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/* harmony import */ var _ff_ui_Button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ff/ui/Button */ "../../libs/ff-ui/source/Button.ts");
/* harmony import */ var _ff_three_GPUPicker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ff/three/GPUPicker */ "../../libs/ff-three/source/GPUPicker.ts");
/* harmony import */ var _AnnotationSprite__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AnnotationSprite */ "./annotations/AnnotationSprite.ts");
/* harmony import */ var _AnnotationFactory__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./AnnotationFactory */ "./annotations/AnnotationFactory.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};








////////////////////////////////////////////////////////////////////////////////
const _vec3a = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vec3b = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _quat1 = new three__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();
const _mat4 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
class CircleSprite extends _AnnotationSprite__WEBPACK_IMPORTED_MODULE_6__["default"] {
    constructor(annotation, assetReader) {
        super(annotation);
        this._isExpanded = false;
        // Temporary until annotation scale implementation is resolved
        this.xrScale = 1.0;
        this.isWebGL2 = false;
        this._isExpanded = annotation.data.expanded;
        this.offset = new three__WEBPACK_IMPORTED_MODULE_0__["Group"]();
        this.offset.matrixAutoUpdate = false;
        this.add(this.offset);
        this.ringGeometry = new three__WEBPACK_IMPORTED_MODULE_0__["RingBufferGeometry"](0.45, 0.5, 32);
        this.ringMaterialA = new three__WEBPACK_IMPORTED_MODULE_0__["MeshBasicMaterial"]();
        this.ringMaterialB = new three__WEBPACK_IMPORTED_MODULE_0__["MeshBasicMaterial"]({
            depthFunc: three__WEBPACK_IMPORTED_MODULE_0__["GreaterDepth"],
            depthWrite: false,
            opacity: CircleSprite.behindOpacity,
            transparent: true
        });
        this.ringMesh = new three__WEBPACK_IMPORTED_MODULE_0__["Mesh"](this.ringGeometry, this.ringMaterialA);
        const ringMeshB = new three__WEBPACK_IMPORTED_MODULE_0__["Mesh"](this.ringGeometry, this.ringMaterialB);
        const innerCircle = new three__WEBPACK_IMPORTED_MODULE_0__["Mesh"](new three__WEBPACK_IMPORTED_MODULE_0__["CircleBufferGeometry"](0.45, 32), new three__WEBPACK_IMPORTED_MODULE_0__["MeshBasicMaterial"]({ color: 0, opacity: 0.65, transparent: true }));
        innerCircle.matrixAutoUpdate = false;
        innerCircle.position.set(0, 0, 0.005);
        innerCircle.updateMatrix();
        this.anchorMesh = new three__WEBPACK_IMPORTED_MODULE_0__["Mesh"](new three__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"](), new three__WEBPACK_IMPORTED_MODULE_0__["MeshBasicMaterial"]());
        this.anchorMesh.frustumCulled = false;
        this.offset.add(this.anchorMesh, this.ringMesh, ringMeshB, innerCircle);
        this.markerGeometry = null;
        this.markerA = null;
        this.markerB = null;
        assetReader.fontReader.load("fonts/Roboto-Bold").then(font => {
            this.markerMaterialA = new three__WEBPACK_IMPORTED_MODULE_0__["RawShaderMaterial"](three_bmfont_text_shaders_msdf__WEBPACK_IMPORTED_MODULE_2__["default"]({
                map: font.texture,
                transparent: true,
                color: 0xffffff,
                isWebGL2: this.isWebGL2
            }));
            this.markerMaterialB = new three__WEBPACK_IMPORTED_MODULE_0__["RawShaderMaterial"](three_bmfont_text_shaders_msdf__WEBPACK_IMPORTED_MODULE_2__["default"]({
                map: font.texture,
                transparent: true,
                opacity: CircleSprite.behindOpacity,
                color: 0xffffff,
                depthFunc: three__WEBPACK_IMPORTED_MODULE_0__["GreaterDepth"],
                depthWrite: false,
                isWebGL2: this.isWebGL2
            }));
            this.markerGeometry = three_bmfont_text__WEBPACK_IMPORTED_MODULE_1__["default"]({ font: font.descriptor });
            this.markerA = new three__WEBPACK_IMPORTED_MODULE_0__["Mesh"](this.markerGeometry, this.markerMaterialA);
            this.markerA.matrixAutoUpdate = false;
            this.markerB = new three__WEBPACK_IMPORTED_MODULE_0__["Mesh"](this.markerGeometry, this.markerMaterialB);
            this.markerB.matrixAutoUpdate = false;
            // we're async here, register marker for picking manually
            _ff_three_GPUPicker__WEBPACK_IMPORTED_MODULE_5__["default"].add(this.markerA, false);
            _ff_three_GPUPicker__WEBPACK_IMPORTED_MODULE_5__["default"].add(this.markerB, false);
            this.offset.add(this.markerA, this.markerB);
            this.update();
        });
        this.update();
    }
    update() {
        const annotation = this.annotation.data;
        const c = annotation.color;
        this.ringMaterialA.color.setRGB(c[0], c[1], c[2]);
        this.ringMaterialB.color.setRGB(c[0], c[1], c[2]);
        //this.anchorMesh.position.set(0, 0, annotation.scale * 0.1);
        if (this.markerA) {
            const length = annotation.marker.length;
            const scale = length > 1 ? 0.013 : 0.016;
            const geometry = this.markerGeometry;
            geometry.update(annotation.marker);
            geometry.computeBoundingBox();
            geometry.boundingBox.getCenter(_vec3a);
            this.markerA.position.set(-scale * (_vec3a.x + 1), scale * _vec3a.y, 0.01);
            this.markerA.scale.set(scale, -scale, -1);
            this.markerA.updateMatrix();
            this.markerB.position.set(-scale * (_vec3a.x + 1), scale * _vec3a.y, 0.01);
            this.markerB.scale.set(scale, -scale, -1);
            this.markerB.updateMatrix();
        }
        super.update();
    }
    renderHTMLElement(element, container, camera) {
        const annotation = this.annotation.data;
        let matrixCamera = null;
        const isShowing = this.annotation.data.visible;
        if (camera instanceof three__WEBPACK_IMPORTED_MODULE_0__["ArrayCamera"]) {
            matrixCamera = camera.cameras[0];
        }
        // billboard rotation
        if (matrixCamera) {
            _mat4.copy(matrixCamera.matrixWorldInverse);
        }
        else {
            _mat4.copy(camera.matrixWorldInverse);
        }
        _mat4.multiply(this.matrixWorld);
        _mat4.decompose(_vec3a, _quat1, _vec3b);
        this.offset.quaternion.copy(_quat1.invert());
        // get inverse world scale relative to user scale
        this.offset.parent.matrixWorld.decompose(_vec3a, _quat1, _vec3b);
        const invWorldScale = 1.0 / _vec3b.x * (1.0 / annotation.scale) * this.xrScale;
        // scale annotation with respect to camera distance
        const vpHeight = container.offsetHeight + 250;
        const vpScale = annotation.scale * 55 / vpHeight * invWorldScale;
        let scaleFactor = 1;
        if (camera.isPerspectiveCamera) {
            const distZ = -_vec3a.set(0, 0, 0).applyMatrix4(_mat4).z;
            const theta = camera.fov * three__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].DEG2RAD * 0.5;
            scaleFactor = Math.tan(theta) * distZ * vpScale;
        }
        else {
            scaleFactor = camera.size * 0.5 * vpScale;
        }
        this.offset.scale.setScalar(scaleFactor);
        this.offset.position.set(0, (annotation.offset + 1) * scaleFactor * 0.5, 0);
        this.offset.updateMatrix();
        // don't show if behind the camera
        this.visible = !this.isBehindCamera(this.offset, camera) && isShowing;
        if (!this.visible) {
            element.setVisible(this.visible);
        }
        if (annotation.expanded) {
            // calculate screen position of HTML sprite element
            _vec3a.set(0, 0, 0).applyMatrix4(this.anchorMesh.modelViewMatrix).applyMatrix4(camera.projectionMatrix);
            _vec3b.set(0.6, 0.5, 0).applyMatrix4(this.anchorMesh.modelViewMatrix).applyMatrix4(camera.projectionMatrix);
            const centerX = (_vec3a.x + 1) * 0.5 * container.clientWidth;
            const centerY = (1 - _vec3a.y) * 0.5 * container.clientHeight;
            const offsetX = (_vec3b.x + 1) * 0.5 * container.clientWidth - centerX;
            const offsetY = (1 - _vec3b.y) * 0.5 * container.clientHeight - centerY;
            let x = centerX + offsetX;
            let y = centerY + offsetY;
            element.classList.remove("sv-align-right", "sv-align-bottom");
            if (x + element.offsetWidth >= container.offsetWidth) {
                x = centerX - offsetX;
                element.classList.add("sv-align-right");
            }
            if (y + element.offsetHeight >= container.offsetHeight) {
                y = centerY - offsetY;
                element.classList.add("sv-align-bottom");
            }
            element.setPosition(x, y);
        }
        if (this._isExpanded !== annotation.expanded) {
            element.style.visibility = "";
            this._isExpanded = annotation.expanded;
        }
    }
    createHTMLElement() {
        return new CircleAnnotation(this);
    }
    updateHTMLElement(element) {
        element.setVisible(this.visible);
        // Stops annotation box from occasionally showing before it has been positioned
        if (this.annotation.data.expanded && this._isExpanded !== this.annotation.data.expanded) {
            element.style.visibility = "hidden";
        }
        element.requestUpdate();
    }
}
CircleSprite.typeName = "Circle";
CircleSprite.behindOpacity = 0.2;
_AnnotationFactory__WEBPACK_IMPORTED_MODULE_7__["default"].registerType(CircleSprite);
////////////////////////////////////////////////////////////////////////////////
let CircleAnnotation = class CircleAnnotation extends _AnnotationSprite__WEBPACK_IMPORTED_MODULE_6__["AnnotationElement"] {
    constructor(sprite) {
        super(sprite);
    }
    setVisible(visible) {
        // element is visible only if the annotation is in expanded state
        super.setVisible(visible && this.sprite.annotation.data.expanded);
    }
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-circle-annotation");
    }
    render() {
        const annotation = this.sprite.annotation;
        const annotationData = annotation.data;
        return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_3__["html"] `<div class="sv-title">${annotation.title}</div>
            <div class="sv-content"><p>${annotation.lead}</p></div>
            ${annotationData.articleId ? _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_3__["html"] `<ff-button inline text="Read more..." icon="document" @click=${this.onClickArticle}></ff-button>` : null}`;
    }
    onClickArticle(event) {
        event.stopPropagation();
        this.sprite.emitLinkEvent(this.sprite.annotation.data.articleId);
    }
};
CircleAnnotation = __decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_3__["customElement"])("sv-circle-annotation")
], CircleAnnotation);


/***/ }),

/***/ "./annotations/ExtendedSprite.ts":
/*!***************************************!*\
  !*** ./annotations/ExtendedSprite.ts ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ExtendedSprite; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_core_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/core/math */ "../../libs/ff-core/source/math.ts");
/* harmony import */ var _ff_core_Color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/core/Color */ "../../libs/ff-core/source/Color.ts");
/* harmony import */ var _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ff/ui/CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/* harmony import */ var _ff_ui_Button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ff/ui/Button */ "../../libs/ff-ui/source/Button.ts");
/* harmony import */ var _AnnotationSprite__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AnnotationSprite */ "./annotations/AnnotationSprite.ts");
/* harmony import */ var _AnnotationFactory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AnnotationFactory */ "./annotations/AnnotationFactory.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};







////////////////////////////////////////////////////////////////////////////////
const _quadrantClasses = ["sv-q0", "sv-q1", "sv-q2", "sv-q3"];
const _color = new _ff_core_Color__WEBPACK_IMPORTED_MODULE_2__["default"]();
const _offset = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 1, 0);
class ExtendedSprite extends _AnnotationSprite__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor(annotation) {
        super(annotation);
        this.quadrant = -1;
        this.adaptive = true;
        const points = [];
        points.push(new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0));
        points.push(new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 1, 0));
        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]().setFromPoints(points);
        const material = new three__WEBPACK_IMPORTED_MODULE_0__["LineBasicMaterial"]({ color: "#009cde", transparent: true });
        this.stemLine = new three__WEBPACK_IMPORTED_MODULE_0__["Line"](geometry, material);
        this.stemLine.frustumCulled = false;
        this.stemLine.matrixAutoUpdate = false;
        this.add(this.stemLine);
        this.update();
    }
    update() {
        const annotation = this.annotation.data;
        this.stemLine.scale.setScalar(annotation.scale);
        this.stemLine.position.y = annotation.offset;
        this.stemLine.updateMatrix();
        const material = this.stemLine.material;
        material.color.fromArray(annotation.color);
        super.update();
    }
    renderHTMLElement(element, container, camera) {
        super.renderHTMLElement(element, container, camera, this.stemLine, _offset);
        const angleOpacity = _ff_core_math__WEBPACK_IMPORTED_MODULE_1__["default"].scaleLimit(this.viewAngle * _ff_core_math__WEBPACK_IMPORTED_MODULE_1__["default"].RAD2DEG, 90, 100, 1, 0);
        const opacity = this.annotation.data.visible ? angleOpacity : 0;
        this.stemLine.material["opacity"] = opacity;
        element.setOpacity(opacity);
        // update quadrant/orientation
        if (this.orientationQuadrant !== this.quadrant) {
            element.classList.remove(_quadrantClasses[this.quadrant]);
            element.classList.add(_quadrantClasses[this.orientationQuadrant]);
            this.quadrant = this.orientationQuadrant;
        }
        // update adaptive width
        if (this.adaptive !== this.isAdaptive) {
            if (this.isAdaptive) {
                element.classList.remove("sv-static-width");
            }
            else {
                element.classList.add("sv-static-width");
            }
            this.adaptive = this.isAdaptive;
        }
        // don't show if behind the camera
        this.visible = !this.isBehindCamera(this.stemLine, camera);
    }
    createHTMLElement() {
        return new ExtendedAnnotation(this);
    }
}
ExtendedSprite.typeName = "Extended";
_AnnotationFactory__WEBPACK_IMPORTED_MODULE_6__["default"].registerType(ExtendedSprite);
////////////////////////////////////////////////////////////////////////////////
let ExtendedAnnotation = class ExtendedAnnotation extends _AnnotationSprite__WEBPACK_IMPORTED_MODULE_5__["AnnotationElement"] {
    constructor(sprite) {
        super(sprite);
        this.handler = 0;
        this.isExpanded = undefined;
        this.onClickTitle = this.onClickTitle.bind(this);
        this.onClickArticle = this.onClickArticle.bind(this);
        this.titleElement = this.appendElement("div");
        this.titleElement.classList.add("sv-title");
        this.titleElement.addEventListener("click", this.onClickTitle);
        this.wrapperElement = this.appendElement("div");
        this.contentElement = this.createElement("div", null, this.wrapperElement);
        this.contentElement.classList.add("sv-content");
    }
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-extended-annotation");
    }
    update(changedProperties) {
        super.update(changedProperties);
        const annotation = this.sprite.annotation.data;
        // update title
        this.titleElement.innerText = this.sprite.annotation.title;
        // update content
        const contentTemplate = _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_3__["html"] `<p>${this.sprite.annotation.lead}</p>
            ${annotation.articleId ? _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_3__["html"] `<ff-button inline text="Read more..." icon="document" @click=${this.onClickArticle}></ff-button>` : null}`;
        Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_3__["render"])(contentTemplate, this.contentElement);
        // update color
        _color.fromArray(annotation.color);
        this.style.borderColor = _color.toString();
        // update expanded height in case annotation changed
        if (this.isExpanded) {
            this.contentElement.style.height = "auto";
        }
        // update expanded/collapsed
        if (this.isExpanded !== annotation.expanded) {
            this.isExpanded = annotation.expanded;
            window.clearTimeout(this.handler);
            if (this.isExpanded) {
                this.classList.add("sv-expanded");
                this.contentElement.style.display = "inherit";
                this.contentElement.style.height = this.contentElement.scrollHeight + "px";
            }
            else {
                this.classList.remove("sv-expanded");
                this.contentElement.style.height = "0";
                this.handler = window.setTimeout(() => this.contentElement.style.display = "none", 300);
            }
        }
    }
    onClickTitle(event) {
        event.stopPropagation();
        this.sprite.emitClickEvent();
    }
    onClickArticle(event) {
        event.stopPropagation();
        this.sprite.emitLinkEvent(this.sprite.annotation.data.articleId);
    }
};
ExtendedAnnotation = __decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_3__["customElement"])("sv-extended-annotation")
], ExtendedAnnotation);


/***/ }),

/***/ "./annotations/StandardSprite.ts":
/*!***************************************!*\
  !*** ./annotations/StandardSprite.ts ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return StandardSprite; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_core_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/core/math */ "../../libs/ff-core/source/math.ts");
/* harmony import */ var _ff_core_Color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/core/Color */ "../../libs/ff-core/source/Color.ts");
/* harmony import */ var _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ff/ui/CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/* harmony import */ var _ff_ui_Button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ff/ui/Button */ "../../libs/ff-ui/source/Button.ts");
/* harmony import */ var _AnnotationSprite__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AnnotationSprite */ "./annotations/AnnotationSprite.ts");
/* harmony import */ var _AnnotationFactory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AnnotationFactory */ "./annotations/AnnotationFactory.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};







////////////////////////////////////////////////////////////////////////////////
const _quadrantClasses = ["sv-q0", "sv-q1", "sv-q2", "sv-q3"];
const _color = new _ff_core_Color__WEBPACK_IMPORTED_MODULE_2__["default"]();
const _offset = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 1, 0);
class StandardSprite extends _AnnotationSprite__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor(annotation) {
        super(annotation);
        this.quadrant = -1;
        this.adaptive = true;
        const points = [];
        points.push(new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0));
        points.push(new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 1, 0));
        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]().setFromPoints(points);
        const material = new three__WEBPACK_IMPORTED_MODULE_0__["LineBasicMaterial"]({ color: "#009cde", transparent: true });
        this.stemLine = new three__WEBPACK_IMPORTED_MODULE_0__["Line"](geometry, material);
        this.stemLine.frustumCulled = false;
        this.stemLine.matrixAutoUpdate = false;
        this.add(this.stemLine);
        this.update();
    }
    update() {
        const annotation = this.annotation.data;
        this.stemLine.scale.setScalar(annotation.scale);
        this.stemLine.position.y = annotation.offset;
        this.stemLine.updateMatrix();
        const material = this.stemLine.material;
        material.color.fromArray(annotation.color);
        super.update();
    }
    renderHTMLElement(element, container, camera) {
        super.renderHTMLElement(element, container, camera, this.stemLine, _offset);
        const angleOpacity = _ff_core_math__WEBPACK_IMPORTED_MODULE_1__["default"].scaleLimit(this.viewAngle * _ff_core_math__WEBPACK_IMPORTED_MODULE_1__["default"].RAD2DEG, 90, 100, 1, 0);
        const opacity = this.annotation.data.visible ? angleOpacity : 0;
        this.stemLine.material["opacity"] = opacity;
        element.setOpacity(opacity);
        // update quadrant/orientation
        if (this.orientationQuadrant !== this.quadrant) {
            element.classList.remove(_quadrantClasses[this.quadrant]);
            element.classList.add(_quadrantClasses[this.orientationQuadrant]);
            this.quadrant = this.orientationQuadrant;
        }
        // update adaptive width
        if (this.adaptive !== this.isAdaptive) {
            if (this.isAdaptive) {
                element.classList.remove("sv-static-width");
            }
            else {
                element.classList.add("sv-static-width");
            }
            this.adaptive = this.isAdaptive;
        }
        // don't show if behind the camera
        this.visible = !this.isBehindCamera(this.stemLine, camera);
    }
    createHTMLElement() {
        return new StandardAnnotation(this);
    }
}
StandardSprite.typeName = "Standard";
_AnnotationFactory__WEBPACK_IMPORTED_MODULE_6__["default"].registerDefaultType(StandardSprite);
////////////////////////////////////////////////////////////////////////////////
let StandardAnnotation = class StandardAnnotation extends _AnnotationSprite__WEBPACK_IMPORTED_MODULE_5__["AnnotationElement"] {
    constructor(sprite) {
        super(sprite);
        this.onClickTitle = this.onClickTitle.bind(this);
        this.titleElement = this.appendElement("div");
        this.titleElement.classList.add("sv-title");
        this.titleElement.addEventListener("click", this.onClickTitle);
    }
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-standard-annotation");
    }
    update(changedProperties) {
        super.update(changedProperties);
        const annotation = this.sprite.annotation.data;
        this.titleElement.innerText = this.sprite.annotation.title;
        _color.fromArray(annotation.color);
        this.style.borderColor = _color.toString();
    }
    onClickTitle(event) {
        event.stopPropagation();
        this.sprite.emitClickEvent();
    }
};
StandardAnnotation = __decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_3__["customElement"])("sv-standard-annotation")
], StandardAnnotation);


/***/ }),

/***/ "./applications/ExplorerApplication.ts":
/*!*********************************************!*\
  !*** ./applications/ExplorerApplication.ts ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ExplorerApplication; });
/* harmony import */ var _ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/browser/parseUrlParameter */ "../../libs/ff-browser/source/parseUrlParameter.ts");
/* harmony import */ var _ff_core_Commander__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/core/Commander */ "../../libs/ff-core/source/Commander.ts");
/* harmony import */ var _ff_core_TypeRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/core/TypeRegistry */ "../../libs/ff-core/source/TypeRegistry.ts");
/* harmony import */ var _ff_ui_Notification__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ff/ui/Notification */ "../../libs/ff-ui/source/Notification.ts");
/* harmony import */ var _ff_graph_System__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ff/graph/System */ "../../libs/ff-graph/source/System.ts");
/* harmony import */ var _coreTypes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./coreTypes */ "./applications/coreTypes.ts");
/* harmony import */ var _explorerTypes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./explorerTypes */ "./applications/explorerTypes.ts");
/* harmony import */ var client_templates_default_svx_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! client/templates/default.svx.json */ "./templates/default.svx.json");
var client_templates_default_svx_json__WEBPACK_IMPORTED_MODULE_7___namespace = /*#__PURE__*/__webpack_require__.t(/*! client/templates/default.svx.json */ "./templates/default.svx.json", 1);
/* harmony import */ var _components_CVDocumentProvider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../components/CVDocumentProvider */ "./components/CVDocumentProvider.ts");
/* harmony import */ var _components_CVAssetManager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../components/CVAssetManager */ "./components/CVAssetManager.ts");
/* harmony import */ var _components_CVAssetReader__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../components/CVAssetReader */ "./components/CVAssetReader.ts");
/* harmony import */ var _components_CVAnalytics__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../components/CVAnalytics */ "./components/CVAnalytics.ts");
/* harmony import */ var _components_CVToolProvider__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../components/CVToolProvider */ "./components/CVToolProvider.ts");
/* harmony import */ var _nodes_NVEngine__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../nodes/NVEngine */ "./nodes/NVEngine.ts");
/* harmony import */ var _nodes_NVDocuments__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../nodes/NVDocuments */ "./nodes/NVDocuments.ts");
/* harmony import */ var _nodes_NVTools__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../nodes/NVTools */ "./nodes/NVTools.ts");
/* harmony import */ var _ui_explorer_MainView__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../ui/explorer/MainView */ "./ui/explorer/MainView.ts");
/* harmony import */ var client_schema_model__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! client/schema/model */ "./schema/model.ts");
/* harmony import */ var client_components_CVARManager__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! client/components/CVARManager */ "./components/CVARManager.ts");
/* harmony import */ var client_components_CVInterface__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! client/components/CVInterface */ "./components/CVInterface.ts");
/* harmony import */ var client_schema_setup__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! client/schema/setup */ "./schema/setup.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





















/**
 * Voyager Explorer main application.
 */
class ExplorerApplication {
    constructor(parent, props, embedded) {
        this.props = props || {};
        console.log(ExplorerApplication.splashMessage);
        // register components
        const registry = new _ff_core_TypeRegistry__WEBPACK_IMPORTED_MODULE_2__["default"]();
        registry.add(_coreTypes__WEBPACK_IMPORTED_MODULE_5__["default"]);
        registry.add(_explorerTypes__WEBPACK_IMPORTED_MODULE_6__["default"]);
        this.commander = new _ff_core_Commander__WEBPACK_IMPORTED_MODULE_1__["default"]();
        const system = this.system = new _ff_graph_System__WEBPACK_IMPORTED_MODULE_4__["default"](registry);
        const engine = system.graph.createCustomNode(_nodes_NVEngine__WEBPACK_IMPORTED_MODULE_13__["default"]);
        system.graph.createCustomNode(_nodes_NVTools__WEBPACK_IMPORTED_MODULE_15__["default"]);
        system.graph.createCustomNode(_nodes_NVDocuments__WEBPACK_IMPORTED_MODULE_14__["default"]);
        // start timing load
        this.analytics.startTimer();
        if (parent) {
            // create a view and attach to parent
            new _ui_explorer_MainView__WEBPACK_IMPORTED_MODULE_16__["default"](this).appendTo(parent);
        }
        if (!embedded) {
            // initialize default document
            this.documentProvider.createDocument(client_templates_default_svx_json__WEBPACK_IMPORTED_MODULE_7__);
            this.evaluateProps();
        }
        //*** Support message passing over channel 2 ***//	
        /*{
            // Add listener for the intial port transfer message
            var port2;
            window.addEventListener('message', initPort);

            // Setup port for message passing
            function initPort(e) {
                port2 = e.ports[0];
                if(port2) {
                    port2.onmessage = onMessage;
                }
            }

            // Handle messages received on port2
            function onMessage(e) {
                if (ENV_DEVELOPMENT) {
                    console.log('Message received by VoyagerExplorer: "' + e.data + '"');
                }

                const analytics = system.getMainComponent(CVAnalytics);

                if (e.data === "enableAR") {
                    const ARIns = system.getMainComponent(CVARManager).ins;

                    ARIns.enabled.setValue(true);
                    analytics.sendProperty("AR.enabled", true);
                }

            }
        }*/
        // start rendering
        engine.pulse.start();
    }
    get assetManager() {
        return this.system.getMainComponent(_components_CVAssetManager__WEBPACK_IMPORTED_MODULE_9__["default"]);
    }
    get assetReader() {
        return this.system.getMainComponent(_components_CVAssetReader__WEBPACK_IMPORTED_MODULE_10__["default"]);
    }
    get documentProvider() {
        return this.system.getMainComponent(_components_CVDocumentProvider__WEBPACK_IMPORTED_MODULE_8__["default"]);
    }
    get analytics() {
        return this.system.getMainComponent(_components_CVAnalytics__WEBPACK_IMPORTED_MODULE_11__["default"]);
    }
    setBaseUrl(url) {
        this.assetManager.baseUrl = url;
    }
    loadDocument(documentPath, merge, quality, uiMode) {
        const dq = client_schema_model__WEBPACK_IMPORTED_MODULE_17__["EDerivativeQuality"][quality];
        return this.assetReader.getJSON(documentPath)
            .then(data => {
            merge = merge === undefined ? !data.lights && !data.cameras : merge;
            return this.documentProvider.amendDocument(data, documentPath, merge);
        })
            .then(document => {
            if (isFinite(dq)) {
                document.setup.viewer.ins.quality.setValue(dq);
            }
            return document;
        });
    }
    loadModel(modelPath, quality) {
        return this.documentProvider.appendModel(modelPath, quality);
    }
    loadGeometry(geoPath, colorMapPath, occlusionMapPath, normalMapPath, quality) {
        return this.documentProvider.appendGeometry(geoPath, colorMapPath, occlusionMapPath, normalMapPath, quality);
    }
    evaluateProps() {
        const props = this.props;
        const manager = this.assetManager;
        props.root = props.root || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("root") || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("r");
        props.dracoRoot = props.dracoRoot || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("dracoRoot") || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("dr");
        props.resourceRoot = props.resourceRoot || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("resourceRoot") || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("rr");
        props.document = props.document || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("document") || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("d");
        props.model = props.model || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("model") || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("m");
        props.geometry = props.geometry || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("geometry") || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("g");
        props.texture = props.texture || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("texture") || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("t");
        props.occlusion = props.occlusion || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("occlusion") || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("o");
        props.normals = props.normals || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("normals") || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("n");
        props.quality = props.quality || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("quality") || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("q");
        props.uiMode = props.uiMode || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("uiMode") || Object(_ff_browser_parseUrlParameter__WEBPACK_IMPORTED_MODULE_0__["default"])("u");
        const url = props.root || props.document || props.model || props.geometry;
        this.setBaseUrl(new URL(url || ".", window.location).href);
        // Config custom UI layout
        if (props.uiMode) {
            //if (props.uiMode.toLowerCase().indexOf("none") !== -1) {
            //    this.documentProvider.activeComponent.setup.interface.ins.visibleElements.setValue(0);
            //}
            let elementValues = 0;
            let hasValidParam = false;
            const enumNames = Object.values(client_components_CVInterface__WEBPACK_IMPORTED_MODULE_19__["EUIElements"]).filter(value => typeof value === 'string');
            const uiParams = props.uiMode.split('|');
            uiParams.forEach(param => {
                const stdParam = param.toLowerCase();
                if (enumNames.includes(stdParam)) {
                    elementValues += client_components_CVInterface__WEBPACK_IMPORTED_MODULE_19__["EUIElements"][stdParam];
                    hasValidParam = true;
                }
            });
            if (hasValidParam) {
                this.documentProvider.activeComponent.setup.interface.ins.visibleElements.setValue(elementValues);
            }
        }
        if (props.dracoRoot) {
            // Set custom Draco path
            this.assetReader.setDracoPath(props.dracoRoot);
        }
        if (props.resourceRoot) {
            // Set custom resource path
            this.assetReader.setSystemAssetPath(props.resourceRoot);
        }
        if (props.document) {
            // first loading priority: document
            props.document = props.root ? props.document : manager.getAssetName(props.document);
            this.loadDocument(props.document, undefined, props.quality, props.uiMode)
                .catch(error => _ff_ui_Notification__WEBPACK_IMPORTED_MODULE_3__["default"].show(`Failed to load document: ${error.message}`, "error"));
        }
        else if (props.model) {
            // second loading priority: model
            props.model = props.root ? props.model : manager.getAssetName(props.model);
            this.loadModel(props.model, props.quality);
        }
        else if (props.geometry) {
            // third loading priority: geometry (plus optional color texture)
            props.geometry = props.root ? props.geometry : manager.getAssetName(props.geometry);
            props.texture = props.root ? props.texture : manager.getAssetName(props.texture);
            props.occlusion = props.root ? props.occlusion : manager.getAssetName(props.occlusion);
            props.normals = props.root ? props.normals : manager.getAssetName(props.normals);
            this.loadGeometry(props.geometry, props.texture, props.occlusion, props.normals, props.quality);
        }
        else {
            // if nothing else specified, try to read "document.svx.json" from the current folder
            this.loadDocument("document.svx.json", undefined).catch(() => { });
        }
    }
    ////////////////////////////////////////////
    //** API functions for external control **//
    ////////////////////////////////////////////
    toggleAnnotations() {
        const viewerIns = this.system.getMainComponent(_components_CVDocumentProvider__WEBPACK_IMPORTED_MODULE_8__["default"]).activeComponent.setup.viewer.ins;
        const toolIns = this.system.getMainComponent(_components_CVToolProvider__WEBPACK_IMPORTED_MODULE_12__["default"]).ins;
        if (toolIns.visible.value) {
            toolIns.visible.setValue(false);
        }
        viewerIns.annotationsVisible.setValue(!viewerIns.annotationsVisible.value);
        this.analytics.sendProperty("Annotations.Visible", viewerIns.annotationsVisible.value);
    }
    toggleReader() {
        const readerIns = this.system.getMainComponent(_components_CVDocumentProvider__WEBPACK_IMPORTED_MODULE_8__["default"]).activeComponent.setup.reader.ins;
        readerIns.enabled.setValue(!readerIns.enabled.value);
        this.analytics.sendProperty("Reader.Enabled", readerIns.enabled.value);
    }
    toggleTours() {
        const tourIns = this.system.getMainComponent(_components_CVDocumentProvider__WEBPACK_IMPORTED_MODULE_8__["default"]).activeComponent.setup.tours.ins;
        const readerIns = this.system.getMainComponent(_components_CVDocumentProvider__WEBPACK_IMPORTED_MODULE_8__["default"]).activeComponent.setup.reader.ins;
        if (tourIns.enabled.value) {
            tourIns.enabled.setValue(false);
        }
        else {
            if (readerIns.enabled.value) {
                readerIns.enabled.setValue(false); // disable reader
            }
            tourIns.enabled.setValue(true); // enable tours
            tourIns.tourIndex.setValue(-1); // show tour menu
        }
        this.analytics.sendProperty("Tours.Enabled", tourIns.enabled.value);
    }
    toggleTools() {
        const toolIns = this.system.getMainComponent(_components_CVToolProvider__WEBPACK_IMPORTED_MODULE_12__["default"]).ins;
        const viewerIns = this.system.getMainComponent(_components_CVDocumentProvider__WEBPACK_IMPORTED_MODULE_8__["default"]).activeComponent.setup.viewer.ins;
        if (viewerIns.annotationsVisible.value) {
            viewerIns.annotationsVisible.setValue(false);
        }
        toolIns.visible.setValue(!toolIns.visible.value);
        this.analytics.sendProperty("Tools.Visible", toolIns.visible.value);
    }
    enableAR() {
        const ARIns = this.system.getMainComponent(client_components_CVARManager__WEBPACK_IMPORTED_MODULE_18__["default"]).ins;
        ARIns.enabled.setValue(true);
        this.analytics.sendProperty("AR.enabled", true);
    }
    // Returns an array of objects with the article data for the current scene
    getArticles() {
        const reader = this.system.getMainComponent(_components_CVDocumentProvider__WEBPACK_IMPORTED_MODULE_8__["default"]).activeComponent.setup.reader;
        const articles = reader.articles.map(entry => entry.article.data);
        return articles;
    }
    // Returns euler angles (yaw/pitch) for orbit navigation
    getCameraOrbit() {
        const orbitNavIns = this.system.getMainComponent(_components_CVDocumentProvider__WEBPACK_IMPORTED_MODULE_8__["default"]).activeComponent.setup.navigation.ins;
        return orbitNavIns.orbit.value.slice(0, 2);
    }
    // Sets euler angles (yaw/pitch) for orbit navigation
    setCameraOrbit(yaw, pitch) {
        const orbitNavIns = this.system.getMainComponent(_components_CVDocumentProvider__WEBPACK_IMPORTED_MODULE_8__["default"]).activeComponent.setup.navigation.ins;
        const yawNum = parseFloat(yaw);
        const pitchNum = parseFloat(pitch);
        if (!isNaN(yawNum) && !isNaN(pitchNum)) {
            orbitNavIns.orbit.setValue([yawNum, pitchNum, 0.0]);
        }
        else {
            console.log("Error: setCameraOrbit param is not a number.");
        }
    }
    // Set background color
    setBackgroundColor(color0, color1) {
        const backgroundIns = this.system.getMainComponent(_components_CVDocumentProvider__WEBPACK_IMPORTED_MODULE_8__["default"]).activeComponent.setup.background.ins;
        const div = document.createElement('div');
        div.id = 'temp-color';
        document.getElementsByTagName("voyager-explorer")[0].appendChild(div);
        div.style.color = color0;
        if (div.style.color !== '') {
            const convColor0 = getComputedStyle(div).color;
            const colorArray0 = convColor0.split("(")[1].split(")")[0].split(",").map(component => parseInt(component) / 255);
            backgroundIns.color0.setValue(colorArray0);
        }
        else {
            console.log("Error: Color0 param is invalid.");
        }
        if (color1) {
            div.style.color = color1;
            if (div.style.color !== '') {
                const convColor1 = getComputedStyle(div).color;
                const colorArray1 = convColor1.split("(")[1].split(")")[0].split(",").map(component => parseInt(component) / 255);
                backgroundIns.color1.setValue(colorArray1);
            }
            else {
                console.log("Error: Color1 param is invalid.");
            }
        }
        document.getElementsByTagName("voyager-explorer")[0].removeChild(div);
    }
    // Set background style (Solid, LinearGradient, RadialGradient)
    setBackgroundStyle(style) {
        const backgroundIns = this.system.getMainComponent(_components_CVDocumentProvider__WEBPACK_IMPORTED_MODULE_8__["default"]).activeComponent.setup.background.ins;
        const enumNames = Object.values(client_schema_setup__WEBPACK_IMPORTED_MODULE_20__["EBackgroundStyle"]).filter(value => typeof value === 'string');
        const foundStyle = enumNames.find(name => name.toLowerCase() === style.toLowerCase());
        if (foundStyle !== undefined) {
            backgroundIns.style.setValue(client_schema_setup__WEBPACK_IMPORTED_MODULE_20__["EBackgroundStyle"][foundStyle]);
        }
        else {
            console.log("Error: Style param is invalid.");
        }
    }
}
ExplorerApplication.splashMessage = `
  _________       .__  __  .__                        .__                ________ ________   
 /   _____/ _____ |__|/  |_|  |__   __________   ____ |__|____    ____   \\_____  \\\\______ \\  
 \\_____  \\ /     \\|  \\   __\\  |  \\ /  ___/  _ \\ /    \\|  \\__  \\  /    \\    _(__  < |    |  \\ 
 /        \\  Y Y  \\  ||  | |   Y  \\\\___ (  <_> )   |  \\  |/ __ \\|   |  \\  /       \\|    \`   \\
/_______  /__|_|  /__||__| |___|  /____  >____/|___|  /__(____  /___|  / /______  /_______  /
        \\/      \\/              \\/     \\/           \\/        \\/     \\/         \\/        \\/ 
    
Voyager - 3D Explorer and Tool Suite
3D Foundation Project
(c) 2019 Smithsonian Institution

https://3d.si.edu
https://github.com/smithsonian/dpo-voyager

-----------------------------------------------------
Version: ${"Voyager Explorer v0.13.0  DEV"}
-----------------------------------------------------
    `;
window["VoyagerExplorer"] = ExplorerApplication;


/***/ }),

/***/ "./applications/coreTypes.ts":
/*!***********************************!*\
  !*** ./applications/coreTypes.ts ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_graph_components_CGraph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/components/CGraph */ "../../libs/ff-graph/source/components/CGraph.ts");
/* harmony import */ var _ff_graph_components_CPulse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/graph/components/CPulse */ "../../libs/ff-graph/source/components/CPulse.ts");
/* harmony import */ var _ff_graph_components_CComponentProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/graph/components/CComponentProvider */ "../../libs/ff-graph/source/components/CComponentProvider.ts");
/* harmony import */ var _ff_graph_components_CNodeProvider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ff/graph/components/CNodeProvider */ "../../libs/ff-graph/source/components/CNodeProvider.ts");
/* harmony import */ var _ff_graph_components_CTweenMachine__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ff/graph/components/CTweenMachine */ "../../libs/ff-graph/source/components/CTweenMachine.ts");
/* harmony import */ var _ff_scene_components_CRenderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ff/scene/components/CRenderer */ "../../libs/ff-scene/source/components/CRenderer.ts");
/* harmony import */ var _ff_scene_components_CFullscreen__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ff/scene/components/CFullscreen */ "../../libs/ff-scene/source/components/CFullscreen.ts");
/* harmony import */ var _ff_scene_components_CPickSelection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ff/scene/components/CPickSelection */ "../../libs/ff-scene/source/components/CPickSelection.ts");
/* harmony import */ var _ff_scene_components_CScene__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ff/scene/components/CScene */ "../../libs/ff-scene/source/components/CScene.ts");
/* harmony import */ var _ff_graph_Node__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ff/graph/Node */ "../../libs/ff-graph/source/Node.ts");
/* harmony import */ var _components_CVAnalytics__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../components/CVAnalytics */ "./components/CVAnalytics.ts");
/* harmony import */ var _components_CVAssetManager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../components/CVAssetManager */ "./components/CVAssetManager.ts");
/* harmony import */ var _components_CVAssetReader__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../components/CVAssetReader */ "./components/CVAssetReader.ts");
/* harmony import */ var _components_CVDocument__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../components/CVDocument */ "./components/CVDocument.ts");
/* harmony import */ var _components_CVDocumentProvider__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../components/CVDocumentProvider */ "./components/CVDocumentProvider.ts");
/* harmony import */ var _components_CVScene__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../components/CVScene */ "./components/CVScene.ts");
/* harmony import */ var _components_CVSetup__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../components/CVSetup */ "./components/CVSetup.ts");
/* harmony import */ var _components_CVNode__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../components/CVNode */ "./components/CVNode.ts");
/* harmony import */ var _components_CVMeta__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../components/CVMeta */ "./components/CVMeta.ts");
/* harmony import */ var _components_CVModel2__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../components/CVModel2 */ "./components/CVModel2.ts");
/* harmony import */ var _components_CVAnnotations__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../components/CVAnnotations */ "./components/CVAnnotations.ts");
/* harmony import */ var _components_CVAnnotationView__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../components/CVAnnotationView */ "./components/CVAnnotationView.ts");
/* harmony import */ var _components_CVCamera__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../components/CVCamera */ "./components/CVCamera.ts");
/* harmony import */ var _components_CVDirectionalLight__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../components/CVDirectionalLight */ "./components/CVDirectionalLight.ts");
/* harmony import */ var _components_CVPointLight__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../components/CVPointLight */ "./components/CVPointLight.ts");
/* harmony import */ var _components_CVSpotLight__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../components/CVSpotLight */ "./components/CVSpotLight.ts");
/* harmony import */ var _components_CVInterface__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../components/CVInterface */ "./components/CVInterface.ts");
/* harmony import */ var _components_CVViewer__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../components/CVViewer */ "./components/CVViewer.ts");
/* harmony import */ var _components_CVReader__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../components/CVReader */ "./components/CVReader.ts");
/* harmony import */ var _components_CVOrbitNavigation__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../components/CVOrbitNavigation */ "./components/CVOrbitNavigation.ts");
/* harmony import */ var _components_CVBackground__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ../components/CVBackground */ "./components/CVBackground.ts");
/* harmony import */ var _components_CVFloor__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ../components/CVFloor */ "./components/CVFloor.ts");
/* harmony import */ var _components_CVGrid__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ../components/CVGrid */ "./components/CVGrid.ts");
/* harmony import */ var _components_CVTape__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ../components/CVTape */ "./components/CVTape.ts");
/* harmony import */ var _components_CVSlicer__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ../components/CVSlicer */ "./components/CVSlicer.ts");
/* harmony import */ var _components_CVTours__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ../components/CVTours */ "./components/CVTours.ts");
/* harmony import */ var _components_CVSnapshots__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ../components/CVSnapshots */ "./components/CVSnapshots.ts");
/* harmony import */ var _components_CVEnvironment__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ../components/CVEnvironment */ "./components/CVEnvironment.ts");
/* harmony import */ var _components_CVARManager__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ../components/CVARManager */ "./components/CVARManager.ts");
/* harmony import */ var _components_CVLanguageManager__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ../components/CVLanguageManager */ "./components/CVLanguageManager.ts");
/* harmony import */ var _nodes_NVEngine__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ../nodes/NVEngine */ "./nodes/NVEngine.ts");
/* harmony import */ var _nodes_NVDocuments__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ../nodes/NVDocuments */ "./nodes/NVDocuments.ts");
/* harmony import */ var _nodes_NVScene__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ../nodes/NVScene */ "./nodes/NVScene.ts");
/* harmony import */ var _nodes_NVNode__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ../nodes/NVNode */ "./nodes/NVNode.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// LIBRARY COMPONENTS //////////////////////////////////////////////////////////









// LIBRARY NODES ///////////////////////////////////////////////////////////////

// PROJECT COMPONENTS //////////////////////////////////////////////////////////






























// PROJECT NODES ///////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////////////
const types = [
    _ff_graph_components_CGraph__WEBPACK_IMPORTED_MODULE_0__["default"],
    _ff_graph_components_CPulse__WEBPACK_IMPORTED_MODULE_1__["default"],
    _ff_graph_components_CComponentProvider__WEBPACK_IMPORTED_MODULE_2__["default"],
    _ff_graph_components_CNodeProvider__WEBPACK_IMPORTED_MODULE_3__["default"],
    _ff_graph_components_CTweenMachine__WEBPACK_IMPORTED_MODULE_4__["default"],
    _ff_scene_components_CRenderer__WEBPACK_IMPORTED_MODULE_5__["default"],
    _ff_scene_components_CFullscreen__WEBPACK_IMPORTED_MODULE_6__["default"],
    _ff_scene_components_CPickSelection__WEBPACK_IMPORTED_MODULE_7__["default"],
    _ff_scene_components_CScene__WEBPACK_IMPORTED_MODULE_8__["default"],
    _ff_graph_Node__WEBPACK_IMPORTED_MODULE_9__["default"],
    _components_CVAnalytics__WEBPACK_IMPORTED_MODULE_10__["default"],
    _components_CVARManager__WEBPACK_IMPORTED_MODULE_38__["default"],
    _components_CVAssetManager__WEBPACK_IMPORTED_MODULE_11__["default"],
    _components_CVAssetReader__WEBPACK_IMPORTED_MODULE_12__["default"],
    _components_CVDocument__WEBPACK_IMPORTED_MODULE_13__["default"],
    _components_CVDocumentProvider__WEBPACK_IMPORTED_MODULE_14__["default"],
    _components_CVScene__WEBPACK_IMPORTED_MODULE_15__["default"],
    _components_CVSetup__WEBPACK_IMPORTED_MODULE_16__["default"],
    _components_CVNode__WEBPACK_IMPORTED_MODULE_17__["default"],
    _components_CVMeta__WEBPACK_IMPORTED_MODULE_18__["default"],
    _components_CVModel2__WEBPACK_IMPORTED_MODULE_19__["default"],
    _components_CVAnnotations__WEBPACK_IMPORTED_MODULE_20__["default"],
    _components_CVAnnotationView__WEBPACK_IMPORTED_MODULE_21__["default"],
    _components_CVCamera__WEBPACK_IMPORTED_MODULE_22__["default"],
    _components_CVDirectionalLight__WEBPACK_IMPORTED_MODULE_23__["default"],
    _components_CVPointLight__WEBPACK_IMPORTED_MODULE_24__["default"],
    _components_CVSpotLight__WEBPACK_IMPORTED_MODULE_25__["default"],
    _components_CVInterface__WEBPACK_IMPORTED_MODULE_26__["default"],
    _components_CVViewer__WEBPACK_IMPORTED_MODULE_27__["default"],
    _components_CVReader__WEBPACK_IMPORTED_MODULE_28__["default"],
    _components_CVOrbitNavigation__WEBPACK_IMPORTED_MODULE_29__["default"],
    _components_CVBackground__WEBPACK_IMPORTED_MODULE_30__["default"],
    _components_CVFloor__WEBPACK_IMPORTED_MODULE_31__["default"],
    _components_CVGrid__WEBPACK_IMPORTED_MODULE_32__["default"],
    _components_CVTape__WEBPACK_IMPORTED_MODULE_33__["default"],
    _components_CVSlicer__WEBPACK_IMPORTED_MODULE_34__["default"],
    _components_CVTours__WEBPACK_IMPORTED_MODULE_35__["default"],
    _components_CVSnapshots__WEBPACK_IMPORTED_MODULE_36__["default"],
    _components_CVEnvironment__WEBPACK_IMPORTED_MODULE_37__["default"],
    _components_CVLanguageManager__WEBPACK_IMPORTED_MODULE_39__["default"],
    _nodes_NVEngine__WEBPACK_IMPORTED_MODULE_40__["default"],
    _nodes_NVDocuments__WEBPACK_IMPORTED_MODULE_41__["default"],
    _nodes_NVScene__WEBPACK_IMPORTED_MODULE_42__["default"],
    _nodes_NVNode__WEBPACK_IMPORTED_MODULE_43__["default"],
];
/* harmony default export */ __webpack_exports__["default"] = (types);


/***/ }),

/***/ "./applications/explorerTypes.ts":
/*!***************************************!*\
  !*** ./applications/explorerTypes.ts ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _components_CVNodeProvider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/CVNodeProvider */ "./components/CVNodeProvider.ts");
/* harmony import */ var _components_CVToolProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/CVToolProvider */ "./components/CVToolProvider.ts");
/* harmony import */ var _components_CVViewTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/CVViewTool */ "./components/CVViewTool.ts");
/* harmony import */ var _components_CVRenderTool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/CVRenderTool */ "./components/CVRenderTool.ts");
/* harmony import */ var _components_CVEnvironmentTool__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/CVEnvironmentTool */ "./components/CVEnvironmentTool.ts");
/* harmony import */ var _components_CVLightTool__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/CVLightTool */ "./components/CVLightTool.ts");
/* harmony import */ var _components_CVTapeTool__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../components/CVTapeTool */ "./components/CVTapeTool.ts");
/* harmony import */ var _components_CVSliceTool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components/CVSliceTool */ "./components/CVSliceTool.ts");
/* harmony import */ var _nodes_NVTools__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../nodes/NVTools */ "./nodes/NVTools.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









////////////////////////////////////////////////////////////////////////////////
const types = [
    _components_CVNodeProvider__WEBPACK_IMPORTED_MODULE_0__["default"],
    _components_CVToolProvider__WEBPACK_IMPORTED_MODULE_1__["default"],
    _components_CVViewTool__WEBPACK_IMPORTED_MODULE_2__["default"],
    _components_CVRenderTool__WEBPACK_IMPORTED_MODULE_3__["default"],
    _components_CVEnvironmentTool__WEBPACK_IMPORTED_MODULE_4__["default"],
    _components_CVLightTool__WEBPACK_IMPORTED_MODULE_5__["default"],
    _components_CVTapeTool__WEBPACK_IMPORTED_MODULE_6__["default"],
    _components_CVSliceTool__WEBPACK_IMPORTED_MODULE_7__["default"],
    _nodes_NVTools__WEBPACK_IMPORTED_MODULE_8__["default"],
];
/* harmony default export */ __webpack_exports__["default"] = (types);


/***/ }),

/***/ "./components/CVARManager.ts":
/*!***********************************!*\
  !*** ./components/CVARManager.ts ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVARManager; });
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _ff_scene_components_CRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/scene/components/CRenderer */ "../../libs/ff-scene/source/components/CRenderer.ts");
/* harmony import */ var _ff_scene_components_CTransform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/scene/components/CTransform */ "../../libs/ff-scene/source/components/CTransform.ts");
/* harmony import */ var _ff_graph_components_CPulse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ff/graph/components/CPulse */ "../../libs/ff-graph/source/components/CPulse.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants */ "./constants.ts");
/* harmony import */ var _CVScene__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CVScene */ "./components/CVScene.ts");
/* harmony import */ var _CVSetup__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./CVSetup */ "./components/CVSetup.ts");
/* harmony import */ var client_schema_common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! client/schema/common */ "./schema/common.ts");
/* harmony import */ var client_models_Derivative__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! client/models/Derivative */ "./models/Derivative.ts");
/* harmony import */ var _CVModel2__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./CVModel2 */ "./components/CVModel2.ts");
/* harmony import */ var _CVAssetManager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./CVAssetManager */ "./components/CVAssetManager.ts");
/* harmony import */ var _CVAnnotationView__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./CVAnnotationView */ "./components/CVAnnotationView.ts");
/* harmony import */ var _xr_XRShadow__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../xr/XRShadow */ "./xr/XRShadow.ts");
/* harmony import */ var _CVDirectionalLight__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./CVDirectionalLight */ "./components/CVDirectionalLight.ts");
/* harmony import */ var client_schema_setup__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! client/schema/setup */ "./schema/setup.ts");
/* harmony import */ var _CVAnalytics__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./CVAnalytics */ "./components/CVAnalytics.ts");
/**
 * 3D Foundation Project
 * Copyright 2020 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *
 * The following is heavily adapted from the great AR work by the <model-viewer> team:
 * Copyright 2019 Google LLC. All Rights Reserved.
 * https://github.com/google/model-viewer/blob/master/packages/model-viewer/src/three-components/ARRenderer.ts
 */
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





//import * as WebXR from "../types/WebXR";












////////////////////////////////////////////////////////////////////////////////
const _matrix4 = new three__WEBPACK_IMPORTED_MODULE_4__["Matrix4"]();
const _vector3 = new three__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
//const _vector3b = new Vector3();
const _hitPosition = new three__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
const _boundingBox = new three__WEBPACK_IMPORTED_MODULE_4__["Box3"]();
const _quat = new three__WEBPACK_IMPORTED_MODULE_4__["Quaternion"]();
const ROTATION_RATE = 1.5;
const ANNOTATION_SCALE = 2.0;
class CVARManager extends _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this._shadowRoot = null;
        this.ins = this.addInputs(CVARManager.ins);
        this.outs = this.addOutputs(CVARManager.outs);
        this.arLink = document.createElement('a');
        this.raycaster = new three__WEBPACK_IMPORTED_MODULE_4__["Raycaster"]();
        this.initialHitTestSource = null;
        this.inputSource = null;
        this.transientHitTestSource = null;
        this.refSpace = null;
        this.frame = null;
        this.vScene = null;
        this.camera = null;
        this.cameraParent = null;
        this.cachedView = null;
        this.cachedQuality = null;
        this.cachedNearPlane = 0.0;
        this.xrCamera = null;
        this.hitPlane = null;
        this.selectionRing = null;
        this.session = null;
        this.setup = null;
        this.originalUnits = null;
        this.isTranslating = false;
        this.isRotating = false;
        this.isScaling = false;
        this.lastDragValueX = 0.0;
        this.lastDragValueY = 0.0;
        this.totalDrag = 0;
        this.lastScale = 0.0;
        this.lastHitPosition = new three__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
        this.lastFrameTime = 0;
        this.targetOpacity = 0.0;
        this.modelFloorOffset = 0.0;
        this.optimalCameraDistance = 0.0;
        this.shadow = null;
        this.lightTransform = null;
        this.lightsToReset = [];
        this.featuresToReset = []; // in order: floor/grid/tape/slicer/material
        this.onSessionEnded = () => {
            this.outs.isPresenting.setValue(false);
            const renderer = this.renderer.views[0].renderer;
            this.resetScene();
            // Clean up
            const hitSourceInitial = this.initialHitTestSource;
            if (hitSourceInitial != null) {
                hitSourceInitial.cancel();
                this.initialHitTestSource = null;
            }
            const hitSource = this.transientHitTestSource;
            if (hitSource != null) {
                hitSource.cancel();
                this.transientHitTestSource = null;
            }
            this.refSpace = null;
            this.frame = null;
            this.inputSource = null;
            this.xrCamera = null;
            this.cachedView = null;
            const session = this.session;
            if (session) {
                session.removeEventListener('end', this.onSessionEnded);
                session.removeEventListener('selectstart', this.onSelectStart);
                session.removeEventListener('selectend', this.onSelectEnd);
                this.session = null;
            }
            this.setup.reader.ins.enabled.off("value", this.endSession, this);
            renderer.setAnimationLoop(null);
            renderer.xr.enabled = false;
            this.outs.isPlaced.setValue(false);
            this.setup.navigation.ins.enabled.setValue(true);
            //this.pulse.start();
            this.renderer.views[0].render();
        };
        this.render = (timestamp, frame) => {
            this.frame = frame;
            const renderer = this.renderer.views[0].renderer;
            const { camera, xrCamera } = this;
            if (!frame || !frame.getViewerPose(this.refSpace)) {
                return;
            }
            // Get xr camera from Three.js to set local camera properties. TODO: More efficient use of xrcamera
            if (!xrCamera && this.session) {
                const xrCameraArray = renderer.xr.getCamera(this.camera);
                this.xrCamera = xrCameraArray.cameras[0];
                return;
            }
            else if (xrCamera) {
                camera.position.setFromMatrixPosition(xrCamera.matrixWorld);
                xrCamera.projectionMatrixInverse.copy(xrCamera.projectionMatrix).invert();
                camera.projectionMatrix.fromArray(xrCamera.projectionMatrix.elements);
                camera.projectionMatrixInverse.copy(xrCamera.projectionMatrix).invert();
            }
            // center model in front of camera while trying for initial placement
            if (this.initialHitTestSource != null && xrCamera) {
                const scene = this.vScene.scene;
                const { position } = scene;
                const radius = this.sceneNode.outs.boundingRadius.value * 2.0 + xrCamera.near; // Math.abs(this.optimalCameraDistance);
                const e = xrCamera.matrixWorld.elements;
                position.set(-e[8], -e[9], -e[10]).normalize();
                position.multiplyScalar(radius);
                position.add(camera.position);
                _boundingBox.getCenter(_vector3);
                position.add(_vector3.negate());
                scene.updateMatrix();
                scene.updateMatrixWorld();
                //this.updateBoundingBox();
            }
            this.setInitialPosition(frame);
            this.handleInput(frame);
            if (this.outs.isPlaced.value) {
                // update selection ring opacity
                const deltaT = timestamp - this.lastFrameTime;
                this.updateOpacity(deltaT, this.targetOpacity);
                this.lastFrameTime = timestamp;
            }
            // TODO: Temporary fix for Chrome depth bug
            // https://bugs.chromium.org/p/chromium/issues/detail?id=1184085
            const gl = renderer.getContext();
            gl.depthMask(false);
            gl.clear(gl.DEPTH_BUFFER_BIT);
            gl.depthMask(true);
            renderer.render(this.vScene.scene, this.camera);
        };
        this.onSelectStart = (event) => {
            if (true) {
                //console.log("WebXR Select Start");
            }
            const scene = this.vScene.scene;
            const hitSource = this.transientHitTestSource;
            if (hitSource == null) {
                return;
            }
            this.targetOpacity = 0.5;
            const fingers = this.frame.getHitTestResultsForTransientInput(hitSource);
            if (fingers.length === 1) {
                this.inputSource = event.inputSource;
                const { axes } = this.inputSource.gamepad;
                const raycaster = this.raycaster;
                raycaster.setFromCamera({ x: axes[0], y: -axes[1] }, this.xrCamera);
                const intersections = raycaster.intersectObject(this.hitPlane);
                if (intersections.length > 0) {
                    this.isTranslating = true;
                    this.lastHitPosition.copy(intersections[0].point);
                }
                else {
                    this.isRotating = true;
                }
                this.lastDragValueX = axes[0];
                this.lastDragValueY = axes[1];
            }
            else if (fingers.length === 2 /*&& scene.canScale*/) {
                this.isScaling = true;
                this.lastScale = this.getFingerSeparation(fingers) / scene.scale.x;
            }
        };
        this.onSelectEnd = () => {
            if (true) {
                //console.log("WebXR Select End");
            }
            this.targetOpacity = 0.0;
            this.totalDrag = 0.0;
            this.isTranslating = false;
            this.isRotating = false;
            this.isScaling = false;
            this.inputSource = null;
        };
    }
    get renderer() {
        return this.getMainComponent(_ff_scene_components_CRenderer__WEBPACK_IMPORTED_MODULE_1__["default"]);
    }
    get pulse() {
        return this.getMainComponent(_ff_graph_components_CPulse__WEBPACK_IMPORTED_MODULE_3__["default"]);
    }
    get sceneNode() {
        return this.getSystemComponent(_CVScene__WEBPACK_IMPORTED_MODULE_6__["default"]);
    }
    get analytics() {
        return this.system.getMainComponent(_CVAnalytics__WEBPACK_IMPORTED_MODULE_16__["default"]);
    }
    get assetManager() {
        return this.getMainComponent(_CVAssetManager__WEBPACK_IMPORTED_MODULE_11__["default"]);
    }
    get shadowRoot() {
        return this._shadowRoot;
    }
    set shadowRoot(root) {
        this._shadowRoot = root;
    }
    update() {
        const { ins, outs } = this;
        if (ins.enabled.changed) {
            let isEnabled = ins.enabled.value;
            if (isEnabled) {
                if (_constants__WEBPACK_IMPORTED_MODULE_5__["IS_WEBXR_AR_CANDIDATE"]) {
                    this.launchWebXR();
                    this.analytics.sendProperty("AR.Enabled", "WebXR");
                }
                else if (_constants__WEBPACK_IMPORTED_MODULE_5__["IS_ANDROID"]) {
                    this.launchSceneViewer();
                    this.analytics.sendProperty("AR.Enabled", "SceneViewer");
                }
                else if (_constants__WEBPACK_IMPORTED_MODULE_5__["IS_IOS"] && _constants__WEBPACK_IMPORTED_MODULE_5__["IS_AR_QUICKLOOK_CANDIDATE"]) {
                    this.launchQuickLook();
                    this.analytics.sendProperty("AR.Enabled", "QuickLook");
                }
                else {
                    isEnabled = false;
                    this.analytics.sendProperty("AR.Enabled", "Unavailable");
                }
            }
            outs.enabled.setValue(isEnabled);
        }
        return true;
    }
    launchWebXR() {
        const renderer = this.renderer.views[0].renderer;
        const sceneComponent = this.vScene = this.renderer.activeSceneComponent;
        const camera = this.camera = sceneComponent.activeCamera;
        this.cameraParent = camera.parent;
        console.log(this);
        const setup = this.setup = this.getSystemComponent(_CVSetup__WEBPACK_IMPORTED_MODULE_7__["default"]); //this.documentProvider.outs.activeDocument.value.setup;
        if (!setup) {
            return false;
        }
        const models = this.sceneNode.getGraphComponents(_CVModel2__WEBPACK_IMPORTED_MODULE_10__["default"]);
        const derivative = models[0] ? models[0].derivatives.get(client_models_Derivative__WEBPACK_IMPORTED_MODULE_9__["EDerivativeUsage"].Web3D, client_models_Derivative__WEBPACK_IMPORTED_MODULE_9__["EDerivativeQuality"].AR) : null;
        if (derivative) {
            this.setup.navigation.setChanged(true); // set changed var to disable autoZoom for bounds changes
            this.cachedQuality = models[0].ins.quality.value;
            models.forEach(model => {
                model.ins.quality.setValue(client_models_Derivative__WEBPACK_IMPORTED_MODULE_9__["EDerivativeQuality"].AR);
            });
            renderer.setAnimationLoop((time, frame) => this.render(time, frame));
            navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['hit-test'],
                optionalFeatures: ['dom-overlay'],
                domOverlay: { root: this.shadowRoot.querySelector('ff-viewport-overlay') }
            }).then(session => this.onSessionStarted(renderer, session)); //.catch(reason => { console.log("Error starting session: " + reason); }); **TODO
        }
    }
    onSessionStarted(renderer, session) {
        return __awaiter(this, void 0, void 0, function* () {
            const gl = this.renderer.views[0].renderer.getContext();
            yield gl.makeXRCompatible();
            session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl, { alpha: true }) });
            this.setupScene();
            renderer.xr.enabled = true;
            renderer.xr.setReferenceSpaceType('local');
            renderer.xr.setSession(session);
            session.addEventListener('end', this.onSessionEnded);
            this.refSpace = yield session.requestReferenceSpace('local');
            const viewerRefSpace = yield session.requestReferenceSpace('viewer');
            // Do an initial hit test (model-viewer suggested 20 deg down)
            const radians = 20 * Math.PI / 180;
            const ray = new XRRay(new DOMPoint(0, 0, 0), { x: 0, y: -Math.sin(radians), z: -Math.cos(radians) });
            session.requestHitTestSource({ space: viewerRefSpace, offsetRay: ray })
                .then(hitTestSource => {
                this.initialHitTestSource = hitTestSource;
            });
            this.outs.isPresenting.setValue(true);
            this.session = session;
            this.lastFrameTime = performance.now();
            this.setup.reader.ins.enabled.on("value", this.endSession, this);
        });
    }
    endSession() {
        if (this.session) {
            this.session.end();
        }
    }
    setupScene() {
        const { cameraParent, setup, featuresToReset } = this;
        const scene = this.sceneNode;
        if (cameraParent) {
            cameraParent.remove(this.camera);
        }
        this.setup.background.hide();
        // Disable navigation so we don't get duplicate events with dom overlay
        //this.pulse.stop();
        this.setup.navigation.ins.enabled.setValue(false);
        // Reset lights moved by navigation
        const lightNode = scene.graph.findNodeByName("Lights");
        const lightTransform = this.lightTransform = lightNode.getComponent(_ff_scene_components_CTransform__WEBPACK_IMPORTED_MODULE_2__["default"], true);
        lightTransform.ins.rotation.reset();
        // Cache extended feature values
        featuresToReset.push(setup.floor.ins.visible.value ? 1 : 0);
        featuresToReset.push(setup.grid.ins.visible.value ? 1 : 0);
        featuresToReset.push(setup.tape.ins.visible.value ? 1 : 0);
        featuresToReset.push(setup.slicer.ins.enabled.value ? 1 : 0);
        featuresToReset.push(setup.viewer.ins.shader.value);
        // Disable extended features (TODO: support some/all of these features)    
        setup.floor.ins.visible.setValue(false);
        setup.grid.ins.visible.setValue(false);
        setup.tape.ins.visible.setValue(false);
        setup.slicer.ins.enabled.setValue(false);
        if (setup.viewer.ins.shader.value !== client_schema_setup__WEBPACK_IMPORTED_MODULE_15__["EShaderMode"].Default) {
            setup.viewer.ins.shader.setValue(client_schema_setup__WEBPACK_IMPORTED_MODULE_15__["EShaderMode"].Default);
        }
        // Set scale to m
        const originalUnits = this.originalUnits = scene.ins.units.getValidatedValue();
        if (originalUnits != client_schema_common__WEBPACK_IMPORTED_MODULE_8__["EUnitType"].m) {
            this.sceneNode.ins.units.setValue(client_schema_common__WEBPACK_IMPORTED_MODULE_8__["EUnitType"].m);
        }
        // Temporary until annotation scale implementation is resolved
        const views = scene.getGraphComponents(_CVAnnotationView__WEBPACK_IMPORTED_MODULE_12__["default"]);
        views.forEach(component => {
            component.setXRScale(ANNOTATION_SCALE);
        });
        // Disable any shadow casting lights
        const lights = scene.getGraphComponents(_CVDirectionalLight__WEBPACK_IMPORTED_MODULE_14__["default"]);
        lights.forEach(light => {
            if (light.ins.shadowEnabled.value) {
                light.ins.shadowEnabled.setValue(false);
                this.lightsToReset.push(light);
            }
        });
        // Setup shadow
        this.pulse.pulse(Date.now());
        scene.update(null); // force bounding box update so shadow is correct size
        const shadow = this.shadow = new _xr_XRShadow__WEBPACK_IMPORTED_MODULE_13__["Shadow"](this.sceneNode, this.vScene.scene, 0.5);
        shadow.setIntensity(0.3);
        // Cache bounding box for placement
        _boundingBox.copy(this.sceneNode.outs.boundingBox.value);
        // Compute optimal camera distance for initial placement
        _boundingBox.getSize(_vector3);
        /*_boundingBox.getCenter(_vector3b);
        const size = Math.max(_vector3.x / this.camera.aspect, _vector3.y);
        const fovFactor = 1 / (2 * Math.tan(this.camera.fov * (180/Math.PI) * 0.5));
        this.optimalCameraDistance = (_vector3b.z + size * fovFactor + _vector3.z * 0.75);*/
        this.cachedNearPlane = this.camera.near;
        if (Math.max(_vector3.x, _vector3.y, _vector3.z) < 0.5) {
            this.camera.near = 0.01;
        }
    }
    resetScene() {
        const { camera, cameraParent, setup, featuresToReset } = this;
        const scene = this.vScene.scene;
        // Reset component camera view
        if (cameraParent) {
            cameraParent.add(camera);
        }
        camera.position.set(0, 0, 0);
        camera.rotation.set(0, 0, 0);
        camera.near = this.cachedNearPlane;
        camera.updateMatrix();
        // reset lights
        this.lightTransform.object3D.rotation.set(0, 0, 0);
        this.lightTransform.object3D.updateMatrix();
        // Reset scene and update graph
        this.sceneNode.ins.units.setValue(this.originalUnits);
        scene.position.setScalar(0);
        scene.rotation.y = 0;
        scene.scale.setScalar(1);
        scene.updateMatrix();
        scene.updateMatrixWorld(true);
        // Reset cached extended feature values
        featuresToReset.reverse();
        setup.floor.ins.visible.setValue(!!featuresToReset.pop());
        setup.grid.ins.visible.setValue(!!featuresToReset.pop());
        setup.tape.ins.visible.setValue(!!featuresToReset.pop());
        setup.slicer.ins.enabled.setValue(!!featuresToReset.pop());
        const cachedShader = featuresToReset.pop();
        if (cachedShader !== client_schema_setup__WEBPACK_IMPORTED_MODULE_15__["EShaderMode"].Default) {
            setup.viewer.ins.shader.setValue(cachedShader);
        }
        // Temporary until annotation scale implementation is resolved
        const views = this.sceneNode.getGraphComponents(_CVAnnotationView__WEBPACK_IMPORTED_MODULE_12__["default"]);
        views.forEach(component => {
            component.setXRScale(1.0);
        });
        // Reset shadowing lights
        this.lightsToReset.forEach(light => {
            light.ins.shadowEnabled.setValue(true);
        });
        this.lightsToReset.length = 0;
        setup.background.show();
        // Reset quality
        const models = this.sceneNode.getGraphComponents(_CVModel2__WEBPACK_IMPORTED_MODULE_10__["default"]);
        models.forEach(model => {
            model.ins.quality.setValue(this.cachedQuality);
        });
        // Clean up
        const hitPlane = this.hitPlane;
        if (hitPlane != null) {
            scene.remove(hitPlane);
            hitPlane.geometry.dispose();
            hitPlane.material.dispose();
            this.hitPlane = null;
        }
        const selectionRing = this.selectionRing;
        if (selectionRing != null) {
            scene.remove(selectionRing);
            selectionRing.geometry.dispose();
            selectionRing.material.dispose();
            this.selectionRing = null;
        }
        const shadow = this.shadow;
        if (shadow != null) {
            scene.remove(shadow);
            shadow.dispose();
            this.shadow = null;
        }
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    }
    // adapted from model-viewer
    setInitialPosition(frame) {
        const hitSource = this.initialHitTestSource;
        if (hitSource == null) {
            return;
        }
        const hitTestResults = frame.getHitTestResults(hitSource);
        if (hitTestResults.length == 0) {
            return;
        }
        const hit = hitTestResults[0];
        const hitPt = this.getHitPoint(hit);
        if (hitPt == null) {
            return;
        }
        this.placeModel(hitPt);
        hitSource.cancel();
        this.initialHitTestSource = null;
        const { session } = frame;
        session.addEventListener('selectstart', this.onSelectStart);
        session.addEventListener('selectend', this.onSelectEnd);
        session.requestHitTestSourceForTransientInput({ profile: 'generic-touchscreen' })
            .then(hitTestSource => {
            this.transientHitTestSource = hitTestSource;
        });
    }
    getHitPoint(hitResult) {
        const pose = hitResult.getPose(this.refSpace);
        if (pose == null) {
            return null;
        }
        const hitMatrix = _matrix4.fromArray(pose.transform.matrix);
        // Check that the y-coordinate of the normal is large enough that the normal
        // is pointing up.
        return hitMatrix.elements[5] > 0.75 ?
            _hitPosition.setFromMatrixPosition(hitMatrix) :
            null;
    }
    handleInput(frame) {
        const hitSource = this.transientHitTestSource;
        if (hitSource == null) {
            return;
        }
        if (!this.isTranslating && !this.isScaling && !this.isRotating) {
            return;
        }
        const fingers = frame.getHitTestResultsForTransientInput(hitSource);
        const scene = this.vScene.scene;
        const scale = scene.scale.x;
        // Rotating, translating and scaling are mutually exclusive operations; only
        // one can happen at a time, but we can switch during a gesture.
        if (this.isScaling) {
            if (fingers.length < 2) {
                // If we lose the second finger, stop scaling (in fact, stop processing
                // input altogether until a new gesture starts).
                this.isScaling = false;
            }
            else {
                // calculate and update scale
                const separation = this.getFingerSeparation(fingers);
                const scale = separation / this.lastScale;
                scene.scale.setScalar(scale);
                scene.position.y = this.lastHitPosition.y - this.modelFloorOffset * scene.scale.y; // set back on floor
                scene.updateMatrix();
                scene.updateMatrixWorld();
                this.shadow.setScaleAndOffset(scale, 0);
                this.updateBoundingBox();
            }
            return;
        }
        else if (fingers.length === 2 /*&& scene.canScale*/) {
            // If we were rotating or translating and we get a second finger, switch
            // to scaling instead.
            this.isTranslating = false;
            this.isRotating = false;
            this.isScaling = true;
            this.lastScale = this.getFingerSeparation(fingers) / scale;
            return;
        }
        if (this.isRotating) {
            const currentDragX = this.inputSource.gamepad.axes[0];
            scene.rotation.y += (currentDragX - this.lastDragValueX) * ROTATION_RATE;
            scene.updateMatrix();
            // undo rotation on lights
            _quat.copy(scene.quaternion);
            _quat.invert();
            this.lightTransform.object3D.rotation.setFromQuaternion(_quat);
            this.lightTransform.object3D.updateMatrix();
            this.shadow.setRotation(scene.rotation.y);
            this.lastDragValueX = currentDragX;
        }
        else if (this.isTranslating) {
            const currentDrag = this.inputSource.gamepad.axes;
            const offsetX = currentDrag[0] - this.lastDragValueX;
            const offsetY = currentDrag[1] - this.lastDragValueY;
            this.totalDrag += Math.hypot(offsetX, offsetY);
            fingers.forEach(finger => {
                if (this.totalDrag < 0.01 || finger.inputSource !== this.inputSource || finger.results.length < 1) {
                    return;
                }
                const hit = this.getHitPoint(finger.results[0]);
                if (hit == null) {
                    return;
                }
                // add difference from last hit
                _vector3.copy(hit);
                _vector3.sub(this.lastHitPosition);
                scene.position.add(_vector3);
                scene.updateMatrix();
                scene.updateMatrixWorld();
                this.lastHitPosition.copy(hit);
                this.updateBoundingBox();
            });
        }
    }
    getFingerSeparation(fingers) {
        const fingerOne = fingers[0].inputSource.gamepad.axes;
        const fingerTwo = fingers[1].inputSource.gamepad.axes;
        const deltaX = fingerTwo[0] - fingerOne[0];
        const deltaY = fingerTwo[1] - fingerOne[1];
        return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    }
    placeModel(hit) {
        const scene = this.vScene.scene;
        const { min, max } = _boundingBox;
        const boundingRadius = this.sceneNode.outs.boundingRadius.value;
        const width = Math.max((max.x - min.x) * 1.25, 0.15);
        const height = Math.max((max.z - min.z) * 1.25, 0.15);
        const centerOffsetX = (min.x + max.x) / 2.0;
        const centerOffsetZ = (min.z + max.z) / 2.0;
        this.lastHitPosition.copy(hit);
        // add interaction plane
        const hitPlane = this.hitPlane = new three__WEBPACK_IMPORTED_MODULE_4__["Mesh"](new three__WEBPACK_IMPORTED_MODULE_4__["PlaneBufferGeometry"](width, height), new three__WEBPACK_IMPORTED_MODULE_4__["MeshBasicMaterial"]());
        hitPlane.position.set(centerOffsetX, min.y, centerOffsetZ);
        hitPlane.rotation.set(-Math.PI / 2.0, 0, 0);
        hitPlane.visible = false;
        scene.add(hitPlane);
        // add selection visualization
        const roundedRectShape = new three__WEBPACK_IMPORTED_MODULE_4__["Shape"]();
        const cutOut = new three__WEBPACK_IMPORTED_MODULE_4__["Shape"]();
        const thickness = width > height ? width * 0.025 : height * 0.025;
        this.roundedRect(roundedRectShape, -width / 2.0, -height / 2.0, width, height, thickness * 0.5);
        this.roundedRect(cutOut, -width / 2.0 + thickness, -height / 2.0 + thickness, width - 2 * thickness, height - 2 * thickness, thickness * 0.4);
        roundedRectShape.holes.push(cutOut);
        let geometry = new three__WEBPACK_IMPORTED_MODULE_4__["ShapeBufferGeometry"](roundedRectShape);
        const selectionRing = this.selectionRing = new three__WEBPACK_IMPORTED_MODULE_4__["Mesh"](geometry, new three__WEBPACK_IMPORTED_MODULE_4__["MeshBasicMaterial"]({ side: three__WEBPACK_IMPORTED_MODULE_4__["DoubleSide"], opacity: 0.0 }));
        selectionRing.position.set(centerOffsetX, min.y, centerOffsetZ);
        selectionRing.rotation.set(-Math.PI / 2.0, 0, 0);
        selectionRing.material.transparent = true;
        selectionRing.visible = false;
        scene.add(selectionRing);
        this.modelFloorOffset = min.y;
        //console.log("Placing in AR: " + hit.x + " " + (hit.y-min.y) + " " + hit.z);
        scene.position.set(hit.x, hit.y - min.y, hit.z);
        scene.updateMatrix();
        scene.updateMatrixWorld(true);
        this.updateBoundingBox();
        this.pulse.pulse(Date.now());
        // if we are not far enough away from the model, shift
        // edge of bounding box to hitpoint so it is in view
        const origin = this.camera.position.clone();
        const placementVector = hit.clone().sub(origin);
        if (placementVector.length() < boundingRadius) {
            const direction = placementVector.normalize();
            // Pull camera back enough to be outside of large models.
            origin.sub(direction.multiplyScalar(boundingRadius * 1.5));
            const ray = new three__WEBPACK_IMPORTED_MODULE_4__["Ray"](origin, direction.normalize());
            const modelPosition = new three__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
            // Make the box tall so that we don't intersect the top face.
            max.y += 10;
            ray.intersectBox(this.sceneNode.outs.boundingBox.value, modelPosition);
            max.y -= 10;
            if (modelPosition != null) {
                scene.position.x += hit.x - modelPosition.x;
                scene.position.z += hit.z - modelPosition.z;
                scene.updateMatrix();
                scene.updateMatrixWorld(true);
                //console.log("Pushing in AR: " + scene.position.x + " " + (hit.y-min.y) + " " + scene.position.z );
            }
        }
        this.updateBoundingBox();
        this.outs.isPlaced.setValue(true);
    }
    launchSceneViewer() {
        const models = this.sceneNode.getGraphComponents(_CVModel2__WEBPACK_IMPORTED_MODULE_10__["default"]);
        const svIndex = models.findIndex(model => { return model.derivatives.get(client_models_Derivative__WEBPACK_IMPORTED_MODULE_9__["EDerivativeUsage"].App3D, client_models_Derivative__WEBPACK_IMPORTED_MODULE_9__["EDerivativeQuality"].AR) !== null; });
        const derivative = svIndex > -1 ? models[svIndex].derivatives.get(client_models_Derivative__WEBPACK_IMPORTED_MODULE_9__["EDerivativeUsage"].App3D, client_models_Derivative__WEBPACK_IMPORTED_MODULE_9__["EDerivativeQuality"].AR) : null;
        if (derivative) {
            const linkElement = this.arLink;
            const modelAsset = derivative.findAsset(client_models_Derivative__WEBPACK_IMPORTED_MODULE_9__["EAssetType"].Model);
            const url = this.assetManager.getAssetUrl(modelAsset.data.uri);
            const intent = `intent://arvr.google.com/scene-viewer/1.0?file=${url}&mode=ar_only#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;end;`;
            linkElement.setAttribute('href', intent);
            linkElement.click();
        }
    }
    launchQuickLook() {
        const models = this.sceneNode.getGraphComponents(_CVModel2__WEBPACK_IMPORTED_MODULE_10__["default"]);
        const iOSIndex = models.findIndex(model => { return model.derivatives.get(client_models_Derivative__WEBPACK_IMPORTED_MODULE_9__["EDerivativeUsage"].iOSApp3D, client_models_Derivative__WEBPACK_IMPORTED_MODULE_9__["EDerivativeQuality"].AR) !== null; });
        const derivative = iOSIndex > -1 ? models[iOSIndex].derivatives.get(client_models_Derivative__WEBPACK_IMPORTED_MODULE_9__["EDerivativeUsage"].iOSApp3D, client_models_Derivative__WEBPACK_IMPORTED_MODULE_9__["EDerivativeQuality"].AR) : null;
        if (derivative) {
            const linkElement = this.arLink;
            const modelAsset = derivative.findAsset(client_models_Derivative__WEBPACK_IMPORTED_MODULE_9__["EAssetType"].Model);
            const url = this.assetManager.getAssetUrl(modelAsset.data.uri);
            linkElement.setAttribute('rel', 'ar');
            const img = document.createElement('img');
            linkElement.appendChild(img);
            linkElement.setAttribute('href', url.toString());
            linkElement.click();
            linkElement.removeChild(img);
        }
    }
    // Update scene bounding box to ensure dependent functionality works correctly
    updateBoundingBox() {
        this.sceneNode.ins.sceneTransformed.set();
    }
    // Animate opacity based on time delta
    updateOpacity(deltaT, target) {
        const material = this.selectionRing.material;
        const currentOpacity = material.opacity;
        if (target === currentOpacity) {
            return;
        }
        const deltaO = target - currentOpacity;
        material.opacity = deltaO > 0 ? Math.min(currentOpacity + 0.002 * deltaT, target) : Math.max(currentOpacity - 0.002 * deltaT, target);
        this.selectionRing.visible = material.opacity > 0;
    }
    // Helper function to generate rounded rectangle shape from Three.js example:
    // https://github.com/mrdoob/three.js/blob/dev/examples/webgl_geometry_shapes.html
    roundedRect(ctx, x, y, width, height, radius) {
        ctx.moveTo(x, y + radius);
        ctx.lineTo(x, y + height - radius);
        ctx.quadraticCurveTo(x, y + height, x + radius, y + height);
        ctx.lineTo(x + width - radius, y + height);
        ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
        ctx.lineTo(x + width, y + radius);
        ctx.quadraticCurveTo(x + width, y, x + width - radius, y);
        ctx.lineTo(x + radius, y);
        ctx.quadraticCurveTo(x, y, x, y + radius);
    }
}
CVARManager.typeName = "CVARManager";
CVARManager.text = "ARManager";
CVARManager.icon = "";
CVARManager.isSystemSingleton = true;
CVARManager.ins = {
    enabled: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("State.Enabled")
};
CVARManager.outs = {
    enabled: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("State.Enabled"),
    available: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("State.Available", _constants__WEBPACK_IMPORTED_MODULE_5__["IS_MOBILE"]),
    isPlaced: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("AR.Placed", false),
    isPresenting: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("AR.Presenting", false)
};


/***/ }),

/***/ "./components/CVAnalytics.ts":
/*!***********************************!*\
  !*** ./components/CVAnalytics.ts ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVAnalytics; });
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

////////////////////////////////////////////////////////////////////////////////
class CVAnalytics extends _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this._title = "Untitled";
        this._timerStart = 0;
    }
    startTimer() {
        if (this._timerStart === 0)
            this._timerStart = Date.now();
    }
    resetTimer() {
        this._timerStart = 0;
    }
    getTimerTime() {
        return this._timerStart > 0 ? Date.now() - this._timerStart : 0;
    }
    setTitle(title) {
        this._title = title;
    }
    sendProperty(property, value) {
        if ( true && value !== undefined) {
            console.log("GA Event %s %s", property, value.toString());
        }
        // track custom event
        if (typeof ga === "function" && false) {
            const text = value !== undefined ? value.toString() : undefined;
            ga("send", "event", this._title, property, text);
        }
    }
}
CVAnalytics.typeName = "CVAnalytics";
CVAnalytics.text = "Analytics";
CVAnalytics.icon = "";
CVAnalytics.isSystemSingleton = true;


/***/ }),

/***/ "./components/CVAnnotationView.ts":
/*!****************************************!*\
  !*** ./components/CVAnnotationView.ts ***!
  \****************************************/
/*! exports provided: Annotation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVAnnotationView; });
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _ff_three_HTMLSpriteGroup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/three/HTMLSpriteGroup */ "../../libs/ff-three/source/HTMLSpriteGroup.ts");
/* harmony import */ var _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/scene/components/CObject3D */ "../../libs/ff-scene/source/components/CObject3D.ts");
/* harmony import */ var _ff_scene_components_CRenderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ff/scene/components/CRenderer */ "../../libs/ff-scene/source/components/CRenderer.ts");
/* harmony import */ var _CVModel2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CVModel2 */ "./components/CVModel2.ts");
/* harmony import */ var _CVMeta__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CVMeta */ "./components/CVMeta.ts");
/* harmony import */ var _CVReader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CVReader */ "./components/CVReader.ts");
/* harmony import */ var _utils_unitScaleFactor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/unitScaleFactor */ "./utils/unitScaleFactor.ts");
/* harmony import */ var _models_Annotation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../models/Annotation */ "./models/Annotation.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Annotation", function() { return _models_Annotation__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _annotations_AnnotationFactory__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../annotations/AnnotationFactory */ "./annotations/AnnotationFactory.ts");
/* harmony import */ var _annotations_StandardSprite__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../annotations/StandardSprite */ "./annotations/StandardSprite.ts");
/* harmony import */ var _annotations_ExtendedSprite__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../annotations/ExtendedSprite */ "./annotations/ExtendedSprite.ts");
/* harmony import */ var _annotations_CircleSprite__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../annotations/CircleSprite */ "./annotations/CircleSprite.ts");
/* harmony import */ var _CVARManager__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./CVARManager */ "./components/CVARManager.ts");
/* harmony import */ var _CVLanguageManager__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./CVLanguageManager */ "./components/CVLanguageManager.ts");
/* harmony import */ var client_schema_common__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! client/schema/common */ "./schema/common.ts");
/* harmony import */ var _CVAssetReader__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./CVAssetReader */ "./components/CVAssetReader.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

















////////////////////////////////////////////////////////////////////////////////

class CVAnnotationView extends _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(node, id) {
        super(node, id);
        this.ins = this.addInputs(CVAnnotationView.ins);
        this._activeAnnotation = null;
        this._annotations = {};
        this._viewports = new Set();
        this._sprites = {};
        this.addEvents("active-annotation", "group");
        this.onSpriteClick = this.onSpriteClick.bind(this);
        this.onSpriteLink = this.onSpriteLink.bind(this);
        this.on("pointer-up", this.onPointerUp, this);
        this.system.on("pointer-up", this.onSystemPointerUp, this);
        this.arManager.outs.isPresenting.on("value", this.handleARStateChange, this);
        this.language.outs.language.on("value", this.updateLanguage, this);
        this.object3D = new _ff_three_HTMLSpriteGroup__WEBPACK_IMPORTED_MODULE_1__["default"]();
    }
    get model() {
        return this.getComponent(_CVModel2__WEBPACK_IMPORTED_MODULE_4__["default"]);
    }
    get meta() {
        return this.getComponent(_CVMeta__WEBPACK_IMPORTED_MODULE_5__["default"], true);
    }
    get reader() {
        return this.getGraphComponent(_CVReader__WEBPACK_IMPORTED_MODULE_6__["default"], true);
    }
    get language() {
        return this.getGraphComponent(_CVLanguageManager__WEBPACK_IMPORTED_MODULE_14__["default"], true);
    }
    get articles() {
        const meta = this.meta;
        return meta ? meta.articles : null;
    }
    get arManager() {
        return this.system.getMainComponent(_CVARManager__WEBPACK_IMPORTED_MODULE_13__["default"]);
    }
    get renderer() {
        return this.getMainComponent(_ff_scene_components_CRenderer__WEBPACK_IMPORTED_MODULE_3__["default"]);
    }
    get assetReader() {
        return this.getMainComponent(_CVAssetReader__WEBPACK_IMPORTED_MODULE_16__["default"]);
    }
    get activeAnnotation() {
        return this._activeAnnotation;
    }
    set activeAnnotation(annotation) {
        if (annotation !== this._activeAnnotation) {
            const previous = this._activeAnnotation;
            if (previous) {
                previous.set("expanded", false);
                this.updateSprite(previous);
            }
            this._activeAnnotation = annotation;
            if (annotation) {
                annotation.set("expanded", true);
                this.updateSprite(annotation);
            }
            const ins = this.ins;
            ins.marker.setValue(annotation ? annotation.data.marker : "", true);
            ins.title.setValue(annotation ? annotation.title : "", true);
            ins.lead.setValue(annotation ? annotation.lead : "", true);
            ins.tags.setValue(annotation ? annotation.tags.join(", ") : "", true);
            ins.style.setOption(annotation ? annotation.data.style : _annotations_AnnotationFactory__WEBPACK_IMPORTED_MODULE_9__["default"].defaultTypeName, true);
            ins.scale.setValue(annotation ? annotation.data.scale : 1, true);
            ins.offset.setValue(annotation ? annotation.data.offset : 0, true);
            ins.tilt.setValue(annotation ? annotation.data.tilt : 0, true);
            ins.azimuth.setValue(annotation ? annotation.data.azimuth : 0, true);
            ins.color.setValue(annotation ? annotation.data.color.slice() : [1, 1, 1], true);
            const articles = this.articles;
            if (articles) {
                const names = articles.items.map(article => article.title);
                names.unshift("(none)");
                ins.article.setOptions(names);
                const article = annotation ? articles.getById(annotation.data.articleId) : null;
                ins.article.setValue(article ? articles.getIndexOf(article) + 1 : 0, true);
            }
            else {
                ins.article.setOptions(["(none)"]);
                ins.article.setValue(0);
            }
            ins.image.setValue(annotation ? annotation.data.imageUri : "", true);
            this.emit({ type: "annotation-update", annotation });
        }
    }
    setActiveAnnotationById(id) {
        this.activeAnnotation = this._annotations[id];
    }
    update(context) {
        super.update(context);
        const ins = this.ins;
        const object3D = this.object3D;
        const annotation = this.activeAnnotation;
        if (ins.unitScale.changed) {
            object3D.scale.setScalar(ins.unitScale.value);
            object3D.updateMatrix();
        }
        if (ins.activeTags.changed) {
            const activeTags = ins.activeTags.value.split(",").map(tag => tag.trim()).filter(tag => tag);
            for (const key in this._annotations) {
                const annotation = this._annotations[key];
                const tags = annotation.tags;
                let visible = tags.length === 0; // annotation is visible by default if no tags
                activeTags.forEach(tag => {
                    if (tags.indexOf(tag) >= 0) {
                        visible = true;
                    }
                });
                annotation.set("visible", visible);
                this.updateSprite(annotation);
            }
        }
        if (annotation) {
            if (ins.marker.changed) {
                annotation.set("marker", ins.marker.value);
            }
            if (ins.title.changed) {
                annotation.title = ins.title.value;
            }
            if (ins.lead.changed) {
                annotation.lead = ins.lead.value;
            }
            if (ins.tags.changed) {
                annotation.tags = ins.tags.value.split(",").map(tag => tag.trim()).filter(tag => tag);
                this.emit({ type: "tag-update" });
            }
            if (ins.style.changed) {
                annotation.set("style", ins.style.getOptionText());
                this.createSprite(annotation);
            }
            if (ins.scale.changed) {
                annotation.set("scale", ins.scale.value * Object(_utils_unitScaleFactor__WEBPACK_IMPORTED_MODULE_7__["default"])(client_schema_common__WEBPACK_IMPORTED_MODULE_15__["EUnitType"].m, this.model.ins.localUnits.getValidatedValue()) * 0.01);
            }
            if (ins.offset.changed) {
                annotation.set("offset", ins.offset.value * Object(_utils_unitScaleFactor__WEBPACK_IMPORTED_MODULE_7__["default"])(client_schema_common__WEBPACK_IMPORTED_MODULE_15__["EUnitType"].m, this.model.ins.localUnits.getValidatedValue()) * 0.01);
            }
            if (ins.tilt.changed) {
                annotation.set("tilt", ins.tilt.value);
            }
            if (ins.azimuth.changed) {
                annotation.set("azimuth", ins.azimuth.value);
            }
            if (ins.color.changed) {
                annotation.set("color", ins.color.value.slice());
            }
            if (ins.image.changed) {
                annotation.set("imageUri", ins.image.value);
            }
            if (ins.article.changed) {
                const articles = this.articles;
                const article = articles && articles.getAt(ins.article.getValidatedValue() - 1);
                annotation.set("articleId", article ? article.id : "");
            }
            this.updateSprite(annotation);
            this.emit({ type: "annotation-update", annotation });
        }
        return true;
    }
    tock() {
        // if updated, render a second frame to properly update annotation sprites
        if (this.updated) {
            return true;
        }
    }
    postRender(context) {
        const viewport = context.viewport;
        if (!this._viewports.has(viewport)) {
            viewport.on("dispose", this.onViewportDispose, this);
            this._viewports.add(viewport);
        }
        const spriteGroup = this.object3D;
        spriteGroup.render(viewport.overlay, context.camera);
    }
    dispose() {
        this.object3D.dispose();
        this.off("pointer-up", this.onPointerUp, this);
        this.system.off("pointer-up", this.onSystemPointerUp, this);
        this.arManager.outs.isPresenting.off("value", this.handleARStateChange, this);
        this.language.outs.language.off("value", this.updateLanguage, this);
        this._viewports.forEach(viewport => viewport.off("dispose", this.onViewportDispose, this));
        this._viewports.clear();
        super.dispose();
    }
    getAnnotations() {
        return Object.keys(this._annotations).map(key => this._annotations[key]);
    }
    // getAnnotationById(id: string)
    // {
    //     return this._annotations[id];
    // }
    addAnnotation(annotation) {
        this._annotations[annotation.id] = annotation;
        this.createSprite(annotation);
        // update langauges used in annotations
        Object.keys(annotation.data.titles).forEach(key => {
            this.language.addLanguage(client_schema_common__WEBPACK_IMPORTED_MODULE_15__["ELanguageType"][key]);
        });
        Object.keys(annotation.data.leads).forEach(key => {
            this.language.addLanguage(client_schema_common__WEBPACK_IMPORTED_MODULE_15__["ELanguageType"][key]);
        });
        // set webgl2 for circle annotations
        for (const key in this._annotations) {
            const annotation = this._annotations[key];
            if (annotation.get("style") === "Circle") {
                const sprite = this._sprites[annotation.id];
                if (sprite) {
                    sprite.isWebGL2 = this.renderer.views[0].renderer.capabilities.isWebGL2;
                }
            }
        }
        this.changed = true;
    }
    removeAnnotation(annotation) {
        const keys = Object.keys(this._annotations);
        delete this._annotations[annotation.id];
        this.removeSprite(annotation);
        if (annotation === this.activeAnnotation) {
            // select next annotation as active annotation
            const index = Math.min(keys.indexOf(annotation.id) + 1, keys.length - 1);
            this.activeAnnotation = index < 0 ? null : this._annotations[keys[index]];
            if (annotation.tags.length > 0) {
                this.emit({ type: "tag-update" });
            }
        }
        this.changed = true;
    }
    updateAnnotation(annotation) {
        //this.updateSprite(annotation);
        this.changed = true;
    }
    toJSON() {
        const json = super.toJSON();
        const data = this.toData();
        if (data) {
            json.data = data;
        }
        return json;
    }
    fromJSON(json) {
        if (json.data) {
            this.fromData(json.data);
        }
    }
    toData() {
        const keys = Object.keys(this._annotations);
        if (keys.length === 0) {
            return null;
        }
        return keys.map(key => this._annotations[key].toJSON());
    }
    fromData(data) {
        data.forEach(annotationJson => this.addAnnotation(new _models_Annotation__WEBPACK_IMPORTED_MODULE_8__["default"](annotationJson)));
        this.emit({ type: "tag-update" });
    }
    // Temporary until annotation scale implementation is resolved
    setXRScale(scale) {
        for (const key in this._annotations) {
            const annotation = this._annotations[key];
            if (annotation.get("style") === "Circle") {
                const sprite = this._sprites[annotation.id];
                if (sprite) {
                    sprite.xrScale = scale;
                }
            }
        }
    }
    handleARStateChange() {
        for (const key in this._annotations) {
            const annotation = this._annotations[key];
            const sprite = this._sprites[annotation.id];
            sprite.isAdaptive = !this.arManager.outs.isPresenting.value;
        }
    }
    onPointerUp(event) {
        if (event.isDragging) {
            return;
        }
        let target = event.object3D;
        while (target && !target.isHTMLSprite) {
            target = target.parent;
        }
        const annotation = target && target.annotation;
        if (annotation) {
            if (true) {
                console.log(`CVAnnotationView.onPointerUp - title: ${annotation.title}, marker: ${annotation.data.marker}, id: ${annotation.id}`);
            }
            // click on annotation: activate annotation
            this.emit({ type: "click", sprite: target, annotation });
            event.stopPropagation = true;
        }
    }
    onSystemPointerUp(event) {
        // click on model/background: deactivate active annotation
        if (!event.isDragging) {
            this.emit({ type: "click", sprite: null, annotation: null });
        }
    }
    onViewportDispose(event) {
        const group = this.object3D;
        group.disposeHTMLElements(event.viewport.overlay);
    }
    onSpriteClick(event) {
        this.emit(event);
    }
    onSpriteLink(event) {
        const reader = this.reader;
        if (reader) {
            this.reader.ins.articleId.setValue(event.annotation.data.articleId);
            this.reader.ins.enabled.setValue(true);
        }
    }
    createSprite(annotation) {
        this.removeSprite(annotation);
        // TODO: Combine when font loading is centralized
        const sprite = annotation.data.style === "Circle" ? _annotations_AnnotationFactory__WEBPACK_IMPORTED_MODULE_9__["default"].createInstance(annotation, "Circle", this.assetReader) : _annotations_AnnotationFactory__WEBPACK_IMPORTED_MODULE_9__["default"].createInstance(annotation);
        sprite.addEventListener("click", this.onSpriteClick);
        sprite.addEventListener("link", this.onSpriteLink);
        this._sprites[annotation.id] = sprite;
        this.object3D.add(sprite);
        this.registerPickableObject3D(sprite, true);
    }
    removeSprite(annotation) {
        const sprite = this._sprites[annotation.id];
        if (sprite) {
            sprite.removeEventListener("click", this.onSpriteClick);
            sprite.removeEventListener("link", this.onSpriteLink);
            sprite.dispose();
            this._sprites[annotation.id] = undefined;
            this.object3D.remove(sprite);
            this.unregisterPickableObject3D(sprite, true);
        }
    }
    updateSprite(annotation) {
        const sprite = this._sprites[annotation.id];
        if (sprite) {
            sprite.update();
        }
    }
    updateLanguage() {
        const ins = this.ins;
        const annotation = this._activeAnnotation;
        const language = this.language;
        this.getAnnotations().forEach(annotation => {
            annotation.language = language.outs.language.value;
        });
        ins.activeTags.set();
        // update sprites
        for (const key in this._annotations) {
            const annotation = this._annotations[key];
            const sprite = this._sprites[annotation.id];
            if (sprite) {
                sprite.update();
            }
        }
        // update properties
        ins.title.setValue(annotation ? annotation.title : "", true);
        ins.lead.setValue(annotation ? annotation.lead : "", true);
        ins.tags.setValue(annotation ? annotation.tags.join(", ") : "");
    }
}
CVAnnotationView.typeName = "CVAnnotationView";
CVAnnotationView.ins = {
    unitScale: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Number("Transform.UnitScale", { preset: 1, precision: 5 }),
    activeTags: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].String("Tags.Active"),
    title: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].String("Annotation.Title"),
    lead: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].String("Annotation.Lead"),
    marker: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].String("Annotation.Marker"),
    tags: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].String("Annotation.Tags"),
    style: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Option("Annotation.Style", _annotations_AnnotationFactory__WEBPACK_IMPORTED_MODULE_9__["default"].typeNames),
    scale: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Scale("Annotation.Scale", { preset: 1, precision: 3 }),
    offset: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Number("Annotation.Offset", { preset: 0, precision: 3 }),
    article: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Option("Annotation.Article", []),
    image: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].String("Annotation.Image"),
    tilt: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Number("Annotation.Tilt"),
    azimuth: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Number("Annotation.Azimuth"),
    color: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].ColorRGB("Annotation.Color"),
};


/***/ }),

/***/ "./components/CVAnnotations.ts":
/*!*************************************!*\
  !*** ./components/CVAnnotations.ts ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVAnnotations; });
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _CVModel2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CVModel2 */ "./components/CVModel2.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


////////////////////////////////////////////////////////////////////////////////
class CVAnnotations extends _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.ins = this.addInputs(CVAnnotations.ins);
    }
    get model() {
        return this.getComponent(_CVModel2__WEBPACK_IMPORTED_MODULE_1__["default"]);
    }
    update(context) {
        return true;
    }
}
CVAnnotations.typeName = "CVAnnotations";
CVAnnotations.ins = {};


/***/ }),

/***/ "./components/CVAssetManager.ts":
/*!**************************************!*\
  !*** ./components/CVAssetManager.ts ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVAssetManager; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


////////////////////////////////////////////////////////////////////////////////
/**
 * Component containing a LoadingManager and services to convert
 * asset paths to URLs and vice versa.
 *
 * Outputs indicate whether the loading manager is busy.
 */
class CVAssetManager extends _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(...arguments);
        this.ins = this.addInputs(CVAssetManager.ins);
        this.outs = this.addOutputs(CVAssetManager.outs);
        this._loadingManager = new AssetLoadingManager(this);
        this._baseUrl = window.location.href;
        this._initialLoad = false;
    }
    get loadingManager() {
        return this._loadingManager;
    }
    get baseUrl() {
        return this._baseUrl;
    }
    set baseUrl(url) {
        this._baseUrl = new URL(url, window.location.href).href;
    }
    get initialLoad() {
        return this._initialLoad;
    }
    set initialLoad(value) {
        this._initialLoad = value;
    }
    getAssetName(pathOrUrl) {
        return pathOrUrl.split("/").pop();
    }
    getAssetUrl(assetPath) {
        return new URL(assetPath, this._baseUrl).href;
    }
    getAssetPath(url) {
        const baseUrl = this._baseUrl;
        const index = url.indexOf(baseUrl);
        if (index >= 0) {
            return url.substr(index + baseUrl.length);
        }
        return url;
    }
    getAssetBasePath(pathOrUrl) {
        const parts = this.getAssetPath(pathOrUrl).split("/");
        parts.pop();
        const basePath = parts.join("/");
        return basePath ? basePath + "/" : basePath;
    }
    getRelativeAssetPath(assetPathOrUrl, basePathOrUrl) {
        const assetUrl = this.getAssetUrl(assetPathOrUrl);
        const baseUrl = this.getAssetUrl(basePathOrUrl);
        const index = assetUrl.indexOf(baseUrl);
        if (index >= 0) {
            return assetUrl.substr(index + baseUrl.length);
        }
        return this.getAssetPath(assetUrl);
    }
    create() {
        super.create();
        //this.outs.baseUrl.setValue(window.location.href);
    }
    update() {
        const { ins, outs } = this;
        if (ins.busy.changed) {
            const isBusy = ins.busy.value || this._loadingManager.isBusy;
            outs.busy.setValue(isBusy);
            if (!isBusy) {
                outs.completed.set();
            }
        }
        // if (ins.baseUrl.changed) {
        //     try {
        //         outs.baseUrl.setValue(new URL(ins.baseUrl.value, window.location.href).href);
        //     }
        //     catch {
        //         outs.baseUrl.setValue(window.location.href);
        //     }
        // }
        return true;
    }
}
CVAssetManager.typeName = "CVAssetManager";
CVAssetManager.text = "AssetManager";
CVAssetManager.icon = "";
CVAssetManager.isSystemSingleton = true;
CVAssetManager.ins = {
    busy: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Boolean("State.Busy"),
};
CVAssetManager.outs = {
    busy: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Boolean("State.Busy"),
    completed: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Event("State.Completed"),
};
////////////////////////////////////////////////////////////////////////////////
class AssetLoadingManager extends three__WEBPACK_IMPORTED_MODULE_0__["LoadingManager"] {
    constructor(manager) {
        super();
        this._manager = manager;
        this._isBusy = false;
        this.onStart = this.onLoadingStart.bind(this);
        this.onProgress = this.onLoadingProgress.bind(this);
        this.onLoad = this.onLoadingCompleted.bind(this);
        this.onError = this.onLoadingError.bind(this);
    }
    get isBusy() {
        return this._isBusy;
    }
    onLoadingStart() {
        if (true) {
            console.log("Loading files...");
        }
        // trigger update
        this._isBusy = true;
        this._manager.ins.busy.set();
    }
    onLoadingProgress(url, itemsLoaded, itemsTotal) {
        if (true) {
            console.log(`Loaded ${itemsLoaded} of ${itemsTotal} files: ${url}`);
        }
    }
    onLoadingCompleted() {
        if (true) {
            console.log("Loading completed");
        }
        // trigger update
        this._isBusy = false;
        this._manager.ins.busy.set();
    }
    onLoadingError() {
        if (true) {
            console.error(`Loading error`);
        }
        // trigger update
        this._isBusy = false;
        this._manager.ins.busy.set();
    }
}


/***/ }),

/***/ "./components/CVAssetReader.ts":
/*!*************************************!*\
  !*** ./components/CVAssetReader.ts ***!
  \*************************************/
/*! exports provided: DEFAULT_SYSTEM_ASSET_PATH, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_SYSTEM_ASSET_PATH", function() { return DEFAULT_SYSTEM_ASSET_PATH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVAssetReader; });
/* harmony import */ var _ff_browser_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/browser/fetch */ "../../libs/ff-browser/source/fetch.ts");
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _io_JSONReader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../io/JSONReader */ "./io/JSONReader.ts");
/* harmony import */ var _io_ModelReader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../io/ModelReader */ "./io/ModelReader.ts");
/* harmony import */ var _io_GeometryReader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../io/GeometryReader */ "./io/GeometryReader.ts");
/* harmony import */ var _io_TextureReader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../io/TextureReader */ "./io/TextureReader.ts");
/* harmony import */ var _io_FontReader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../io/FontReader */ "./io/FontReader.ts");
/* harmony import */ var _CVAssetManager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./CVAssetManager */ "./components/CVAssetManager.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};








////////////////////////////////////////////////////////////////////////////////
const DEFAULT_SYSTEM_ASSET_PATH = "https://cdn.jsdelivr.net/gh/smithsonian/dpo-voyager@latest/assets/";
class CVAssetReader extends _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(node, id) {
        super(node, id);
        this.systemAssetPath = null;
        const loadingManager = this.assetManager.loadingManager;
        this.jsonLoader = new _io_JSONReader__WEBPACK_IMPORTED_MODULE_2__["default"](loadingManager);
        this.modelLoader = new _io_ModelReader__WEBPACK_IMPORTED_MODULE_3__["default"](loadingManager);
        this.geometryLoader = new _io_GeometryReader__WEBPACK_IMPORTED_MODULE_4__["default"](loadingManager);
        this.textureLoader = new _io_TextureReader__WEBPACK_IMPORTED_MODULE_5__["default"](loadingManager);
        this.fontReader = new _io_FontReader__WEBPACK_IMPORTED_MODULE_6__["default"](loadingManager);
    }
    get assetManager() {
        return this.getMainComponent(_CVAssetManager__WEBPACK_IMPORTED_MODULE_7__["default"]);
    }
    setDracoPath(dracoPath) {
        this.modelLoader.dracoPath = dracoPath;
    }
    setSystemAssetPath(assetPath) {
        this.fontReader.fontPath = assetPath;
        this.systemAssetPath = assetPath;
    }
    getJSON(assetPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.assetManager.getAssetUrl(assetPath);
            return this.jsonLoader.get(url);
        });
    }
    getText(assetPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.assetManager.getAssetUrl(assetPath);
            return _ff_browser_fetch__WEBPACK_IMPORTED_MODULE_0__["default"].text(url, "GET");
        });
    }
    getModel(assetPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.assetManager.getAssetUrl(assetPath);
            return this.modelLoader.get(url);
        });
    }
    getGeometry(assetPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.assetManager.getAssetUrl(assetPath);
            return this.geometryLoader.get(url);
        });
    }
    getTexture(assetPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.assetManager.getAssetUrl(assetPath);
            return this.textureLoader.get(url);
        });
    }
    getFont(assetPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.assetManager.getAssetUrl(assetPath);
            return this.fontReader.load(url);
        });
    }
    getSystemTexture(assetPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = (this.systemAssetPath || DEFAULT_SYSTEM_ASSET_PATH) + assetPath;
            return this.textureLoader.get(url);
        });
    }
    getSystemJSON(assetPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = (this.systemAssetPath || DEFAULT_SYSTEM_ASSET_PATH) + assetPath;
            return this.jsonLoader.get(url);
        });
    }
}
CVAssetReader.typeName = "CVAssetReader";
CVAssetReader.text = "AssetReader";
CVAssetReader.icon = "";
CVAssetReader.isSystemSingleton = true;


/***/ }),

/***/ "./components/CVBackground.ts":
/*!************************************!*\
  !*** ./components/CVBackground.ts ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVBackground; });
/* harmony import */ var _ff_scene_components_CBackground__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/scene/components/CBackground */ "../../libs/ff-scene/source/components/CBackground.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

////////////////////////////////////////////////////////////////////////////////
class CVBackground extends _ff_scene_components_CBackground__WEBPACK_IMPORTED_MODULE_0__["default"] {
    get settingProperties() {
        return [
            this.ins.style,
            this.ins.color0,
            this.ins.color1,
        ];
    }
    get snapshotProperties() {
        return [
            this.ins.color0,
            this.ins.color1,
        ];
    }
    hide() {
        this.background.visible = false;
    }
    show() {
        this.background.visible = true;
    }
    fromData(data) {
        this.ins.copyValues({
            style: _ff_scene_components_CBackground__WEBPACK_IMPORTED_MODULE_0__["EBackgroundStyle"][data.style] || _ff_scene_components_CBackground__WEBPACK_IMPORTED_MODULE_0__["EBackgroundStyle"].Solid,
            color0: data.color0 || [0.2, 0.25, 0.3],
            color1: data.color1 || [0.01, 0.03, 0.05],
        });
    }
    toData() {
        const ins = this.ins;
        return {
            style: _ff_scene_components_CBackground__WEBPACK_IMPORTED_MODULE_0__["EBackgroundStyle"][ins.style.value],
            color0: ins.color0.cloneValue(),
            color1: ins.color1.cloneValue(),
        };
    }
}
CVBackground.typeName = "CVBackground";


/***/ }),

/***/ "./components/CVCamera.ts":
/*!********************************!*\
  !*** ./components/CVCamera.ts ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVCamera; });
/* harmony import */ var _ff_scene_components_CCamera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/scene/components/CCamera */ "../../libs/ff-scene/source/components/CCamera.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

////////////////////////////////////////////////////////////////////////////////
class CVCamera extends _ff_scene_components_CCamera__WEBPACK_IMPORTED_MODULE_0__["default"] {
    get settingProperties() {
        return [
            this.ins.projection,
            this.ins.fov,
            this.ins.size,
            this.ins.near,
            this.ins.far,
        ];
    }
    fromDocument(document, node) {
        if (!isFinite(node.camera)) {
            throw new Error("camera property missing in node");
        }
        const data = document.cameras[node.camera];
        if (data.type === "perspective") {
            this.ins.copyValues({
                projection: _ff_scene_components_CCamera__WEBPACK_IMPORTED_MODULE_0__["EProjection"].Perspective,
                fov: data.perspective.yfov,
                near: data.perspective.znear,
                far: data.perspective.zfar
            });
        }
        else {
            this.ins.copyValues({
                projection: _ff_scene_components_CCamera__WEBPACK_IMPORTED_MODULE_0__["EProjection"].Orthographic,
                size: data.orthographic.ymag,
                near: data.orthographic.znear,
                far: data.orthographic.zfar
            });
        }
        return node.camera;
    }
    toDocument(document, node) {
        const ins = this.ins;
        const data = {};
        if (ins.projection.getValidatedValue() === _ff_scene_components_CCamera__WEBPACK_IMPORTED_MODULE_0__["EProjection"].Perspective) {
            data.type = "perspective";
            data.perspective = {
                yfov: ins.fov.value,
                znear: ins.near.value,
                zfar: ins.far.value
            };
        }
        else {
            data.type = "orthographic";
            data.orthographic = {
                ymag: ins.size.value,
                znear: ins.near.value,
                zfar: ins.far.value
            };
        }
        document.cameras = document.cameras || [];
        const cameraIndex = document.cameras.length;
        document.cameras.push(data);
        return cameraIndex;
    }
}
CVCamera.typeName = "CVCamera";
CVCamera.text = "Camera";
CVCamera.icon = "video";


/***/ }),

/***/ "./components/CVDirectionalLight.ts":
/*!******************************************!*\
  !*** ./components/CVDirectionalLight.ts ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVDirectionalLight; });
/* harmony import */ var _ff_scene_components_CDirectionalLight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/scene/components/CDirectionalLight */ "../../libs/ff-scene/source/components/CDirectionalLight.ts");
/* harmony import */ var _ff_scene_components_CLight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/scene/components/CLight */ "../../libs/ff-scene/source/components/CLight.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


////////////////////////////////////////////////////////////////////////////////
class CVDirectionalLight extends _ff_scene_components_CDirectionalLight__WEBPACK_IMPORTED_MODULE_0__["default"] {
    get settingProperties() {
        return [
            this.ins.color,
            this.ins.intensity,
            this.ins.shadowEnabled,
            this.ins.shadowSize,
            this.ins.shadowResolution,
            this.ins.shadowBlur,
        ];
    }
    get snapshotProperties() {
        return [
            this.ins.color,
            this.ins.intensity,
        ];
    }
    fromDocument(document, node) {
        if (!isFinite(node.light)) {
            throw new Error("light property missing in node");
        }
        const data = document.lights[node.light];
        const ins = this.ins;
        if (data.type !== "directional") {
            throw new Error("light type mismatch: not a directional light");
        }
        ins.copyValues({
            color: data.color !== undefined ? data.color : ins.color.schema.preset,
            intensity: data.intensity !== undefined ? data.intensity : ins.intensity.schema.preset,
            position: ins.position.schema.preset,
            target: ins.target.schema.preset,
            shadowEnabled: data.shadowEnabled || false,
            shadowSize: data.shadowSize !== undefined ? data.shadowSize : ins.shadowSize.schema.preset,
            shadowResolution: data.shadowResolution !== undefined ? _ff_scene_components_CLight__WEBPACK_IMPORTED_MODULE_1__["EShadowMapResolution"][data.shadowResolution] || 0 : ins.shadowResolution.schema.preset,
            shadowBlur: data.shadowBlur !== undefined ? data.shadowBlur : ins.shadowBlur.schema.preset,
        });
        return node.light;
    }
    toDocument(document, node) {
        const ins = this.ins;
        const data = {
            color: ins.color.cloneValue(),
            intensity: ins.intensity.value
        };
        data.type = "directional";
        if (ins.shadowEnabled.value) {
            data.shadowEnabled = true;
            if (!ins.shadowSize.isDefault()) {
                data.shadowSize = ins.shadowSize.value;
            }
            if (!ins.shadowBlur.isDefault()) {
                data.shadowBlur = ins.shadowBlur.value;
            }
            if (!ins.shadowResolution.isDefault()) {
                data.shadowResolution = _ff_scene_components_CLight__WEBPACK_IMPORTED_MODULE_1__["EShadowMapResolution"][ins.shadowResolution.value];
            }
        }
        document.lights = document.lights || [];
        const lightIndex = document.lights.length;
        document.lights.push(data);
        return lightIndex;
    }
}
CVDirectionalLight.typeName = "CVDirectionalLight";
CVDirectionalLight.text = "Directional Light";
CVDirectionalLight.icon = "bulb";


/***/ }),

/***/ "./components/CVDocument.ts":
/*!**********************************!*\
  !*** ./components/CVDocument.ts ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVDocument; });
/* harmony import */ var _ff_browser_download__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/browser/download */ "../../libs/ff-browser/source/download.ts");
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _ff_scene_components_CRenderGraph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/scene/components/CRenderGraph */ "../../libs/ff-scene/source/components/CRenderGraph.ts");
/* harmony import */ var _io_DocumentValidator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../io/DocumentValidator */ "./io/DocumentValidator.ts");
/* harmony import */ var _nodes_NVNode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../nodes/NVNode */ "./nodes/NVNode.ts");
/* harmony import */ var _nodes_NVScene__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../nodes/NVScene */ "./nodes/NVScene.ts");
/* harmony import */ var _CVMeta__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CVMeta */ "./components/CVMeta.ts");
/* harmony import */ var _CVSetup__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./CVSetup */ "./components/CVSetup.ts");
/* harmony import */ var _CVAssetManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./CVAssetManager */ "./components/CVAssetManager.ts");
/* harmony import */ var client_components_CVAnalytics__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! client/components/CVAnalytics */ "./components/CVAnalytics.ts");
/* harmony import */ var client_schema_common__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! client/schema/common */ "./schema/common.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











/**
 * A Voyager document is a special kind of graph. Its inner graph has a standard structure, and it can
 * be serialized to and from an IDocument structure which is compatible with a glTF document.
 */
class CVDocument extends _ff_scene_components_CRenderGraph__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(node, id) {
        super(node, id);
        this.titles = {};
        this.ins = this.addInputs(CVDocument.ins);
        this.outs = this.addOutputs(CVDocument.outs);
        // create root scene node with features component
        this.innerGraph.createCustomNode(_nodes_NVScene__WEBPACK_IMPORTED_MODULE_5__["default"]);
        // document is inactive and hidden, unless it becomes the active document
        this.ins.active.setValue(false);
        this.ins.visible.setValue(false);
    }
    get root() {
        return this.innerNodes.get(_nodes_NVScene__WEBPACK_IMPORTED_MODULE_5__["default"]);
    }
    get setup() {
        return this.innerComponents.get(_CVSetup__WEBPACK_IMPORTED_MODULE_7__["default"]);
    }
    get assetPath() {
        return this.outs.assetPath.value;
    }
    get assetBaseName() {
        let name = this.assetPath;
        const index = name.indexOf(".svx.json");
        if (index >= 0) {
            name = name.substr(0, index);
        }
        return name;
    }
    get analytics() {
        return this.getMainComponent(client_components_CVAnalytics__WEBPACK_IMPORTED_MODULE_9__["default"]);
    }
    create() {
        super.create();
        this.innerGraph.components.on(_CVMeta__WEBPACK_IMPORTED_MODULE_6__["default"], this.onMetaComponent, this);
        this.setup.language.outs.language.on("value", this.updateTitle, this);
    }
    dispose() {
        this.setup.language.outs.language.off("value", this.updateTitle, this);
        this.innerGraph.components.off(_CVMeta__WEBPACK_IMPORTED_MODULE_6__["default"], this.onMetaComponent, this);
        super.dispose();
    }
    update(context) {
        super.update(context);
        const { ins, outs } = this;
        if (ins.dumpJson.changed) {
            const json = this.deflateDocument();
            console.log("-------------------- VOYAGER DOCUMENT --------------------");
            console.log(JSON.stringify(json, (key, value) => typeof value === "number" ? parseFloat(value.toFixed(5)) : value, 2));
        }
        if (ins.dumpTree.changed) {
            console.log("-------------------- VOYAGER DOCUMENT --------------------");
            this.dump();
        }
        if (ins.download.changed) {
            const fileName = outs.assetPath.value.split("/").pop() || "voyager-document.json";
            _ff_browser_download__WEBPACK_IMPORTED_MODULE_0__["default"].json(this.deflateDocument(), fileName);
        }
        if (ins.title.changed && this.titles) {
            const language = this.setup.language;
            this.titles[client_schema_common__WEBPACK_IMPORTED_MODULE_10__["ELanguageType"][language.outs.language.value]] = ins.title.value;
            outs.title.setValue(ins.title.value);
        }
        return true;
    }
    clearNodeTree() {
        const children = this.root.transform.children.slice();
        children.forEach(child => child.node.dispose());
    }
    /**
     * Loads the document from the given document data. The data is validated first.
     * If a parent node/scene is given, the data is attached to the given parent.
     * @param documentData The document data to be loaded.
     * @param assetPath The path to the document asset to be loaded.
     * @param mergeParent If true or a scene or node, appends to the root or the given scene/node.
     */
    openDocument(documentData, assetPath, mergeParent) {
        if (true) {
            console.log("CVDocument.openDocument - assetPath: %s, mergeParent: %s", assetPath, mergeParent);
        }
        if (!CVDocument.validator.validate(documentData)) {
            throw new Error("document schema validation failed");
        }
        if (!mergeParent) {
            this.clearNodeTree();
        }
        // listen to load events on scene meta component
        this.onMetaComponent({ type: "CVMeta", object: this.root.meta, add: true, remove: false });
        let parent = (typeof mergeParent === "object" ? mergeParent : this.root);
        if (parent.graph !== this.innerGraph) {
            throw new Error("invalid parent node");
        }
        const pathMap = new Map();
        if (parent instanceof _nodes_NVScene__WEBPACK_IMPORTED_MODULE_5__["default"]) {
            parent.fromDocument(documentData, documentData.scene, pathMap);
        }
        else {
            // if we append to a node, skip the document's root scene and append the scene's child nodes
            const rootIndices = documentData.scenes[documentData.scene].nodes;
            rootIndices.forEach(rootIndex => {
                const rootNode = this.innerGraph.createCustomNode(_nodes_NVNode__WEBPACK_IMPORTED_MODULE_4__["default"]);
                parent.transform.addChild(rootNode.transform);
                rootNode.fromDocument(documentData, rootIndex, pathMap);
            });
        }
        //pathMap.forEach((comp, path) => console.log("CVDocument - pathMap: %s - '%s'", path, comp.displayName));
        if (assetPath) {
            this.outs.assetPath.setValue(assetPath);
            this.name = this.getMainComponent(_CVAssetManager__WEBPACK_IMPORTED_MODULE_8__["default"]).getAssetName(assetPath);
        }
    }
    appendModel(assetPath, quality, parent) {
        if (parent && parent.graph !== this.innerGraph) {
            throw new Error("invalid parent node");
        }
        if (this.isEmpty()) {
            throw new Error("empty document, can't append model");
        }
        parent = parent || this.root;
        const modelNode = this.innerGraph.createCustomNode(_nodes_NVNode__WEBPACK_IMPORTED_MODULE_4__["default"]);
        parent.transform.addChild(modelNode.transform);
        modelNode.createModel();
        const model = modelNode.model;
        model.derivatives.createModelAsset(assetPath, quality);
    }
    appendGeometry(geoPath, colorMapPath, occlusionMapPath, normalMapPath, quality, parent) {
        if (parent && parent.graph !== this.innerGraph) {
            throw new Error("invalid parent node");
        }
        if (this.isEmpty()) {
            throw new Error("empty document, can't append geometry");
        }
        parent = parent || this.root;
        const modelNode = this.innerGraph.createCustomNode(_nodes_NVNode__WEBPACK_IMPORTED_MODULE_4__["default"]);
        parent.transform.addChild(modelNode.transform);
        modelNode.createModel();
        const model = modelNode.model;
        model.derivatives.createMeshAsset(geoPath, colorMapPath, occlusionMapPath, normalMapPath, quality);
    }
    deflateDocument(components) {
        if (this.isEmpty()) {
            throw new Error("empty document, can't serialize");
        }
        const document = {
            asset: {
                type: CVDocument.mimeType,
                version: CVDocument.version,
                generator: "Voyager",
                copyright: "(c) Smithsonian Institution. All rights reserved."
            },
            scene: 0,
            scenes: [],
        };
        const pathMap = new Map();
        document.scene = this.root.toDocument(document, pathMap, components);
        //pathMap.forEach((path, comp) => console.log("CVDocument - pathMap: %s - '%s'", path, comp.displayName));
        return document;
    }
    onMetaComponent(event) {
        const meta = event.object;
        const propTitle = this.ins.title;
        const language = this.setup.language;
        if (event.add && !propTitle.value) {
            meta.once("load", () => {
                this.titles = meta.collection.get("titles") || {};
                // TODO: Temporary - remove when single string properties are phased out
                if (Object.keys(this.titles).length === 0) {
                    this.titles[client_schema_common__WEBPACK_IMPORTED_MODULE_10__["ELanguageType"][language.outs.language.value]] = meta.collection.get("title") || "";
                    meta.collection.dictionary["titles"] = this.titles;
                }
                const title = this.titles[client_schema_common__WEBPACK_IMPORTED_MODULE_10__["ELanguageType"][language.outs.language.value]];
                propTitle.setValue(title);
                this.analytics.setTitle(title);
            });
        }
    }
    updateTitle() {
        const language = this.setup.language;
        const newTitle = this.titles[client_schema_common__WEBPACK_IMPORTED_MODULE_10__["ELanguageType"][language.outs.language.value]];
        this.ins.title.setValue(newTitle ? newTitle : "Missing Title");
    }
}
CVDocument.typeName = "CVDocument";
CVDocument.mimeType = "application/si-dpo-3d.document+json";
CVDocument.version = "1.0";
CVDocument.validator = new _io_DocumentValidator__WEBPACK_IMPORTED_MODULE_3__["default"]();
CVDocument.ins = {
    dumpJson: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Event("Document.DumpJSON"),
    dumpTree: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Event("Document.DumpTree"),
    download: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Event("Document.Download"),
    title: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].String("Document.Title"),
};
CVDocument.outs = {
    assetPath: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].AssetPath("Asset.Path", { preset: "document.svx.json" }),
    title: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].String("Document.Title"),
};


/***/ }),

/***/ "./components/CVDocumentObserver.ts":
/*!******************************************!*\
  !*** ./components/CVDocumentObserver.ts ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVDocumentObserver; });
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _CVDocumentProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CVDocumentProvider */ "./components/CVDocumentProvider.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


////////////////////////////////////////////////////////////////////////////////
/**
 * Inherit from this class to observe changes of the currently active document.
 * Call startObserving() to begin receiving change events. Override onActiveDocument() to react on active document changes.
 */
class CVDocumentObserver extends _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.activeDocument = null;
    }
    get documentProvider() {
        return this.getGraphComponent(_CVDocumentProvider__WEBPACK_IMPORTED_MODULE_1__["default"]);
    }
    /**
     * Starts observing changes of the active document. Must be called explicitly by descendant classes
     * in order to start observation.
     */
    startObserving() {
        const provider = this.documentProvider;
        provider.on("active-component", this.onActiveDocumentEvent, this);
        if (provider.activeComponent) {
            this.activeDocument = provider.activeComponent;
            this.onActiveDocument(null, provider.activeComponent);
        }
    }
    /**
     * Stops observing changes of the active node.
     */
    stopObserving() {
        const provider = this.documentProvider;
        provider.off("active-component", this.onActiveDocumentEvent, this);
        if (provider.activeComponent) {
            this.activeDocument = null;
            this.onActiveDocument(provider.activeComponent, null);
        }
    }
    /**
     * Called after the active document has changed. Override to react on the change.
     * @param previous The previous active document.
     * @param next The next active document.
     */
    onActiveDocument(previous, next) {
    }
    onActiveDocumentEvent(event) {
        this.activeDocument = event.next;
        this.onActiveDocument(event.previous, event.next);
    }
}
CVDocumentObserver.typeName = "CVDocumentObserver";


/***/ }),

/***/ "./components/CVDocumentProvider.ts":
/*!******************************************!*\
  !*** ./components/CVDocumentProvider.ts ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVDocumentProvider; });
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _ff_graph_components_CComponentProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/graph/components/CComponentProvider */ "../../libs/ff-graph/source/components/CComponentProvider.ts");
/* harmony import */ var _CVDocument__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CVDocument */ "./components/CVDocument.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class CVDocumentProvider extends _ff_graph_components_CComponentProvider__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(node, id) {
        super(node, id);
        this.outs = this.addOutputs(CVDocumentProvider.outs);
        this.scope = _ff_graph_components_CComponentProvider__WEBPACK_IMPORTED_MODULE_1__["EComponentScope"].Node;
    }
    createDocument(data, path) {
        const document = this.node.createComponent(_CVDocument__WEBPACK_IMPORTED_MODULE_2__["default"]);
        this.activeComponent = document;
        if (data) {
            document.openDocument(data, path);
        }
        return document;
    }
    amendDocument(data, path, merge) {
        const document = this.activeComponent;
        if (!document) {
            throw new Error("no active document, can't amend");
        }
        document.openDocument(data, path, merge);
        return document;
    }
    appendModel(modelPath, quality) {
        const document = this.activeComponent;
        if (!document) {
            throw new Error("no active document, can't append model");
        }
        document.appendModel(modelPath, quality);
        return document;
    }
    appendGeometry(geoPath, colorMapPath, occlusionMapPath, normalMapPath, quality) {
        const document = this.activeComponent;
        if (!document) {
            throw new Error("no active document, can't append geometry");
        }
        document.appendGeometry(geoPath, colorMapPath, occlusionMapPath, normalMapPath, quality);
        return document;
    }
    removeActiveDocument() {
        const document = this.activeComponent;
        if (document) {
            document.dispose();
        }
    }
    activateComponent(document) {
        document.ins.visible.setValue(true);
        document.ins.active.setValue(true);
    }
    deactivateComponent(document) {
        document.ins.visible.setValue(false);
        document.ins.active.setValue(false);
    }
    onActiveComponent(previous, next) {
        this.outs.activeDocument.setValue(next);
    }
    onScopedComponents() {
        this.outs.changedDocuments.set();
    }
}
CVDocumentProvider.typeName = "CVDocumentProvider";
CVDocumentProvider.componentType = _CVDocument__WEBPACK_IMPORTED_MODULE_2__["default"];
CVDocumentProvider.outs = {
    activeDocument: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Object("Documents.Active", _CVDocument__WEBPACK_IMPORTED_MODULE_2__["default"]),
    changedDocuments: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Event("Documents.Changed"),
};


/***/ }),

/***/ "./components/CVEnvironment.ts":
/*!*************************************!*\
  !*** ./components/CVEnvironment.ts ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVEnvironment; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _CVAssetReader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CVAssetReader */ "./components/CVAssetReader.ts");
/* harmony import */ var _CVScene__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CVScene */ "./components/CVScene.ts");
/**
 * 3D Foundation Project
 * Copyright 2020 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




const images = ["Footprint_Court_1k_TMap.jpg", "spruit_sunrise_1k_LDR.jpg", "campbell_env.jpg"];
////////////////////////////////////////////////////////////////////////////////
class CVEnvironment extends _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(...arguments);
        this.ins = this.addInputs(CVEnvironment.envIns);
        this._texture = null;
        this._currentIdx = 0;
    }
    get assetReader() {
        return this.getMainComponent(_CVAssetReader__WEBPACK_IMPORTED_MODULE_2__["default"]);
    }
    update() {
        const ins = this.ins;
        if (ins.dirty.changed || ins.imageIndex.changed) {
            const scene = this.getGraphComponent(_CVScene__WEBPACK_IMPORTED_MODULE_3__["default"]);
            scene.models.forEach(model => {
                model.object3D.traverse(object => {
                    const material = object["material"];
                    if (material && material.isUberPBRMaterial) {
                        // currently only doing env reflection if we have a rougness or metalness map defined
                        if (material.roughnessMap || material.metalnessMap) {
                            if (ins.imageIndex.value != this._currentIdx || this._texture === null) {
                                this._currentIdx = ins.imageIndex.value;
                                if (this._texture === null) {
                                    const metalnessCache = material.metalness; // hack to avoid showing reflective geometry briefly as black
                                    material.metalness = 0.0;
                                    this.assetReader.getSystemTexture("images/" + images[ins.imageIndex.value]).then(texture => {
                                        this._texture = texture;
                                        this._texture.mapping = three__WEBPACK_IMPORTED_MODULE_0__["EquirectangularReflectionMapping"];
                                        material.envMap = this._texture;
                                        material.metalness = metalnessCache;
                                        material.needsUpdate = true;
                                    });
                                }
                                else {
                                    this.assetReader.getSystemTexture("images/" + images[ins.imageIndex.value]).then(texture => {
                                        this._texture.dispose();
                                        this._texture = texture;
                                        this._texture.mapping = three__WEBPACK_IMPORTED_MODULE_0__["EquirectangularReflectionMapping"];
                                        material.envMap = this._texture;
                                        material.needsUpdate = true;
                                    });
                                }
                            }
                            else {
                                material.envMap = this._texture;
                                material.envMap.mapping = three__WEBPACK_IMPORTED_MODULE_0__["EquirectangularReflectionMapping"];
                                material.needsUpdate = true;
                            }
                        }
                    }
                });
            });
        }
        return true;
    }
    fromData(data) {
        this.ins.copyValues({
            imageIndex: data.index
        });
    }
    toData() {
        const ins = this.ins;
        return {
            index: ins.imageIndex.cloneValue()
        };
    }
}
CVEnvironment.typeName = "CVEnvironment";
CVEnvironment.text = "Environment";
CVEnvironment.envIns = {
    imageIndex: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Integer("Environment.Index", { preset: 0, options: images.map(function (item, index) { return index.toString(); }) }),
    dirty: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Event("Environment.Dirty")
};


/***/ }),

/***/ "./components/CVEnvironmentTool.ts":
/*!*****************************************!*\
  !*** ./components/CVEnvironmentTool.ts ***!
  \*****************************************/
/*! exports provided: default, EnvironmentToolView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVEnvironmentTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EnvironmentToolView", function() { return EnvironmentToolView; });
/* harmony import */ var _CVTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CVTool */ "./components/CVTool.ts");
/* harmony import */ var _ff_scene_components_CBackground__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/scene/components/CBackground */ "../../libs/ff-scene/source/components/CBackground.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


////////////////////////////////////////////////////////////////////////////////
class CVEnvironmentTool extends _CVTool__WEBPACK_IMPORTED_MODULE_0__["default"] {
    createView() {
        return new EnvironmentToolView(this);
    }
}
CVEnvironmentTool.typeName = "CVEnvironmentTool";
CVEnvironmentTool.text = "Environment";
CVEnvironmentTool.icon = "environment";
////////////////////////////////////////////////////////////////////////////////
let EnvironmentToolView = class EnvironmentToolView extends _CVTool__WEBPACK_IMPORTED_MODULE_0__["ToolView"] {
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-group", "sv-environment-tool-view");
    }
    render() {
        const tool = this.tool;
        if (!this.activeDocument) {
            return _CVTool__WEBPACK_IMPORTED_MODULE_0__["html"] `No active document`;
        }
        const setup = this.activeDocument.setup;
        const grid = setup.grid;
        const floor = setup.floor;
        const background = setup.background;
        const options = ["Solid", "Linear", "Radial"];
        const style = background.ins.style.getValidatedValue();
        const isSolid = style === _ff_scene_components_CBackground__WEBPACK_IMPORTED_MODULE_1__["EBackgroundStyle"].Solid;
        //const isLinear = style === EBackgroundStyle.LinearGradient;
        const environment = setup.environment;
        const language = setup.language;
        //let name0 = isSolid ? " " : (isLinear ? "Top" : "Inner");
        //let name1 = isSolid ? "" : (isLinear ? "Btm" : "Outer");
        return _CVTool__WEBPACK_IMPORTED_MODULE_0__["html"] `<div class="sv-section"><ff-button class="sv-section-lead" transparent icon=${tool.icon}></ff-button>
            <div class="sv-tool-controls">
                <sv-property-options .property=${background.ins.style} .language=${language} .options=${options} name=${language.getLocalizedString("Background")}></sv-property-options>
                <sv-property-color class="sv-nogap" .property=${background.ins.color0} name=" "></sv-property-color>
                ${!isSolid ? _CVTool__WEBPACK_IMPORTED_MODULE_0__["html"] `<sv-property-color class="sv-nogap" .property=${background.ins.color1} name=" "></sv-property-color>` : null}
                <sv-property-boolean .property=${grid.ins.visible} .language=${language} name=${language.getLocalizedString("Grid")}></sv-property-boolean>
                <sv-property-color class="sv-nogap" .property=${grid.ins.color} name=" "></sv-property-color>
                <sv-property-boolean .property=${floor.ins.visible} .language=${language} name=${language.getLocalizedString("Floor")}></sv-property-boolean>
                <sv-property-color class="sv-nogap" .property=${floor.ins.color} name=" "></sv-property-color>
                <sv-property-options .property=${environment.ins.imageIndex} name="Env Map"></sv-property-options>
            </div>
        </div>`;
    }
    onActiveDocument(previous, next) {
        if (previous) {
            const background = previous.setup.background;
            background.ins.style.off("value", this.onUpdate, this);
        }
        if (next) {
            const background = next.setup.background;
            background.ins.style.on("value", this.onUpdate, this);
        }
        this.requestUpdate();
    }
};
EnvironmentToolView = __decorate([
    Object(_CVTool__WEBPACK_IMPORTED_MODULE_0__["customElement"])("sv-environment-tool-view")
], EnvironmentToolView);



/***/ }),

/***/ "./components/CVFloor.ts":
/*!*******************************!*\
  !*** ./components/CVFloor.ts ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVFloor; });
/* harmony import */ var _ff_scene_components_CFloor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/scene/components/CFloor */ "../../libs/ff-scene/source/components/CFloor.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

////////////////////////////////////////////////////////////////////////////////
class CVFloor extends _ff_scene_components_CFloor__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(node, id) {
        super(node, id);
        this.ins.visible.setValue(false);
        this.ins.receiveShadow.setValue(true);
        // make sure floor is rendered behind other transparent scene objects
        this.floor.renderOrder = -1;
    }
    get settingProperties() {
        return [
            this.ins.visible,
            this.ins.position,
            this.ins.radius,
            this.ins.color,
            this.ins.opacity,
            this.ins.receiveShadow,
        ];
    }
    get snapshotProperties() {
        return [
            this.ins.opacity,
        ];
    }
    fromData(data) {
        data = data || {};
        this.ins.copyValues({
            visible: !!data.visible,
            position: data.position || [0, -25, 0],
            radius: data.size !== undefined ? data.size : 50,
            color: data.color || [0.6, 0.75, 0.8],
            opacity: data.opacity !== undefined ? data.opacity : 0.5,
            receiveShadow: !!data.receiveShadow,
        });
    }
    toData() {
        const ins = this.ins;
        return {
            visible: ins.visible.value,
            position: ins.position.cloneValue(),
            size: ins.radius.value,
            color: ins.color.cloneValue(),
            opacity: ins.opacity.value,
            receiveShadow: ins.receiveShadow.value,
        };
    }
}
CVFloor.typeName = "CVFloor";
CVFloor.text = "Floor";
CVFloor.icon = "";


/***/ }),

/***/ "./components/CVGrid.ts":
/*!******************************!*\
  !*** ./components/CVGrid.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVGrid; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_three_Grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/three/Grid */ "../../libs/ff-three/source/Grid.ts");
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ff/scene/components/CObject3D */ "../../libs/ff-scene/source/components/CObject3D.ts");
/* harmony import */ var client_schema_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! client/schema/common */ "./schema/common.ts");
/* harmony import */ var _CVScene__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CVScene */ "./components/CVScene.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






////////////////////////////////////////////////////////////////////////////////
const _vec3a = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vec3b = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _matRotationOffset = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]().makeRotationX(Math.PI * 0.5);
const _matIdentity = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
class CVGrid extends _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor() {
        super(...arguments);
        this.ins = this.addInputs(CVGrid.gridIns);
        this.outs = this.addOutputs(CVGrid.gridOuts);
        this._lastViewport = null;
        this._gridProps = {
            size: 20,
            mainDivisions: 2,
            subDivisions: 10,
            mainColor: new three__WEBPACK_IMPORTED_MODULE_0__["Color"](0.5, 0.7, 0.8),
            subColor: new three__WEBPACK_IMPORTED_MODULE_0__["Color"](0.25, 0.35, 0.4)
        };
    }
    get settingProperties() {
        return [
            this.ins.visible,
            this.ins.color,
            this.ins.opacity,
        ];
    }
    get snapshotProperties() {
        return [
            this.ins.opacity,
        ];
    }
    get grid() {
        return this.object3D;
    }
    create() {
        this.ins.pickable.setValue(false);
        this.ins.visible.setValue(false);
        super.create();
    }
    activate() {
        const scene = this.getGraphComponent(_CVScene__WEBPACK_IMPORTED_MODULE_5__["default"]);
        scene.outs.boundingBox.linkTo(this.ins.boundingBox);
    }
    update() {
        const ins = this.ins;
        if (ins.color.changed || ins.boundingBox.changed) {
            const props = this._gridProps;
            if (ins.color.changed) {
                const mainColor = props.mainColor;
                const subColor = props.subColor;
                mainColor.fromArray(ins.color.value);
                subColor.r = mainColor.r * 0.5;
                subColor.g = mainColor.g * 0.5;
                subColor.b = mainColor.b * 0.5;
            }
            if (ins.boundingBox.changed) {
                const scene = this.getGraphComponent(_CVScene__WEBPACK_IMPORTED_MODULE_5__["default"]);
                const box = scene.outs.boundingBox.value;
                const units = scene.ins.units.value;
                box.getSize(_vec3a);
                let size = Math.max(_vec3a.x, _vec3a.y, _vec3a.z);
                let f = 1;
                while (size / f > 5) {
                    f = f * 10;
                }
                size = Math.ceil(size / f) * f * 2;
                if (true) {
                    console.log("CVGrid.update - grid size = %s %s", size, client_schema_common__WEBPACK_IMPORTED_MODULE_4__["EUnitType"][units]);
                }
                props.size = size;
                this.outs.size.setValue(size);
                this.outs.units.setValue(units);
                props.mainDivisions = size / f;
                props.subDivisions = 10;
                _vec3b.set(0, box.min.y, 0);
            }
            if (!this.object3D) {
                this.object3D = new _ff_three_Grid__WEBPACK_IMPORTED_MODULE_1__["default"](props);
            }
            else {
                this.grid.update(props);
            }
            if (ins.boundingBox.changed) {
                this.grid.position.copy(_vec3b);
                this.grid.updateMatrix();
            }
        }
        if (ins.visible.changed) {
            this.grid.visible = ins.visible.value;
        }
        if (ins.opacity.changed) {
            this.grid.opacity = ins.opacity.value;
        }
        return true;
    }
    preRender(context) {
        const viewport = context.viewport;
        const gridObject = this.object3D;
        if (viewport !== this._lastViewport) {
            this._lastViewport = viewport;
            const vpCamera = context.viewport.camera;
            if (vpCamera) {
                gridObject.matrix.extractRotation(vpCamera.matrixWorld).multiply(_matRotationOffset);
            }
            else {
                gridObject.matrix.extractRotation(_matIdentity);
            }
            gridObject.updateMatrixWorld(true);
        }
    }
    postRender(context) {
        this.object3D.matrix.extractRotation(_matIdentity);
    }
    fromData(data) {
        data = data || {};
        this.ins.copyValues({
            visible: !!data.visible,
            color: data.color || [0.5, 0.7, 0.8],
        });
    }
    toData() {
        const ins = this.ins;
        return {
            visible: ins.visible.cloneValue(),
            color: ins.color.cloneValue(),
        };
    }
}
CVGrid.typeName = "CVGrid";
CVGrid.text = "Grid";
CVGrid.icon = "";
CVGrid.gridIns = {
    color: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].ColorRGB("Grid.Color", [0.5, 0.7, 0.8]),
    opacity: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Percent("Grid.Opacity", 1.0),
    boundingBox: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Object("Scene.BoundingBox", three__WEBPACK_IMPORTED_MODULE_0__["Box3"]),
};
CVGrid.gridOuts = {
    size: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Number("Size"),
    units: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Enum("Units", client_schema_common__WEBPACK_IMPORTED_MODULE_4__["EUnitType"]),
};


/***/ }),

/***/ "./components/CVInterface.ts":
/*!***********************************!*\
  !*** ./components/CVInterface.ts ***!
  \***********************************/
/*! exports provided: EUIElements, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EUIElements", function() { return EUIElements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVInterface; });
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

////////////////////////////////////////////////////////////////////////////////
var EUIElements;
(function (EUIElements) {
    EUIElements[EUIElements["none"] = 0] = "none";
    EUIElements[EUIElements["menu"] = 1] = "menu";
    EUIElements[EUIElements["title"] = 2] = "title";
    EUIElements[EUIElements["logo"] = 4] = "logo";
    EUIElements[EUIElements["language"] = 8] = "language";
})(EUIElements || (EUIElements = {}));
class CVInterface extends _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.ins = this.addInputs(CVInterface.ins);
        this.outs = this.addOutputs(CVInterface.outs);
    }
    update(context) {
        return true;
    }
    fromData(data) {
        data = data || {};
        this.ins.setValues({
            visible: data.visible !== undefined ? data.visible : true,
            logo: data.logo !== undefined ? data.logo : true,
            menu: data.menu !== undefined ? data.menu : true,
            tools: data.tools !== undefined ? data.tools : true
        });
    }
    toData() {
        const ins = this.ins;
        return {
            visible: ins.visible.value,
            logo: ins.logo.value,
            menu: ins.menu.value,
            tools: ins.tools.value
        };
    }
    isShowing(element) {
        const ins = this.ins;
        return (element & ins.visibleElements.value) === element;
    }
}
CVInterface.typeName = "CVInterface";
CVInterface.ins = {
    visible: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("Interface.Visible", true),
    logo: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("Interface.Logo", true),
    menu: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("Interface.Menu", true),
    tools: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("Interface.Tools", true),
    visibleElements: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Number("Interface.VisibleElements", 15)
};
CVInterface.outs = {
    documentTitle: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].String("Document.Title"),
};


/***/ }),

/***/ "./components/CVLanguageManager.ts":
/*!*****************************************!*\
  !*** ./components/CVLanguageManager.ts ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVLanguageManager; });
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var client_schema_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! client/schema/common */ "./schema/common.ts");
/* harmony import */ var _CVAssetReader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CVAssetReader */ "./components/CVAssetReader.ts");
/**
 * 3D Foundation Project
 * Copyright 2020 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Component that manages current language options and
 * facilitates the switching of languages.
 */
class CVLanguageManager extends _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this._activeLanguages = [];
        this._translations = {};
        this.ins = this.addInputs(CVLanguageManager.ins);
        this.outs = this.addOutputs(CVLanguageManager.outs);
        this.updateLanguage = () => {
            const { ins, outs } = this;
            outs.language.setValue(ins.language.value);
            this.emit({ type: "tag-update" });
        };
    }
    get assetReader() {
        return this.getMainComponent(_CVAssetReader__WEBPACK_IMPORTED_MODULE_2__["default"]);
    }
    get activeLanguages() {
        return this._activeLanguages;
    }
    toString() {
        return client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageStringType"][client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][this.ins.language.value]];
    }
    create() {
        super.create();
    }
    update() {
        const { ins, outs } = this;
        if (this.activeLanguages.length == 0) {
            this.addLanguage(outs.language.value);
            return;
        }
        if (ins.language.changed) {
            this.assetReader.getSystemJSON("language/string.resources." + client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][this.ins.language.value].toLowerCase() + ".json").then(json => {
                this._translations = json;
                this.updateLanguage();
                //this.analytics.sendProperty("Menu.Language", outs.language.value);
            });
        }
        return true;
    }
    fromData(data) {
        data = data || {};
        const language = client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][data.language || "EN"];
        this.ins.language.setValue(isFinite(language) ? language : client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"].EN);
        this.updateLanguage();
    }
    toData() {
        const ins = this.ins;
        return {
            language: client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][ins.language.getValidatedValue()],
        };
    }
    addLanguage(language) {
        const exists = this._activeLanguages.find(element => element.id === language);
        if (!exists) {
            this._activeLanguages.push({ id: language, name: client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageStringType"][client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][language]] });
        }
    }
    getLocalizedString(text) {
        const dictionary = this._translations;
        if (dictionary === undefined) {
            return text;
        }
        return dictionary[text] || text;
    }
}
CVLanguageManager.typeName = "CVLanguageManager";
CVLanguageManager.text = "LanguageManager";
CVLanguageManager.icon = "";
CVLanguageManager.isSystemSingleton = true;
CVLanguageManager.ins = {
    enabled: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("Language.Enabled", false),
    language: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Enum("Interface.Language", client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"], client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"].EN),
};
CVLanguageManager.outs = {
    language: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Enum("Interface.Language", client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"], client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"].EN),
};


/***/ }),

/***/ "./components/CVLight.ts":
/*!*******************************!*\
  !*** ./components/CVLight.ts ***!
  \*******************************/
/*! exports provided: CLight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_scene_components_CLight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/scene/components/CLight */ "../../libs/ff-scene/source/components/CLight.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CLight", function() { return _ff_scene_components_CLight__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

////////////////////////////////////////////////////////////////////////////////



/***/ }),

/***/ "./components/CVLightTool.ts":
/*!***********************************!*\
  !*** ./components/CVLightTool.ts ***!
  \***********************************/
/*! exports provided: default, LightToolView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVLightTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LightToolView", function() { return LightToolView; });
/* harmony import */ var _ff_scene_components_CLight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/scene/components/CLight */ "../../libs/ff-scene/source/components/CLight.ts");
/* harmony import */ var _ui_PropertyBoolean__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ui/PropertyBoolean */ "./ui/PropertyBoolean.ts");
/* harmony import */ var _ui_PropertyOptions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ui/PropertyOptions */ "./ui/PropertyOptions.ts");
/* harmony import */ var _ui_PropertySlider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ui/PropertySlider */ "./ui/PropertySlider.ts");
/* harmony import */ var _ui_PropertyColor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ui/PropertyColor */ "./ui/PropertyColor.ts");
/* harmony import */ var _CVTool__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CVTool */ "./components/CVTool.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






////////////////////////////////////////////////////////////////////////////////
class CVLightTool extends _CVTool__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor() {
        super(...arguments);
        this.lights = [];
        this.ins = this.addInputs(CVLightTool.ins);
        this.outs = this.addOutputs(CVLightTool.outs);
    }
    update(context) {
        this.outs.light.setValue(this.lights[this.ins.light.getValidatedValue()]);
        return true;
    }
    createView() {
        return new LightToolView(this);
    }
    onActiveDocument(previous, next) {
        this.lights = next ? next.getInnerComponents(_ff_scene_components_CLight__WEBPACK_IMPORTED_MODULE_0__["default"]) : [];
        this.ins.light.setOptions(this.lights.map(light => light.node.name));
        this.outs.light.setValue(this.lights[0]);
        super.onActiveDocument(previous, next);
    }
}
CVLightTool.typeName = "CVLightTool";
CVLightTool.text = "Lights";
CVLightTool.icon = "bulb";
CVLightTool.ins = {
    light: _CVTool__WEBPACK_IMPORTED_MODULE_5__["types"].Option("Tool.Light", []),
};
CVLightTool.outs = {
    light: _CVTool__WEBPACK_IMPORTED_MODULE_5__["types"].Object("Tool.SelectedLight", _ff_scene_components_CLight__WEBPACK_IMPORTED_MODULE_0__["default"]),
};
////////////////////////////////////////////////////////////////////////////////
let LightToolView = class LightToolView extends _CVTool__WEBPACK_IMPORTED_MODULE_5__["ToolView"] {
    constructor() {
        super(...arguments);
        this.lights = null;
    }
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-group", "sv-light-tool-view");
    }
    connected() {
        super.connected();
        this.tool.outs.light.on("value", this.onUpdate, this);
    }
    disconnected() {
        this.tool.outs.light.off("value", this.onUpdate, this);
        super.disconnected();
    }
    render() {
        const tool = this.tool;
        const lights = tool.lights;
        const document = this.activeDocument;
        if (!lights || !document) {
            return _CVTool__WEBPACK_IMPORTED_MODULE_5__["html"] `No editable lights in this scene.`;
        }
        const activeLight = tool.outs.light.value;
        const navigation = document.setup.navigation;
        const language = document.setup.language;
        const lightDetails = activeLight ? _CVTool__WEBPACK_IMPORTED_MODULE_5__["html"] `<div class="sv-section">
            <ff-button class="sv-section-lead" transparent icon="cog"></ff-button>
            <div class="sv-tool-controls">
                <!-- <sv-property-boolean .property=${activeLight.ins.visible} name="Switch"></sv-property-boolean> -->
                <sv-property-slider .property=${activeLight.ins.intensity} name=${language.getLocalizedString("Intensity")} min="0" max="2"></sv-property-slider>
                <sv-property-color .property=${activeLight.ins.color} name=${language.getLocalizedString("Color")}></sv-property-color>
            </div>
        </div>` : null;
        return _CVTool__WEBPACK_IMPORTED_MODULE_5__["html"] `${lightDetails}<div class="sv-section"><ff-button class="sv-section-lead" transparent icon=${tool.icon}></ff-button>
            <div class="sv-tool-controls">
                <!-- <sv-property-boolean .property=${navigation.ins.lightsFollowCamera} name="Follow Camera"></sv-property-boolean> -->
                <sv-property-options .property=${tool.ins.light} .language=${language} name=${language.getLocalizedString("Select Scene Light")}></sv-property-options>
            </div>
        </div>`;
    }
    onActiveDocument(previous, next) {
        if (previous) {
            previous.setup.navigation.ins.lightsFollowCamera.off("value", this.onUpdate, this);
        }
        if (next) {
            next.setup.navigation.ins.lightsFollowCamera.on("value", this.onUpdate, this);
        }
        this.requestUpdate();
    }
};
LightToolView = __decorate([
    Object(_CVTool__WEBPACK_IMPORTED_MODULE_5__["customElement"])("sv-light-tool-view")
], LightToolView);



/***/ }),

/***/ "./components/CVMeta.ts":
/*!******************************!*\
  !*** ./components/CVMeta.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVMeta; });
/* harmony import */ var _ff_core_OrderedCollection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/OrderedCollection */ "../../libs/ff-core/source/OrderedCollection.ts");
/* harmony import */ var _ff_core_UnorderedCollection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/core/UnorderedCollection */ "../../libs/ff-core/source/UnorderedCollection.ts");
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _models_Article__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../models/Article */ "./models/Article.ts");
/* harmony import */ var client_schema_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! client/schema/common */ "./schema/common.ts");
/* harmony import */ var _CVLanguageManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CVLanguageManager */ "./components/CVLanguageManager.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






class CVMeta extends _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super(...arguments);
        this.collection = new _ff_core_UnorderedCollection__WEBPACK_IMPORTED_MODULE_1__["default"]();
        this.process = new _ff_core_UnorderedCollection__WEBPACK_IMPORTED_MODULE_1__["default"]();
        this.images = new _ff_core_UnorderedCollection__WEBPACK_IMPORTED_MODULE_1__["default"]();
        this.articles = new _ff_core_OrderedCollection__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.leadArticle = null;
        this.notes = [];
    }
    get language() {
        return this.getGraphComponent(_CVLanguageManager__WEBPACK_IMPORTED_MODULE_5__["default"], true);
    }
    fromDocument(document, node) {
        if (!isFinite(node.meta)) {
            throw new Error("info property missing in node");
        }
        const data = document.metas[node.meta];
        if (data.collection) {
            this.collection.dictionary = data.collection;
        }
        if (data.process) {
            this.process.dictionary = data.process;
        }
        if (data.images) {
            const imageDict = {};
            data.images.forEach(image => imageDict[image.quality] = image);
            this.images.dictionary = imageDict;
        }
        if (data.articles) {
            this.articles.items = data.articles.map(article => _models_Article__WEBPACK_IMPORTED_MODULE_3__["default"].fromJSON(article));
            if (data.leadArticle !== undefined) {
                this.leadArticle = this.articles.getAt(data.leadArticle);
            }
            this.articles.items.forEach(article => {
                Object.keys(article.data.titles).forEach(key => {
                    this.language.addLanguage(client_schema_common__WEBPACK_IMPORTED_MODULE_4__["ELanguageType"][key]);
                });
            });
        }
        this.emit("load");
        return node.meta;
    }
    toDocument(document, node) {
        let data = null;
        if (this.collection.length > 0) {
            data = {
                collection: this.collection.dictionary,
            };
        }
        if (this.process.length > 0) {
            data = data || {};
            data.process = this.process.dictionary;
        }
        if (this.images.length > 0) {
            data = data || {};
            data.images = this.images.items;
        }
        if (this.articles.length > 0) {
            data = data || {};
            const articles = this.articles.items;
            data.articles = articles.map(article => article.toJSON());
            if (this.leadArticle) {
                data.leadArticle = articles.indexOf(this.leadArticle);
            }
        }
        if (data) {
            document.metas = document.metas || [];
            const metaIndex = document.metas.length;
            document.metas.push(data);
            return metaIndex;
        }
    }
}
CVMeta.typeName = "CVMeta";
CVMeta.text = "Meta";
CVMeta.icon = "document";


/***/ }),

/***/ "./components/CVModel2.ts":
/*!********************************!*\
  !*** ./components/CVModel2.ts ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVModel2; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_ui_Notification__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/ui/Notification */ "../../libs/ff-ui/source/Notification.ts");
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ff/scene/components/CObject3D */ "../../libs/ff-scene/source/components/CObject3D.ts");
/* harmony import */ var _ff_three_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ff/three/helpers */ "../../libs/ff-three/source/helpers.ts");
/* harmony import */ var client_schema_model__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! client/schema/model */ "./schema/model.ts");
/* harmony import */ var _utils_unitScaleFactor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/unitScaleFactor */ "./utils/unitScaleFactor.ts");
/* harmony import */ var _shaders_UberPBRMaterial__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../shaders/UberPBRMaterial */ "./shaders/UberPBRMaterial.ts");
/* harmony import */ var _models_DerivativeList__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../models/DerivativeList */ "./models/DerivativeList.ts");
/* harmony import */ var _CVAnnotationView__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./CVAnnotationView */ "./components/CVAnnotationView.ts");
/* harmony import */ var _CVAssetManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./CVAssetManager */ "./components/CVAssetManager.ts");
/* harmony import */ var _CVAssetReader__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./CVAssetReader */ "./components/CVAssetReader.ts");
/* harmony import */ var _ff_scene_components_CRenderer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @ff/scene/components/CRenderer */ "../../libs/ff-scene/source/components/CRenderer.ts");
/* harmony import */ var _CVEnvironment__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./CVEnvironment */ "./components/CVEnvironment.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */














////////////////////////////////////////////////////////////////////////////////
const _vec3a = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vec3b = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _quat = new three__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();
const _box = new three__WEBPACK_IMPORTED_MODULE_0__["Box3"]();
/**
 * Graph component rendering a model or model part.
 *
 * ### Events
 * - *"bounding-box"* - emitted after the model's bounding box changed
 */
class CVModel2 extends _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(node, id) {
        super(node, id);
        this.ins = this.addInputs(CVModel2.ins);
        this.outs = this.addOutputs(CVModel2.outs);
        this._derivatives = new _models_DerivativeList__WEBPACK_IMPORTED_MODULE_8__["default"]();
        this._activeDerivative = null;
        this._visible = true;
        this._boxFrame = null;
        this._localBoundingBox = new three__WEBPACK_IMPORTED_MODULE_0__["Box3"]();
        this.object3D = new three__WEBPACK_IMPORTED_MODULE_0__["Group"]();
    }
    get settingProperties() {
        return [
            this.ins.visible,
            this.ins.quality,
            this.ins.localUnits,
            this.ins.tags,
            this.ins.renderOrder,
            this.ins.shadowSide,
            this.ins.shader,
            this.ins.override,
            this.ins.color,
            this.ins.opacity,
            this.ins.hiddenOpacity,
            this.ins.roughness,
            this.ins.metalness,
            this.ins.occlusion,
        ];
    }
    get derivatives() {
        return this._derivatives;
    }
    get activeDerivative() {
        return this._activeDerivative;
    }
    get localBoundingBox() {
        return this._localBoundingBox;
    }
    get assetManager() {
        return this.getMainComponent(_CVAssetManager__WEBPACK_IMPORTED_MODULE_10__["default"]);
    }
    get assetReader() {
        return this.getMainComponent(_CVAssetReader__WEBPACK_IMPORTED_MODULE_11__["default"]);
    }
    get renderer() {
        return this.getMainComponent(_ff_scene_components_CRenderer__WEBPACK_IMPORTED_MODULE_12__["default"]);
    }
    create() {
        super.create();
        // link units with annotation view
        const av = this.node.createComponent(_CVAnnotationView__WEBPACK_IMPORTED_MODULE_9__["default"]);
        av.ins.unitScale.linkFrom(this.outs.unitScale);
        // set quality based on max texture size
        const maxTextureSize = this.renderer.outs.maxTextureSize.value;
        if (maxTextureSize < 2048) {
            this.ins.quality.setValue(client_schema_model__WEBPACK_IMPORTED_MODULE_5__["EDerivativeQuality"].Low);
        }
        else if (maxTextureSize < 4096) {
            this.ins.quality.setValue(client_schema_model__WEBPACK_IMPORTED_MODULE_5__["EDerivativeQuality"].Medium);
        }
        else {
            this.ins.quality.setValue(client_schema_model__WEBPACK_IMPORTED_MODULE_5__["EDerivativeQuality"].High);
        }
    }
    update() {
        const ins = this.ins;
        if (ins.tags.changed || ins.activeTags.changed || ins.visible.changed) {
            let visible = ins.visible.value;
            if (visible) {
                // determine visibility based on whether a tag of this model is selected
                const tags = ins.tags.value.split(",").map(tag => tag.trim()).filter(tag => tag);
                const activeTags = ins.activeTags.value.split(",").map(tag => tag.trim()).filter(tag => tag);
                visible = !tags.length;
                activeTags.forEach(activeTag => {
                    if (tags.indexOf(activeTag) >= 0) {
                        visible = true;
                    }
                });
            }
            const overrideActive = this.ins.override.value;
            this._visible = visible;
            if (visible) {
                this.object3D.visible = true;
                if (overrideActive) {
                    this.updateMaterial();
                }
            }
            else if (ins.visible.value && overrideActive && this.ins.hiddenOpacity.value > 0) {
                this.object3D.visible = true;
                this.updateMaterial();
            }
            else {
                this.object3D.visible = false;
            }
        }
        if (ins.tags.changed) {
            this.emit({ type: "tag-update" });
        }
        if (!this.activeDerivative && ins.autoLoad.changed && ins.autoLoad.value) {
            this.autoLoad(ins.quality.value);
        }
        else if (ins.quality.changed) {
            const derivative = this.derivatives.select(client_schema_model__WEBPACK_IMPORTED_MODULE_5__["EDerivativeUsage"].Web3D, ins.quality.value);
            if (derivative && derivative !== this.activeDerivative) {
                this.loadDerivative(derivative)
                    .catch(error => {
                    console.warn("Model.update - failed to load derivative");
                    console.warn(error);
                });
            }
        }
        if (ins.renderOrder.changed) {
            this.updateRenderOrder(this.object3D, ins.renderOrder.value);
        }
        if (ins.localUnits.changed || ins.globalUnits.changed) {
            this.updateUnitScale();
        }
        if (ins.shader.changed) {
            this.updateShader();
        }
        if (ins.override.value && ins.shader.value === _shaders_UberPBRMaterial__WEBPACK_IMPORTED_MODULE_7__["EShaderMode"].Default && (ins.override.changed ||
            ins.color.changed || ins.opacity.changed ||
            ins.roughness.changed || ins.metalness.changed || ins.occlusion.changed)) {
            this.updateMaterial();
        }
        if (ins.center.changed) {
            this.center();
        }
        if (ins.position.changed || ins.rotation.changed) {
            this.updateMatrixFromProps();
        }
        if (ins.dumpDerivatives.changed) {
            console.log(this.derivatives.toString(true));
        }
        return true;
    }
    dispose() {
        this.derivatives.clear();
        this._activeDerivative = null;
        super.dispose();
    }
    center() {
        const object3D = this.object3D;
        const position = this.ins.position;
        // remove position and scaling, but preserve rotation
        object3D.matrix.decompose(_vec3a, _quat, _vec3b);
        object3D.matrix.makeRotationFromQuaternion(_quat);
        // compute local bounding box and set position offset
        _box.makeEmpty();
        _ff_three_helpers__WEBPACK_IMPORTED_MODULE_4__["computeLocalBoundingBox"](object3D, _box, object3D.parent);
        _box.getCenter(_vec3a);
        _vec3a.multiplyScalar(-1).toArray(position.value);
        // trigger matrix update
        position.set();
    }
    setFromMatrix(matrix) {
        const ins = this.ins;
        matrix.decompose(_vec3a, _quat, _vec3b);
        _vec3a.multiplyScalar(1 / this.outs.unitScale.value).toArray(ins.position.value);
        ins.position.set();
        _ff_three_helpers__WEBPACK_IMPORTED_MODULE_4__["quaternionToDegrees"](_quat, CVModel2.rotationOrder, ins.rotation.value);
        ins.rotation.set();
    }
    fromDocument(document, node) {
        const { ins, outs } = this;
        if (!isFinite(node.model)) {
            throw new Error("model property missing in node");
        }
        const data = document.models[node.model];
        const units = client_schema_model__WEBPACK_IMPORTED_MODULE_5__["EUnitType"][data.units || "cm"];
        ins.localUnits.setValue(isFinite(units) ? units : client_schema_model__WEBPACK_IMPORTED_MODULE_5__["EUnitType"].cm);
        ins.visible.setValue(data.visible !== undefined ? data.visible : true);
        ins.tags.setValue(data.tags || "");
        ins.renderOrder.setValue(data.renderOrder !== undefined ? data.renderOrder : 0);
        const side = client_schema_model__WEBPACK_IMPORTED_MODULE_5__["ESideType"][data.shadowSide || "Back"];
        ins.shadowSide.setValue(isFinite(side) ? side : client_schema_model__WEBPACK_IMPORTED_MODULE_5__["ESideType"].Back);
        ins.position.reset();
        ins.rotation.reset();
        if (data.translation) {
            ins.position.copyValue(data.translation);
        }
        if (data.rotation) {
            _quat.fromArray(data.rotation);
            _ff_three_helpers__WEBPACK_IMPORTED_MODULE_4__["quaternionToDegrees"](_quat, CVModel2.rotationOrder, ins.rotation.value);
            ins.rotation.set();
        }
        if (data.boundingBox) {
            const boundingBox = this._localBoundingBox;
            boundingBox.min.fromArray(data.boundingBox.min);
            boundingBox.max.fromArray(data.boundingBox.max);
            this._boxFrame = new three__WEBPACK_IMPORTED_MODULE_0__["Box3Helper"](boundingBox, "#009cde");
            this.addObject3D(this._boxFrame);
            this._boxFrame.updateMatrixWorld(true);
            outs.updated.set();
        }
        if (data.derivatives) {
            this.derivatives.fromJSON(data.derivatives);
        }
        if (data.material) {
            const material = data.material;
            ins.copyValues({
                override: true,
                color: material.color || ins.color.schema.preset,
                opacity: material.opacity !== undefined ? material.opacity : ins.opacity.schema.preset,
                hiddenOpacity: material.hiddenOpacity !== undefined ? material.hiddenOpacity : ins.hiddenOpacity.schema.preset,
                roughness: material.roughness !== undefined ? material.roughness : ins.roughness.schema.preset,
                metalness: material.metalness !== undefined ? material.metalness : ins.metalness.schema.preset,
                occlusion: material.occlusion !== undefined ? material.occlusion : ins.occlusion.schema.preset,
            });
        }
        if (data.annotations) {
            this.getComponent(_CVAnnotationView__WEBPACK_IMPORTED_MODULE_9__["default"]).fromData(data.annotations);
        }
        // emit tag update event
        this.emit({ type: "tag-update" });
        // trigger automatic loading of derivatives if active
        this.ins.autoLoad.set();
        return node.model;
    }
    toDocument(document, node) {
        const data = {
            units: client_schema_model__WEBPACK_IMPORTED_MODULE_5__["EUnitType"][this.ins.localUnits.getValidatedValue()]
        };
        const ins = this.ins;
        if (!ins.visible.value) {
            data.visible = false;
        }
        if (ins.tags.value) {
            data.tags = ins.tags.value;
        }
        if (ins.renderOrder.value !== 0) {
            data.renderOrder = ins.renderOrder.value;
        }
        if (ins.shadowSide.value != client_schema_model__WEBPACK_IMPORTED_MODULE_5__["ESideType"].Back) {
            data.shadowSide = client_schema_model__WEBPACK_IMPORTED_MODULE_5__["ESideType"][this.ins.shadowSide.getValidatedValue()];
        }
        const position = ins.position.value;
        if (position[0] !== 0 || position[1] !== 0 || position[2] !== 0) {
            data.translation = ins.position.value;
        }
        const rotation = ins.rotation.value;
        if (rotation[0] !== 0 || rotation[1] !== 0 || rotation[2] !== 0) {
            _ff_three_helpers__WEBPACK_IMPORTED_MODULE_4__["degreesToQuaternion"](rotation, CVModel2.rotationOrder, _quat);
            data.rotation = _quat.toArray();
        }
        if (ins.override.value) {
            data.material = {
                color: ins.color.value,
                opacity: ins.opacity.value,
                hiddenOpacity: ins.hiddenOpacity.value,
                roughness: ins.roughness.value,
                metalness: ins.metalness.value,
                occlusion: ins.occlusion.value,
            };
        }
        data.boundingBox = {
            min: this._localBoundingBox.min.toArray(),
            max: this._localBoundingBox.max.toArray()
        };
        data.derivatives = this.derivatives.toJSON();
        const annotations = this.getComponent(_CVAnnotationView__WEBPACK_IMPORTED_MODULE_9__["default"]).toData();
        if (annotations && annotations.length > 0) {
            data.annotations = annotations;
        }
        document.models = document.models || [];
        const modelIndex = document.models.length;
        document.models.push(data);
        return modelIndex;
    }
    updateShader() {
        const shader = this.ins.shader.getValidatedValue();
        this.object3D.traverse(object => {
            const material = object["material"];
            if (material && material.isUberPBRMaterial) {
                material.setShaderMode(shader);
            }
        });
    }
    updateMaterial() {
        const ins = this.ins;
        this.object3D.traverse(object => {
            const material = object["material"];
            if (material && material.isUberPBRMaterial) {
                material.aoMapMix.setScalar(ins.occlusion.value);
                material.color.fromArray(ins.color.value);
                material.opacity = this._visible ? ins.opacity.value : ins.hiddenOpacity.value;
                material.transparent = material.opacity < 1 || !!material.alphaMap;
                //material.depthWrite = material.opacity === 1;
                material.roughness = ins.roughness.value;
                material.metalness = ins.metalness.value;
            }
        });
    }
    updateUnitScale() {
        const fromUnits = this.ins.localUnits.getValidatedValue();
        const toUnits = this.ins.globalUnits.getValidatedValue();
        this.outs.unitScale.setValue(Object(_utils_unitScaleFactor__WEBPACK_IMPORTED_MODULE_6__["default"])(fromUnits, toUnits));
        if (true) {
            console.log("Model.updateUnitScale, from: %s, to: %s", fromUnits, toUnits);
        }
        this.updateMatrixFromProps();
    }
    updateMatrixFromProps() {
        const ins = this.ins;
        const unitScale = this.outs.unitScale.value;
        const object3D = this.object3D;
        _vec3a.fromArray(ins.position.value).multiplyScalar(unitScale);
        _ff_three_helpers__WEBPACK_IMPORTED_MODULE_4__["degreesToQuaternion"](ins.rotation.value, CVModel2.rotationOrder, _quat);
        _vec3b.setScalar(unitScale);
        object3D.matrix.compose(_vec3a, _quat, _vec3b);
        object3D.matrixWorldNeedsUpdate = true;
        this.outs.updated.set();
    }
    updateRenderOrder(model, value) {
        model.renderOrder = value;
        model.children.forEach(child => this.updateRenderOrder(child, value));
    }
    /**
     * Automatically loads derivatives up to the given quality.
     * First loads the lowest available quality (usually thumb), then
     * loads the desired quality level.
     * @param quality
     */
    autoLoad(quality) {
        const sequence = [];
        const lowestQualityDerivative = this.derivatives.select(client_schema_model__WEBPACK_IMPORTED_MODULE_5__["EDerivativeUsage"].Web3D, client_schema_model__WEBPACK_IMPORTED_MODULE_5__["EDerivativeQuality"].Thumb);
        if (lowestQualityDerivative) {
            sequence.push(lowestQualityDerivative);
        }
        const targetQualityDerivative = this.derivatives.select(client_schema_model__WEBPACK_IMPORTED_MODULE_5__["EDerivativeUsage"].Web3D, quality);
        if (targetQualityDerivative && targetQualityDerivative !== lowestQualityDerivative) {
            sequence.push(targetQualityDerivative);
        }
        if (sequence.length === 0) {
            _ff_ui_Notification__WEBPACK_IMPORTED_MODULE_1__["default"].show(`No 3D derivatives available for '${this.displayName}'.`);
            return Promise.resolve();
        }
        // load sequence of derivatives one by one
        return sequence.reduce((promise, derivative) => {
            return promise.then(() => this.loadDerivative(derivative));
        }, Promise.resolve());
    }
    /**
     * Loads and displays the given derivative.
     * @param derivative
     */
    loadDerivative(derivative) {
        return derivative.load(this.assetReader)
            .then(() => {
            if (!derivative.model) {
                return;
            }
            // set asset manager flag for initial model load
            if (!this.assetManager.initialLoad && !this._activeDerivative) {
                this.assetManager.initialLoad = true;
            }
            if (this._activeDerivative) {
                this.removeObject3D(this._activeDerivative.model);
                this._activeDerivative.unload();
            }
            this._activeDerivative = derivative;
            this.addObject3D(derivative.model);
            this.renderer.activeSceneComponent.scene.updateMatrixWorld(true);
            if (this._boxFrame) {
                this.removeObject3D(this._boxFrame);
                this._boxFrame.geometry.dispose();
                this._boxFrame = null;
            }
            // update bounding box based on loaded derivative
            _ff_three_helpers__WEBPACK_IMPORTED_MODULE_4__["computeLocalBoundingBox"](derivative.model, this._localBoundingBox);
            this.outs.updated.set();
            if (true) {
                // log bounding box to console
                const box = { min: this._localBoundingBox.min.toArray(), max: this._localBoundingBox.max.toArray() };
                console.log("CVModel.onLoad - bounding box: ", box);
            }
            // update loaded quality property
            this.outs.quality.setValue(derivative.data.quality);
            if (this.ins.override.value) {
                this.updateMaterial();
            }
            // update shadow render side
            if (this.ins.shadowSide.value != client_schema_model__WEBPACK_IMPORTED_MODULE_5__["ESideType"].Back) {
                this.object3D.traverse(object => {
                    const material = object["material"];
                    if (material && material.isUberPBRMaterial) {
                        if (this.ins.shadowSide.value == client_schema_model__WEBPACK_IMPORTED_MODULE_5__["ESideType"].Front) {
                            material.shadowSide = three__WEBPACK_IMPORTED_MODULE_0__["FrontSide"];
                        }
                        else {
                            material.shadowSide = three__WEBPACK_IMPORTED_MODULE_0__["BackSide"];
                        }
                    }
                });
            }
            // flag environment map to update if needed
            this.getGraphComponent(_CVEnvironment__WEBPACK_IMPORTED_MODULE_13__["default"]).ins.dirty.set();
            // make sure render order is correct
            if (this.ins.renderOrder.value !== 0)
                this.updateRenderOrder(this.object3D, this.ins.renderOrder.value);
        })
            .catch(error => _ff_ui_Notification__WEBPACK_IMPORTED_MODULE_1__["default"].show(`Failed to load model derivative: ${error.message}`));
    }
    addObject3D(object) {
        this.object3D.add(object);
        this.object3D.traverse(node => {
            if (node.type === "Mesh") {
                this.registerPickableObject3D(node, true);
            }
        });
    }
}
CVModel2.typeName = "CVModel2";
CVModel2.text = "Model";
CVModel2.icon = "cube";
CVModel2.rotationOrder = "ZYX";
CVModel2.ins = {
    globalUnits: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Enum("Model.GlobalUnits", client_schema_model__WEBPACK_IMPORTED_MODULE_5__["EUnitType"], client_schema_model__WEBPACK_IMPORTED_MODULE_5__["EUnitType"].cm),
    localUnits: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Enum("Model.LocalUnits", client_schema_model__WEBPACK_IMPORTED_MODULE_5__["EUnitType"], client_schema_model__WEBPACK_IMPORTED_MODULE_5__["EUnitType"].cm),
    quality: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Enum("Model.Quality", client_schema_model__WEBPACK_IMPORTED_MODULE_5__["EDerivativeQuality"], client_schema_model__WEBPACK_IMPORTED_MODULE_5__["EDerivativeQuality"].High),
    tags: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].String("Model.Tags"),
    renderOrder: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Number("Model.RenderOrder", 0),
    shadowSide: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Enum("Model.ShadowSide", client_schema_model__WEBPACK_IMPORTED_MODULE_5__["ESideType"], client_schema_model__WEBPACK_IMPORTED_MODULE_5__["ESideType"].Back),
    activeTags: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].String("Model.ActiveTags"),
    autoLoad: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Boolean("Model.AutoLoad", true),
    position: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Vector3("Model.Position"),
    rotation: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Vector3("Model.Rotation"),
    center: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Event("Model.Center"),
    shader: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Enum("Material.Shader", _shaders_UberPBRMaterial__WEBPACK_IMPORTED_MODULE_7__["EShaderMode"], _shaders_UberPBRMaterial__WEBPACK_IMPORTED_MODULE_7__["EShaderMode"].Default),
    override: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Boolean("Material.Override", false),
    color: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].ColorRGB("Material.BaseColor"),
    opacity: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Percent("Material.Opacity", 1.0),
    hiddenOpacity: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Percent("Material.HiddenOpacity", 0.0),
    roughness: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Percent("Material.Roughness", 0.8),
    metalness: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Percent("Material.Metalness", 0.1),
    occlusion: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Percent("Material.Occlusion", 0.3),
    dumpDerivatives: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Event("Derivatives.Dump"),
};
CVModel2.outs = {
    unitScale: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Number("UnitScale", { preset: 1, precision: 5 }),
    quality: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Enum("LoadedQuality", client_schema_model__WEBPACK_IMPORTED_MODULE_5__["EDerivativeQuality"]),
    updated: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_2__["types"].Event("Updated"),
};


/***/ }),

/***/ "./components/CVNode.ts":
/*!******************************!*\
  !*** ./components/CVNode.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVNode; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_scene_components_CTransform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/scene/components/CTransform */ "../../libs/ff-scene/source/components/CTransform.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


////////////////////////////////////////////////////////////////////////////////
const _vec3a = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vec3b = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _mat4 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
const _quat = new three__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();
const _euler = new three__WEBPACK_IMPORTED_MODULE_0__["Euler"]();
class CVNode extends _ff_scene_components_CTransform__WEBPACK_IMPORTED_MODULE_1__["default"] {
    get settingProperties() {
        return [
            this.ins.position,
            this.ins.rotation,
            this.ins.scale,
        ];
    }
    get snapshotProperties() {
        return [
            this.ins.position,
            this.ins.rotation,
            this.ins.scale,
        ];
    }
    fromData(data) {
        const { position, rotation, order, scale } = this.ins;
        const orderTag = _ff_scene_components_CTransform__WEBPACK_IMPORTED_MODULE_1__["ERotationOrder"][order.getValidatedValue()];
        if (data.matrix) {
            _mat4.fromArray(data.matrix);
            _mat4.decompose(_vec3a, _quat, _vec3b);
            _vec3a.toArray(position.value);
            _euler.setFromQuaternion(_quat, orderTag);
            _euler.toVector3(_vec3a).multiplyScalar(three__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].RAD2DEG).toArray(rotation.value);
            _vec3b.toArray(scale.value);
            position.set();
            rotation.set();
            scale.set();
        }
        else {
            if (data.translation) {
                position.setValue(data.translation.slice());
            }
            if (data.rotation) {
                _quat.fromArray(data.rotation);
                _euler.setFromQuaternion(_quat, orderTag);
                _euler.toVector3(_vec3a).multiplyScalar(three__WEBPACK_IMPORTED_MODULE_0__["MathUtils"].RAD2DEG).toArray(rotation.value);
                rotation.set();
            }
            if (data.scale) {
                scale.setValue(data.scale.slice());
            }
            // this updates the matrix from the PRS properties
            this.transform.changed = true;
        }
    }
    toData() {
        this.object3D.matrix.decompose(_vec3a, _quat, _vec3b);
        const data = {};
        if (_vec3a.x !== 0 || _vec3a.y !== 0 || _vec3a.z !== 0) {
            data.translation = _vec3a.toArray();
        }
        if (_quat.x !== 0 || _quat.y !== 0 || _quat.z !== 0 || _quat.w !== 1) {
            data.rotation = _quat.toArray();
        }
        if (_vec3b.x !== 1 || _vec3b.y !== 1 || _vec3b.z !== 1) {
            data.scale = _vec3b.toArray();
        }
        return data;
    }
}
CVNode.typeName = "CVNode";
CVNode.text = "Transform";
CVNode.icon = "";


/***/ }),

/***/ "./components/CVNodeObserver.ts":
/*!**************************************!*\
  !*** ./components/CVNodeObserver.ts ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVNodeObserver; });
/* harmony import */ var _CVNodeProvider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CVNodeProvider */ "./components/CVNodeProvider.ts");
/* harmony import */ var _CVDocumentObserver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CVDocumentObserver */ "./components/CVDocumentObserver.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


////////////////////////////////////////////////////////////////////////////////
/**
 * Inherit from this class to observe changes of the currently active node and document.
 * Call startObserving() to begin receiving change events. Override onActiveNode() to react on active node changes.
 * Override onActiveDocument() to react on active document changes.
 */
class CVNodeObserver extends _CVDocumentObserver__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(...arguments);
        this.activeNode = null;
    }
    get nodeProvider() {
        return this.getGraphComponent(_CVNodeProvider__WEBPACK_IMPORTED_MODULE_0__["default"]);
    }
    /**
     * Starts observing changes of the active node. Must be called explicitly by descendant classes
     * in order to start observation.
     */
    startObserving() {
        super.startObserving();
        const provider = this.nodeProvider;
        provider.on("active-node", this.onActiveNodeEvent, this);
        if (provider.activeNode) {
            this.activeNode = provider.activeNode;
            this.onActiveNode(null, provider.activeNode);
        }
    }
    /**
     * Stops observing changes of the active node.
     */
    stopObserving() {
        const provider = this.nodeProvider;
        provider.off("active-node", this.onActiveNodeEvent, this);
        // if a node is active,
        if (provider.activeNode) {
            this.activeNode = null;
            this.onActiveNode(provider.activeNode, null);
        }
        super.stopObserving();
    }
    /**
     * Called after the active node has changed. Override to react on the change.
     * @param previous The previous active node.
     * @param next The next active node.
     */
    onActiveNode(previous, next) {
    }
    onActiveNodeEvent(event) {
        this.activeNode = event.next;
        this.onActiveNode(event.previous, event.next);
    }
}
CVNodeObserver.typeName = "CVNodeObserver";


/***/ }),

/***/ "./components/CVNodeProvider.ts":
/*!**************************************!*\
  !*** ./components/CVNodeProvider.ts ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVNodeProvider; });
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _ff_graph_components_CNodeProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/graph/components/CNodeProvider */ "../../libs/ff-graph/source/components/CNodeProvider.ts");
/* harmony import */ var _nodes_NVNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../nodes/NVNode */ "./nodes/NVNode.ts");
/* harmony import */ var _CVDocumentProvider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CVDocumentProvider */ "./components/CVDocumentProvider.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class CVNodeProvider extends _ff_graph_components_CNodeProvider__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(node, id) {
        super(node, id);
        this.outs = this.addOutputs(CVNodeProvider.outs);
        this.scope = _ff_graph_components_CNodeProvider__WEBPACK_IMPORTED_MODULE_1__["ENodeScope"].Graph;
    }
    get documentProvider() {
        return this.getComponent(_CVDocumentProvider__WEBPACK_IMPORTED_MODULE_3__["default"]);
    }
    create() {
        super.create();
        this.documentProvider.on("active-component", this.onActiveDocument, this);
    }
    dispose() {
        this.documentProvider.off("active-component", this.onActiveDocument, this);
        super.dispose();
    }
    onActiveDocument(event) {
        this.scopedGraph = event.next;
    }
    onActiveNode(previous, next) {
        this.outs.activeNode.setValue(next);
        const selection = this.selection;
        if (next) {
            if (!selection.nodeContainsSelectedComponent(next)) {
                selection.selectNode(next);
            }
        }
        else if (previous) {
            selection.clearSelection();
        }
    }
    onScopedNodes() {
        this.outs.changedNodes.set();
    }
}
CVNodeProvider.typeName = "CVNodeProvider";
CVNodeProvider.nodeType = _nodes_NVNode__WEBPACK_IMPORTED_MODULE_2__["default"];
CVNodeProvider.followComponentSelection = true;
CVNodeProvider.outs = {
    activeNode: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Object("Nodes.Active", _nodes_NVNode__WEBPACK_IMPORTED_MODULE_2__["default"]),
    changedNodes: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Event("Nodes.Changed"),
};


/***/ }),

/***/ "./components/CVOrbitNavigation.ts":
/*!*****************************************!*\
  !*** ./components/CVOrbitNavigation.ts ***!
  \*****************************************/
/*! exports provided: EProjection, EViewPreset, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EViewPreset", function() { return EViewPreset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVOrbitNavigation; });
/* harmony import */ var _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/scene/components/CObject3D */ "../../libs/ff-scene/source/components/CObject3D.ts");
/* harmony import */ var _ff_three_CameraController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/three/CameraController */ "../../libs/ff-three/source/CameraController.ts");
/* harmony import */ var _ff_scene_components_CTransform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/scene/components/CTransform */ "../../libs/ff-scene/source/components/CTransform.ts");
/* harmony import */ var _ff_three_UniversalCamera__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ff/three/UniversalCamera */ "../../libs/ff-three/source/UniversalCamera.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EProjection", function() { return _ff_three_UniversalCamera__WEBPACK_IMPORTED_MODULE_3__["EProjection"]; });

/* harmony import */ var _CVScene__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CVScene */ "./components/CVScene.ts");
/* harmony import */ var _CVAssetManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CVAssetManager */ "./components/CVAssetManager.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






////////////////////////////////////////////////////////////////////////////////

var EViewPreset;
(function (EViewPreset) {
    EViewPreset[EViewPreset["Left"] = 0] = "Left";
    EViewPreset[EViewPreset["Right"] = 1] = "Right";
    EViewPreset[EViewPreset["Top"] = 2] = "Top";
    EViewPreset[EViewPreset["Bottom"] = 3] = "Bottom";
    EViewPreset[EViewPreset["Front"] = 4] = "Front";
    EViewPreset[EViewPreset["Back"] = 5] = "Back";
    EViewPreset[EViewPreset["None"] = 6] = "None";
})(EViewPreset || (EViewPreset = {}));
const _orientationPresets = [];
_orientationPresets[EViewPreset.Left] = [0, -90, 0];
_orientationPresets[EViewPreset.Right] = [0, 90, 0];
_orientationPresets[EViewPreset.Front] = [0, 0, 0];
_orientationPresets[EViewPreset.Back] = [0, 180, 0];
_orientationPresets[EViewPreset.Top] = [-90, 0, 0];
_orientationPresets[EViewPreset.Bottom] = [90, 0, 0];
const _replaceNull = function (vector, replacement) {
    for (let i = 0, n = vector.length; i < n; ++i) {
        vector[i] = vector[i] === null ? replacement : vector[i];
    }
    return vector;
};
/**
 * Voyager explorer orbit navigation.
 * Controls manipulation and parameters of the camera.
 */
class CVOrbitNavigation extends _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(node, id) {
        super(node, id);
        this.ins = this.addInputs(CVOrbitNavigation.ins);
        this._controller = new _ff_three_CameraController__WEBPACK_IMPORTED_MODULE_1__["default"]();
        this._scene = null;
        this._modelBoundingBox = null;
        this._hasChanged = false;
        this._scene = this.scene;
    }
    get settingProperties() {
        return [
            this.ins.enabled,
            this.ins.orbit,
            this.ins.offset,
            this.ins.autoZoom,
            this.ins.autoRotation,
            this.ins.lightsFollowCamera,
            this.ins.minOrbit,
            this.ins.minOffset,
            this.ins.maxOrbit,
            this.ins.maxOffset,
        ];
    }
    get snapshotProperties() {
        return [
            this.ins.orbit,
            this.ins.offset,
        ];
    }
    get assetManager() {
        return this.getMainComponent(_CVAssetManager__WEBPACK_IMPORTED_MODULE_5__["default"]);
    }
    get sceneNode() {
        return this.getSystemComponent(_CVScene__WEBPACK_IMPORTED_MODULE_4__["default"]);
    }
    create() {
        super.create();
        this.system.on(["pointer-down", "pointer-up", "pointer-move"], this.onPointer, this);
        this.system.on("wheel", this.onTrigger, this);
        this.assetManager.outs.completed.on("value", this.onLoadingCompleted, this);
        this.sceneNode.outs.boundingBox.on("value", this.onBoundsUpdate, this);
    }
    dispose() {
        this.sceneNode.outs.boundingBox.off("value", this.onBoundsUpdate, this);
        this.assetManager.outs.completed.off("value", this.onLoadingCompleted, this);
        this.system.off(["pointer-down", "pointer-up", "pointer-move"], this.onPointer, this);
        this.system.off("wheel", this.onTrigger, this);
        super.dispose();
    }
    update() {
        const ins = this.ins;
        const controller = this._controller;
        const cameraComponent = this._scene.activeCameraComponent;
        const camera = cameraComponent ? cameraComponent.camera : null;
        const { projection, preset, orbit, offset } = ins;
        // camera projection
        if (cameraComponent && projection.changed) {
            camera.setProjection(projection.getValidatedValue());
            cameraComponent.ins.projection.setValue(projection.value, true);
        }
        // camera preset
        if (preset.changed && preset.value !== EViewPreset.None) {
            orbit.setValue(_orientationPresets[preset.getValidatedValue()].slice());
        }
        // zoom extents
        if (camera && ins.zoomExtents.changed) {
            const scene = this.getGraphComponent(_CVScene__WEBPACK_IMPORTED_MODULE_4__["default"]);
            this._modelBoundingBox = scene.outs.boundingBox.value;
            controller.zoomExtents(this._modelBoundingBox);
        }
        // include lights
        if (ins.lightsFollowCamera.changed) {
            const lightTransform = this.getLightTransform();
            if (lightTransform) {
                if (ins.lightsFollowCamera.value) {
                    lightTransform.ins.order.setValue(_ff_scene_components_CTransform__WEBPACK_IMPORTED_MODULE_2__["ERotationOrder"].ZXY);
                    lightTransform.ins.rotation.reset();
                    lightTransform.ins.rotation.linkFrom(orbit, 1, 1);
                }
                else {
                    lightTransform.ins.rotation.unlinkFrom(orbit, 1, 1);
                    lightTransform.ins.rotation.reset();
                }
            }
        }
        const { minOrbit, minOffset, maxOrbit, maxOffset } = ins;
        // orbit, offset and limits
        if (orbit.changed || offset.changed) {
            controller.orbit.fromArray(orbit.value);
            controller.offset.fromArray(offset.value);
        }
        if (minOrbit.changed || minOffset.changed || maxOrbit.changed || maxOffset.changed) {
            controller.minOrbit.fromArray(minOrbit.value);
            controller.minOffset.fromArray(minOffset.value);
            controller.maxOrbit.fromArray(maxOrbit.value);
            controller.maxOffset.fromArray(maxOffset.value);
        }
        return true;
    }
    tick() {
        const ins = this.ins;
        const cameraComponent = this._scene.activeCameraComponent;
        if (!ins.enabled.value || !cameraComponent) {
            return;
        }
        const controller = this._controller;
        controller.camera = cameraComponent.camera;
        const transform = cameraComponent.transform;
        const forceUpdate = this.changed;
        if (controller.updateCamera(transform.object3D, forceUpdate)) {
            controller.orbit.toArray(ins.orbit.value);
            ins.orbit.set(true);
            controller.offset.toArray(ins.offset.value);
            ins.offset.set(true);
            // if camera has moved, set preset to "None"
            if (ins.preset.value !== EViewPreset.None && !ins.preset.changed) {
                ins.preset.setValue(EViewPreset.None, true);
            }
            if (transform) {
                transform.setPropertiesFromMatrix();
            }
            else {
                cameraComponent.setPropertiesFromMatrix();
            }
            return true;
        }
        return false;
    }
    preRender(context) {
        if (this._modelBoundingBox) {
            context.viewport.zoomExtents(this._modelBoundingBox);
        }
    }
    setChanged(changed) {
        this._hasChanged = changed;
    }
    tock() {
        this._modelBoundingBox = null;
        return false;
    }
    fromData(data) {
        data = data || {};
        const orbit = data.orbit || {
            orbit: [-25, -25, 0],
            offset: [0, 0, 100],
            minOrbit: [-90, -Infinity, -Infinity],
            minOffset: [-Infinity, -Infinity, 0.1],
            maxOrbit: [90, Infinity, Infinity],
            maxOffset: [Infinity, Infinity, Infinity],
        };
        this.ins.copyValues({
            enabled: !!data.enabled,
            autoZoom: !!data.autoZoom,
            autoRotation: !!data.autoRotation,
            lightsFollowCamera: !!data.lightsFollowCamera,
            orbit: orbit.orbit,
            offset: orbit.offset,
            minOrbit: _replaceNull(orbit.minOrbit, -Infinity),
            maxOrbit: _replaceNull(orbit.maxOrbit, Infinity),
            minOffset: _replaceNull(orbit.minOffset, -Infinity),
            maxOffset: _replaceNull(orbit.maxOffset, Infinity),
        });
    }
    toData() {
        const ins = this.ins;
        const data = {};
        data.enabled = ins.enabled.value;
        data.autoZoom = ins.autoZoom.value;
        data.autoRotation = ins.autoRotation.value;
        data.lightsFollowCamera = ins.lightsFollowCamera.value;
        data.type = "Orbit";
        data.orbit = {
            orbit: ins.orbit.cloneValue(),
            offset: ins.offset.cloneValue(),
            minOrbit: ins.minOrbit.cloneValue(),
            maxOrbit: ins.maxOrbit.cloneValue(),
            minOffset: ins.minOffset.cloneValue(),
            maxOffset: ins.maxOffset.cloneValue(),
        };
        return data;
    }
    getLightTransform() {
        const lights = this.graph.findNodeByName("Lights");
        return lights && lights.getComponent(_ff_scene_components_CTransform__WEBPACK_IMPORTED_MODULE_2__["default"], true);
    }
    onPointer(event) {
        const viewport = event.viewport;
        // if viewport has it's own camera, don't handle event here
        if (viewport.camera) {
            return;
        }
        if (this.ins.enabled.value && this._scene.activeCameraComponent) {
            this._controller.setViewportSize(viewport.width, viewport.height);
            this._controller.onPointer(event);
            event.stopPropagation = true;
        }
        this._hasChanged = true;
    }
    onTrigger(event) {
        const viewport = event.viewport;
        // if viewport has it's own camera, don't handle event here
        if (viewport.camera) {
            return;
        }
        if (this.ins.enabled.value && this._scene.activeCameraComponent) {
            this._controller.setViewportSize(viewport.width, viewport.height);
            this._controller.onTrigger(event);
            event.stopPropagation = true;
        }
        this._hasChanged = true;
    }
    onLoadingCompleted(isLoading) {
        if (this.ins.autoZoom.value && !this._hasChanged) {
            this.ins.zoomExtents.set();
        }
    }
    onBoundsUpdate() {
        if (this.ins.autoZoom.value) {
            this.ins.zoomExtents.set();
        }
    }
}
CVOrbitNavigation.typeName = "CVOrbitNavigation";
CVOrbitNavigation.text = "Orbit Navigation";
CVOrbitNavigation.icon = "";
CVOrbitNavigation.ins = {
    enabled: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("Settings.Enabled", true),
    preset: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].Enum("Camera.ViewPreset", EViewPreset, EViewPreset.None),
    projection: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].Enum("Camera.Projection", _ff_three_UniversalCamera__WEBPACK_IMPORTED_MODULE_3__["EProjection"], _ff_three_UniversalCamera__WEBPACK_IMPORTED_MODULE_3__["EProjection"].Perspective),
    lightsFollowCamera: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("Navigation.LightsFollowCam", true),
    autoRotation: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("Navigation.AutoRotation", false),
    zoomExtents: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].Event("Settings.ZoomExtents"),
    autoZoom: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("Settings.AutoZoom", true),
    orbit: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].Vector3("Current.Orbit", [-25, -25, 0]),
    offset: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].Vector3("Current.Offset", [0, 0, 100]),
    minOrbit: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].Vector3("Limits.Min.Orbit", [-90, -Infinity, -Infinity]),
    minOffset: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].Vector3("Limits.Min.Offset", [-Infinity, -Infinity, 0.1]),
    maxOrbit: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].Vector3("Limits.Max.Orbit", [90, Infinity, Infinity]),
    maxOffset: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_0__["types"].Vector3("Limits.Max.Offset", [Infinity, Infinity, Infinity]),
};


/***/ }),

/***/ "./components/CVPointLight.ts":
/*!************************************!*\
  !*** ./components/CVPointLight.ts ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVPointLight; });
/* harmony import */ var _ff_scene_components_CPointLight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/scene/components/CPointLight */ "../../libs/ff-scene/source/components/CPointLight.ts");
/* harmony import */ var _ff_scene_components_CLight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/scene/components/CLight */ "../../libs/ff-scene/source/components/CLight.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


////////////////////////////////////////////////////////////////////////////////
class CVPointLight extends _ff_scene_components_CPointLight__WEBPACK_IMPORTED_MODULE_0__["default"] {
    get settingProperties() {
        return [
            this.ins.color,
            this.ins.intensity,
            this.ins.distance,
            this.ins.decay,
            this.ins.shadowEnabled,
            this.ins.shadowResolution,
            this.ins.shadowBlur,
        ];
    }
    get snapshotProperties() {
        return [
            this.ins.color,
            this.ins.intensity,
        ];
    }
    fromDocument(document, node) {
        if (!isFinite(node.light)) {
            throw new Error("light property missing in node");
        }
        const data = document.lights[node.light];
        const ins = this.ins;
        if (data.type !== "point") {
            throw new Error("light type mismatch: not a point light");
        }
        data.point = data.point || {};
        ins.copyValues({
            color: data.color !== undefined ? data.color : ins.color.schema.preset,
            intensity: data.intensity !== undefined ? data.intensity : ins.intensity.schema.preset,
            position: ins.position.schema.preset,
            distance: data.point.distance || ins.distance.schema.preset,
            decay: data.point.decay !== undefined ? data.point.decay : ins.decay.schema.preset,
            shadowEnabled: data.shadowEnabled || false,
            shadowResolution: data.shadowResolution !== undefined ? _ff_scene_components_CLight__WEBPACK_IMPORTED_MODULE_1__["EShadowMapResolution"][data.shadowResolution] || 1 : 1,
            shadowBlur: data.shadowBlur !== undefined ? data.shadowBlur : ins.shadowBlur.schema.preset,
        });
        return node.light;
    }
    toDocument(document, node) {
        const ins = this.ins;
        const data = {
            color: ins.color.cloneValue(),
            intensity: ins.intensity.value,
            point: {
                distance: ins.distance.value,
                decay: ins.decay.value,
            },
        };
        data.type = "point";
        if (ins.shadowEnabled.value) {
            data.shadowEnabled = true;
            if (!ins.shadowBlur.isDefault()) {
                data.shadowBlur = ins.shadowBlur.value;
            }
            if (!ins.shadowResolution.isDefault()) {
                data.shadowResolution = _ff_scene_components_CLight__WEBPACK_IMPORTED_MODULE_1__["EShadowMapResolution"][ins.shadowResolution.value];
            }
        }
        document.lights = document.lights || [];
        const lightIndex = document.lights.length;
        document.lights.push(data);
        return lightIndex;
    }
}
CVPointLight.typeName = "CVPointLight";
CVPointLight.text = "Point Light";
CVPointLight.icon = "bulb";


/***/ }),

/***/ "./components/CVReader.ts":
/*!********************************!*\
  !*** ./components/CVReader.ts ***!
  \********************************/
/*! exports provided: Article, EReaderPosition, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVReader; });
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var client_schema_setup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! client/schema/setup */ "./schema/setup.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EReaderPosition", function() { return client_schema_setup__WEBPACK_IMPORTED_MODULE_1__["EReaderPosition"]; });

/* harmony import */ var _models_Article__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../models/Article */ "./models/Article.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Article", function() { return _models_Article__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _CVMeta__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CVMeta */ "./components/CVMeta.ts");
/* harmony import */ var _CVAssetManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CVAssetManager */ "./components/CVAssetManager.ts");
/* harmony import */ var _CVAssetReader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CVAssetReader */ "./components/CVAssetReader.ts");
/* harmony import */ var _CVAnalytics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CVAnalytics */ "./components/CVAnalytics.ts");
/* harmony import */ var _CVLanguageManager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./CVLanguageManager */ "./components/CVLanguageManager.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



//import NVNode from "../nodes/NVNode";





////////////////////////////////////////////////////////////////////////////////

class CVReader extends _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.ins = this.addInputs(CVReader.ins);
        this.outs = this.addOutputs(CVReader.outs);
    }
    get settingProperties() {
        return [
            this.ins.enabled,
            this.ins.position,
        ];
    }
    get snapshotProperties() {
        return [
            this.ins.enabled,
            this.ins.articleId,
        ];
    }
    get articles() {
        return Object.keys(this._articles).map(key => this._articles[key]);
    }
    get activeArticle() {
        return this.outs.article.value;
    }
    get assetManager() {
        return this.getMainComponent(_CVAssetManager__WEBPACK_IMPORTED_MODULE_4__["default"]);
    }
    get assetReader() {
        return this.getMainComponent(_CVAssetReader__WEBPACK_IMPORTED_MODULE_5__["default"]);
    }
    get analytics() {
        return this.getMainComponent(_CVAnalytics__WEBPACK_IMPORTED_MODULE_6__["default"]);
    }
    get language() {
        return this.getGraphComponent(_CVLanguageManager__WEBPACK_IMPORTED_MODULE_7__["default"]);
    }
    create() {
        super.create();
        this.getGraphComponents(_CVMeta__WEBPACK_IMPORTED_MODULE_3__["default"]).forEach(meta => meta.on("update", this.updateArticles, this));
        this.graph.components.on(_CVMeta__WEBPACK_IMPORTED_MODULE_3__["default"], this.onMetaComponent, this);
        this.graph.components.on(_CVLanguageManager__WEBPACK_IMPORTED_MODULE_7__["default"], this.onLanguageComponent, this);
        this.updateArticles();
    }
    dispose() {
        this.graph.components.off(_CVLanguageManager__WEBPACK_IMPORTED_MODULE_7__["default"], this.onLanguageComponent, this);
        this.graph.components.off(_CVMeta__WEBPACK_IMPORTED_MODULE_3__["default"], this.onMetaComponent, this);
        this.getGraphComponents(_CVMeta__WEBPACK_IMPORTED_MODULE_3__["default"]).forEach(meta => meta.off("update", this.updateArticles, this));
        super.dispose();
    }
    update(context) {
        const ins = this.ins;
        const outs = this.outs;
        if (ins.enabled.changed) {
            //this.analytics.sendProperty("Reader.Enabled", ins.enabled.value);
        }
        if (ins.articleId.changed) {
            const entry = this._articles[ins.articleId.value] || null;
            const article = entry && entry.article;
            //outs.node.setValue(entry && entry.node);
            outs.article.setValue(article);
            outs.content.setValue("");
            if (article) {
                this.readArticle(article);
                this.analytics.sendProperty("Reader.ArticleId", article.defaultTitle);
            }
        }
        return true;
    }
    readArticle(article) {
        const outs = this.outs;
        const uri = article.uri;
        if (!uri) {
            outs.content.setValue(`<h2>Can't display article: no URI.</h2>`);
            return;
        }
        return this.assetReader.getText(uri)
            .then(content => this.parseArticle(content, uri))
            .then(content => outs.content.setValue(content))
            .catch(error => outs.content.setValue(`<h2>Article not found at ${uri}</h2>`));
    }
    parseArticle(content, articlePath) {
        // remove line breaks
        content = content.replace(/[\n\r]/g, "");
        // transform article-relative to absolute URLs
        const articleBasePath = this.assetManager.getAssetBasePath(articlePath);
        content = content.replace(/(src=\")(.*?)(\")/g, (match, pre, assetUrl, post) => {
            if (!assetUrl.startsWith("/") && !assetUrl.startsWith("http")) {
                assetUrl = this.assetManager.getAssetUrl(articleBasePath + assetUrl);
            }
            return pre + assetUrl + post;
        });
        return Promise.resolve(content);
    }
    onMetaComponent(event) {
        if (event.add) {
            event.object.articles.on("update", this.updateArticles, this);
        }
        if (event.remove) {
            event.object.articles.off("update", this.updateArticles, this);
        }
        this.updateArticles();
    }
    onLanguageComponent(event) {
        if (event.add) {
            event.object.outs.language.on("value", this.updateLanguage, this);
        }
        if (event.remove) {
            event.object.outs.language.off("value", this.updateLanguage, this);
        }
    }
    updateArticles() {
        const metas = this.getGraphComponents(_CVMeta__WEBPACK_IMPORTED_MODULE_3__["default"]);
        const masterList = this._articles = {};
        metas.forEach(meta => {
            const articles = meta.articles;
            const node = meta.node;
            articles.items.forEach(article => {
                masterList[article.id] = { article, node };
            });
        });
        const firstMeta = metas[0];
        if (firstMeta && firstMeta.leadArticle) {
            this.ins.articleId.setValue(firstMeta.leadArticle.id);
        }
        else {
            this.ins.articleId.setValue("");
        }
    }
    updateLanguage() {
        const ins = this.ins;
        // update articles
        this.articles.forEach(entry => {
            entry.article.language = this.language.outs.language.value;
        });
        // trigger reader active article update
        ins.articleId.set();
    }
    fromData(data) {
        data = data || {};
        this.ins.setValues({
            enabled: !!data.enabled,
            position: client_schema_setup__WEBPACK_IMPORTED_MODULE_1__["EReaderPosition"][data.position] || client_schema_setup__WEBPACK_IMPORTED_MODULE_1__["EReaderPosition"].Overlay,
            articleId: data.articleId || "",
        });
    }
    toData() {
        const ins = this.ins;
        const data = {
            enabled: ins.enabled.value,
            position: client_schema_setup__WEBPACK_IMPORTED_MODULE_1__["EReaderPosition"][ins.position.value] || "Overlay",
        };
        if (ins.articleId.value) {
            data.articleId = ins.articleId.value;
        }
        return data;
    }
}
CVReader.typeName = "CVReader";
CVReader.text = "Reader";
CVReader.icon = "";
CVReader.ins = {
    enabled: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("Reader.Enabled"),
    position: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Enum("Reader.Position", client_schema_setup__WEBPACK_IMPORTED_MODULE_1__["EReaderPosition"]),
    articleId: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].String("Article.ID"),
};
CVReader.outs = {
    article: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Object("Article.Active", _models_Article__WEBPACK_IMPORTED_MODULE_2__["default"]),
    content: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].String("Article.Content"),
};


/***/ }),

/***/ "./components/CVRenderTool.ts":
/*!************************************!*\
  !*** ./components/CVRenderTool.ts ***!
  \************************************/
/*! exports provided: default, RenderToolView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVRenderTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderToolView", function() { return RenderToolView; });
/* harmony import */ var _ui_PropertyOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ui/PropertyOptions */ "./ui/PropertyOptions.ts");
/* harmony import */ var _CVTool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CVTool */ "./components/CVTool.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


////////////////////////////////////////////////////////////////////////////////
class CVRenderTool extends _CVTool__WEBPACK_IMPORTED_MODULE_1__["default"] {
    createView() {
        return new RenderToolView(this);
    }
}
CVRenderTool.typeName = "CVRenderTool";
CVRenderTool.text = "Material";
CVRenderTool.icon = "palette";
////////////////////////////////////////////////////////////////////////////////
let RenderToolView = class RenderToolView extends _CVTool__WEBPACK_IMPORTED_MODULE_1__["ToolView"] {
    constructor() {
        super(...arguments);
        this.viewer = null;
    }
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-group", "sv-render-tool-view");
    }
    render() {
        const tool = this.tool;
        const document = this.activeDocument;
        const viewer = this.viewer;
        if (!viewer) {
            return _CVTool__WEBPACK_IMPORTED_MODULE_1__["html"] ``;
        }
        const shader = viewer.ins.shader;
        const language = document.setup.language;
        return _CVTool__WEBPACK_IMPORTED_MODULE_1__["html"] `<div class="sv-section"><ff-button class="sv-section-lead" transparent icon=${tool.icon}></ff-button>
            <div class="sv-tool-controls">
                <sv-property-options .property=${shader} .language=${language} name=${language.getLocalizedString("Material")}></sv-property-options>
            </div>
        </div>`;
    }
    onActiveDocument(previous, next) {
        if (this.viewer) {
            this.viewer.ins.shader.off("value", this.onUpdate, this);
            this.viewer = null;
        }
        if (next) {
            this.viewer = next.setup.viewer;
            this.viewer.ins.shader.on("value", this.onUpdate, this);
        }
    }
};
RenderToolView = __decorate([
    Object(_CVTool__WEBPACK_IMPORTED_MODULE_1__["customElement"])("sv-render-tool-view")
], RenderToolView);



/***/ }),

/***/ "./components/CVScene.ts":
/*!*******************************!*\
  !*** ./components/CVScene.ts ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVScene; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var client_schema_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! client/schema/common */ "./schema/common.ts");
/* harmony import */ var _CVNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CVNode */ "./components/CVNode.ts");
/* harmony import */ var _CVModel2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CVModel2 */ "./components/CVModel2.ts");
/* harmony import */ var client_utils_unitScaleFactor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! client/utils/unitScaleFactor */ "./utils/unitScaleFactor.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






////////////////////////////////////////////////////////////////////////////////
const _vec3 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
/**
 * Manages the scene and the nodes in the scene tree.
 *
 *  * ### Events
 * - *"bounding-box*" - emitted after the scene's model bounding box changed.
 */
class CVScene extends _CVNode__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor() {
        super(...arguments);
        this.ins = this.addInputs(CVScene.ins);
        this.outs = this.addOutputs(CVScene.outs);
    }
    get settingProperties() {
        return null;
    }
    get snapshotProperties() {
        return null;
    }
    get models() {
        return this.getGraphComponents(_CVModel2__WEBPACK_IMPORTED_MODULE_4__["default"]);
    }
    create() {
        super.create();
        this.outs.boundingBox.setValue(new three__WEBPACK_IMPORTED_MODULE_0__["Box3"]());
        this.graph.components.on(_CVModel2__WEBPACK_IMPORTED_MODULE_4__["default"], this.onModelComponent, this);
        this.models.forEach(model => {
            model.ins.globalUnits.linkFrom(this.ins.units);
            this.ins.modelUpdated.linkFrom(model.outs.updated);
        });
    }
    update(context) {
        const ins = this.ins;
        const outs = this.outs;
        if (ins.units.changed) {
            this.updateTransformHierarchy();
            this.updateModelBoundingBox();
            outs.units.setValue(ins.units.value);
        }
        if (ins.modelUpdated.changed) {
            this.updateModelBoundingBox();
        }
        if (ins.sceneTransformed.changed) {
            this.updateModelBoundingBox();
        }
        return true;
    }
    dispose() {
        this.graph.components.off(_CVModel2__WEBPACK_IMPORTED_MODULE_4__["default"], this.onModelComponent, this);
        super.dispose();
    }
    fromDocument(document, scene) {
        this.ins.units.setValue(client_schema_common__WEBPACK_IMPORTED_MODULE_2__["EUnitType"][scene.units] || 0);
        this.outs.units.setValue(client_schema_common__WEBPACK_IMPORTED_MODULE_2__["EUnitType"][scene.units] || 0);
    }
    toDocument(document, scene) {
        scene.units = client_schema_common__WEBPACK_IMPORTED_MODULE_2__["EUnitType"][this.ins.units.getValidatedValue()];
    }
    onModelComponent(event) {
        const model = event.object;
        if (event.add) {
            model.ins.globalUnits.linkFrom(this.ins.units);
            this.ins.modelUpdated.linkFrom(model.outs.updated);
        }
        this.updateModelBoundingBox();
    }
    updateModelBoundingBox() {
        if (true) {
            //console.log("CVScene.updateModelBoundingBox");
        }
        const box = this.outs.boundingBox.value;
        box.makeEmpty();
        this.models.forEach(model => box.expandByObject(model.object3D));
        box.getSize(_vec3);
        this.outs.boundingBox.set();
        this.outs.boundingRadius.setValue(_vec3.length() * 0.5);
    }
    updateTransformHierarchy() {
        if (this.models.length === 0) {
            return;
        }
        const ins = this.ins;
        const outs = this.outs;
        const unitScale = Object(client_utils_unitScaleFactor__WEBPACK_IMPORTED_MODULE_5__["default"])(outs.units.value, ins.units.value);
        const object3D = this.models[0].object3D.parent.parent; // TODO: Should probably crawl all the way up the hierarchy
        object3D.position.multiplyScalar(unitScale);
        object3D.updateMatrix();
        object3D.updateMatrixWorld(true);
    }
}
CVScene.typeName = "CVScene";
CVScene.text = "Scene";
CVScene.icon = "hierarchy";
CVScene.ins = {
    units: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Enum("Scene.Units", client_schema_common__WEBPACK_IMPORTED_MODULE_2__["EUnitType"], client_schema_common__WEBPACK_IMPORTED_MODULE_2__["EUnitType"].cm),
    modelUpdated: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Event("Scene.ModelUpdated"),
    sceneTransformed: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Event("Scene.Transformed"),
};
CVScene.outs = {
    units: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Enum("Scene.Units", client_schema_common__WEBPACK_IMPORTED_MODULE_2__["EUnitType"], client_schema_common__WEBPACK_IMPORTED_MODULE_2__["EUnitType"].cm),
    boundingBox: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Object("Models.BoundingBox", three__WEBPACK_IMPORTED_MODULE_0__["Box3"]),
    boundingRadius: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Number("Models.BoundingRadius"),
};


/***/ }),

/***/ "./components/CVSetup.ts":
/*!*******************************!*\
  !*** ./components/CVSetup.ts ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVSetup; });
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _ff_scene_components_CTransform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/scene/components/CTransform */ "../../libs/ff-scene/source/components/CTransform.ts");
/* harmony import */ var _CVInterface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CVInterface */ "./components/CVInterface.ts");
/* harmony import */ var _CVViewer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CVViewer */ "./components/CVViewer.ts");
/* harmony import */ var _CVReader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CVReader */ "./components/CVReader.ts");
/* harmony import */ var _CVOrbitNavigation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CVOrbitNavigation */ "./components/CVOrbitNavigation.ts");
/* harmony import */ var _CVBackground__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CVBackground */ "./components/CVBackground.ts");
/* harmony import */ var _CVFloor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./CVFloor */ "./components/CVFloor.ts");
/* harmony import */ var _CVGrid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./CVGrid */ "./components/CVGrid.ts");
/* harmony import */ var _CVTape__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./CVTape */ "./components/CVTape.ts");
/* harmony import */ var _CVSlicer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./CVSlicer */ "./components/CVSlicer.ts");
/* harmony import */ var _CVTours__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./CVTours */ "./components/CVTours.ts");
/* harmony import */ var _CVSnapshots__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./CVSnapshots */ "./components/CVSnapshots.ts");
/* harmony import */ var _CVEnvironment__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./CVEnvironment */ "./components/CVEnvironment.ts");
/* harmony import */ var _CVLanguageManager__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./CVLanguageManager */ "./components/CVLanguageManager.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */















////////////////////////////////////////////////////////////////////////////////
/**
 * At the root of a Voyager scene, this component manages scene features,
 * including tours.
 */
class CVSetup extends _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    get featureMap() {
        return this.constructor.featureMap;
    }
    get transform() {
        return this.getComponent(_ff_scene_components_CTransform__WEBPACK_IMPORTED_MODULE_1__["default"]);
    }
    create() {
        super.create();
        const node = this.node;
        const features = CVSetup.featureMap;
        for (const name in features) {
            this[name] = node.createComponent(features[name]);
        }
        this.snapshots = node.createComponent(_CVSnapshots__WEBPACK_IMPORTED_MODULE_12__["default"]);
    }
    fromDocument(document, sceneIndex, pathMap) {
        const scene = document.scenes[sceneIndex];
        if (!isFinite(scene.setup)) {
            throw new Error("setup property missing in node");
        }
        const setupData = document.setups[scene.setup];
        const features = CVSetup.featureMap;
        for (const name in features) {
            pathMap.set(`scenes/${sceneIndex}/setup/${name}`, this[name]);
            const featureData = setupData[name];
            if (featureData) {
                this[name].fromData(featureData);
            }
        }
        if (setupData.snapshots) {
            this.snapshots.fromData(setupData.snapshots, pathMap);
        }
    }
    toDocument(document, sceneIndex, pathMap) {
        let setupData = null;
        const features = CVSetup.featureMap;
        for (const name in features) {
            pathMap.set(this[name], `scenes/${sceneIndex}/setup/${name}`);
            const featureData = this[name].toData();
            if (featureData) {
                setupData = setupData || {};
                setupData[name] = featureData;
            }
        }
        const snapshotData = this.snapshots.toData(pathMap);
        if (snapshotData) {
            setupData = setupData || {};
            setupData.snapshots = snapshotData;
        }
        if (setupData) {
            document.setups = document.setups || [];
            const index = document.setups.length;
            document.setups.push(setupData);
            document.scenes[sceneIndex].setup = index;
        }
    }
}
CVSetup.typeName = "CVSetup";
CVSetup.featureMap = {
    "interface": _CVInterface__WEBPACK_IMPORTED_MODULE_2__["default"],
    "reader": _CVReader__WEBPACK_IMPORTED_MODULE_4__["default"],
    "viewer": _CVViewer__WEBPACK_IMPORTED_MODULE_3__["default"],
    "navigation": _CVOrbitNavigation__WEBPACK_IMPORTED_MODULE_5__["default"],
    "background": _CVBackground__WEBPACK_IMPORTED_MODULE_6__["default"],
    "environment": _CVEnvironment__WEBPACK_IMPORTED_MODULE_13__["default"],
    "language": _CVLanguageManager__WEBPACK_IMPORTED_MODULE_14__["default"],
    "floor": _CVFloor__WEBPACK_IMPORTED_MODULE_7__["default"],
    "grid": _CVGrid__WEBPACK_IMPORTED_MODULE_8__["default"],
    "tape": _CVTape__WEBPACK_IMPORTED_MODULE_9__["default"],
    "slicer": _CVSlicer__WEBPACK_IMPORTED_MODULE_10__["default"],
    "tours": _CVTours__WEBPACK_IMPORTED_MODULE_11__["default"],
};


/***/ }),

/***/ "./components/CVSliceTool.ts":
/*!***********************************!*\
  !*** ./components/CVSliceTool.ts ***!
  \***********************************/
/*! exports provided: default, SliceToolView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVSliceTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SliceToolView", function() { return SliceToolView; });
/* harmony import */ var _ui_PropertyBoolean__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ui/PropertyBoolean */ "./ui/PropertyBoolean.ts");
/* harmony import */ var _ui_PropertyOptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ui/PropertyOptions */ "./ui/PropertyOptions.ts");
/* harmony import */ var _ui_PropertySlider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ui/PropertySlider */ "./ui/PropertySlider.ts");
/* harmony import */ var _CVTool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CVTool */ "./components/CVTool.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




////////////////////////////////////////////////////////////////////////////////
class CVSliceTool extends _CVTool__WEBPACK_IMPORTED_MODULE_3__["default"] {
    createView() {
        return new SliceToolView(this);
    }
}
CVSliceTool.typeName = "CVSliceTool";
CVSliceTool.text = "Slice";
CVSliceTool.icon = "knife";
////////////////////////////////////////////////////////////////////////////////
let SliceToolView = class SliceToolView extends _CVTool__WEBPACK_IMPORTED_MODULE_3__["ToolView"] {
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-group", "sv-slice-tool-view");
    }
    render() {
        const document = this.activeDocument;
        if (!document) {
            return _CVTool__WEBPACK_IMPORTED_MODULE_3__["html"] ``;
        }
        const tool = this.tool;
        const slicer = document.setup.slicer;
        const enabled = slicer.ins.enabled;
        const axis = slicer.ins.axis;
        const position = slicer.ins.position;
        const language = document.setup.language;
        return _CVTool__WEBPACK_IMPORTED_MODULE_3__["html"] `<div class="sv-section"><ff-button class="sv-section-lead" transparent icon=${tool.icon}></ff-button>
            <div class="sv-tool-controls">
                <sv-property-boolean .property=${enabled} .language=${language} name=${language.getLocalizedString("Slice Tool")}></sv-property-boolean>
                <sv-property-options .property=${axis} .language=${language} name=${language.getLocalizedString("Axis")}></sv-property-options>
                <sv-property-slider .property=${position} name=${language.getLocalizedString("Position")}></sv-property-slider>
            </div>
        </div>`;
    }
    onActiveDocument(previous, next) {
        this.requestUpdate();
    }
};
SliceToolView = __decorate([
    Object(_CVTool__WEBPACK_IMPORTED_MODULE_3__["customElement"])("sv-slice-tool-view")
], SliceToolView);



/***/ }),

/***/ "./components/CVSlicer.ts":
/*!********************************!*\
  !*** ./components/CVSlicer.ts ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVSlicer; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var client_schema_setup__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! client/schema/setup */ "./schema/setup.ts");
/* harmony import */ var _CVScene__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CVScene */ "./components/CVScene.ts");
/* harmony import */ var _CVModel2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CVModel2 */ "./components/CVModel2.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





////////////////////////////////////////////////////////////////////////////////
/**
 * Slicing plane vectors (X+, Y+, Z+, X-, Y-, Z-).
 */
const _planes = [
    [-1, 0, 0, 0],
    [0, -1, 0, 0],
    [0, 0, -1, 0],
    [1, 0, 0, 0],
    [0, 1, 0, 0],
    [0, 0, 1, 0],
];
/**
 * Component controlling global slicing parameters for all [[CVModel2]] components in a scene.
 */
class CVSlicer extends _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(...arguments);
        this.ins = this.addInputs(CVSlicer.ins);
        this.plane = null;
        this.axisIndex = -1;
    }
    get settingProperties() {
        return [
            this.ins.enabled,
        ];
    }
    get snapshotProperties() {
        return [
            this.ins.enabled,
            this.ins.axis,
            this.ins.position,
            this.ins.inverted,
        ];
    }
    create() {
        super.create();
        const scene = this.getGraphComponent(_CVScene__WEBPACK_IMPORTED_MODULE_3__["default"]);
        this.ins.boundingBox.linkFrom(scene.outs.boundingBox);
    }
    update(context) {
        const ins = this.ins;
        if (ins.axis.changed) {
            const axisIndex = ins.axis.getValidatedValue();
            if (axisIndex === this.axisIndex) {
                // if same axis is selected again, invert its orientation
                ins.inverted.setValue(!ins.inverted.value);
            }
            else {
                ins.inverted.setValue(false);
                this.axisIndex = axisIndex;
            }
        }
        if (!ins.enabled.value && !ins.enabled.changed) {
            return false;
        }
        const axisIndex = ins.axis.getValidatedValue();
        const axisInverted = ins.inverted.value;
        const planeIndex = axisIndex + (axisInverted ? 3 : 0);
        const boundingBox = this.ins.boundingBox.value;
        if (!boundingBox) {
            return true;
        }
        // set components of slicing plane vector
        this.plane = _planes[planeIndex];
        const min = boundingBox.min.getComponent(axisIndex);
        const max = boundingBox.max.getComponent(axisIndex);
        const value = 1 - ins.position.value;
        this.plane[3] = axisInverted ? value * (max - min) - max : max - value * (max - min);
        const models = this.getGraphComponents(_CVModel2__WEBPACK_IMPORTED_MODULE_4__["default"]);
        // set the slicing plane in the Uber materials of each scene model
        models.forEach(model => {
            const object = model.object3D;
            object.traverse((mesh) => {
                if (mesh.isMesh) {
                    const material = mesh.material;
                    if (material.isUberPBRMaterial) {
                        this.updateMaterial(material);
                    }
                }
            });
        });
        return true;
    }
    fromData(data) {
        data = data || {};
        this.ins.setValues({
            enabled: data.enabled || false,
            axis: client_schema_setup__WEBPACK_IMPORTED_MODULE_2__["ESliceAxis"][data.axis] || client_schema_setup__WEBPACK_IMPORTED_MODULE_2__["ESliceAxis"].X,
            position: data.position || 0,
            inverted: data.inverted || false
        });
    }
    toData() {
        const ins = this.ins;
        return {
            enabled: ins.enabled.value,
            axis: client_schema_setup__WEBPACK_IMPORTED_MODULE_2__["ESliceAxis"][ins.axis.getValidatedValue()],
            position: ins.position.value,
            inverted: ins.inverted.value,
        };
    }
    updateMaterial(material) {
        const ins = this.ins;
        if (ins.enabled.changed) {
            material.enableCutPlane(ins.enabled.value);
            material.needsUpdate = true;
        }
        material.cutPlaneDirection.fromArray(this.plane);
        material.cutPlaneColor.fromArray(ins.color.value);
    }
}
CVSlicer.typeName = "CVSlicer";
CVSlicer.text = "Slicer";
CVSlicer.icon = "";
CVSlicer.ins = {
    enabled: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Boolean("Slice.Enabled"),
    axis: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Enum("Slice.Axis", client_schema_setup__WEBPACK_IMPORTED_MODULE_2__["ESliceAxis"]),
    position: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Number("Slice.Position", { min: 0, max: 1, preset: 0.5 }),
    inverted: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Boolean("Slice.Inverted"),
    color: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].ColorRGB("Slice.Color", [0, 0.61, 0.87]),
    boundingBox: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Object("Scene.BoundingBox", three__WEBPACK_IMPORTED_MODULE_0__["Box3"]),
};


/***/ }),

/***/ "./components/CVSnapshots.ts":
/*!***********************************!*\
  !*** ./components/CVSnapshots.ts ***!
  \***********************************/
/*! exports provided: EEasingCurve, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVSnapshots; });
/* harmony import */ var _ff_graph_components_CTweenMachine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/components/CTweenMachine */ "../../libs/ff-graph/source/components/CTweenMachine.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EEasingCurve", function() { return _ff_graph_components_CTweenMachine__WEBPACK_IMPORTED_MODULE_0__["EEasingCurve"]; });

/* harmony import */ var _ff_scene_components_CLight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/scene/components/CLight */ "../../libs/ff-scene/source/components/CLight.ts");
/* harmony import */ var _CVSetup__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CVSetup */ "./components/CVSetup.ts");
/* harmony import */ var _CVModel2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CVModel2 */ "./components/CVModel2.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




////////////////////////////////////////////////////////////////////////////////

class CVSnapshots extends _ff_graph_components_CTweenMachine__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.targetFeatures = {};
    }
    create() {
        super.create();
        const setup = this.getGraphComponent(_CVSetup__WEBPACK_IMPORTED_MODULE_2__["default"]);
        Object.keys(setup.featureMap).forEach(name => {
            this.targetFeatures[name] = false;
        });
        this.targetFeatures["models"] = false;
        this.targetFeatures["lights"] = false;
        this.initializeTargetFeatures();
    }
    initializeTargetFeatures() {
        const features = this.targetFeatures;
        Object.keys(features).forEach(key => features[key] = false);
        features["navigation"] = true;
        features["reader"] = true;
        this.updateTargets();
    }
    updateTargets() {
        const features = this.targetFeatures;
        const setup = this.getGraphComponent(_CVSetup__WEBPACK_IMPORTED_MODULE_2__["default"]);
        Object.keys(features).forEach(name => {
            const component = setup[name];
            const shouldInclude = features[name];
            if (component) {
                this.updateComponentTarget(component, shouldInclude);
            }
        });
        const models = this.getGraphComponents(_CVModel2__WEBPACK_IMPORTED_MODULE_3__["default"]);
        models.forEach(model => this.updateComponentTarget(model.transform, !!features["models"]));
        const lights = this.getGraphComponents(_ff_scene_components_CLight__WEBPACK_IMPORTED_MODULE_1__["default"]);
        lights.forEach(light => this.updateComponentTarget(light, !!features["lights"]));
        /*
        this.targets.forEach((target, index) => {
            const component = target.property.group.linkable as Component;
            console.log("CVSnapshot.updateTargets - target #%s, component: %s, property: %s",
                index, component.displayName, target.property.path);
        });
         */
    }
    updateComponentTarget(component, include) {
        const snapshotProperties = component["snapshotProperties"];
        if (!snapshotProperties) {
            return;
        }
        snapshotProperties.forEach(property => {
            const schema = property.schema;
            if (!schema.event && property.type !== "object") {
                const isIncluded = this.hasTargetProperty(property);
                if (include && !isIncluded) {
                    this.addTargetProperty(property);
                }
                else if (!include && isIncluded) {
                    this.removeTargetProperty(property);
                }
            }
        });
    }
    fromData(data, pathMap) {
        this.clear();
        const features = this.targetFeatures;
        const keys = Object.keys(features);
        if (data.features) {
            keys.forEach(key => features[key] = data.features.indexOf(key) >= 0);
        }
        else {
            this.initializeTargetFeatures();
        }
        const missingTargets = new Set();
        data.targets.forEach((target, index) => {
            const slashIndex = target.lastIndexOf("/");
            const componentPath = target.substr(0, slashIndex);
            const propertyKey = target.substr(slashIndex + 1);
            const component = pathMap.get(componentPath);
            const property = component ? component.ins[propertyKey] : null;
            if (!property) {
                console.warn(`missing snapshot target property for '${target}'`);
                missingTargets.add(index);
            }
            else {
                this.addTargetProperty(property);
            }
        });
        data.states.forEach(state => {
            this.setState({
                id: state.id,
                curve: state.curve !== undefined ? _ff_graph_components_CTweenMachine__WEBPACK_IMPORTED_MODULE_0__["EEasingCurve"][state.curve] : _ff_graph_components_CTweenMachine__WEBPACK_IMPORTED_MODULE_0__["EEasingCurve"].EaseQuad,
                duration: state.duration !== undefined ? state.duration : 2,
                threshold: state.threshold !== undefined ? state.threshold : 0.5,
                values: state.values.filter((value, index) => !missingTargets.has(index)),
            });
        });
    }
    toData(pathMap) {
        const features = this.targetFeatures;
        const data = {
            features: Object.keys(features).filter(key => features[key]),
            targets: this.targets.map(target => {
                const component = target.property.group.linkable;
                const key = target.property.key;
                const componentPath = pathMap.get(component);
                if (!componentPath) {
                    //Array.from(pathMap).forEach(entry => console.log(entry[1], entry[0].displayName));
                    throw new Error(`snapshot path not registered for component '${component.displayName}'`);
                }
                return componentPath + "/" + key;
            }),
            states: Object.keys(this.states).map(key => {
                const state = this.states[key];
                const data = { id: state.id, values: state.values };
                if (state.curve !== _ff_graph_components_CTweenMachine__WEBPACK_IMPORTED_MODULE_0__["EEasingCurve"].EaseQuad) {
                    data.curve = _ff_graph_components_CTweenMachine__WEBPACK_IMPORTED_MODULE_0__["EEasingCurve"][state.curve];
                }
                if (state.duration !== 2) {
                    data.duration = state.duration;
                }
                if (state.threshold !== 0.5) {
                    data.threshold = state.threshold;
                }
                return data;
            }),
        };
        if (data.targets.length > 0 && data.states.length > 0) {
            return data;
        }
        return null;
    }
}
CVSnapshots.typeName = "CVSnapshots";


/***/ }),

/***/ "./components/CVSpotLight.ts":
/*!***********************************!*\
  !*** ./components/CVSpotLight.ts ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVSpotLight; });
/* harmony import */ var _ff_scene_components_CSpotLight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/scene/components/CSpotLight */ "../../libs/ff-scene/source/components/CSpotLight.ts");
/* harmony import */ var _ff_scene_components_CLight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/scene/components/CLight */ "../../libs/ff-scene/source/components/CLight.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


////////////////////////////////////////////////////////////////////////////////
class CVSpotLight extends _ff_scene_components_CSpotLight__WEBPACK_IMPORTED_MODULE_0__["default"] {
    get settingProperties() {
        return [
            this.ins.color,
            this.ins.intensity,
            this.ins.distance,
            this.ins.decay,
            this.ins.angle,
            this.ins.penumbra,
            this.ins.shadowEnabled,
            this.ins.shadowResolution,
            this.ins.shadowBlur,
        ];
    }
    get snapshotProperties() {
        return [
            this.ins.color,
            this.ins.intensity
        ];
    }
    fromDocument(document, node) {
        if (!isFinite(node.light)) {
            throw new Error("light property missing in node");
        }
        const data = document.lights[node.light];
        const ins = this.ins;
        if (data.type !== "spot") {
            throw new Error("light type mismatch: not a spot light");
        }
        data.spot = data.spot || {};
        ins.copyValues({
            color: data.color !== undefined ? data.color : ins.color.schema.preset,
            intensity: data.intensity !== undefined ? data.intensity : ins.intensity.schema.preset,
            position: ins.position.schema.preset,
            target: ins.target.schema.preset,
            distance: data.spot.distance || ins.distance.schema.preset,
            decay: data.spot.decay !== undefined ? data.spot.decay : ins.decay.schema.preset,
            angle: data.spot.angle !== undefined ? data.spot.angle : ins.angle.schema.preset,
            penumbra: data.spot.penumbra || ins.penumbra.schema.preset,
            shadowEnabled: data.shadowEnabled || false,
            shadowResolution: data.shadowResolution !== undefined ? _ff_scene_components_CLight__WEBPACK_IMPORTED_MODULE_1__["EShadowMapResolution"][data.shadowResolution] || 1 : 1,
            shadowBlur: data.shadowBlur !== undefined ? data.shadowBlur : ins.shadowBlur.schema.preset,
        });
        return node.light;
    }
    toDocument(document, node) {
        const ins = this.ins;
        const data = {
            color: ins.color.cloneValue(),
            intensity: ins.intensity.value,
            spot: {
                distance: ins.distance.value,
                decay: ins.decay.value,
                angle: ins.angle.value,
                penumbra: ins.penumbra.value,
            },
        };
        data.type = "spot";
        if (ins.shadowEnabled.value) {
            data.shadowEnabled = true;
            if (!ins.shadowBlur.isDefault()) {
                data.shadowBlur = ins.shadowBlur.value;
            }
            if (!ins.shadowResolution.isDefault()) {
                data.shadowResolution = _ff_scene_components_CLight__WEBPACK_IMPORTED_MODULE_1__["EShadowMapResolution"][ins.shadowResolution.value];
            }
        }
        document.lights = document.lights || [];
        const lightIndex = document.lights.length;
        document.lights.push(data);
        return lightIndex;
    }
}
CVSpotLight.typeName = "CVSpotLight";
CVSpotLight.text = "Spot Light";
CVSpotLight.icon = "bulb";


/***/ }),

/***/ "./components/CVTape.ts":
/*!******************************!*\
  !*** ./components/CVTape.ts ***!
  \******************************/
/*! exports provided: ETapeState, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ETapeState", function() { return ETapeState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVTape; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/scene/components/CObject3D */ "../../libs/ff-scene/source/components/CObject3D.ts");
/* harmony import */ var _utils_Pin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Pin */ "./utils/Pin.ts");
/* harmony import */ var _CVModel2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CVModel2 */ "./components/CVModel2.ts");
/* harmony import */ var client_components_CVScene__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! client/components/CVScene */ "./components/CVScene.ts");
/* harmony import */ var client_schema_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! client/schema/common */ "./schema/common.ts");
/* harmony import */ var client_utils_unitScaleFactor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! client/utils/unitScaleFactor */ "./utils/unitScaleFactor.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







////////////////////////////////////////////////////////////////////////////////
const _mat3 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix3"]();
const _vec3a = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vec3b = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
const _vec3up = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 1, 0);
var ETapeState;
(function (ETapeState) {
    ETapeState[ETapeState["SetStart"] = 0] = "SetStart";
    ETapeState[ETapeState["SetEnd"] = 1] = "SetEnd";
})(ETapeState || (ETapeState = {}));
class CVTape extends _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(node, id) {
        super(node, id);
        this.ins = this.addInputs(CVTape.tapeIns);
        this.outs = this.addOutputs(CVTape.tapeOuts);
        this.startPin = null;
        this.endPin = null;
        this.line = null;
        this.object3D = new three__WEBPACK_IMPORTED_MODULE_0__["Group"]();
        this.startPin = new _utils_Pin__WEBPACK_IMPORTED_MODULE_2__["default"]();
        this.startPin.matrixAutoUpdate = false;
        this.startPin.visible = false;
        this.endPin = new _utils_Pin__WEBPACK_IMPORTED_MODULE_2__["default"]();
        this.endPin.matrixAutoUpdate = false;
        this.endPin.visible = false;
        const points = [];
        points.push(new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0));
        points.push(new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0));
        const lineGeometry = new three__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"]().setFromPoints(points);
        const lineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__["LineBasicMaterial"]();
        lineMaterial.depthTest = false;
        lineMaterial.transparent = true;
        this.line = new three__WEBPACK_IMPORTED_MODULE_0__["Line"](lineGeometry, lineMaterial);
        this.line.visible = false;
        this.object3D.add(this.startPin, this.endPin, this.line);
    }
    get settingProperties() {
        return [
            this.ins.visible,
        ];
    }
    get snapshotProperties() {
        return [
            this.ins.visible,
            this.ins.startPosition,
            this.ins.startDirection,
            this.ins.endPosition,
            this.ins.endDirection,
        ];
    }
    create() {
        super.create();
        const scene = this.getGraphComponent(client_components_CVScene__WEBPACK_IMPORTED_MODULE_4__["default"]);
        this.ins.boundingBox.linkFrom(scene.outs.boundingBox);
        this.ins.globalUnits.linkFrom(scene.ins.units);
    }
    update(context) {
        super.update(context);
        const ins = this.ins;
        const lineGeometry = this.line.geometry;
        // determine pin scale based on scene/model bounding box
        if (ins.boundingBox.changed && ins.boundingBox.value) {
            ins.boundingBox.value.getSize(_vec3a);
            const radius = _vec3a.length() * 0.5;
            this.startPin.scale.setScalar(radius * 0.003);
            this.startPin.updateMatrix();
            this.endPin.scale.setScalar(radius * 0.003);
            this.endPin.updateMatrix();
        }
        // if tape is visible, listen for pointer events to set tape start/end
        if (ins.visible.changed) {
            if (ins.visible.value) {
                this.system.on("pointer-up", this.onPointerUp, this);
            }
            else {
                this.system.off("pointer-up", this.onPointerUp, this);
            }
        }
        if (ins.globalUnits.changed) {
            this.updateUnitScale();
        }
        // update tape start point
        if (ins.startPosition.changed || ins.startDirection.changed) {
            const startPin = this.startPin;
            startPin.position.fromArray(ins.startPosition.value);
            _vec3a.fromArray(ins.startDirection.value);
            startPin.quaternion.setFromUnitVectors(_vec3up, _vec3a);
            startPin.updateMatrix();
            const positions = lineGeometry.attributes.position.array;
            positions[0] = startPin.position.x;
            positions[1] = startPin.position.y;
            positions[2] = startPin.position.z;
            lineGeometry.attributes.position.needsUpdate = true;
        }
        // update tape end point
        if (ins.endPosition.changed || ins.endDirection.changed) {
            const endPin = this.endPin;
            endPin.position.fromArray(ins.endPosition.value);
            _vec3a.fromArray(ins.endDirection.value);
            endPin.quaternion.setFromUnitVectors(_vec3up, _vec3a);
            endPin.updateMatrix();
            const positions = lineGeometry.attributes.position.array;
            positions[3] = endPin.position.x;
            positions[4] = endPin.position.y;
            positions[5] = endPin.position.z;
            lineGeometry.attributes.position.needsUpdate = true;
        }
        // update distance between measured points
        _vec3a.fromArray(ins.startPosition.value);
        _vec3b.fromArray(ins.endPosition.value);
        this.outs.distance.setValue(_vec3a.distanceTo(_vec3b));
        return true;
    }
    fromData(data) {
        this.ins.copyValues({
            visible: data.enabled,
            startPosition: data.startPosition,
            startDirection: data.startDirection,
            endPosition: data.endPosition,
            endDirection: data.endDirection
        });
    }
    toData() {
        const ins = this.ins;
        return {
            enabled: ins.visible.cloneValue(),
            startPosition: ins.startPosition.cloneValue(),
            startDirection: ins.startDirection.cloneValue(),
            endPosition: ins.endPosition.cloneValue(),
            endDirection: ins.endDirection.cloneValue()
        };
    }
    onPointerUp(event) {
        if (event.isDragging || !event.component || !event.component.is(_CVModel2__WEBPACK_IMPORTED_MODULE_3__["default"])) {
            return;
        }
        // get click position and normal
        const worldMatrix = event.object3D.matrixWorld;
        _mat3.getNormalMatrix(worldMatrix);
        const position = event.view.pickPosition(event).applyMatrix4(worldMatrix);
        const normal = event.view.pickNormal(event).applyMatrix3(_mat3).normalize();
        // update pins and measurement line
        const { startPin, endPin, line, ins, outs } = this;
        if (outs.state.value === ETapeState.SetStart) {
            position.toArray(ins.startPosition.value);
            normal.toArray(ins.startDirection.value);
            ins.startPosition.set();
            ins.startDirection.set();
            startPin.visible = true;
            endPin.visible = false;
            line.visible = false;
            outs.state.setValue(ETapeState.SetEnd);
        }
        else {
            position.toArray(ins.endPosition.value);
            normal.toArray(ins.endDirection.value);
            ins.endPosition.set();
            ins.endDirection.set();
            // set end position of tape
            startPin.visible = true;
            endPin.visible = true;
            line.visible = true;
            outs.state.setValue(ETapeState.SetStart);
        }
    }
    updateUnitScale() {
        const ins = this.ins;
        const fromUnits = ins.localUnits.getValidatedValue();
        const toUnits = ins.globalUnits.getValidatedValue();
        this.outs.unitScale.setValue(Object(client_utils_unitScaleFactor__WEBPACK_IMPORTED_MODULE_6__["default"])(fromUnits, toUnits));
        _vec3a.fromArray(ins.startPosition.value);
        ins.startPosition.setValue(_vec3a.multiplyScalar(this.outs.unitScale.value).toArray());
        _vec3a.fromArray(ins.endPosition.value);
        ins.endPosition.setValue(_vec3a.multiplyScalar(this.outs.unitScale.value).toArray());
        ins.localUnits.setValue(toUnits);
    }
}
CVTape.typeName = "CVTape";
CVTape.text = "Tape";
CVTape.icon = "";
CVTape.tapeIns = {
    startPosition: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_1__["types"].Vector3("Start.Position"),
    startDirection: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_1__["types"].Vector3("Start.Direction"),
    endPosition: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_1__["types"].Vector3("End.Position"),
    endDirection: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_1__["types"].Vector3("End.Direction"),
    boundingBox: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_1__["types"].Object("Scene.BoundingBox", three__WEBPACK_IMPORTED_MODULE_0__["Box3"]),
    globalUnits: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_1__["types"].Enum("Model.GlobalUnits", client_schema_common__WEBPACK_IMPORTED_MODULE_5__["EUnitType"], client_schema_common__WEBPACK_IMPORTED_MODULE_5__["EUnitType"].cm),
    localUnits: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_1__["types"].Enum("Model.LocalUnits", client_schema_common__WEBPACK_IMPORTED_MODULE_5__["EUnitType"], client_schema_common__WEBPACK_IMPORTED_MODULE_5__["EUnitType"].cm)
};
CVTape.tapeOuts = {
    state: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_1__["types"].Enum("Tape.State", ETapeState),
    distance: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_1__["types"].Number("Tape.Distance"),
    unitScale: _ff_scene_components_CObject3D__WEBPACK_IMPORTED_MODULE_1__["types"].Number("UnitScale", { preset: 1, precision: 5 })
};


/***/ }),

/***/ "./components/CVTapeTool.ts":
/*!**********************************!*\
  !*** ./components/CVTapeTool.ts ***!
  \**********************************/
/*! exports provided: default, TapeToolView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVTapeTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TapeToolView", function() { return TapeToolView; });
/* harmony import */ var _ui_PropertyBoolean__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ui/PropertyBoolean */ "./ui/PropertyBoolean.ts");
/* harmony import */ var _ui_PropertyString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ui/PropertyString */ "./ui/PropertyString.ts");
/* harmony import */ var _CVTape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CVTape */ "./components/CVTape.ts");
/* harmony import */ var _CVTool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CVTool */ "./components/CVTool.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




////////////////////////////////////////////////////////////////////////////////
class CVTapeTool extends _CVTool__WEBPACK_IMPORTED_MODULE_3__["default"] {
    createView() {
        return new TapeToolView(this);
    }
}
CVTapeTool.typeName = "CVTapeTool";
CVTapeTool.text = "Measure";
CVTapeTool.icon = "tape";
////////////////////////////////////////////////////////////////////////////////
let TapeToolView = class TapeToolView extends _CVTool__WEBPACK_IMPORTED_MODULE_3__["ToolView"] {
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-group", "sv-tape-tool-view");
    }
    render() {
        const document = this.activeDocument;
        if (!document) {
            return _CVTool__WEBPACK_IMPORTED_MODULE_3__["html"] ``;
        }
        const tool = this.tool;
        const tape = document.setup.tape;
        const visible = tape.ins.visible;
        const state = tape.outs.state.value;
        const distance = tape.outs.distance.value;
        const language = document.setup.language;
        let text;
        if (!visible.value) {
            text = language.getLocalizedString("Switch on to take measurements") + ".";
        }
        else if (distance === 0) {
            text = language.getLocalizedString("Tap on model to set start of tape") + ".";
        }
        else if (state === _CVTape__WEBPACK_IMPORTED_MODULE_2__["ETapeState"].SetStart) {
            const units = document.root.scene.ins.units.getOptionText();
            text = `${distance.toFixed(2)} ${units}`;
        }
        else {
            text = language.getLocalizedString("Tap on model to set end of tape") + ".";
        }
        return _CVTool__WEBPACK_IMPORTED_MODULE_3__["html"] `<div class="sv-section"><ff-button class="sv-section-lead" transparent icon=${tool.icon}></ff-button>
            <div class="sv-tool-controls">
                <sv-property-boolean .property=${visible} .language=${language} name=${language.getLocalizedString("Tape Tool")}></sv-property-boolean>
                <div class="sv-property-view"><label class="ff-label ff-off">${language.getLocalizedString("Measured Distance")}</label>
                <div class="ff-string">${text}</div></div>
            </div></div>`;
    }
    onActiveDocument(previous, next) {
        if (previous) {
            previous.setup.tape.off("update", this.onUpdate, this);
        }
        if (next) {
            next.setup.tape.on("update", this.onUpdate, this);
        }
        this.requestUpdate();
    }
};
TapeToolView = __decorate([
    Object(_CVTool__WEBPACK_IMPORTED_MODULE_3__["customElement"])("sv-tape-tool-view")
], TapeToolView);



/***/ }),

/***/ "./components/CVTool.ts":
/*!******************************!*\
  !*** ./components/CVTool.ts ***!
  \******************************/
/*! exports provided: types, customElement, property, html, default, ToolView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToolView", function() { return ToolView; });
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "types", function() { return _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"]; });

/* harmony import */ var _CVNodeObserver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CVNodeObserver */ "./components/CVNodeObserver.ts");
/* harmony import */ var _CVAnalytics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CVAnalytics */ "./components/CVAnalytics.ts");
/* harmony import */ var _ui_explorer_NodeView__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ui/explorer/NodeView */ "./ui/explorer/NodeView.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "customElement", function() { return _ui_explorer_NodeView__WEBPACK_IMPORTED_MODULE_3__["customElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "property", function() { return _ui_explorer_NodeView__WEBPACK_IMPORTED_MODULE_3__["property"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "html", function() { return _ui_explorer_NodeView__WEBPACK_IMPORTED_MODULE_3__["html"]; });

/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




////////////////////////////////////////////////////////////////////////////////

class CVTool extends _CVNodeObserver__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(...arguments);
        this.ins = this.addInputs(CVTool.toolIns);
        this.outs = this.addOutputs(CVTool.toolOuts);
        this._isActiveTool = false;
    }
    get isActiveTool() {
        return this._isActiveTool;
    }
    dispose() {
        if (this._isActiveTool) {
            this.deactivateTool();
        }
        super.dispose();
    }
    createView() {
        throw new Error("must override");
    }
    /**
     * Called when the tool is activated.
     */
    activateTool() {
        this._isActiveTool = true;
        this.startObserving();
    }
    /**
     * Called when the tool is deactivated.
     */
    deactivateTool() {
        this.stopObserving();
        this._isActiveTool = false;
    }
}
CVTool.typeName = "CVTool";
CVTool.toolIns = {};
CVTool.toolOuts = {};
////////////////////////////////////////////////////////////////////////////////
class ToolView extends _ui_explorer_NodeView__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(tool) {
        super(tool.system);
        this.tool = null;
        this.tool = tool;
    }
    get analytics() {
        return this.system.getMainComponent(_CVAnalytics__WEBPACK_IMPORTED_MODULE_2__["default"]);
    }
    firstConnected() {
        this.classList.add("sv-group", "sv-tool-view");
    }
    connected() {
        super.connected();
        this.tool.on("update", this.onUpdate, this);
    }
    disconnected() {
        this.tool.off("update", this.onUpdate, this);
        super.disconnected();
    }
}
__decorate([
    Object(_ui_explorer_NodeView__WEBPACK_IMPORTED_MODULE_3__["property"])({ attribute: false })
], ToolView.prototype, "tool", void 0);


/***/ }),

/***/ "./components/CVToolProvider.ts":
/*!**************************************!*\
  !*** ./components/CVToolProvider.ts ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVToolProvider; });
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _ff_graph_components_CComponentProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/graph/components/CComponentProvider */ "../../libs/ff-graph/source/components/CComponentProvider.ts");
/* harmony import */ var _CVTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CVTool */ "./components/CVTool.ts");
/* harmony import */ var _CVAnalytics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CVAnalytics */ "./components/CVAnalytics.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class CVToolProvider extends _ff_graph_components_CComponentProvider__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(node, id) {
        super(node, id);
        this.ins = this.addInputs(CVToolProvider.ins);
        this.scope = _ff_graph_components_CComponentProvider__WEBPACK_IMPORTED_MODULE_1__["EComponentScope"].Node;
    }
    get analytics() {
        return this.getMainComponent(_CVAnalytics__WEBPACK_IMPORTED_MODULE_3__["default"]);
    }
    update(context) {
        const ins = this.ins;
        if (ins.visible.changed) {
            if (ins.visible.value && !this.activeComponent) {
                this.activeComponent = this.scopedComponents[0];
            }
        }
        return true;
    }
    activateComponent(tool) {
        tool.activateTool();
        this.analytics.sendProperty("Tools.ActiveTool", tool.text);
    }
    deactivateComponent(tool) {
        tool.deactivateTool();
    }
    onActiveComponent(previous, next) {
    }
}
CVToolProvider.typeName = "CVToolProvider";
CVToolProvider.isSystemSingleton = true;
CVToolProvider.componentType = _CVTool__WEBPACK_IMPORTED_MODULE_2__["default"];
CVToolProvider.ins = {
    visible: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("Tools.Visible")
};


/***/ }),

/***/ "./components/CVTours.ts":
/*!*******************************!*\
  !*** ./components/CVTours.ts ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVTours; });
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var client_schema_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! client/schema/common */ "./schema/common.ts");
/* harmony import */ var _CVSnapshots__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CVSnapshots */ "./components/CVSnapshots.ts");
/* harmony import */ var _CVAnalytics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CVAnalytics */ "./components/CVAnalytics.ts");
/* harmony import */ var _CVLanguageManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CVLanguageManager */ "./components/CVLanguageManager.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





////////////////////////////////////////////////////////////////////////////////
class CVTours extends _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.ins = this.addInputs(CVTours.ins);
        this.outs = this.addOutputs(CVTours.outs);
        this._tours = [];
    }
    get analytics() {
        return this.getMainComponent(_CVAnalytics__WEBPACK_IMPORTED_MODULE_3__["default"]);
    }
    get language() {
        return this.getGraphComponent(_CVLanguageManager__WEBPACK_IMPORTED_MODULE_4__["default"]);
    }
    get snapshots() {
        return this.getComponent(_CVSnapshots__WEBPACK_IMPORTED_MODULE_2__["default"]);
    }
    get tours() {
        return this._tours;
    }
    get activeSteps() {
        const tour = this.activeTour;
        return tour ? tour.steps : null;
    }
    get activeTour() {
        return this._tours[this.outs.tourIndex.value];
    }
    get activeStep() {
        const tour = this.activeTour;
        return tour ? tour.steps[this.outs.stepIndex.value] : null;
    }
    get title() {
        const tour = this.activeTour;
        // TODO: Temporary - remove when single string properties are phased out
        if (Object.keys(tour.titles).length === 0) {
            tour.titles[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_LANGUAGE"]] = tour.title;
        }
        return tour.titles[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][this.language.outs.language.value]] || "undefined";
    }
    set title(inTitle) {
        const tour = this.activeTour;
        tour.titles[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][this.language.outs.language.value]] = inTitle;
    }
    get lead() {
        const tour = this.activeTour;
        // TODO: Temporary - remove when single string properties are phased out
        if (Object.keys(tour.leads).length === 0) {
            tour.leads[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_LANGUAGE"]] = tour.lead;
        }
        return tour.leads[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][this.language.outs.language.value]] || "";
    }
    set lead(inLead) {
        const tour = this.activeTour;
        tour.leads[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][this.language.outs.language.value]] = inLead;
    }
    get taglist() {
        const tour = this.activeTour;
        // TODO: Temporary - remove when single string properties are phased out
        if (Object.keys(tour.taglist).length === 0) {
            if (tour.tags.length > 0) {
                tour.taglist[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_LANGUAGE"]] = tour.tags;
            }
        }
        return tour.taglist[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][this.language.outs.language.value]] || [];
    }
    set taglist(inTags) {
        const tour = this.activeTour;
        tour.taglist[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][this.language.outs.language.value]] = inTags;
    }
    get stepTitle() {
        const step = this.activeStep;
        if (step) {
            // TODO: Temporary - remove when single string properties are phased out
            if (Object.keys(step.titles).length === 0) {
                step.titles[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_LANGUAGE"]] = step.title;
            }
            return step.titles[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][this.language.outs.language.value]] || "undefined";
        }
        else {
            return null;
        }
    }
    set stepTitle(inTitle) {
        const step = this.activeStep;
        if (step) {
            step.titles[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][this.language.outs.language.value]] = inTitle;
        }
    }
    create() {
        super.create();
        this.language.outs.language.on("value", this.update, this);
    }
    dispose() {
        this.language.outs.language.off("value", this.update, this);
        super.dispose();
    }
    update(context) {
        const { ins, outs } = this;
        const tours = this._tours;
        const machine = this.snapshots;
        if (ins.enabled.changed) {
            if (ins.enabled.value) {
                // store pre-tour scene state
                const state = {
                    id: CVTours.sceneSnapshotId,
                    curve: _CVSnapshots__WEBPACK_IMPORTED_MODULE_2__["EEasingCurve"].EaseOutQuad,
                    duration: 1,
                    threshold: 0,
                    values: machine.getCurrentValues(),
                };
                machine.setState(state);
            }
            else {
                outs.tourIndex.set();
                // recall pre-tour scene state
                machine.tweenTo(CVTours.sceneSnapshotId, context.secondsElapsed);
                machine.deleteState(CVTours.sceneSnapshotId);
                return true;
            }
        }
        const tourIndex = Math.min(tours.length - 1, Math.max(-1, ins.tourIndex.value));
        const tour = tours[tourIndex];
        const stepCount = tour ? tour.steps.length : 0;
        outs.stepCount.setValue(stepCount);
        let nextStepIndex = -1;
        if (ins.tourIndex.changed || ins.enabled.changed) {
            if (tourIndex !== outs.tourIndex.value) {
                nextStepIndex = 0;
            }
            outs.tourIndex.setValue(tourIndex);
            outs.tourTitle.setValue(tour ? this.title : "");
            outs.tourLead.setValue(tour ? this.lead : "");
        }
        if (stepCount === 0) {
            outs.stepIndex.setValue(-1);
            outs.stepTitle.setValue("");
            return true;
        }
        let tween = true;
        if (ins.enabled.changed) {
            nextStepIndex = outs.stepIndex.value;
        }
        if (ins.stepIndex.changed) {
            nextStepIndex = Math.min(tour.steps.length - 1, Math.max(0, ins.stepIndex.value));
            tween = false;
        }
        if (ins.first.changed) {
            nextStepIndex = 0;
        }
        if (ins.next.changed) {
            nextStepIndex = outs.stepIndex.value + 1;
            // after last step, show tour menu
            if (nextStepIndex >= stepCount) {
                outs.tourIndex.setValue(-1);
                outs.tourTitle.setValue("");
                outs.tourLead.setValue("");
                outs.stepIndex.set();
                nextStepIndex = -1;
            }
        }
        if (ins.previous.changed) {
            // previous step, wrap around when reaching first step
            nextStepIndex = (outs.stepIndex.value + stepCount - 1) % stepCount;
        }
        if (nextStepIndex >= 0) {
            // tween to the next step
            const step = tour.steps[nextStepIndex];
            outs.stepIndex.setValue(nextStepIndex);
            outs.stepTitle.setValue(this.stepTitle || "undefined");
            machine.ins.id.setValue(step.id);
            tween ? machine.ins.tween.set() : machine.ins.recall.set();
        }
        return true;
    }
    fromData(data) {
        this._tours = data.map(tour => ({
            title: tour.title,
            titles: tour.titles || {},
            steps: tour.steps.map(step => ({
                title: step.title,
                titles: step.titles || {},
                id: step.id,
            })),
            lead: tour.lead || "",
            leads: tour.leads || {},
            tags: tour.tags || [],
            taglist: tour.taglist || {}
        }));
        // update langauges used in tours
        this._tours.forEach(tour => {
            Object.keys(tour.titles).forEach(key => {
                this.language.addLanguage(client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][key]);
            });
            // TODO: Delete when single string properties are phased out
            tour.steps.forEach(step => {
                if (Object.keys(step.titles).length == 0) {
                    step.titles[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_LANGUAGE"]] = step.title || null;
                }
            });
        });
        this.ins.tourIndex.setValue(-1);
        this.outs.count.setValue(this._tours.length);
    }
    toData() {
        if (this._tours.length === 0) {
            return null;
        }
        return this._tours.map(tour => {
            const data = {
                steps: tour.steps.map(step => {
                    const tourstep = {};
                    tourstep.id = step.id;
                    if (Object.keys(step.titles).length > 0) {
                        tourstep.titles = step.titles;
                    }
                    else if (step.title) {
                        tourstep.title = step.title;
                    }
                    return tourstep;
                }),
            };
            if (Object.keys(tour.titles).length > 0) {
                data.titles = tour.titles;
            }
            else if (tour.title) {
                data.title = tour.title;
            }
            if (Object.keys(tour.leads).length > 0) {
                data.leads = tour.leads;
            }
            else if (tour.lead) {
                data.lead = tour.lead;
            }
            if (Object.keys(tour.taglist).length > 0) {
                data.taglist = tour.taglist;
            }
            else if (tour.tags.length > 0) {
                data.tags = tour.tags;
            }
            return data;
        });
    }
}
CVTours.typeName = "CVTours";
CVTours.sceneSnapshotId = "scene-default";
CVTours.ins = {
    enabled: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Boolean("Tours.Enabled"),
    tourIndex: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Integer("Tours.Index", -1),
    stepIndex: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Integer("Step.Index"),
    next: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Event("Step.Next"),
    previous: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Event("Step.Previous"),
    first: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Event("Step.First"),
};
CVTours.outs = {
    count: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Integer("Tours.Count"),
    tourIndex: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Integer("Tour.Index", -1),
    tourTitle: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].String("Tour.Title"),
    tourLead: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].String("Tour.Lead"),
    stepCount: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Integer("Tour.Steps"),
    stepIndex: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].Integer("Step.Index"),
    stepTitle: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_0__["types"].String("Step.Title"),
};


/***/ }),

/***/ "./components/CVViewTool.ts":
/*!**********************************!*\
  !*** ./components/CVViewTool.ts ***!
  \**********************************/
/*! exports provided: default, ViewToolView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVViewTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ViewToolView", function() { return ViewToolView; });
/* harmony import */ var _ff_ui_Button__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/ui/Button */ "../../libs/ff-ui/source/Button.ts");
/* harmony import */ var _ui_PropertyOptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ui/PropertyOptions */ "./ui/PropertyOptions.ts");
/* harmony import */ var _ui_PropertyEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ui/PropertyEvent */ "./ui/PropertyEvent.ts");
/* harmony import */ var _CVOrbitNavigation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CVOrbitNavigation */ "./components/CVOrbitNavigation.ts");
/* harmony import */ var _CVTool__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CVTool */ "./components/CVTool.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};





////////////////////////////////////////////////////////////////////////////////
class CVViewTool extends _CVTool__WEBPACK_IMPORTED_MODULE_4__["default"] {
    createView() {
        return new ViewToolView(this);
    }
}
CVViewTool.typeName = "CVViewTool";
CVViewTool.text = "View";
CVViewTool.icon = "eye";
////////////////////////////////////////////////////////////////////////////////
let ViewToolView = class ViewToolView extends _CVTool__WEBPACK_IMPORTED_MODULE_4__["ToolView"] {
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-view-tool-view");
    }
    render() {
        const document = this.activeDocument;
        if (!document) {
            return _CVTool__WEBPACK_IMPORTED_MODULE_4__["html"] ``;
        }
        const tool = this.tool;
        const navigation = document.setup.navigation;
        const language = document.setup.language;
        const projection = navigation.ins.projection;
        const preset = navigation.ins.preset;
        const zoom = navigation.ins.zoomExtents;
        const presetMap = [_CVOrbitNavigation__WEBPACK_IMPORTED_MODULE_3__["EViewPreset"].Front, _CVOrbitNavigation__WEBPACK_IMPORTED_MODULE_3__["EViewPreset"].Back,
            _CVOrbitNavigation__WEBPACK_IMPORTED_MODULE_3__["EViewPreset"].Left, _CVOrbitNavigation__WEBPACK_IMPORTED_MODULE_3__["EViewPreset"].Right,
            _CVOrbitNavigation__WEBPACK_IMPORTED_MODULE_3__["EViewPreset"].Top, _CVOrbitNavigation__WEBPACK_IMPORTED_MODULE_3__["EViewPreset"].Bottom];
        return _CVTool__WEBPACK_IMPORTED_MODULE_4__["html"] `<div class="sv-section"><ff-button class="sv-section-lead" transparent icon=${tool.icon}></ff-button>
            <div class="sv-tool-controls">
                <sv-property-options .property=${projection} .language=${language} name=${language.getLocalizedString("Projection")}></sv-property-options>
                <sv-property-options .property=${preset} .language=${language} name=${language.getLocalizedString("View")} .indexMap=${presetMap}></sv-property-options>
                <sv-property-event .property=${zoom} name=${language.getLocalizedString("Center")} icon="zoom"></sv-property-event>
            </div>
        </div>`;
    }
    onActiveDocument(previous, next) {
        this.requestUpdate();
    }
};
ViewToolView = __decorate([
    Object(_CVTool__WEBPACK_IMPORTED_MODULE_4__["customElement"])("sv-view-tool-view")
], ViewToolView);



/***/ }),

/***/ "./components/CVViewer.ts":
/*!********************************!*\
  !*** ./components/CVViewer.ts ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CVViewer; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/graph/Component */ "../../libs/ff-graph/source/Component.ts");
/* harmony import */ var _ff_scene_components_CRenderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/scene/components/CRenderer */ "../../libs/ff-scene/source/components/CRenderer.ts");
/* harmony import */ var client_schema_setup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! client/schema/setup */ "./schema/setup.ts");
/* harmony import */ var client_schema_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! client/schema/model */ "./schema/model.ts");
/* harmony import */ var _CVModel2__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CVModel2 */ "./components/CVModel2.ts");
/* harmony import */ var _CVAnnotationView__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CVAnnotationView */ "./components/CVAnnotationView.ts");
/* harmony import */ var _CVAnalytics__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./CVAnalytics */ "./components/CVAnalytics.ts");
/* harmony import */ var _CVLanguageManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./CVLanguageManager */ "./components/CVLanguageManager.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









////////////////////////////////////////////////////////////////////////////////
class CVViewer extends _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(...arguments);
        this.ins = this.addInputs(CVViewer.ins);
        this.outs = this.addOutputs(CVViewer.outs);
    }
    get settingProperties() {
        return [
            this.ins.annotationsVisible,
            this.ins.activeTags,
            this.ins.sortedTags,
            this.ins.radioTags,
            this.ins.shader,
            this.ins.exposure,
            this.ins.gamma,
        ];
    }
    get snapshotProperties() {
        return [
            this.ins.annotationsVisible,
            this.ins.activeAnnotation,
            this.ins.activeTags,
            this.ins.shader,
            this.ins.exposure,
        ];
    }
    get analytics() {
        return this.getMainComponent(_CVAnalytics__WEBPACK_IMPORTED_MODULE_7__["default"]);
    }
    get renderer() {
        return this.getMainComponent(_ff_scene_components_CRenderer__WEBPACK_IMPORTED_MODULE_2__["default"]);
    }
    create() {
        super.create();
        this.graph.components.on(_CVModel2__WEBPACK_IMPORTED_MODULE_5__["default"], this.onModelComponent, this);
        this.graph.components.on(_CVAnnotationView__WEBPACK_IMPORTED_MODULE_6__["default"], this.onAnnotationsComponent, this);
        this.graph.components.on(_CVLanguageManager__WEBPACK_IMPORTED_MODULE_8__["default"], this.onLanguageComponent, this);
    }
    dispose() {
        this.graph.components.off(_CVModel2__WEBPACK_IMPORTED_MODULE_5__["default"], this.onModelComponent, this);
        this.graph.components.off(_CVAnnotationView__WEBPACK_IMPORTED_MODULE_6__["default"], this.onAnnotationsComponent, this);
        this.graph.components.off(_CVLanguageManager__WEBPACK_IMPORTED_MODULE_8__["default"], this.onLanguageComponent, this);
        super.dispose();
    }
    update(context) {
        const ins = this.ins;
        if (ins.shader.changed) {
            const shader = ins.shader.getValidatedValue();
            this.getGraphComponents(_CVModel2__WEBPACK_IMPORTED_MODULE_5__["default"]).forEach(model => model.ins.shader.setValue(shader));
        }
        if (ins.exposure.changed) {
            this.renderer.ins.exposure.setValue(ins.exposure.value);
        }
        if (ins.gamma.changed) {
            this.renderer.ins.gamma.setValue(ins.gamma.value);
        }
        if (ins.quality.changed) {
            const quality = ins.quality.getValidatedValue();
            this.getGraphComponents(_CVModel2__WEBPACK_IMPORTED_MODULE_5__["default"]).forEach(model => model.ins.quality.setValue(quality));
        }
        if (ins.activeAnnotation.changed) {
            const id = ins.activeAnnotation.value;
            this.getGraphComponents(_CVAnnotationView__WEBPACK_IMPORTED_MODULE_6__["default"]).forEach(view => view.setActiveAnnotationById(id));
        }
        if (ins.annotationsVisible.changed) {
            const visible = ins.annotationsVisible.value;
            this.getGraphComponents(_CVAnnotationView__WEBPACK_IMPORTED_MODULE_6__["default"]).forEach(view => view.ins.visible.setValue(visible));
        }
        if (ins.activeTags.changed) {
            const tags = ins.activeTags.value;
            this.getGraphComponents(_CVAnnotationView__WEBPACK_IMPORTED_MODULE_6__["default"]).forEach(view => view.ins.activeTags.setValue(tags));
            this.getGraphComponents(_CVModel2__WEBPACK_IMPORTED_MODULE_5__["default"]).forEach(model => model.ins.activeTags.setValue(tags));
        }
        if (ins.sortedTags.changed) {
            this.refreshTagCloud();
        }
        // ** Temporary hack until RenderView supports outputEncoding param
        if (this.renderer.views[0] && this.renderer.views[0].renderer.outputEncoding !== three__WEBPACK_IMPORTED_MODULE_0__["GammaEncoding"]) {
            this.renderer.views[0].renderer.outputEncoding = three__WEBPACK_IMPORTED_MODULE_0__["GammaEncoding"];
        }
        return true;
    }
    // preRender(context)
    // {
    //     const qualityName = this.ins.quality.getOptionText();
    //     context.viewport.overlay.setLabel(ELocation.BottomRight, "quality", `Quality: ${qualityName}`);
    // }
    fromData(data) {
        const ins = this.ins;
        ins.copyValues({
            shader: client_schema_setup__WEBPACK_IMPORTED_MODULE_3__["EShaderMode"][data.shader] || client_schema_setup__WEBPACK_IMPORTED_MODULE_3__["EShaderMode"].Default,
            exposure: data.exposure !== undefined ? data.exposure : ins.exposure.schema.preset,
            gamma: data.gamma !== undefined ? data.gamma : ins.gamma.schema.preset,
            annotationsVisible: !!data.annotationsVisible,
            activeTags: data.activeTags || "",
            sortedTags: data.sortedTags || "",
            radioTags: data.radioTags !== undefined ? !!data.radioTags : ins.radioTags.schema.preset,
        });
    }
    toData() {
        const ins = this.ins;
        const data = {
            shader: client_schema_setup__WEBPACK_IMPORTED_MODULE_3__["EShaderMode"][ins.shader.value],
            exposure: ins.exposure.value,
            gamma: ins.gamma.value,
        };
        if (ins.annotationsVisible.value) {
            data.annotationsVisible = true;
        }
        if (ins.activeTags.value) {
            data.activeTags = ins.activeTags.value;
        }
        if (ins.sortedTags.value) {
            data.sortedTags = ins.sortedTags.value;
        }
        if (ins.radioTags.value) {
            data.radioTags = ins.radioTags.value;
        }
        return data;
    }
    refreshTagCloud() {
        const tagCloud = new Set();
        const models = this.getGraphComponents(_CVModel2__WEBPACK_IMPORTED_MODULE_5__["default"]);
        models.forEach(model => {
            const tags = model.ins.tags.value.split(",").map(tag => tag.trim()).filter(tag => tag);
            tags.forEach(tag => tagCloud.add(tag));
        });
        const views = this.getGraphComponents(_CVAnnotationView__WEBPACK_IMPORTED_MODULE_6__["default"]);
        const oldTagCloud = this.outs.tagCloud.value.split(",").map(tag => tag.trim()).filter(tag => tag);
        views.forEach(component => {
            const annotations = component.getAnnotations();
            annotations.forEach(annotation => {
                const tags = annotation.tags;
                tags.forEach(tag => {
                    if (!oldTagCloud.includes(tag)) {
                        this.ins.activeTags.setValue(this.ins.activeTags.value + ", " + tag);
                    }
                    tagCloud.add(tag);
                });
            });
        });
        const tagArray = Array.from(tagCloud);
        const sortedTags = this.ins.sortedTags.value.split(",").map(tag => tag.trim()).filter(tag => tag);
        tagArray.sort((a, b) => {
            const aIndex = sortedTags.indexOf(a);
            const bIndex = sortedTags.indexOf(b);
            return aIndex < bIndex ? -1 : (aIndex > bIndex ? 1 : 0);
        });
        this.outs.tagCloud.setValue(tagArray.join(", "));
        // refresh tag display
        this.ins.activeTags.set();
        this.ins.annotationsVisible.set();
        if (true) {
            console.log("CVViewer.refreshTagCloud - %s", tagArray.join(", "));
        }
    }
    onAnnotationClick(event) {
        const id = event.annotation ? event.annotation.id : "";
        this.ins.activeAnnotation.setValue(id);
    }
    onModelComponent(event) {
        const component = event.object;
        if (event.add) {
            component.on("tag-update", this.refreshTagCloud, this);
        }
        else if (event.remove) {
            component.off("tag-update", this.refreshTagCloud, this);
        }
    }
    onAnnotationsComponent(event) {
        const component = event.object;
        if (event.add) {
            component.on("tag-update", this.refreshTagCloud, this);
            component.on("click", this.onAnnotationClick, this);
            component.ins.visible.setValue(this.ins.annotationsVisible.value);
        }
        else if (event.remove) {
            component.off("tag-update", this.refreshTagCloud, this);
            component.off("click", this.onAnnotationClick, this);
        }
    }
    onLanguageComponent(event) {
        const component = event.object;
        if (event.add) {
            component.on("tag-update", this.refreshTagCloud, this);
        }
        else if (event.remove) {
            component.off("tag-update", this.refreshTagCloud, this);
        }
    }
}
CVViewer.typeName = "CVViewer";
CVViewer.text = "Viewer";
CVViewer.icon = "";
CVViewer.ins = {
    annotationsVisible: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Boolean("Annotations.Visible"),
    activeAnnotation: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].String("Annotations.ActiveId"),
    activeTags: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].String("Tags.Active"),
    sortedTags: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].String("Tags.Sorted"),
    radioTags: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Boolean("Tags.Radio"),
    shader: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Enum("Renderer.Shader", client_schema_setup__WEBPACK_IMPORTED_MODULE_3__["EShaderMode"]),
    exposure: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Number("Renderer.Exposure", 1),
    gamma: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Number("Renderer.Gamma", 2),
    quality: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].Enum("Models.Quality", client_schema_model__WEBPACK_IMPORTED_MODULE_4__["EDerivativeQuality"], client_schema_model__WEBPACK_IMPORTED_MODULE_4__["EDerivativeQuality"].High),
};
CVViewer.outs = {
    tagCloud: _ff_graph_Component__WEBPACK_IMPORTED_MODULE_1__["types"].String("Tags.Cloud"),
};


/***/ }),

/***/ "./constants.ts":
/*!**********************!*\
  !*** ./constants.ts ***!
  \**********************/
/*! exports provided: HAS_WEBXR_DEVICE_API, HAS_WEBXR_HIT_TEST_API, IS_WEBXR_AR_CANDIDATE, IS_MOBILE, IS_IOS, IS_AR_QUICKLOOK_CANDIDATE, IS_CHROMEOS, IS_ANDROID */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HAS_WEBXR_DEVICE_API", function() { return HAS_WEBXR_DEVICE_API; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HAS_WEBXR_HIT_TEST_API", function() { return HAS_WEBXR_HIT_TEST_API; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IS_WEBXR_AR_CANDIDATE", function() { return IS_WEBXR_AR_CANDIDATE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IS_MOBILE", function() { return IS_MOBILE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IS_IOS", function() { return IS_IOS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IS_AR_QUICKLOOK_CANDIDATE", function() { return IS_AR_QUICKLOOK_CANDIDATE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IS_CHROMEOS", function() { return IS_CHROMEOS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IS_ANDROID", function() { return IS_ANDROID; });
//import * as WebXR from "./types/WebXR";
//*****************************************************************//
// Constants from <model-viewer> 
// https://github.com/google/model-viewer/blob/master/packages/model-viewer/src/constants.ts
const HAS_WEBXR_DEVICE_API = navigator.xr != null &&
    self.XRSession != null && navigator.xr.isSessionSupported != null;
const HAS_WEBXR_HIT_TEST_API = HAS_WEBXR_DEVICE_API && self.XRSession.prototype.requestHitTestSource;
//export const HAS_RESIZE_OBSERVER = self.ResizeObserver != null;
//export const HAS_INTERSECTION_OBSERVER = self.IntersectionObserver != null;
const IS_WEBXR_AR_CANDIDATE = HAS_WEBXR_HIT_TEST_API;
const IS_MOBILE = (() => {
    const userAgent = navigator.userAgent || navigator.vendor || self.opera;
    let check = false;
    // eslint-disable-next-line
    if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i
        .test(userAgent) ||
        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i
            .test(userAgent.substr(0, 4))) {
        check = true;
    }
    return check;
})();
const IS_IOS = (/iPad|iPhone|iPod/.test(navigator.userAgent) && !self.MSStream) ||
    (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
const IS_AR_QUICKLOOK_CANDIDATE = (() => {
    const tempAnchor = document.createElement('a');
    return Boolean(tempAnchor.relList && tempAnchor.relList.supports &&
        tempAnchor.relList.supports('ar'));
})();
const IS_CHROMEOS = /\bCrOS\b/.test(navigator.userAgent);
const IS_ANDROID = /android/i.test(navigator.userAgent);
//*****************************************************************//


/***/ }),

/***/ "./io/DocumentValidator.ts":
/*!*********************************!*\
  !*** ./io/DocumentValidator.ts ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DocumentValidator; });
/* harmony import */ var ajv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ajv */ "../../node_modules/ajv/dist/ajv.js");
/* harmony import */ var ajv__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ajv__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var client_schema_json_document_schema_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! client/schema/json/document.schema.json */ "./schema/json/document.schema.json");
var client_schema_json_document_schema_json__WEBPACK_IMPORTED_MODULE_1___namespace = /*#__PURE__*/__webpack_require__.t(/*! client/schema/json/document.schema.json */ "./schema/json/document.schema.json", 1);
/* harmony import */ var client_schema_json_common_schema_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! client/schema/json/common.schema.json */ "./schema/json/common.schema.json");
var client_schema_json_common_schema_json__WEBPACK_IMPORTED_MODULE_2___namespace = /*#__PURE__*/__webpack_require__.t(/*! client/schema/json/common.schema.json */ "./schema/json/common.schema.json", 1);
/* harmony import */ var client_schema_json_meta_schema_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! client/schema/json/meta.schema.json */ "./schema/json/meta.schema.json");
var client_schema_json_meta_schema_json__WEBPACK_IMPORTED_MODULE_3___namespace = /*#__PURE__*/__webpack_require__.t(/*! client/schema/json/meta.schema.json */ "./schema/json/meta.schema.json", 1);
/* harmony import */ var client_schema_json_model_schema_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! client/schema/json/model.schema.json */ "./schema/json/model.schema.json");
var client_schema_json_model_schema_json__WEBPACK_IMPORTED_MODULE_4___namespace = /*#__PURE__*/__webpack_require__.t(/*! client/schema/json/model.schema.json */ "./schema/json/model.schema.json", 1);
/* harmony import */ var client_schema_json_setup_schema_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! client/schema/json/setup.schema.json */ "./schema/json/setup.schema.json");
var client_schema_json_setup_schema_json__WEBPACK_IMPORTED_MODULE_5___namespace = /*#__PURE__*/__webpack_require__.t(/*! client/schema/json/setup.schema.json */ "./schema/json/setup.schema.json", 1);
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






////////////////////////////////////////////////////////////////////////////////
class DocumentValidator {
    constructor() {
        this._schemaValidator = new ajv__WEBPACK_IMPORTED_MODULE_0___default.a({
            schemas: [
                client_schema_json_document_schema_json__WEBPACK_IMPORTED_MODULE_1__,
                client_schema_json_common_schema_json__WEBPACK_IMPORTED_MODULE_2__,
                client_schema_json_meta_schema_json__WEBPACK_IMPORTED_MODULE_3__,
                client_schema_json_model_schema_json__WEBPACK_IMPORTED_MODULE_4__,
                client_schema_json_setup_schema_json__WEBPACK_IMPORTED_MODULE_5__,
            ],
            allErrors: true
        });
        this._validateDocument = this._schemaValidator.getSchema("https://schemas.3d.si.edu/voyager/document.schema.json");
    }
    validate(document) {
        if (!this._validateDocument(document)) {
            console.warn(this._schemaValidator.errorsText(this._validateDocument.errors, { separator: ", ", dataVar: "document" }));
            return false;
        }
        if (true) {
            console.log("JSONValidator.validateDocument - OK");
        }
        return true;
    }
}


/***/ }),

/***/ "./io/FontReader.ts":
/*!**************************!*\
  !*** ./io/FontReader.ts ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FontReader; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _components_CVAssetReader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/CVAssetReader */ "./components/CVAssetReader.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


class FontReader {
    constructor(loadingManager) {
        this._customFontPath = null;
        this._loadingManager = loadingManager;
        this._textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__["TextureLoader"](loadingManager);
        this._cache = {};
    }
    set fontPath(path) {
        this._customFontPath = path;
    }
    get fontPath() {
        return this._customFontPath;
    }
    get(url) {
        return this._cache[url];
    }
    load(url) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._cache[url]) {
                return Promise.resolve(this._cache[url]);
            }
            this._loadingManager.itemStart(url);
            const customUrl = this.fontPath;
            const descriptorUrl = customUrl ? customUrl + url + ".json" : _components_CVAssetReader__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_SYSTEM_ASSET_PATH"] + url + ".json";
            const bitmapUrl = customUrl ? customUrl + url + ".png" : _components_CVAssetReader__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_SYSTEM_ASSET_PATH"] + url + ".png";
            const loadDescriptor = fetch(descriptorUrl, {
                headers: {
                    "Accept": "application/json"
                }
            }).then(result => {
                if (!result.ok) {
                    this._loadingManager.itemError(url);
                    throw new Error(`failed to load bitmap font descriptor: '${descriptorUrl}', status: ${result.status} ${result.statusText}`);
                }
                return result.json();
            });
            const loadBitmap = new Promise((resolve, reject) => {
                this._textureLoader.load(bitmapUrl, texture => {
                    if (texture) {
                        return resolve(texture);
                    }
                    return reject(new Error(`failed to load font texture from '${bitmapUrl}'`));
                });
            });
            return Promise.all([loadDescriptor, loadBitmap])
                .then(result => {
                const font = {
                    descriptor: result[0],
                    texture: result[1],
                };
                this._cache[url] = font; // TODO: Revisit caching - this doesn't do much for us
                this._loadingManager.itemEnd(url);
                return font;
            });
        });
    }
}


/***/ }),

/***/ "./io/GeometryReader.ts":
/*!******************************!*\
  !*** ./io/GeometryReader.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GeometryReader; });
/* harmony import */ var three_examples_jsm_loaders_OBJLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three/examples/jsm/loaders/OBJLoader */ "../../node_modules/three/examples/jsm/loaders/OBJLoader.js");
/* harmony import */ var three_examples_jsm_loaders_PLYLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three/examples/jsm/loaders/PLYLoader */ "../../node_modules/three/examples/jsm/loaders/PLYLoader.js");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//const OBJLoader = (THREE as any).OBJLoader;

//const PLYLoader = (THREE as any).PLYLoader;
////////////////////////////////////////////////////////////////////////////////
class GeometryReader {
    constructor(loadingManager) {
        this.objLoader = new three_examples_jsm_loaders_OBJLoader__WEBPACK_IMPORTED_MODULE_0__["OBJLoader"](loadingManager);
        this.plyLoader = new three_examples_jsm_loaders_PLYLoader__WEBPACK_IMPORTED_MODULE_1__["PLYLoader"](loadingManager);
    }
    isValid(url) {
        const extension = url.split(".").pop().toLowerCase();
        return GeometryReader.extensions.indexOf(extension) >= 0;
    }
    get(url) {
        const extension = url.split(".").pop().toLowerCase();
        return new Promise((resolve, reject) => {
            if (extension === "obj") {
                this.objLoader.load(url, result => {
                    const geometry = result.children[0].geometry;
                    if (geometry && geometry.type === "Geometry" || geometry.type === "BufferGeometry") {
                        return resolve(geometry);
                    }
                    return reject(new Error(`Can't parse geometry from '${url}'`));
                });
            }
            else if (extension === "ply") {
                this.plyLoader.load(url, geometry => {
                    if (geometry && geometry.type === "Geometry" || geometry.type === "BufferGeometry") {
                        return resolve(geometry);
                    }
                    return reject(new Error(`Can't parse geometry from '${url}'`));
                });
            }
            else {
                throw new Error(`Can't load geometry, unknown extension: '${extension}' in '${url}'`);
            }
        });
    }
}
GeometryReader.extensions = ["obj", "ply"];


/***/ }),

/***/ "./io/JSONReader.ts":
/*!**************************!*\
  !*** ./io/JSONReader.ts ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return JSONReader; });
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
////////////////////////////////////////////////////////////////////////////////
class JSONReader {
    constructor(loadingManager) {
        this._loadingManager = loadingManager;
    }
    get(url) {
        return __awaiter(this, void 0, void 0, function* () {
            this._loadingManager.itemStart(url);
            return fetch(url, {
                headers: {
                    "Accept": "application/json"
                }
            }).then(result => {
                if (!result.ok) {
                    this._loadingManager.itemError(url);
                    throw new Error(`failed to fetch from '${url}', status: ${result.status} ${result.statusText}`);
                }
                this._loadingManager.itemEnd(url);
                return result.json();
            });
        });
    }
}


/***/ }),

/***/ "./io/ModelReader.ts":
/*!***************************!*\
  !*** ./io/ModelReader.ts ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelReader; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var three_examples_jsm_loaders_DRACOLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three/examples/jsm/loaders/DRACOLoader.js */ "../../node_modules/three/examples/jsm/loaders/DRACOLoader.js");
/* harmony import */ var three_examples_jsm_loaders_GLTFLoader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader.js */ "../../node_modules/three/examples/jsm/loaders/GLTFLoader.js");
/* harmony import */ var _shaders_UberPBRMaterial__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shaders/UberPBRMaterial */ "./shaders/UberPBRMaterial.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//import resolvePathname from "resolve-pathname";




////////////////////////////////////////////////////////////////////////////////
const DEFAULT_DRACO_PATH = "https://www.gstatic.com/draco/versioned/decoders/1.3.6/";
class ModelReader {
    constructor(loadingManager) {
        this.customDracoPath = null;
        this.loadingManager = loadingManager;
        //const dracoPath = resolvePathname("js/draco/", window.location.origin + window.location.pathname);
        if (true) {
            console.log("ModelReader.constructor - DRACO path: %s", this.customDracoPath || DEFAULT_DRACO_PATH);
        }
        const dracoLoader = new three_examples_jsm_loaders_DRACOLoader_js__WEBPACK_IMPORTED_MODULE_1__["DRACOLoader"]();
        dracoLoader.setDecoderPath(this.customDracoPath || DEFAULT_DRACO_PATH);
        this.gltfLoader = new three_examples_jsm_loaders_GLTFLoader_js__WEBPACK_IMPORTED_MODULE_2__["GLTFLoader"](loadingManager);
        this.gltfLoader.setDRACOLoader(dracoLoader);
    }
    set dracoPath(path) {
        this.customDracoPath = path;
        if (this.gltfLoader.dracoLoader !== null) {
            this.gltfLoader.dracoLoader.setDecoderPath(this.customDracoPath);
        }
    }
    isValid(url) {
        const extension = url.split(".").pop().toLowerCase();
        return ModelReader.extensions.indexOf(extension) >= 0;
    }
    isValidMimeType(mimeType) {
        return ModelReader.mimeTypes.indexOf(mimeType) >= 0;
    }
    get(url) {
        return new Promise((resolve, reject) => {
            this.gltfLoader.load(url, gltf => {
                resolve(this.createModelGroup(gltf));
            }, null, error => {
                console.error(`failed to load '${url}': ${error}`);
                reject(new Error(error));
            });
        });
    }
    createModelGroup(gltf) {
        const scene = gltf.scene;
        //if (scene.type !== "Scene") {
        //    throw new Error("not a valid gltf scene");
        //}
        const model = new three__WEBPACK_IMPORTED_MODULE_0__["Group"]();
        scene.children.forEach(child => model.add(child));
        model.traverse((object) => {
            if (object.type === "Mesh") {
                const mesh = object;
                mesh.castShadow = true;
                const material = mesh.material;
                if (material.map) {
                    material.map.encoding = three__WEBPACK_IMPORTED_MODULE_0__["sRGBEncoding"];
                }
                mesh.geometry.computeBoundingBox();
                const uberMat = new _shaders_UberPBRMaterial__WEBPACK_IMPORTED_MODULE_3__["default"]();
                // copy properties from previous material
                if (material.type === "MeshStandardMaterial") {
                    uberMat.copyStandardMaterial(material);
                }
                // check if the material's normal map uses object space (indicated in glTF extras)
                if (material.userData["objectSpaceNormals"]) {
                    uberMat.enableObjectSpaceNormalMap(true);
                    if (true) {
                        console.log("ModelReader.createModelGroup - objectSpaceNormals: ", true);
                    }
                }
                mesh.material = uberMat;
            }
        });
        return model;
    }
}
ModelReader.extensions = ["gltf", "glb"];
ModelReader.mimeTypes = ["model/gltf+json", "model/gltf-binary"];


/***/ }),

/***/ "./io/TextureReader.ts":
/*!*****************************!*\
  !*** ./io/TextureReader.ts ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TextureReader; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

////////////////////////////////////////////////////////////////////////////////
class TextureReader {
    constructor(loadingManager) {
        this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__["TextureLoader"](loadingManager);
    }
    isValid(url) {
        const extension = url.split(".").pop().toLowerCase();
        return TextureReader.extensions.indexOf(extension) >= 0;
    }
    isValidMimeType(mimeType) {
        return TextureReader.mimeTypes.indexOf(mimeType) >= 0;
    }
    get(url) {
        return new Promise((resolve, reject) => {
            this.textureLoader.load(url, texture => {
                resolve(texture);
            }, null, errorEvent => {
                console.error(errorEvent);
                reject(new Error(errorEvent.message));
            });
        });
    }
    getImmediate(url) {
        return this.textureLoader.load(url, null, null, errorEvent => {
            console.error(errorEvent);
        });
    }
}
TextureReader.extensions = ["jpg", "png"];
TextureReader.mimeTypes = ["image/jpeg", "image/png"];


/***/ }),

/***/ "./models/Annotation.ts":
/*!******************************!*\
  !*** ./models/Annotation.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Annotation; });
/* harmony import */ var _ff_core_Document__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/Document */ "../../libs/ff-core/source/Document.ts");
/* harmony import */ var client_annotations_AnnotationFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! client/annotations/AnnotationFactory */ "./annotations/AnnotationFactory.ts");
/* harmony import */ var client_schema_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! client/schema/common */ "./schema/common.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class Annotation extends _ff_core_Document__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this._language = client_schema_common__WEBPACK_IMPORTED_MODULE_2__["ELanguageType"].EN;
    }
    get title() {
        // TODO: Temporary - remove when single string properties are phased out
        if (Object.keys(this.data.titles).length === 0) {
            this.data.titles[client_schema_common__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_LANGUAGE"]] = this.data.title;
        }
        return this.data.titles[client_schema_common__WEBPACK_IMPORTED_MODULE_2__["ELanguageType"][this.language]] || "undefined";
    }
    set title(inTitle) {
        this.data.titles[client_schema_common__WEBPACK_IMPORTED_MODULE_2__["ELanguageType"][this.language]] = inTitle;
        this.update();
    }
    get lead() {
        // TODO: Temporary - remove when single string properties are phased out
        if (Object.keys(this.data.leads).length === 0) {
            this.data.leads[client_schema_common__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_LANGUAGE"]] = this.data.lead;
        }
        return this.data.leads[client_schema_common__WEBPACK_IMPORTED_MODULE_2__["ELanguageType"][this.language]] || "";
    }
    set lead(inLead) {
        this.data.leads[client_schema_common__WEBPACK_IMPORTED_MODULE_2__["ELanguageType"][this.language]] = inLead;
        this.update();
    }
    get tags() {
        // TODO: Temporary - remove when single string properties are phased out
        if (Object.keys(this.data.taglist).length === 0) {
            if (this.data.tags.length > 0) {
                this.data.taglist[client_schema_common__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_LANGUAGE"]] = this.data.tags;
            }
        }
        return this.data.taglist[client_schema_common__WEBPACK_IMPORTED_MODULE_2__["ELanguageType"][this.language]] || [];
    }
    set tags(inTags) {
        this.data.taglist[client_schema_common__WEBPACK_IMPORTED_MODULE_2__["ELanguageType"][this.language]] = inTags;
        this.update();
    }
    get language() {
        return this._language;
    }
    set language(newLanguage) {
        this._language = newLanguage;
    }
    static fromJSON(json) {
        return new Annotation(json);
    }
    init() {
        return {
            id: _ff_core_Document__WEBPACK_IMPORTED_MODULE_0__["default"].generateId(),
            title: "New Annotation",
            titles: {},
            lead: "",
            leads: {},
            marker: "",
            tags: [],
            taglist: {},
            articleId: "",
            imageUri: "",
            style: client_annotations_AnnotationFactory__WEBPACK_IMPORTED_MODULE_1__["default"].defaultTypeName,
            visible: true,
            expanded: false,
            position: null,
            direction: null,
            scale: 1,
            offset: 0,
            tilt: 0,
            azimuth: 0,
            color: [0, 0.61, 0.87],
            zoneIndex: -1,
        };
    }
    deflate(data, json) {
        json.id = data.id;
        if (Object.keys(this.data.titles).length > 0) {
            json.titles = {};
            Object.keys(this.data.titles).forEach(key => {
                json.titles[key] = data.titles[key];
            });
        }
        else if (data.title) {
            json.title = data.title;
        }
        if (Object.keys(this.data.leads).length > 0) {
            json.leads = {};
            Object.keys(this.data.leads).forEach(key => {
                json.leads[key] = data.leads[key];
            });
        }
        else if (data.lead) {
            json.lead = data.lead;
        }
        if (data.marker) {
            json.marker = data.marker;
        }
        if (Object.keys(this.data.taglist).length > 0) {
            json.taglist = {};
            Object.keys(this.data.taglist).forEach(key => {
                json.taglist[key] = data.taglist[key].slice();
            });
        }
        else if (data.tags.length > 0) {
            json.tags = data.tags;
        }
        if (data.articleId) {
            json.articleId = data.articleId;
        }
        if (data.imageUri) {
            json.imageUri = data.imageUri;
        }
        if (data.style !== client_annotations_AnnotationFactory__WEBPACK_IMPORTED_MODULE_1__["default"].defaultTypeName) {
            json.style = data.style;
        }
        if (data.visible === false) {
            json.visible = data.visible;
        }
        if (data.position) {
            json.position = data.position.slice();
        }
        if (data.direction) {
            json.direction = data.direction.slice();
        }
        if (data.scale !== 1) {
            json.scale = data.scale;
        }
        if (data.offset !== 0) {
            json.offset = data.offset;
        }
        if (data.tilt !== 0) {
            json.tilt = data.tilt;
        }
        if (data.azimuth !== 0) {
            json.azimuth = data.azimuth;
        }
        const color = data.color;
        if (color && (color[0] !== 1 || color[1] !== 1 || color[2] !== 1)) {
            json.color = color.slice();
        }
        if (data.zoneIndex > -1) {
            json.zoneIndex = data.zoneIndex;
        }
        return data;
    }
    inflate(json, data) {
        data.id = json.id;
        data.title = json.title || "";
        data.titles = json.titles || {};
        data.lead = json.lead || "";
        data.leads = json.leads || {};
        data.marker = json.marker || "";
        data.tags = json.tags || [];
        data.taglist = json.taglist || {};
        data.articleId = json.articleId || "";
        data.imageUri = json.imageUri || "";
        data.style = json.style || client_annotations_AnnotationFactory__WEBPACK_IMPORTED_MODULE_1__["default"].defaultTypeName;
        data.visible = json.visible !== undefined ? json.visible : true;
        data.expanded = false;
        data.position = json.position.slice();
        data.direction = json.direction.slice();
        data.scale = json.scale !== undefined ? json.scale : 1;
        data.offset = json.offset || 0;
        data.tilt = json.tilt || 0;
        data.azimuth = json.azimuth || 0;
        data.color = json.color || Annotation.defaultColor.slice();
        data.zoneIndex = json.zoneIndex !== undefined ? json.zoneIndex : -1;
    }
}
Annotation.defaultColor = [0, 0.61, 0.87];


/***/ }),

/***/ "./models/Article.ts":
/*!***************************!*\
  !*** ./models/Article.ts ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Article; });
/* harmony import */ var _ff_core_Document__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/Document */ "../../libs/ff-core/source/Document.ts");
/* harmony import */ var client_schema_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! client/schema/common */ "./schema/common.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


class Article extends _ff_core_Document__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this._language = client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"].EN;
    }
    static fromJSON(json) {
        return new Article(json);
    }
    toString() {
        return this.title;
    }
    get title() {
        // TODO: Temporary - remove when single string properties are phased out
        if (Object.keys(this.data.titles).length === 0) {
            this.data.titles[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_LANGUAGE"]] = this.data.title;
        }
        return this.data.titles[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][this.language]] || "undefined";
    }
    set title(inTitle) {
        this.data.titles[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][this.language]] = inTitle;
        this.update();
    }
    get defaultTitle() {
        // TODO: Temporary - remove when single string properties are phased out
        if (Object.keys(this.data.titles).length === 0) {
            this.data.titles[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_LANGUAGE"]] = this.data.title;
        }
        return this.data.titles[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_LANGUAGE"]] || "undefined";
    }
    get uri() {
        // TODO: Temporary - remove when single string properties are phased out
        if (Object.keys(this.data.uris).length === 0) {
            this.data.uris[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_LANGUAGE"]] = this.data.uri;
        }
        return this.data.uris[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][this.language]];
    }
    set uri(inUri) {
        this.data.uris[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][this.language]] = inUri;
        this.update();
    }
    get lead() {
        // TODO: Temporary - remove when single string properties are phased out
        if (Object.keys(this.data.leads).length === 0) {
            this.data.leads[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_LANGUAGE"]] = this.data.lead;
        }
        return this.data.leads[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][this.language]] || "";
    }
    set lead(inLead) {
        this.data.leads[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][this.language]] = inLead;
        this.update();
    }
    get tags() {
        // TODO: Temporary - remove when single string properties are phased out
        if (Object.keys(this.data.taglist).length === 0) {
            if (this.data.tags.length > 0) {
                this.data.taglist[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_LANGUAGE"]] = this.data.tags;
            }
        }
        return this.data.taglist[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][this.language]] || [];
    }
    set tags(inTags) {
        this.data.taglist[client_schema_common__WEBPACK_IMPORTED_MODULE_1__["ELanguageType"][this.language]] = inTags;
        this.update();
    }
    get language() {
        return this._language;
    }
    set language(newLanguage) {
        this._language = newLanguage;
    }
    init() {
        return {
            id: _ff_core_Document__WEBPACK_IMPORTED_MODULE_0__["default"].generateId(),
            title: "New Article",
            titles: {},
            lead: "",
            leads: {},
            tags: [],
            taglist: {},
            uri: "",
            uris: {},
            mimeType: "",
            thumbnailUri: "",
        };
    }
    deflate(data, json) {
        json.id = data.id;
        if (Object.keys(this.data.uris).length > 0) {
            json.uris = {};
            Object.keys(this.data.uris).forEach(key => {
                json.uris[key] = data.uris[key];
            });
        }
        else if (data.uri) {
            json.uri = data.uri;
        }
        if (Object.keys(this.data.titles).length > 0) {
            json.titles = {};
            Object.keys(this.data.titles).forEach(key => {
                json.titles[key] = data.titles[key];
            });
        }
        else if (data.title) {
            json.title = data.title;
        }
        if (Object.keys(this.data.leads).length > 0) {
            json.leads = {};
            Object.keys(this.data.leads).forEach(key => {
                json.leads[key] = data.leads[key];
            });
        }
        else if (data.lead) {
            json.lead = data.lead;
        }
        if (Object.keys(this.data.taglist).length > 0) {
            json.taglist = {};
            Object.keys(this.data.taglist).forEach(key => {
                json.taglist[key] = data.taglist[key].slice();
            });
        }
        else if (data.tags.length > 0) {
            json.tags = data.tags.slice();
        }
        if (data.mimeType) {
            json.mimeType = data.mimeType;
        }
        if (data.thumbnailUri) {
            json.thumbnailUri = data.thumbnailUri;
        }
    }
    inflate(json, data) {
        data.id = json.id;
        data.uri = json.uri || "";
        data.uris = json.uris || {};
        data.title = json.title || "";
        data.titles = json.titles || {};
        data.lead = json.lead || "";
        data.leads = json.leads || {};
        data.tags = json.tags || [];
        data.taglist = json.taglist || {};
        data.mimeType = json.mimeType || "";
        data.thumbnailUri = json.thumbnailUri || "";
    }
}


/***/ }),

/***/ "./models/Asset.ts":
/*!*************************!*\
  !*** ./models/Asset.ts ***!
  \*************************/
/*! exports provided: EAssetType, EMapType, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Asset; });
/* harmony import */ var _ff_core_Document__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/Document */ "../../libs/ff-core/source/Document.ts");
/* harmony import */ var client_schema_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! client/schema/model */ "./schema/model.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EAssetType", function() { return client_schema_model__WEBPACK_IMPORTED_MODULE_1__["EAssetType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EMapType", function() { return client_schema_model__WEBPACK_IMPORTED_MODULE_1__["EMapType"]; });

/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


////////////////////////////////////////////////////////////////////////////////

class Asset extends _ff_core_Document__WEBPACK_IMPORTED_MODULE_0__["default"] {
    setModel(uri) {
        this.data.uri = uri;
        this.data.type = client_schema_model__WEBPACK_IMPORTED_MODULE_1__["EAssetType"].Model;
        this.data.mimeType = this.guessAssetMimeType();
    }
    setGeometry(uri) {
        this.data.uri = uri;
        this.data.type = client_schema_model__WEBPACK_IMPORTED_MODULE_1__["EAssetType"].Geometry;
        this.data.mimeType = this.guessAssetMimeType();
    }
    setTexture(uri, mapType) {
        this.data.uri = uri;
        this.data.type = client_schema_model__WEBPACK_IMPORTED_MODULE_1__["EAssetType"].Image;
        this.data.mimeType = this.guessAssetMimeType();
        this.data.mapType = mapType;
    }
    isValid() {
        return !!this.data.uri && this.data.type !== undefined;
    }
    toString() {
        const data = this.data;
        return `Asset - type: '${client_schema_model__WEBPACK_IMPORTED_MODULE_1__["EAssetType"][data.type]}', uri: '${data.uri}', mime type: '${data.mimeType || "(not set)"}'`;
    }
    init() {
        return {
            uri: "",
            mimeType: "",
            type: undefined,
            mapType: undefined,
            byteSize: 0,
            numFaces: 0,
            numVertices: 0,
            imageSize: 0,
        };
    }
    deflate(data, json) {
        json.uri = data.uri;
        json.type = client_schema_model__WEBPACK_IMPORTED_MODULE_1__["EAssetType"][data.type];
        if (data.mimeType) {
            json.mimeType = data.mimeType;
        }
        if (data.mapType !== undefined) {
            json.mapType = client_schema_model__WEBPACK_IMPORTED_MODULE_1__["EMapType"][data.mapType];
        }
        if (data.byteSize > 0) {
            json.byteSize = data.byteSize;
        }
        // for model and geometry assets, save number of faces
        if (data.type === client_schema_model__WEBPACK_IMPORTED_MODULE_1__["EAssetType"].Model || data.type === client_schema_model__WEBPACK_IMPORTED_MODULE_1__["EAssetType"].Geometry) {
            if (data.numFaces > 0) {
                json.numFaces = data.numFaces;
            }
        }
        // for model, image, and texture assets, save image/map size
        if (data.type === client_schema_model__WEBPACK_IMPORTED_MODULE_1__["EAssetType"].Model || data.type === client_schema_model__WEBPACK_IMPORTED_MODULE_1__["EAssetType"].Image || data.type === client_schema_model__WEBPACK_IMPORTED_MODULE_1__["EAssetType"].Texture) {
            if (data.imageSize > 0) {
                json.imageSize = data.imageSize;
            }
        }
    }
    inflate(json, data) {
        data.uri = json.uri;
        data.mimeType = json.mimeType || "";
        data.type = client_schema_model__WEBPACK_IMPORTED_MODULE_1__["EAssetType"][json.type];
        data.mapType = client_schema_model__WEBPACK_IMPORTED_MODULE_1__["EMapType"][json.mapType];
        data.byteSize = json.byteSize || 0;
        data.numFaces = json.numFaces || 0;
        data.imageSize = json.imageSize || 0;
        if (data.type === undefined) {
            data.type = this.guessAssetType();
            if (data.type === undefined) {
                console.warn(`failed to determine asset type from asset: ${data.uri}`);
            }
        }
    }
    guessAssetType() {
        const data = this.data;
        if (data.type !== undefined && client_schema_model__WEBPACK_IMPORTED_MODULE_1__["EAssetType"][data.type]) {
            return data.type;
        }
        if (data.mimeType) {
            if (data.mimeType === Asset.mimeType.gltfJson || data.mimeType === Asset.mimeType.gltfBinary) {
                return client_schema_model__WEBPACK_IMPORTED_MODULE_1__["EAssetType"].Model;
            }
            if (data.mimeType === Asset.mimeType.imageJpeg || data.mimeType === Asset.mimeType.imagePng) {
                return client_schema_model__WEBPACK_IMPORTED_MODULE_1__["EAssetType"].Image;
            }
        }
        const extension = data.uri.split(".").pop().toLowerCase();
        if (extension === "gltf" || extension === "glb") {
            return client_schema_model__WEBPACK_IMPORTED_MODULE_1__["EAssetType"].Model;
        }
        if (extension === "obj" || extension === "ply") {
            return client_schema_model__WEBPACK_IMPORTED_MODULE_1__["EAssetType"].Geometry;
        }
        if (extension === "jpg" || extension === "png") {
            return client_schema_model__WEBPACK_IMPORTED_MODULE_1__["EAssetType"].Image;
        }
        return undefined;
    }
    guessAssetMimeType() {
        const data = this.data;
        if (data.mimeType) {
            return data.mimeType;
        }
        const extension = data.uri.split(".").pop().toLowerCase();
        if (extension === "gltf") {
            return Asset.mimeType.gltfJson;
        }
        if (extension === "glb") {
            return Asset.mimeType.gltfBinary;
        }
        if (extension === "jpg") {
            return Asset.mimeType.imageJpeg;
        }
        if (extension === "png") {
            return Asset.mimeType.imagePng;
        }
        return "";
    }
}
Asset.mimeType = {
    gltfJson: "model/gltf+json",
    gltfBinary: "model/gltf-binary",
    imageJpeg: "image/jpeg",
    imagePng: "image/png"
};


/***/ }),

/***/ "./models/Derivative.ts":
/*!******************************!*\
  !*** ./models/Derivative.ts ***!
  \******************************/
/*! exports provided: EDerivativeQuality, EDerivativeUsage, Asset, EAssetType, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Derivative; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var _ff_three_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/three/helpers */ "../../libs/ff-three/source/helpers.ts");
/* harmony import */ var _ff_core_Document__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/core/Document */ "../../libs/ff-core/source/Document.ts");
/* harmony import */ var client_schema_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! client/schema/model */ "./schema/model.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EDerivativeQuality", function() { return client_schema_model__WEBPACK_IMPORTED_MODULE_3__["EDerivativeQuality"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EDerivativeUsage", function() { return client_schema_model__WEBPACK_IMPORTED_MODULE_3__["EDerivativeUsage"]; });

/* harmony import */ var _shaders_UberPBRMaterial__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shaders/UberPBRMaterial */ "./shaders/UberPBRMaterial.ts");
/* harmony import */ var _Asset__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Asset */ "./models/Asset.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Asset", function() { return _Asset__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EAssetType", function() { return _Asset__WEBPACK_IMPORTED_MODULE_5__["EAssetType"]; });

/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






////////////////////////////////////////////////////////////////////////////////

class Derivative extends _ff_core_Document__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super(...arguments);
        this.model = null;
    }
    static fromJSON(json) {
        return new Derivative(json);
    }
    dispose() {
        this.unload();
        super.dispose();
    }
    load(assetReader) {
        if (this.data.usage !== client_schema_model__WEBPACK_IMPORTED_MODULE_3__["EDerivativeUsage"].Web3D) {
            throw new Error("can't load, not a Web3D derivative");
        }
        const modelAsset = this.findAsset(_Asset__WEBPACK_IMPORTED_MODULE_5__["EAssetType"].Model);
        if (modelAsset) {
            return assetReader.getModel(modelAsset.data.uri)
                .then(object => {
                if (this.model) {
                    Object(_ff_three_helpers__WEBPACK_IMPORTED_MODULE_1__["disposeObject"])(this.model);
                }
                this.model = object;
                return object;
            });
        }
        const geoAsset = this.findAsset(_Asset__WEBPACK_IMPORTED_MODULE_5__["EAssetType"].Geometry);
        const imageAssets = this.findAssets(_Asset__WEBPACK_IMPORTED_MODULE_5__["EAssetType"].Image);
        if (geoAsset) {
            return assetReader.getGeometry(geoAsset.data.uri)
                .then(geometry => {
                this.model = new three__WEBPACK_IMPORTED_MODULE_0__["Mesh"](geometry, new _shaders_UberPBRMaterial__WEBPACK_IMPORTED_MODULE_4__["default"]());
                return Promise.all(imageAssets.map(asset => assetReader.getTexture(asset.data.uri)))
                    .catch(error => {
                    console.warn("failed to load texture files");
                    return [];
                });
            })
                .then(textures => {
                const material = this.model.material;
                this.assignTextures(imageAssets, textures, material);
                if (!material.map) {
                    material.color.setScalar(0.5);
                    material.roughness = 0.8;
                    material.metalness = 0;
                }
                return this.model;
            });
        }
    }
    unload() {
        if (this.model) {
            Object(_ff_three_helpers__WEBPACK_IMPORTED_MODULE_1__["disposeObject"])(this.model);
            this.model = null;
        }
    }
    createAsset(type, uri) {
        const asset = new _Asset__WEBPACK_IMPORTED_MODULE_5__["default"]();
        asset.data.type = type;
        asset.data.uri = uri;
        this.addAsset(asset);
        return asset;
    }
    addAsset(asset) {
        if (!asset.data.uri) {
            throw new Error("uri must be specified");
        }
        this.data.assets.push(asset);
        this.update();
    }
    removeAsset(asset) {
        const index = this.data.assets.indexOf(asset);
        if (index >= 0) {
            this.data.assets.splice(index, 1);
        }
    }
    findAsset(type) {
        return this.data.assets.find(asset => asset.data.type === type);
    }
    findAssets(type) {
        return this.data.assets.filter(asset => asset.data.type === type);
    }
    toString(verbose = false) {
        const data = this.data;
        if (verbose) {
            return `Derivative - usage: '${client_schema_model__WEBPACK_IMPORTED_MODULE_3__["EDerivativeUsage"][data.usage]}', quality: '${client_schema_model__WEBPACK_IMPORTED_MODULE_3__["EDerivativeQuality"][data.quality]}'\n   `
                + data.assets.map(asset => asset.toString()).join("\n   ");
        }
        else {
            return `Derivative - usage: '${client_schema_model__WEBPACK_IMPORTED_MODULE_3__["EDerivativeUsage"][data.usage]}', quality: '${client_schema_model__WEBPACK_IMPORTED_MODULE_3__["EDerivativeQuality"][data.quality]}', #assets: ${data.assets.length})`;
        }
    }
    init() {
        return {
            usage: client_schema_model__WEBPACK_IMPORTED_MODULE_3__["EDerivativeUsage"].Web3D,
            quality: client_schema_model__WEBPACK_IMPORTED_MODULE_3__["EDerivativeQuality"].Medium,
            assets: [],
        };
    }
    deflate(data, json) {
        json.usage = client_schema_model__WEBPACK_IMPORTED_MODULE_3__["EDerivativeUsage"][data.usage];
        json.quality = client_schema_model__WEBPACK_IMPORTED_MODULE_3__["EDerivativeQuality"][data.quality];
        json.assets = data.assets.map(asset => asset.toJSON());
    }
    inflate(json, data) {
        data.usage = client_schema_model__WEBPACK_IMPORTED_MODULE_3__["EDerivativeUsage"][json.usage];
        if (data.usage === undefined) {
            throw new Error(`unknown derivative usage: ${json.usage}`);
        }
        data.quality = client_schema_model__WEBPACK_IMPORTED_MODULE_3__["EDerivativeQuality"][json.quality];
        if (data.quality === undefined) {
            throw new Error(`unknown derivative quality: ${json.quality}`);
        }
        data.assets = json.assets.map(assetJson => new _Asset__WEBPACK_IMPORTED_MODULE_5__["default"](assetJson));
    }
    assignTextures(assets, textures, material) {
        for (let i = 0; i < assets.length; ++i) {
            const asset = assets[i];
            const texture = textures[i];
            switch (asset.data.mapType) {
                case _Asset__WEBPACK_IMPORTED_MODULE_5__["EMapType"].Color:
                    material.map = texture;
                    break;
                case _Asset__WEBPACK_IMPORTED_MODULE_5__["EMapType"].Occlusion:
                    material.aoMap = texture;
                    break;
                case _Asset__WEBPACK_IMPORTED_MODULE_5__["EMapType"].Emissive:
                    material.emissiveMap = texture;
                    break;
                case _Asset__WEBPACK_IMPORTED_MODULE_5__["EMapType"].MetallicRoughness:
                    material.metalnessMap = texture;
                    material.roughnessMap = texture;
                    break;
                case _Asset__WEBPACK_IMPORTED_MODULE_5__["EMapType"].Normal:
                    material.normalMap = texture;
                    break;
            }
        }
    }
}


/***/ }),

/***/ "./models/DerivativeList.ts":
/*!**********************************!*\
  !*** ./models/DerivativeList.ts ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DerivativeList; });
/* harmony import */ var _Derivative__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Derivative */ "./models/Derivative.ts");
/* harmony import */ var _Asset__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Asset */ "./models/Asset.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


////////////////////////////////////////////////////////////////////////////////
const _EMPTY_ARRAY = [];
const _qualityLevels = [
    _Derivative__WEBPACK_IMPORTED_MODULE_0__["EDerivativeQuality"].Thumb,
    _Derivative__WEBPACK_IMPORTED_MODULE_0__["EDerivativeQuality"].AR,
    _Derivative__WEBPACK_IMPORTED_MODULE_0__["EDerivativeQuality"].Low,
    _Derivative__WEBPACK_IMPORTED_MODULE_0__["EDerivativeQuality"].Medium,
    _Derivative__WEBPACK_IMPORTED_MODULE_0__["EDerivativeQuality"].High,
    _Derivative__WEBPACK_IMPORTED_MODULE_0__["EDerivativeQuality"].Highest
];
class DerivativeList {
    constructor() {
        this.derivatives = {};
    }
    /**
     * From all derivatives with the given usage (e.g. web), select a derivative as close as possible to
     * the given quality. The selection strategy works as follows:
     * 1. Look for a derivative matching the quality exactly. If found, return it.
     * 2. Look for a derivative with higher quality. If found, return it.
     * 3. Look for a derivative with lower quality. If found return it, otherwise report an error.
     * @param quality
     * @param usage
     */
    select(usage, quality) {
        const usageKey = _Derivative__WEBPACK_IMPORTED_MODULE_0__["EDerivativeUsage"][usage];
        const qualityKey = _Derivative__WEBPACK_IMPORTED_MODULE_0__["EDerivativeQuality"][quality];
        const qualityIndex = _qualityLevels.indexOf(quality);
        if (qualityIndex < 0) {
            console.warn(`derivative quality not supported: '${qualityKey}'`);
            return null;
        }
        const derivative = this.get(usage, quality);
        if (derivative) {
            return derivative;
        }
        for (let i = qualityIndex + 1; i < _qualityLevels.length; ++i) {
            const derivative = this.get(usage, _qualityLevels[i]);
            if (derivative) {
                console.warn(`derivative quality '${qualityKey}' not available, using higher quality`);
                return derivative;
            }
        }
        for (let i = qualityIndex - 1; i >= 0; --i) {
            const derivative = this.get(usage, _qualityLevels[i]);
            if (derivative) {
                console.warn(`derivative quality '${qualityKey}' not available, using lower quality`);
                return derivative;
            }
        }
        console.warn(`no suitable derivative found for quality '${qualityKey}'`
            + ` and usage '${usageKey}'`);
        return null;
    }
    getByUsage(usage) {
        const key = _Derivative__WEBPACK_IMPORTED_MODULE_0__["EDerivativeUsage"][usage];
        const derivatives = this.derivatives[key] || _EMPTY_ARRAY;
        return derivatives.sort((a, b) => {
            if (a.data.quality < b.data.quality)
                return -1;
            if (a.data.quality > b.data.quality)
                return 1;
            return 0;
        });
    }
    getByQuality(quality) {
        const derivatives = this.getArray();
        return derivatives.filter(a => a.data.quality === quality);
    }
    getArray() {
        return Object.keys(this.derivatives)
            .reduce((arr, key) => arr.concat(this.derivatives[key]), []);
    }
    get(usage, quality) {
        const key = _Derivative__WEBPACK_IMPORTED_MODULE_0__["EDerivativeUsage"][usage];
        const bin = this.derivatives[key];
        if (bin) {
            for (let i = 0, n = bin.length; i < n; ++i) {
                if (bin[i].data.quality === quality) {
                    return bin[i];
                }
            }
        }
        return null;
    }
    getOrCreate(usage, quality) {
        const bin = this.getOrCreateBin(usage);
        for (let i = 0, n = bin.length; i < n; ++i) {
            if (bin[i].data.quality === quality) {
                return bin[i];
            }
        }
        const derivative = new _Derivative__WEBPACK_IMPORTED_MODULE_0__["default"]();
        derivative.set("usage", usage);
        derivative.set("quality", quality);
        bin.push(derivative);
        return derivative;
    }
    createModelAsset(assetPath, quality) {
        quality = (typeof quality === "string" ? _Derivative__WEBPACK_IMPORTED_MODULE_0__["EDerivativeQuality"][quality] : quality);
        quality = isFinite(quality) ? quality : _Derivative__WEBPACK_IMPORTED_MODULE_0__["EDerivativeQuality"].Medium;
        const derivative = this.getOrCreate(_Derivative__WEBPACK_IMPORTED_MODULE_0__["EDerivativeUsage"].Web3D, quality);
        const asset = new _Asset__WEBPACK_IMPORTED_MODULE_1__["default"]();
        asset.setModel(assetPath);
        derivative.addAsset(asset);
        return derivative;
    }
    createMeshAsset(geoPath, colorMapPath, occlusionMapPath, normalMapPath, quality) {
        quality = (typeof quality === "string" ? _Derivative__WEBPACK_IMPORTED_MODULE_0__["EDerivativeQuality"][quality] : quality);
        quality = isFinite(quality) ? quality : _Derivative__WEBPACK_IMPORTED_MODULE_0__["EDerivativeQuality"].Medium;
        const derivative = this.getOrCreate(_Derivative__WEBPACK_IMPORTED_MODULE_0__["EDerivativeUsage"].Web3D, quality);
        const geoAsset = new _Asset__WEBPACK_IMPORTED_MODULE_1__["default"]();
        geoAsset.setGeometry(geoPath);
        derivative.addAsset(geoAsset);
        if (colorMapPath) {
            const colorMapAsset = new _Asset__WEBPACK_IMPORTED_MODULE_1__["default"]();
            colorMapAsset.setTexture(colorMapPath, _Asset__WEBPACK_IMPORTED_MODULE_1__["EMapType"].Color);
            derivative.addAsset(colorMapAsset);
        }
        if (occlusionMapPath) {
            const occlusionMapAsset = new _Asset__WEBPACK_IMPORTED_MODULE_1__["default"]();
            occlusionMapAsset.setTexture(occlusionMapPath, _Asset__WEBPACK_IMPORTED_MODULE_1__["EMapType"].Occlusion);
            derivative.addAsset(occlusionMapAsset);
        }
        if (normalMapPath) {
            const normalMapAsset = new _Asset__WEBPACK_IMPORTED_MODULE_1__["default"]();
            normalMapAsset.setTexture(normalMapPath, _Asset__WEBPACK_IMPORTED_MODULE_1__["EMapType"].Normal);
            derivative.addAsset(normalMapAsset);
        }
        return derivative;
    }
    clear() {
        for (let key in this.derivatives) {
            this.derivatives[key].forEach(derivative => derivative.dispose());
        }
        this.derivatives = {};
    }
    toJSON() {
        const data = [];
        for (let key in this.derivatives) {
            this.derivatives[key].forEach(derivative => data.push(derivative.toJSON()));
        }
        return data;
    }
    fromJSON(data) {
        this.clear();
        data.forEach(derivativeData => {
            const bin = this.getOrCreateBin(_Derivative__WEBPACK_IMPORTED_MODULE_0__["EDerivativeUsage"][derivativeData.usage]);
            bin.push(new _Derivative__WEBPACK_IMPORTED_MODULE_0__["default"](derivativeData));
        });
    }
    toString(verbose = false) {
        const derivatives = this.derivatives;
        const keys = Object.keys(derivatives);
        if (verbose) {
            return `Derivatives (${keys.length}) \n ` + keys.map(key => derivatives[key].map(derivative => derivative.toString(true)).join("\n ")).join("\n ");
        }
        else {
            return `Derivatives (${keys.length}) ` + keys.map(key => `${key} (${derivatives[key].length})`).join(", ");
        }
    }
    getOrCreateBin(usage) {
        const key = _Derivative__WEBPACK_IMPORTED_MODULE_0__["EDerivativeUsage"][usage];
        return this.derivatives[key] || (this.derivatives[key] = []);
    }
}


/***/ }),

/***/ "./nodes/NVDocuments.ts":
/*!******************************!*\
  !*** ./nodes/NVDocuments.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NVDocuments; });
/* harmony import */ var _ff_graph_Node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/Node */ "../../libs/ff-graph/source/Node.ts");
/* harmony import */ var _ff_scene_components_CScene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/scene/components/CScene */ "../../libs/ff-scene/source/components/CScene.ts");
/* harmony import */ var _components_CVDocumentProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/CVDocumentProvider */ "./components/CVDocumentProvider.ts");
/* harmony import */ var _components_CVNodeProvider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/CVNodeProvider */ "./components/CVNodeProvider.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




////////////////////////////////////////////////////////////////////////////////
class NVDocuments extends _ff_graph_Node__WEBPACK_IMPORTED_MODULE_0__["default"] {
    get scene() {
        return this.components.get(_ff_scene_components_CScene__WEBPACK_IMPORTED_MODULE_1__["default"]);
    }
    get documentProvider() {
        return this.components.get(_components_CVDocumentProvider__WEBPACK_IMPORTED_MODULE_2__["default"]);
    }
    get nodeProvider() {
        return this.components.get(_components_CVNodeProvider__WEBPACK_IMPORTED_MODULE_3__["default"]);
    }
    createComponents() {
        this.createComponent(_ff_scene_components_CScene__WEBPACK_IMPORTED_MODULE_1__["default"], "Master Scene");
        this.createComponent(_components_CVDocumentProvider__WEBPACK_IMPORTED_MODULE_2__["default"]);
        this.createComponent(_components_CVNodeProvider__WEBPACK_IMPORTED_MODULE_3__["default"]);
    }
}
NVDocuments.typeName = "NVDocuments";


/***/ }),

/***/ "./nodes/NVEngine.ts":
/*!***************************!*\
  !*** ./nodes/NVEngine.ts ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NVEngine; });
/* harmony import */ var _ff_graph_Node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/Node */ "../../libs/ff-graph/source/Node.ts");
/* harmony import */ var _ff_graph_components_CPulse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/graph/components/CPulse */ "../../libs/ff-graph/source/components/CPulse.ts");
/* harmony import */ var _ff_scene_components_CRenderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/scene/components/CRenderer */ "../../libs/ff-scene/source/components/CRenderer.ts");
/* harmony import */ var _ff_scene_components_CPickSelection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ff/scene/components/CPickSelection */ "../../libs/ff-scene/source/components/CPickSelection.ts");
/* harmony import */ var _ff_scene_components_CFullscreen__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ff/scene/components/CFullscreen */ "../../libs/ff-scene/source/components/CFullscreen.ts");
/* harmony import */ var _components_CVAssetManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/CVAssetManager */ "./components/CVAssetManager.ts");
/* harmony import */ var _components_CVAssetReader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../components/CVAssetReader */ "./components/CVAssetReader.ts");
/* harmony import */ var _components_CVAnalytics__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components/CVAnalytics */ "./components/CVAnalytics.ts");
/* harmony import */ var _components_CVARManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../components/CVARManager */ "./components/CVARManager.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









////////////////////////////////////////////////////////////////////////////////
class NVEngine extends _ff_graph_Node__WEBPACK_IMPORTED_MODULE_0__["default"] {
    get pulse() {
        return this.components.get(_ff_graph_components_CPulse__WEBPACK_IMPORTED_MODULE_1__["default"]);
    }
    get renderer() {
        return this.components.get(_ff_scene_components_CRenderer__WEBPACK_IMPORTED_MODULE_2__["default"]);
    }
    get fullscreen() {
        return this.components.get(_ff_scene_components_CFullscreen__WEBPACK_IMPORTED_MODULE_4__["default"]);
    }
    get selection() {
        return this.components.get(_ff_scene_components_CPickSelection__WEBPACK_IMPORTED_MODULE_3__["default"]);
    }
    get assetManager() {
        return this.components.get(_components_CVAssetManager__WEBPACK_IMPORTED_MODULE_5__["default"]);
    }
    get assetReader() {
        return this.components.get(_components_CVAssetReader__WEBPACK_IMPORTED_MODULE_6__["default"]);
    }
    get analytics() {
        return this.components.get(_components_CVAnalytics__WEBPACK_IMPORTED_MODULE_7__["default"]);
    }
    get arManager() {
        return this.components.get(_components_CVARManager__WEBPACK_IMPORTED_MODULE_8__["default"]);
    }
    createComponents() {
        this.createComponent(_ff_graph_components_CPulse__WEBPACK_IMPORTED_MODULE_1__["default"]);
        this.createComponent(_ff_scene_components_CRenderer__WEBPACK_IMPORTED_MODULE_2__["default"]);
        this.createComponent(_ff_scene_components_CFullscreen__WEBPACK_IMPORTED_MODULE_4__["default"]);
        this.createComponent(_components_CVAssetManager__WEBPACK_IMPORTED_MODULE_5__["default"]);
        this.createComponent(_components_CVAssetReader__WEBPACK_IMPORTED_MODULE_6__["default"]);
        this.createComponent(_components_CVAnalytics__WEBPACK_IMPORTED_MODULE_7__["default"]);
        this.createComponent(_components_CVARManager__WEBPACK_IMPORTED_MODULE_8__["default"]);
        const selection = this.createComponent(_ff_scene_components_CPickSelection__WEBPACK_IMPORTED_MODULE_3__["default"]);
        // allow simultaneous selection of nodes and components
        //selection.exclusiveSelect = false;
        // don't allow selecting multiple nodes or components
        //selection.multiSelect = false;
        // do not display selection brackets
        selection.ins.viewportBrackets.setValue(false);
    }
}
NVEngine.typeName = "NVEngine";


/***/ }),

/***/ "./nodes/NVNode.ts":
/*!*************************!*\
  !*** ./nodes/NVNode.ts ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NVNode; });
/* harmony import */ var _ff_graph_Node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/Node */ "../../libs/ff-graph/source/Node.ts");
/* harmony import */ var _components_CVNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/CVNode */ "./components/CVNode.ts");
/* harmony import */ var _components_CVCamera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/CVCamera */ "./components/CVCamera.ts");
/* harmony import */ var _components_CVLight__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/CVLight */ "./components/CVLight.ts");
/* harmony import */ var _components_CVDirectionalLight__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/CVDirectionalLight */ "./components/CVDirectionalLight.ts");
/* harmony import */ var _components_CVPointLight__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/CVPointLight */ "./components/CVPointLight.ts");
/* harmony import */ var _components_CVSpotLight__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../components/CVSpotLight */ "./components/CVSpotLight.ts");
/* harmony import */ var _components_CVMeta__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components/CVMeta */ "./components/CVMeta.ts");
/* harmony import */ var _components_CVModel2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../components/CVModel2 */ "./components/CVModel2.ts");
/* harmony import */ var _components_CVScene__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../components/CVScene */ "./components/CVScene.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










class NVNode extends _ff_graph_Node__WEBPACK_IMPORTED_MODULE_0__["default"] {
    get transform() {
        return this.components.get(_components_CVNode__WEBPACK_IMPORTED_MODULE_1__["default"]);
    }
    get meta() {
        return this.components.get(_components_CVMeta__WEBPACK_IMPORTED_MODULE_7__["default"], true);
    }
    get model() {
        return this.components.get(_components_CVModel2__WEBPACK_IMPORTED_MODULE_8__["default"], true);
    }
    get camera() {
        return this.components.get(_components_CVCamera__WEBPACK_IMPORTED_MODULE_2__["default"], true);
    }
    get light() {
        return this.components.get(_components_CVLight__WEBPACK_IMPORTED_MODULE_3__["CLight"], true);
    }
    get scene() {
        return this.components.get(_components_CVScene__WEBPACK_IMPORTED_MODULE_9__["default"], true);
    }
    createComponents() {
        this.name = "Node";
        this.createComponent(_components_CVNode__WEBPACK_IMPORTED_MODULE_1__["default"]);
    }
    createModel() {
        this.name = "Model";
        this.createComponent(_components_CVMeta__WEBPACK_IMPORTED_MODULE_7__["default"]);
        this.createComponent(_components_CVModel2__WEBPACK_IMPORTED_MODULE_8__["default"]);
    }
    fromDocument(document, nodeIndex, pathMap) {
        const node = document.nodes[nodeIndex];
        this.transform.fromData(node);
        pathMap.set(`node/${nodeIndex}`, this.transform);
        let name = "Node";
        if (isFinite(node.meta)) {
            this.createComponent(_components_CVMeta__WEBPACK_IMPORTED_MODULE_7__["default"]).fromDocument(document, node);
            pathMap.set(`meta/${node.meta}`, this.meta);
            name = "Meta";
        }
        if (isFinite(node.model)) {
            this.createComponent(_components_CVModel2__WEBPACK_IMPORTED_MODULE_8__["default"]).fromDocument(document, node);
            pathMap.set(`model/${node.model}`, this.model);
            name = "Model";
        }
        if (isFinite(node.camera)) {
            this.createComponent(_components_CVCamera__WEBPACK_IMPORTED_MODULE_2__["default"]).fromDocument(document, node);
            pathMap.set(`camera/${node.camera}`, this.camera);
            name = "Camera";
        }
        if (isFinite(node.light)) {
            const type = document.lights[node.light].type;
            switch (type) {
                case "directional":
                    this.createComponent(_components_CVDirectionalLight__WEBPACK_IMPORTED_MODULE_4__["default"]).fromDocument(document, node);
                    name = "Directional Light";
                    break;
                case "point":
                    this.createComponent(_components_CVPointLight__WEBPACK_IMPORTED_MODULE_5__["default"]).fromDocument(document, node);
                    name = "Point Light";
                    break;
                case "spot":
                    this.createComponent(_components_CVSpotLight__WEBPACK_IMPORTED_MODULE_6__["default"]).fromDocument(document, node);
                    name = "Spot Light";
                    break;
                default:
                    throw new Error(`unknown light type: '${type}'`);
            }
            pathMap.set(`light/${node.light}`, this.light);
        }
        this.name = node.name || name;
        const childIndices = node.children;
        if (childIndices) {
            childIndices.forEach(childIndex => {
                const childNode = this.graph.createCustomNode(NVNode);
                this.transform.addChild(childNode.transform);
                childNode.fromDocument(document, childIndex, pathMap);
            });
        }
    }
    toDocument(document, pathMap, components) {
        components = components || {
            meta: true,
            setup: true,
            model: true,
            camera: true,
            light: true,
        };
        document.nodes = document.nodes || [];
        const nodeIndex = document.nodes.length;
        const node = this.transform.toData();
        document.nodes.push(node);
        pathMap.set(this.transform, `node/${nodeIndex}`);
        if (this.name) {
            node.name = this.name;
        }
        if (this.model && components.model) {
            node.model = this.model.toDocument(document, node);
            pathMap.set(this.model, `model/${node.model}`);
        }
        if (this.camera && components.camera) {
            node.camera = this.camera.toDocument(document, node);
            pathMap.set(this.camera, `camera/${node.camera}`);
        }
        if (this.light && components.light) {
            node.light = this.light.toDocument(document, node);
            pathMap.set(this.light, `light/${node.light}`);
        }
        if (this.meta && components.meta) {
            node.meta = this.meta.toDocument(document, node);
            pathMap.set(this.meta, `info/${node.meta}`);
        }
        const children = this.transform.children
            .map(child => child.node).filter(node => node.is(NVNode));
        children.forEach(child => {
            if (child.hasNodeComponents(components)) {
                const index = child.toDocument(document, pathMap, components);
                node.children = node.children || [];
                node.children.push(index);
            }
        });
        return nodeIndex;
    }
    hasNodeComponents(components) {
        if (!components) {
            return true;
        }
        const tf = this.transform;
        const comps = this.components;
        if (components.model && (comps.has(_components_CVModel2__WEBPACK_IMPORTED_MODULE_8__["default"]) || tf.hasChildComponents(_components_CVModel2__WEBPACK_IMPORTED_MODULE_8__["default"], true))) {
            return true;
        }
        if (components.camera && (comps.has(_components_CVCamera__WEBPACK_IMPORTED_MODULE_2__["default"]) || tf.hasChildComponents(_components_CVCamera__WEBPACK_IMPORTED_MODULE_2__["default"], true))) {
            return true;
        }
        if (components.light && (comps.has(_components_CVLight__WEBPACK_IMPORTED_MODULE_3__["CLight"]) || tf.hasChildComponents(_components_CVLight__WEBPACK_IMPORTED_MODULE_3__["CLight"], true))) {
            return true;
        }
        return false;
    }
}
NVNode.typeName = "NVNode";


/***/ }),

/***/ "./nodes/NVScene.ts":
/*!**************************!*\
  !*** ./nodes/NVScene.ts ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NVScene; });
/* harmony import */ var _NVNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NVNode */ "./nodes/NVNode.ts");
/* harmony import */ var _components_CVScene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/CVScene */ "./components/CVScene.ts");
/* harmony import */ var _components_CVSetup__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/CVSetup */ "./components/CVSetup.ts");
/* harmony import */ var _components_CVMeta__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/CVMeta */ "./components/CVMeta.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




////////////////////////////////////////////////////////////////////////////////
class NVScene extends _NVNode__WEBPACK_IMPORTED_MODULE_0__["default"] {
    get setup() {
        return this.components.get(_components_CVSetup__WEBPACK_IMPORTED_MODULE_2__["default"], true);
    }
    createComponents() {
        this.createComponent(_components_CVScene__WEBPACK_IMPORTED_MODULE_1__["default"]);
        this.createComponent(_components_CVSetup__WEBPACK_IMPORTED_MODULE_2__["default"]);
        this.createComponent(_components_CVMeta__WEBPACK_IMPORTED_MODULE_3__["default"]);
    }
    fromDocument(document, sceneIndex, pathMap) {
        const scene = document.scenes[sceneIndex];
        if (scene.name) {
            this.name = scene.name;
        }
        this.scene.fromDocument(document, scene);
        // serialize node tree
        const nodeIndices = scene.nodes;
        if (nodeIndices) {
            nodeIndices.forEach(nodeIndex => {
                const childNode = this.graph.createCustomNode(_NVNode__WEBPACK_IMPORTED_MODULE_0__["default"]);
                this.transform.addChild(childNode.transform);
                childNode.fromDocument(document, nodeIndex, pathMap);
            });
        }
        // serialize additional scene components
        if (isFinite(scene.meta)) {
            this.meta.fromDocument(document, scene);
            pathMap.set(`meta/${scene.meta}`, this.meta);
        }
        if (isFinite(scene.setup)) {
            this.setup.fromDocument(document, sceneIndex, pathMap);
        }
    }
    toDocument(document, pathMap, components) {
        document.scenes = document.scenes || [];
        const sceneIndex = document.scenes.length;
        const scene = { units: "cm" };
        document.scenes.push(scene);
        if (this.name) {
            scene.name = this.name;
        }
        this.scene.toDocument(document, scene);
        // serialize node tree
        const children = this.transform.children
            .map(child => child.node).filter(node => node.is(_NVNode__WEBPACK_IMPORTED_MODULE_0__["default"]));
        children.forEach(child => {
            if (child.hasNodeComponents(components)) {
                const index = child.toDocument(document, pathMap, components);
                scene.nodes = scene.nodes || [];
                scene.nodes.push(index);
            }
        });
        // serialize additional scene components
        if (!components || components.setup) {
            if (this.meta) {
                scene.meta = this.meta.toDocument(document, scene);
                pathMap.set(this.meta, `meta/${scene.meta}`);
            }
            if (this.setup) {
                this.setup.toDocument(document, sceneIndex, pathMap);
            }
        }
        return sceneIndex;
    }
}
NVScene.typeName = "NVScene";


/***/ }),

/***/ "./nodes/NVTools.ts":
/*!**************************!*\
  !*** ./nodes/NVTools.ts ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NVTools; });
/* harmony import */ var _ff_graph_Node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/graph/Node */ "../../libs/ff-graph/source/Node.ts");
/* harmony import */ var _components_CVToolProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/CVToolProvider */ "./components/CVToolProvider.ts");
/* harmony import */ var _components_CVViewTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/CVViewTool */ "./components/CVViewTool.ts");
/* harmony import */ var _components_CVRenderTool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/CVRenderTool */ "./components/CVRenderTool.ts");
/* harmony import */ var _components_CVEnvironmentTool__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/CVEnvironmentTool */ "./components/CVEnvironmentTool.ts");
/* harmony import */ var _components_CVLightTool__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/CVLightTool */ "./components/CVLightTool.ts");
/* harmony import */ var _components_CVTapeTool__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../components/CVTapeTool */ "./components/CVTapeTool.ts");
/* harmony import */ var _components_CVSliceTool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components/CVSliceTool */ "./components/CVSliceTool.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








////////////////////////////////////////////////////////////////////////////////
class NVTools extends _ff_graph_Node__WEBPACK_IMPORTED_MODULE_0__["default"] {
    get toolProvider() {
        return this.getComponent(_components_CVToolProvider__WEBPACK_IMPORTED_MODULE_1__["default"]);
    }
    createComponents() {
        this.createComponent(_components_CVToolProvider__WEBPACK_IMPORTED_MODULE_1__["default"]);
        this.createComponent(_components_CVViewTool__WEBPACK_IMPORTED_MODULE_2__["default"]);
        this.createComponent(_components_CVRenderTool__WEBPACK_IMPORTED_MODULE_3__["default"]);
        this.createComponent(_components_CVEnvironmentTool__WEBPACK_IMPORTED_MODULE_4__["default"]);
        this.createComponent(_components_CVLightTool__WEBPACK_IMPORTED_MODULE_5__["default"]);
        this.createComponent(_components_CVTapeTool__WEBPACK_IMPORTED_MODULE_6__["default"]);
        this.createComponent(_components_CVSliceTool__WEBPACK_IMPORTED_MODULE_7__["default"]);
    }
}
NVTools.typeName = "NVTools";


/***/ }),

/***/ "./schema/common.ts":
/*!**************************!*\
  !*** ./schema/common.ts ***!
  \**************************/
/*! exports provided: EUnitType, ELanguageType, ELanguageStringType, DEFAULT_LANGUAGE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EUnitType", function() { return EUnitType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ELanguageType", function() { return ELanguageType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ELanguageStringType", function() { return ELanguageStringType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_LANGUAGE", function() { return DEFAULT_LANGUAGE; });
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var EUnitType;
(function (EUnitType) {
    EUnitType[EUnitType["mm"] = 0] = "mm";
    EUnitType[EUnitType["cm"] = 1] = "cm";
    EUnitType[EUnitType["m"] = 2] = "m";
    EUnitType[EUnitType["km"] = 3] = "km";
    EUnitType[EUnitType["in"] = 4] = "in";
    EUnitType[EUnitType["ft"] = 5] = "ft";
    EUnitType[EUnitType["yd"] = 6] = "yd";
    EUnitType[EUnitType["mi"] = 7] = "mi";
})(EUnitType || (EUnitType = {}));
var ELanguageType;
(function (ELanguageType) {
    ELanguageType[ELanguageType["EN"] = 0] = "EN";
    ELanguageType[ELanguageType["ES"] = 1] = "ES";
    ELanguageType[ELanguageType["DE"] = 2] = "DE";
})(ELanguageType || (ELanguageType = {}));
var ELanguageStringType;
(function (ELanguageStringType) {
    ELanguageStringType["EN"] = "English";
    ELanguageStringType["ES"] = "Spanish (Espa\u00F1ol)";
    ELanguageStringType["DE"] = "German (Deutsche)";
})(ELanguageStringType || (ELanguageStringType = {}));
const DEFAULT_LANGUAGE = "EN";


/***/ }),

/***/ "./schema/json/common.schema.json":
/*!****************************************!*\
  !*** ./schema/json/common.schema.json ***!
  \****************************************/
/*! exports provided: $id, $schema, title, description, definitions, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"$id\":\"https://schemas.3d.si.edu/voyager/common.schema.json\",\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"Math\",\"description\":\"Definitions for mathematical compound objects such as vectors and matrices.\",\"definitions\":{\"units\":{\"$id\":\"#units\",\"type\":\"string\",\"enum\":[\"inherit\",\"mm\",\"cm\",\"m\",\"km\",\"in\",\"ft\",\"yd\",\"mi\"]},\"vector2\":{\"description\":\"2-component vector.\",\"$id\":\"#vector2\",\"type\":\"array\",\"items\":{\"type\":\"number\"},\"minItems\":2,\"maxItems\":2,\"default\":[0,0]},\"vector3\":{\"description\":\"3-component vector.\",\"$id\":\"#vector3\",\"type\":\"array\",\"items\":{\"type\":\"number\"},\"minItems\":3,\"maxItems\":3,\"default\":[0,0,0]},\"vector4\":{\"description\":\"4-component vector.\",\"$id\":\"#vector4\",\"type\":\"array\",\"items\":{\"type\":\"number\"},\"minItems\":4,\"maxItems\":4,\"default\":[0,0,0,0]},\"matrix3\":{\"description\":\"3 by 3, matrix, storage: column-major.\",\"$id\":\"#matrix3\",\"type\":\"array\",\"items\":{\"type\":\"number\"},\"minItems\":9,\"maxItems\":9,\"default\":[1,0,0,0,1,0,0,0,1]},\"matrix4\":{\"description\":\"4 by 4 matrix, storage: column-major.\",\"$id\":\"#matrix4\",\"type\":\"array\",\"items\":{\"type\":\"number\"},\"minItems\":16,\"maxItems\":16,\"default\":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},\"boundingBox\":{\"description\":\"Axis-aligned 3D bounding box.\",\"$id\":\"#boundingBox\",\"type\":\"object\",\"properties\":{\"min\":{\"$ref\":\"#/definitions/vector3\"},\"max\":{\"$ref\":\"#/definitions/vector3\"}},\"required\":[\"min\",\"max\"]}}}");

/***/ }),

/***/ "./schema/json/document.schema.json":
/*!******************************************!*\
  !*** ./schema/json/document.schema.json ***!
  \******************************************/
/*! exports provided: $id, $schema, title, description, definitions, type, properties, required, additionalProperties, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"$id\":\"https://schemas.3d.si.edu/voyager/document.schema.json\",\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"Smithsonian 3D Document\",\"description\":\"Describes a 3D document containing a scene with 3D models.\",\"definitions\":{\"scene\":{\"$id\":\"#scene\",\"type\":\"object\",\"properties\":{\"nodes\":{\"type\":\"array\",\"description\":\"The indices of the scene's root nodes.\",\"items\":{\"type\":\"integer\",\"minimum\":0},\"uniqueItems\":true,\"minItems\":1},\"setup\":{\"description\":\"The index of the scene's setup.\",\"type\":\"integer\",\"minimum\":0}}},\"node\":{\"$id\":\"#node\",\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"},\"children\":{\"type\":\"array\",\"description\":\"The indices of this node's children.\",\"items\":{\"type\":\"integer\",\"minimum\":0},\"uniqueItems\":true,\"minItems\":1},\"matrix\":{\"description\":\"A floating-point 4x4 transformation matrix stored in column-major order.\",\"type\":\"array\",\"items\":{\"type\":\"number\"},\"minItems\":16,\"maxItems\":16,\"default\":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},\"translation\":{\"description\":\"The node's translation along the x, y, and z axes.\",\"type\":\"array\",\"items\":{\"type\":\"number\"},\"minItems\":3,\"maxItems\":3,\"default\":[0,0,0]},\"rotation\":{\"description\":\"The node's unit quaternion rotation in the order (x, y, z, w), where w is the scalar.\",\"type\":\"array\",\"items\":{\"type\":\"number\",\"minimum\":-1,\"maximum\":1},\"minItems\":4,\"maxItems\":4,\"default\":[0,0,0,1]},\"scale\":{\"description\":\"The node's non-uniform scale, given as the scaling factors along the x, y, and z axes.\",\"type\":\"array\",\"items\":{\"type\":\"number\"},\"minItems\":3,\"maxItems\":3,\"default\":[1,1,1]},\"camera\":{\"description\":\"The index of the camera component of this node.\",\"type\":\"integer\",\"minimum\":0},\"light\":{\"description\":\"The index of the light component of this node.\",\"type\":\"integer\",\"minimum\":0},\"meta\":{\"description\":\"The index of the meta data component of this node.\",\"type\":\"integer\",\"minimum\":0},\"model\":{\"description\":\"The index of the model component of this node.\",\"type\":\"integer\",\"minimum\":0}},\"not\":{\"anyOf\":[{\"required\":[\"matrix\",\"translation\"]},{\"required\":[\"matrix\",\"rotation\"]},{\"required\":[\"matrix\",\"scale\"]}]}},\"camera\":{\"$id\":\"#camera\",\"type\":\"object\",\"properties\":{\"type\":{\"description\":\"Specifies if the camera uses a perspective or orthographic projection.\",\"type\":\"string\",\"enum\":[\"perspective\",\"orthographic\"]},\"perspective\":{\"description\":\"A perspective camera containing properties to create a perspective projection matrix.\",\"type\":\"object\",\"properties\":{\"yfov\":{\"type\":\"number\",\"description\":\"The floating-point vertical field of view in radians.\",\"exclusiveMinimum\":0},\"aspectRatio\":{\"type\":\"number\",\"description\":\"The floating-point aspect ratio of the field of view.\",\"exclusiveMinimum\":0},\"znear\":{\"type\":\"number\",\"description\":\"The floating-point distance to the near clipping plane.\",\"exclusiveMinimum\":0},\"zfar\":{\"type\":\"number\",\"description\":\"The floating-point distance to the far clipping plane.\",\"exclusiveMinimum\":0}},\"required\":[\"yfov\",\"znear\"]},\"orthographic\":{\"description\":\"An orthographic camera containing properties to create an orthographic projection matrix.\",\"type\":\"object\",\"properties\":{\"xmag\":{\"type\":\"number\",\"description\":\"The floating-point horizontal magnification of the view. Must not be zero.\"},\"ymag\":{\"type\":\"number\",\"description\":\"The floating-point vertical magnification of the view. Must not be zero.\"},\"znear\":{\"type\":\"number\",\"description\":\"The floating-point distance to the near clipping plane.\",\"exclusiveMinimum\":0},\"zfar\":{\"type\":\"number\",\"description\":\"The floating-point distance to the far clipping plane. `zfar` must be greater than `znear`.\",\"exclusiveMinimum\":0}},\"required\":[\"xmag\",\"ymag\",\"znear\",\"zfar\"]}},\"required\":[\"type\"],\"not\":{\"required\":[\"perspective\",\"orthographic\"]}},\"light\":{\"$id\":\"#light\",\"type\":\"object\",\"properties\":{\"type\":{\"description\":\"Specifies the type of the light source.\",\"type\":\"string\",\"enum\":[\"ambient\",\"directional\",\"point\",\"spot\",\"hemisphere\"]},\"color\":{\"$ref\":\"#/definitions/colorRGB\"},\"intensity\":{\"type\":\"number\",\"minimum\":0,\"default\":1},\"castShadow\":{\"type\":\"boolean\",\"default\":false},\"point\":{\"type\":\"object\",\"properties\":{\"distance\":{\"type\":\"number\",\"minimum\":0},\"decay\":{\"type\":\"number\",\"minimum\":0}}},\"spot\":{\"type\":\"object\",\"properties\":{\"distance\":{\"type\":\"number\",\"minimum\":0},\"decay\":{\"type\":\"number\",\"minimum\":0},\"angle\":{\"type\":\"number\",\"minimum\":0},\"penumbra\":{\"type\":\"number\",\"minimum\":0}}},\"hemisphere\":{\"type\":\"object\",\"properties\":{\"groundColor\":{\"$ref\":\"#/definitions/colorRGB\"}}}},\"required\":[\"type\"],\"not\":{\"required\":[\"point\",\"spot\",\"hemisphere\"]}},\"colorRGB\":{\"$id\":\"#colorRGB\",\"type\":\"array\",\"items\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1},\"minItems\":3,\"maxItems\":3,\"default\":[1,1,1]}},\"type\":\"object\",\"properties\":{\"asset\":{\"type\":\"object\",\"properties\":{\"type\":{\"type\":\"string\",\"const\":\"application/si-dpo-3d.document+json\"},\"version\":{\"description\":\"Version of this presentation description.\",\"type\":\"string\",\"minLength\":1},\"copyright\":{\"description\":\"A copyright message to credit the content creator.\",\"type\":\"string\",\"minLength\":1},\"generator\":{\"description\":\"Tool that generated this presentation description.\",\"type\":\"string\",\"minLength\":1}},\"required\":[\"type\",\"version\"]},\"scene\":{\"description\":\"Index of the root scene of the document.\",\"type\":\"integer\",\"minimum\":0},\"scenes\":{\"description\":\"An array of scenes.\",\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/scene\"}},\"nodes\":{\"description\":\"An array of nodes.\",\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/node\"},\"minItems\":1},\"metas\":{\"description\":\"An array of meta data components.\",\"type\":\"array\",\"items\":{\"$ref\":\"./meta.schema.json\"}},\"setups\":{\"description\":\"An array of setup components.\",\"type\":\"array\",\"items\":{\"$ref\":\"./setup.schema.json\"},\"minItems\":1},\"cameras\":{\"description\":\"An array of camera components.\",\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/camera\"},\"minItems\":1},\"lights\":{\"description\":\"An array of light components.\",\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/light\"},\"minItems\":1},\"models\":{\"description\":\"An array of model components.\",\"type\":\"array\",\"items\":{\"$ref\":\"./model.schema.json\"},\"minItems\":1}},\"required\":[\"asset\",\"scene\",\"scenes\"],\"additionalProperties\":false}");

/***/ }),

/***/ "./schema/json/meta.schema.json":
/*!**************************************!*\
  !*** ./schema/json/meta.schema.json ***!
  \**************************************/
/*! exports provided: $id, $schema, title, description, definitions, type, properties, additionalProperties, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"$id\":\"https://schemas.3d.si.edu/voyager/meta.schema.json\",\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"Meta\",\"description\":\"Meta data for a scene or model item.\",\"definitions\":{\"image\":{\"$id\":\"image\",\"description\":\"Reference to a preview image\",\"type\":\"object\",\"properties\":{\"uri\":{\"description\":\"Location of the image resource, absolute URL or path relative to this document\",\"type\":\"string\",\"minLength\":1},\"quality\":{\"type\":\"string\",\"enum\":[\"Thumb\",\"Low\",\"Medium\",\"High\"]},\"byteSize\":{\"type\":\"integer\",\"minimum\":1},\"width\":{\"type\":\"integer\",\"minimum\":1},\"height\":{\"type\":\"integer\",\"minimum\":1}},\"required\":[\"uri\",\"quality\"]},\"article\":{\"$id\":\"#article\",\"description\":\"Reference to an external document (HTML)\",\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"minLength\":1},\"title\":{\"description\":\"Short title.\",\"type\":\"string\"},\"titles\":{\"description\":\"Short title with language key.\",\"type\":\"object\"},\"lead\":{\"description\":\"Short lead text.\",\"type\":\"string\"},\"leads\":{\"description\":\"Short lead text with language key.\",\"type\":\"object\"},\"tags\":{\"description\":\"Array of tags, categorizing the article.\",\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"taglist\":{\"description\":\"Array of tags, categorizing the annotation with language key.\",\"type\":\"object\"},\"uri\":{\"description\":\"Location of the article resource, absolute URL or path relative to this document\",\"type\":\"string\",\"minLength\":1},\"uris\":{\"description\":\"Location of the article resource, absolute URL or path relative to this document with language key\",\"type\":\"object\"},\"mimeType\":{\"description\":\"MIME type of the resource.\",\"type\":\"string\"},\"thumbnailUri\":{\"description\":\"Location of a thumbnail/preview image of the resource.\",\"type\":\"string\"}},\"required\":[\"id\"],\"additionalProperties\":false}},\"type\":\"object\",\"properties\":{\"collection\":{\"description\":\"Information retrieved from the collection record for the item.\",\"type\":\"object\"},\"process\":{\"description\":\"Information about how the item was processed.\",\"type\":\"object\"},\"images\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/image\"},\"minItems\":1},\"articles\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/article\"},\"minItems\":1},\"leadArticle\":{\"description\":\"Index of the main article. This is the default article displayed with the item.\",\"type\":\"integer\",\"minimum\":0}},\"additionalProperties\":false}");

/***/ }),

/***/ "./schema/json/model.schema.json":
/*!***************************************!*\
  !*** ./schema/json/model.schema.json ***!
  \***************************************/
/*! exports provided: $id, $schema, title, description, definitions, type, properties, required, additionalProperties, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"$id\":\"https://schemas.3d.si.edu/voyager/model.schema.json\",\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"Model\",\"description\":\"Describes the visual representations (models, derivatives) of a 3D item.\",\"definitions\":{\"annotation\":{\"description\":\"Spatial annotation (hot spot, hot zone) on a model. Annotations can reference articles.\",\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"minLength\":1},\"title\":{\"type\":\"string\"},\"titles\":{\"description\":\"Short title with language key.\",\"type\":\"object\"},\"lead\":{\"type\":\"string\"},\"leads\":{\"description\":\"Short lead text with language key.\",\"type\":\"object\"},\"marker\":{\"type\":\"string\"},\"tags\":{\"description\":\"Array of tags, categorizing the annotation.\",\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"taglist\":{\"description\":\"Array of tags, categorizing the annotation with language key.\",\"type\":\"object\"},\"articleId\":{\"description\":\"Id of an article related to this annotation.\",\"type\":\"string\",\"minLength\":1},\"imageUri\":{\"description\":\"URI of an image resource for this annotation.\",\"type\":\"string\",\"minLength\":1},\"style\":{\"type\":\"string\"},\"visible\":{\"description\":\"Flag indicating whether the annotation is visible.\",\"type\":\"boolean\",\"default\":true},\"expanded\":{\"description\":\"Flag indicating whether the annotation is displayed in expanded state.\",\"type\":\"boolean\",\"default\":false},\"scale\":{\"description\":\"Scales the annotation relative to its default size.\",\"type\":\"number\",\"default\":1},\"offset\":{\"description\":\"Offsets the annotation along its direction.\",\"type\":\"number\",\"default\":0},\"tilt\":{\"description\":\"Tilt angle of the annotation relative to the direction vector in degrees.\",\"type\":\"number\",\"default\":0},\"azimuth\":{\"description\":\"Azimuth angle of a tilted annotation.\",\"type\":\"number\",\"default\":0},\"color\":{\"description\":\"Color of the annotation\",\"type\":\"array\",\"minItems\":3,\"maxItems\":3,\"items\":{\"type\":\"number\"}},\"position\":{\"description\":\"Position where the annotation is anchored, in local item coordinates.\",\"$ref\":\"./common.schema.json#/definitions/vector3\"},\"direction\":{\"description\":\"Direction of the stem of this annotation, usually corresponds to the surface normal.\",\"$ref\":\"./common.schema.json#/definitions/vector3\"},\"zoneIndex\":{\"description\":\"Index of the zone on the zone texture.\",\"type\":\"integer\",\"minimum\":0}},\"required\":[\"id\"],\"additionalProperties\":false},\"derivative\":{\"description\":\"Visual representation derived from the master model.\",\"type\":\"object\",\"properties\":{\"usage\":{\"description\":\"usage categories for a derivative.\",\"type\":\"string\",\"enum\":[\"Image2D\",\"Web3D\",\"App3D\",\"iOSApp3D\",\"Print3D\",\"Editorial3D\"]},\"quality\":{\"type\":\"string\",\"enum\":[\"Thumb\",\"Low\",\"Medium\",\"High\",\"Highest\",\"LOD\",\"Stream\",\"AR\"]},\"assets\":{\"description\":\"List of individual resources this derivative is composed of.\",\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/asset\"}}}},\"asset\":{\"description\":\"an individual resource for a 3D model.\",\"type\":\"object\",\"properties\":{\"uri\":{\"type\":\"string\",\"minLength\":1},\"type\":{\"type\":\"string\",\"enum\":[\"Model\",\"Geometry\",\"Image\",\"Texture\",\"Points\",\"Volume\"]},\"part\":{\"type\":\"string\",\"minLength\":1},\"mimeType\":{\"type\":\"string\",\"minLength\":1},\"byteSize\":{\"type\":\"integer\",\"minimum\":1},\"numFaces\":{\"type\":\"integer\",\"minimum\":1},\"imageSize\":{\"type\":\"integer\",\"minimum\":1},\"mapType\":{\"type\":\"string\",\"enum\":[\"Color\",\"Normal\",\"Occlusion\",\"Emissive\",\"MetallicRoughness\",\"Zone\"]}},\"required\":[\"uri\",\"type\"]},\"material\":{\"description\":\"Surface properties for this model, shared by all derivatives.\",\"type\":\"object\",\"properties\":{}}},\"type\":\"object\",\"properties\":{\"units\":{\"$ref\":\"./common.schema.json#/definitions/units\"},\"tags\":{\"type\":\"string\"},\"visible\":{\"type\":\"boolean\"},\"renderOrder\":{\"type\":\"number\"},\"shadowSide\":{\"type\":\"string\",\"enum\":[\"Front\",\"Back\",\"Double\"]},\"derivatives\":{\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/derivative\"}},\"translation\":{\"description\":\"Translation vector. Must be applied to bring model into its 'neutral' pose.\",\"$ref\":\"./common.schema.json#/definitions/vector3\"},\"rotation\":{\"description\":\"Rotation quaternion. Must be applied to bring model into its 'neutral' pose.\",\"$ref\":\"./common.schema.json#/definitions/vector4\"},\"boundingBox\":{\"description\":\"Bounding box for this model, shared by all derivatives.\",\"$ref\":\"./common.schema.json#/definitions/boundingBox\"},\"material\":{\"$ref\":\"#/definitions/material\"},\"annotations\":{\"description\":\"List of annotations to be displayed with the model\",\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/annotation\"}}},\"required\":[\"units\",\"derivatives\"],\"additionalProperties\":false}");

/***/ }),

/***/ "./schema/json/setup.schema.json":
/*!***************************************!*\
  !*** ./schema/json/setup.schema.json ***!
  \***************************************/
/*! exports provided: $id, $schema, title, description, definitions, type, properties, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"$id\":\"https://schemas.3d.si.edu/voyager/setup.schema.json\",\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"Setup\",\"description\":\"Tours and settings for explorer documents (background, interface, etc.)\",\"definitions\":{\"viewer\":{\"type\":\"object\",\"properties\":{\"shader\":{\"type\":\"string\"},\"exposure\":{\"type\":\"number\"},\"gamma\":{\"type\":\"number\"},\"annotationsVisible\":{\"type\":\"boolean\"},\"activeTags\":{\"type\":\"string\"},\"sortedTags\":{\"type\":\"string\"},\"radioTags\":{\"type\":\"boolean\"}},\"required\":[\"shader\",\"exposure\",\"gamma\"]},\"reader\":{\"type\":\"object\",\"properties\":{\"enabled\":{\"type\":\"boolean\"},\"position\":{\"type\":\"string\"},\"articleId\":{\"description\":\"Id of the article currently displayed in the reader.\",\"type\":\"string\",\"minLength\":1}}},\"interface\":{\"type\":\"object\",\"properties\":{\"visible\":{\"type\":\"boolean\"},\"logo\":{\"type\":\"boolean\"},\"menu\":{\"type\":\"boolean\"},\"tools\":{\"type\":\"boolean\"}}},\"navigation\":{\"type\":\"object\",\"properties\":{\"type\":{\"type\":\"string\",\"enum\":[\"Orbit\",\"Walk\"]},\"enabled\":{\"type\":\"boolean\"},\"autoZoom\":{\"type\":\"boolean\"},\"orbit\":{\"$comment\":\"TODO: Implement\",\"type\":\"object\",\"properties\":{}},\"walk\":{\"$comment\":\"TODO: Implement\",\"type\":\"object\",\"properties\":{}}}},\"background\":{\"type\":\"object\",\"properties\":{\"style\":{\"type\":\"string\",\"enum\":[\"Solid\",\"LinearGradient\",\"RadialGradient\"]},\"color0\":{\"$ref\":\"./common.schema.json#/definitions/vector3\"},\"color1\":{\"$ref\":\"./common.schema.json#/definitions/vector3\"}}},\"floor\":{\"type\":\"object\",\"properties\":{\"visible\":{\"type\":\"boolean\"},\"position\":{\"$ref\":\"./common.schema.json#/definitions/vector3\"},\"size\":{\"type\":\"number\"},\"color\":{\"$ref\":\"./common.schema.json#/definitions/vector3\"},\"opacity\":{\"type\":\"number\"},\"receiveShadow\":{\"type\":\"boolean\"}}},\"grid\":{\"type\":\"object\",\"properties\":{\"visible\":{\"type\":\"boolean\"},\"color\":{\"$ref\":\"./common.schema.json#/definitions/vector3\"}}},\"tape\":{\"type\":\"object\",\"properties\":{\"enabled\":{\"type\":\"boolean\"},\"startPosition\":{\"$ref\":\"./common.schema.json#/definitions/vector3\"},\"startDirection\":{\"$ref\":\"./common.schema.json#/definitions/vector3\"},\"endPosition\":{\"$ref\":\"./common.schema.json#/definitions/vector3\"},\"endDirection\":{\"$ref\":\"./common.schema.json#/definitions/vector3\"}}},\"slicer\":{\"type\":\"object\",\"properties\":{\"enabled\":{\"type\":\"boolean\"},\"axis\":{\"type\":\"string\",\"enum\":[\"X\",\"Y\",\"Z\"]},\"inverted\":{\"type\":\"boolean\"},\"position\":{\"type\":\"number\"}}},\"tours\":{\"description\":\"Animated tours.\",\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"title\":{\"type\":\"string\"},\"titles\":{\"description\":\"Short title with language key.\",\"type\":\"object\"},\"lead\":{\"type\":\"string\"},\"leads\":{\"description\":\"Short lead text with language key.\",\"type\":\"object\"},\"tags\":{\"description\":\"Array of tags, categorizing the tour.\",\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"taglist\":{\"description\":\"Array of tags, categorizing the annotation with language key.\",\"type\":\"object\"},\"steps\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"title\":{\"type\":\"string\"},\"titles\":{\"description\":\"Short title with language key.\",\"type\":\"object\"},\"id\":{\"type\":\"string\"}}}}}}},\"snapshots\":{\"description\":\"Snapshots are animatable scene states.\",\"type\":\"object\",\"properties\":{\"features\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"targets\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"states\":{\"type\":\"array\",\"items\":{\"type\":\"object\"}}}}},\"type\":\"object\",\"properties\":{\"units\":{\"$ref\":\"./common.schema.json#/definitions/units\"},\"interface\":{\"$ref\":\"#/definitions/interface\"},\"viewer\":{\"$ref\":\"#/definitions/viewer\"},\"reader\":{\"$ref\":\"#/definitions/reader\"},\"navigation\":{\"$ref\":\"#/definitions/navigation\"},\"background\":{\"$ref\":\"#/definitions/background\"},\"floor\":{\"$ref\":\"#/definitions/floor\"},\"grid\":{\"$ref\":\"#/definitions/grid\"},\"tape\":{\"$ref\":\"#/definitions/tape\"},\"slicer\":{\"$ref\":\"#/definitions/slicer\"},\"tours\":{\"$ref\":\"#/definitions/tours\"}}}");

/***/ }),

/***/ "./schema/model.ts":
/*!*************************!*\
  !*** ./schema/model.ts ***!
  \*************************/
/*! exports provided: EUnitType, EDerivativeUsage, EDerivativeQuality, EAssetType, EMapType, ESideType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EDerivativeUsage", function() { return EDerivativeUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EDerivativeQuality", function() { return EDerivativeQuality; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EAssetType", function() { return EAssetType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EMapType", function() { return EMapType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ESideType", function() { return ESideType; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./schema/common.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EUnitType", function() { return _common__WEBPACK_IMPORTED_MODULE_0__["EUnitType"]; });

/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

////////////////////////////////////////////////////////////////////////////////

var EDerivativeUsage;
(function (EDerivativeUsage) {
    EDerivativeUsage[EDerivativeUsage["Image2D"] = 0] = "Image2D";
    EDerivativeUsage[EDerivativeUsage["Web3D"] = 1] = "Web3D";
    EDerivativeUsage[EDerivativeUsage["App3D"] = 2] = "App3D";
    EDerivativeUsage[EDerivativeUsage["iOSApp3D"] = 3] = "iOSApp3D";
    EDerivativeUsage[EDerivativeUsage["Print3D"] = 4] = "Print3D";
    EDerivativeUsage[EDerivativeUsage["Editorial3D"] = 5] = "Editorial3D";
})(EDerivativeUsage || (EDerivativeUsage = {}));
var EDerivativeQuality;
(function (EDerivativeQuality) {
    EDerivativeQuality[EDerivativeQuality["Thumb"] = 0] = "Thumb";
    EDerivativeQuality[EDerivativeQuality["Low"] = 1] = "Low";
    EDerivativeQuality[EDerivativeQuality["Medium"] = 2] = "Medium";
    EDerivativeQuality[EDerivativeQuality["High"] = 3] = "High";
    EDerivativeQuality[EDerivativeQuality["Highest"] = 4] = "Highest";
    EDerivativeQuality[EDerivativeQuality["LOD"] = 5] = "LOD";
    EDerivativeQuality[EDerivativeQuality["Stream"] = 6] = "Stream";
    EDerivativeQuality[EDerivativeQuality["AR"] = 7] = "AR";
})(EDerivativeQuality || (EDerivativeQuality = {}));
var EAssetType;
(function (EAssetType) {
    EAssetType[EAssetType["Model"] = 0] = "Model";
    EAssetType[EAssetType["Geometry"] = 1] = "Geometry";
    EAssetType[EAssetType["Image"] = 2] = "Image";
    EAssetType[EAssetType["Texture"] = 3] = "Texture";
    EAssetType[EAssetType["Points"] = 4] = "Points";
    EAssetType[EAssetType["Volume"] = 5] = "Volume";
})(EAssetType || (EAssetType = {}));
var EMapType;
(function (EMapType) {
    EMapType[EMapType["Color"] = 0] = "Color";
    EMapType[EMapType["Emissive"] = 1] = "Emissive";
    EMapType[EMapType["Occlusion"] = 2] = "Occlusion";
    EMapType[EMapType["Normal"] = 3] = "Normal";
    EMapType[EMapType["MetallicRoughness"] = 4] = "MetallicRoughness";
    EMapType[EMapType["Zone"] = 5] = "Zone";
})(EMapType || (EMapType = {}));
var ESideType;
(function (ESideType) {
    ESideType[ESideType["Front"] = 0] = "Front";
    ESideType[ESideType["Back"] = 1] = "Back";
    ESideType[ESideType["Double"] = 2] = "Double";
})(ESideType || (ESideType = {}));


/***/ }),

/***/ "./schema/setup.ts":
/*!*************************!*\
  !*** ./schema/setup.ts ***!
  \*************************/
/*! exports provided: EShaderMode, EBackgroundStyle, ENavigationType, EReaderPosition, ESliceAxis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EShaderMode", function() { return EShaderMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EBackgroundStyle", function() { return EBackgroundStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENavigationType", function() { return ENavigationType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EReaderPosition", function() { return EReaderPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ESliceAxis", function() { return ESliceAxis; });
var EShaderMode;
(function (EShaderMode) {
    EShaderMode[EShaderMode["Default"] = 0] = "Default";
    EShaderMode[EShaderMode["Clay"] = 1] = "Clay";
    EShaderMode[EShaderMode["XRay"] = 2] = "XRay";
    EShaderMode[EShaderMode["Normals"] = 3] = "Normals";
    EShaderMode[EShaderMode["Wireframe"] = 4] = "Wireframe";
})(EShaderMode || (EShaderMode = {}));
var EBackgroundStyle;
(function (EBackgroundStyle) {
    EBackgroundStyle[EBackgroundStyle["Solid"] = 0] = "Solid";
    EBackgroundStyle[EBackgroundStyle["LinearGradient"] = 1] = "LinearGradient";
    EBackgroundStyle[EBackgroundStyle["RadialGradient"] = 2] = "RadialGradient";
})(EBackgroundStyle || (EBackgroundStyle = {}));
var ENavigationType;
(function (ENavigationType) {
    ENavigationType[ENavigationType["Orbit"] = 0] = "Orbit";
    ENavigationType[ENavigationType["Walk"] = 1] = "Walk";
})(ENavigationType || (ENavigationType = {}));
var EReaderPosition;
(function (EReaderPosition) {
    EReaderPosition[EReaderPosition["Overlay"] = 0] = "Overlay";
    EReaderPosition[EReaderPosition["Left"] = 1] = "Left";
    EReaderPosition[EReaderPosition["Right"] = 2] = "Right";
})(EReaderPosition || (EReaderPosition = {}));
var ESliceAxis;
(function (ESliceAxis) {
    ESliceAxis[ESliceAxis["X"] = 0] = "X";
    ESliceAxis[ESliceAxis["Y"] = 1] = "Y";
    ESliceAxis[ESliceAxis["Z"] = 2] = "Z";
})(ESliceAxis || (ESliceAxis = {}));


/***/ }),

/***/ "./shaders/UberPBRMaterial.ts":
/*!************************************!*\
  !*** ./shaders/UberPBRMaterial.ts ***!
  \************************************/
/*! exports provided: EShaderMode, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UberPBRMaterial; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* harmony import */ var client_schema_setup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! client/schema/setup */ "./schema/setup.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EShaderMode", function() { return client_schema_setup__WEBPACK_IMPORTED_MODULE_1__["EShaderMode"]; });

/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const fragmentShader = __webpack_require__(/*! ./uberPBRShader.frag */ "./shaders/uberPBRShader.frag").default;
const vertexShader = __webpack_require__(/*! ./uberPBRShader.vert */ "./shaders/uberPBRShader.vert").default;

////////////////////////////////////////////////////////////////////////////////

class UberPBRMaterial extends three__WEBPACK_IMPORTED_MODULE_0__["MeshStandardMaterial"] {
    constructor(params) {
        super();
        this._clayColor = new three__WEBPACK_IMPORTED_MODULE_0__["Color"]("#a67a6c");
        this._wireColor = new three__WEBPACK_IMPORTED_MODULE_0__["Color"]("#004966");
        this._wireEmissiveColor = new three__WEBPACK_IMPORTED_MODULE_0__["Color"]("#004966");
        this._objectSpaceNormalMap = false;
        this._paramCopy = {};
        this._sideCopy = three__WEBPACK_IMPORTED_MODULE_0__["FrontSide"];
        this.type = "UberPBRMaterial";
        this.isUberPBRMaterial = true;
        this.isMeshStandardMaterial = true;
        this.isMeshPhysicalMaterial = false;
        this.defines = {
            "STANDARD": true,
            "PHYSICAL": false,
            "OBJECTSPACE_NORMALMAP": false,
            "MODE_NORMALS": false,
            "MODE_XRAY": false,
            "CUT_PLANE": false,
        };
        this.uniforms = three__WEBPACK_IMPORTED_MODULE_0__["UniformsUtils"].merge([
            three__WEBPACK_IMPORTED_MODULE_0__["ShaderLib"].standard.uniforms,
            {
                aoMapMix: { value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0.25, 0.25, 0.25) },
                cutPlaneDirection: { value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector4"](0, 0, -1, 0) },
                cutPlaneColor: { value: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](1, 0, 0) },
            }
        ]);
        this._aoMapMix = this.uniforms.aoMapMix.value;
        this._cutPlaneDirection = this.uniforms.cutPlaneDirection.value;
        this._cutPlaneColor = this.uniforms.cutPlaneColor.value;
        //this.vertexShader = ShaderLib.standard.vertexShader;
        this.vertexShader = vertexShader;
        //this.fragmentShader = ShaderLib.standard.fragmentShader;
        this.fragmentShader = fragmentShader;
        this.color = new three__WEBPACK_IMPORTED_MODULE_0__["Color"](0xffffff); // diffuse
        this.roughness = 0.7;
        this.metalness = 0.0;
        if (params) {
            this.setValues(params);
        }
    }
    set cutPlaneDirection(direction) {
        this._cutPlaneDirection.copy(direction);
    }
    get cutPlaneDirection() {
        return this._cutPlaneDirection;
    }
    set cutPlaneColor(color) {
        this._cutPlaneColor.copy(color);
    }
    get cutPlaneColor() {
        return this._cutPlaneColor;
    }
    set aoMapMix(mix) {
        this._aoMapMix.copy(mix);
    }
    get aoMapMix() {
        return this._aoMapMix;
    }
    setShaderMode(mode) {
        Object.assign(this, this._paramCopy);
        this.defines["MODE_NORMALS"] = false;
        this.defines["MODE_XRAY"] = false;
        this.defines["OBJECTSPACE_NORMALMAP"] = !!(this.normalMap && this._objectSpaceNormalMap);
        this.side = this.defines["CUT_PLANE"] ? three__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"] : this.side;
        this.needsUpdate = true;
        switch (mode) {
            case client_schema_setup__WEBPACK_IMPORTED_MODULE_1__["EShaderMode"].Clay:
                this._paramCopy = {
                    color: this.color,
                    map: this.map,
                    roughness: this.roughness,
                    metalness: this.metalness,
                    aoMapIntensity: this.aoMapIntensity,
                    blending: this.blending,
                    transparent: this.transparent,
                    depthWrite: this.depthWrite,
                };
                this.color = this._clayColor;
                this.map = null;
                this.roughness = 1;
                this.metalness = 0;
                this.aoMapIntensity *= 1;
                this.blending = three__WEBPACK_IMPORTED_MODULE_0__["NoBlending"];
                this.transparent = false;
                this.depthWrite = true;
                break;
            case client_schema_setup__WEBPACK_IMPORTED_MODULE_1__["EShaderMode"].Normals:
                this._paramCopy = {
                    blending: this.blending,
                    transparent: this.transparent,
                    depthWrite: this.depthWrite,
                };
                this.defines["MODE_NORMALS"] = true;
                this.blending = three__WEBPACK_IMPORTED_MODULE_0__["NoBlending"];
                this.transparent = false;
                this.depthWrite = true;
                break;
            case client_schema_setup__WEBPACK_IMPORTED_MODULE_1__["EShaderMode"].XRay:
                this._paramCopy = {
                    side: this.side,
                    blending: this.blending,
                    transparent: this.transparent,
                    depthWrite: this.depthWrite,
                };
                this.defines["MODE_XRAY"] = true;
                this.side = three__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"];
                this.blending = three__WEBPACK_IMPORTED_MODULE_0__["AdditiveBlending"];
                this.transparent = true;
                this.depthWrite = false;
                break;
            case client_schema_setup__WEBPACK_IMPORTED_MODULE_1__["EShaderMode"].Wireframe:
                this._paramCopy = {
                    color: this.color,
                    emissive: this.emissive,
                    roughness: this.roughness,
                    metalness: this.metalness,
                    wireframe: this.wireframe,
                    map: this.map,
                    aoMap: this.aoMap,
                    emissiveMap: this.emissiveMap,
                    normalMap: this.normalMap,
                };
                this.color = this._wireColor;
                this.emissive = this._wireEmissiveColor;
                this.roughness = 0.8;
                this.metalness = 0.1;
                this.wireframe = true;
                this.map = null;
                this.aoMap = null;
                this.emissiveMap = null;
                this.normalMap = null;
                this.defines["OBJECTSPACE_NORMALMAP"] = false;
                break;
        }
    }
    enableCutPlane(enabled) {
        this.defines["CUT_PLANE"] = enabled;
        if (enabled) {
            this._sideCopy = this.side;
            this.side = three__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"];
        }
        else {
            this.side = this._sideCopy;
        }
    }
    enableObjectSpaceNormalMap(useObjectSpace) {
        if (useObjectSpace !== this._objectSpaceNormalMap) {
            this._objectSpaceNormalMap = useObjectSpace;
        }
        if (this.normalMap) {
            this.defines["OBJECTSPACE_NORMALMAP"] = useObjectSpace;
            this.needsUpdate = true;
        }
    }
    copyStandardMaterial(material) {
        this.color = material.color;
        this.opacity = material.opacity;
        this.transparent = material.opacity < 1 || !!material.alphaMap || material.transparent;
        this.alphaTest = material.alphaTest;
        this.roughness = material.roughness;
        this.roughnessMap = material.roughnessMap;
        this.metalness = material.metalness;
        this.metalnessMap = material.metalnessMap;
        this.map = material.map;
        this.aoMap = material.aoMap;
        this.aoMapIntensity = material.aoMapIntensity;
        this.normalMap = material.normalMap;
        this.shadowSide = material.shadowSide;
        //this.side = material.side;
        return this;
    }
}


/***/ }),

/***/ "./shaders/uberPBRShader.frag":
/*!************************************!*\
  !*** ./shaders/uberPBRShader.frag ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("//#define PHYSICAL\n//#define STANDARD\n\n#ifdef PHYSICAL\n    #define REFLECTIVITY\n    #define CLEARCOAT\n    #define TRANSPARENCY\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef TRANSPARENCY\n    uniform float transparency;\n#endif\n\n#ifdef REFLECTIVITY\n    uniform float reflectivity;\n#endif\n\n#ifdef CLEARCOAT\n    uniform float clearcoat;\n    uniform float clearcoatRoughness;\n#endif\n\n#ifdef USE_SHEEN\n    uniform vec3 sheen;\n#endif\n\n//#ifndef STANDARD\n//\tuniform float clearCoat;\n//\tuniform float clearCoatRoughness;\n//#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\n    #ifdef USE_TANGENT\n        varying vec3 vTangent;\n        varying vec3 vBitangent;\n    #endif\n#endif\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n\n//#include <uv_pars_fragment>\n//#include <uv2_pars_fragment>\n// REPLACED WITH\n#if defined(USE_MAP) || defined(USE_BUMPMAP) || defined(USE_NORMALMAP) || defined(USE_SPECULARMAP) || defined(USE_ALPHAMAP) || defined(USE_EMISSIVEMAP) || defined(USE_ROUGHNESSMAP) || defined(USE_METALNESSMAP) || defined(USE_LIGHTMAP) || defined(USE_AOMAP)\n\tvarying vec2 vUv;\n#endif\n\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n//#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n#ifdef USE_AOMAP\n    uniform vec3 aoMapMix;\n#endif\n\n#ifdef MODE_XRAY\n    varying float vIntensity;\n#endif\n\n#ifdef CUT_PLANE\n    varying vec3 vWorldPosition;\n    uniform vec4 cutPlaneDirection;\n    uniform vec3 cutPlaneColor;\n#endif\n\nvoid main() {\n    #ifdef CUT_PLANE\n        if (dot(vWorldPosition, cutPlaneDirection.xyz) < -cutPlaneDirection.w) {\n            discard;\n        }\n    #endif\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n\n\t#ifdef CUT_PLANE\n\t    // on the cut surface (back facing fragments revealed), replace normal with cut plane direction\n        if (!gl_FrontFacing) {\n            normal = -cutPlaneDirection.xyz;\n            diffuseColor.rgb = cutPlaneColor.rgb;\n        }\n\t#endif\n\n    #include <clearcoat_normal_fragment_begin>\n    #include <clearcoat_normal_fragment_maps>\n    #include <emissivemap_fragment>\n\n\t// accumulation\n    #if defined(USE_LIGHTMAP) || defined(USE_AOMAP)\n        vec2 vUv2 = vUv;\n    #endif\n\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t//#include <aomap_fragment>\n\t// REPLACED WITH\n\t#ifdef USE_AOMAP\n\t    // if cut plane is enabled, disable ambient occlusion on back facing fragments\n\t    #ifdef CUT_PLANE\n            if (gl_FrontFacing) {\n\t    #endif\n\n    \t// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n    \tvec3 aoSample = texture2D(aoMap, vUv).rgb;\n    \tvec3 aoFactors = mix(vec3(1.0), aoSample, clamp(aoMapMix * aoMapIntensity, 0.0, 1.0));\n    \tfloat ambientOcclusion = aoFactors.x * aoFactors.y * aoFactors.z;\n    \tfloat ambientOcclusion2 = ambientOcclusion * ambientOcclusion;\n    \treflectedLight.directDiffuse *= ambientOcclusion2;\n    \treflectedLight.directSpecular *= ambientOcclusion;\n    \t//reflectedLight.indirectDiffuse *= ambientOcclusion;\n\n    \t#if defined(USE_ENVMAP) && defined(PHYSICAL)\n    \t\tfloat dotNV = saturate(dot(geometry.normal, geometry.viewDir));\n    \t\treflectedLight.indirectSpecular *= computeSpecularOcclusion(dotNV, ambientOcclusion, material.specularRoughness);\n    \t#endif\n\n    \t#ifdef CUT_PLANE\n    \t    }\n    \t#endif\n    #endif\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n    // this is a stub for the transparency model\n    #ifdef TRANSPARENCY\n        diffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n    #endif\n\n\t#ifdef CUT_PLANE\n\tif (!gl_FrontFacing) {\n\t\toutgoingLight = cutPlaneColor.rgb;\n\t}\n\t#endif\n\n\tgl_FragColor = vec4(outgoingLight, diffuseColor.a);\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n    #ifdef MODE_NORMALS\n        gl_FragColor = vec4(vec3(normal * 0.5 + 0.5), 1.0);\n    #endif\n\n    #ifdef MODE_XRAY\n        gl_FragColor = vec4(vec3(0.4, 0.7, 1.0) * vIntensity, 1.0);\n    #endif\n}\n");

/***/ }),

/***/ "./shaders/uberPBRShader.vert":
/*!************************************!*\
  !*** ./shaders/uberPBRShader.vert ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("//#define PHYSICAL\n//#define STANDARD\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n\n#include <common>\n\n//#include <uv_pars_vertex>\n//#include <uv2_pars_vertex>\n// REPLACED WITH\n#if defined(USE_MAP) || defined(USE_BUMPMAP) || defined(USE_NORMALMAP) || defined(USE_SPECULARMAP) || defined(USE_ALPHAMAP) || defined(USE_EMISSIVEMAP) || defined(USE_ROUGHNESSMAP) || defined(USE_METALNESSMAP) || defined(USE_LIGHTMAP) || defined(USE_AOMAP)\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#ifdef MODE_XRAY\n    varying float vIntensity;\n#endif\n\n#ifdef CUT_PLANE\n    varying vec3 vWorldPosition;\n#endif\n\nvoid main() {\n\n//\t#include <uv_vertex>\n//\t#include <uv2_vertex>\n//  REPLACED WITH\n#if defined(USE_MAP) || defined(USE_BUMPMAP) || defined(USE_NORMALMAP) || defined(USE_SPECULARMAP) || defined(USE_ALPHAMAP) || defined(USE_EMISSIVEMAP) || defined(USE_ROUGHNESSMAP) || defined(USE_METALNESSMAP) || defined(USE_LIGHTMAP) || defined(USE_AOMAP)\n\tvUv = (uvTransform * vec3(uv, 1)).xy;\n#endif\n\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\tvNormal = normalize(transformedNormal);\n\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\n#ifdef MODE_XRAY\n    vIntensity = pow(abs(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0)))), 3.0);\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = -mvPosition.xyz;\n\n\t// #include <worldpos_vertex>\n\t// REPLACED WITH\n\t#if defined(USE_ENVMAP) || defined(DISTANCE) || defined(USE_SHADOWMAP) || defined(CUT_PLANE)\n    \tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n    #endif\n\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n#ifdef CUT_PLANE\n    vWorldPosition = worldPosition.xyz / worldPosition.w;\n#endif\n\n#ifdef MODE_NORMALS\n    vNormal = normal;\n#endif\n}\n");

/***/ }),

/***/ "./templates/default.svx.json":
/*!************************************!*\
  !*** ./templates/default.svx.json ***!
  \************************************/
/*! exports provided: asset, scene, scenes, nodes, setups, cameras, lights, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"asset\":{\"type\":\"application/si-dpo-3d.document+json\",\"version\":\"1.0\",\"copyright\":\"(c) Smithsonian Institution, all rights reserved\",\"generator\":\"Voyager\"},\"scene\":0,\"scenes\":[{\"nodes\":[0,1],\"setup\":0}],\"nodes\":[{\"translation\":[0,0,15],\"camera\":0},{\"name\":\"Lights\",\"children\":[2,3,4,5]},{\"translation\":[0,0,2],\"rotation\":[0.4829741,-0.1070728,0.1880998,0.8484633],\"scale\":[1,1,1],\"name\":\"Key\",\"light\":0},{\"rotation\":[0.3546969,0.163893,-0.3861077,0.8356136],\"scale\":[1,1,1],\"name\":\"Fill #1\",\"light\":1},{\"translation\":[0,0,1],\"rotation\":[0.9374013,-0.3018693,0.0532277,0.1652891],\"name\":\"Fill #2\",\"light\":2},{\"translation\":[1,0,-1],\"rotation\":[0.373256,0.6426073,-0.5786063,0.3360813],\"scale\":[1,1,1],\"name\":\"Rim\",\"light\":3}],\"setups\":[{\"units\":\"cm\",\"interface\":{\"visible\":true,\"logo\":true,\"menu\":true,\"tools\":true},\"viewer\":{\"shader\":\"Default\",\"exposure\":1,\"gamma\":2,\"annotationsVisible\":false},\"reader\":{\"enabled\":false,\"position\":\"Overlay\"},\"navigation\":{\"type\":\"Orbit\",\"enabled\":true,\"autoZoom\":true,\"lightsFollowCamera\":true,\"autoRotation\":false,\"orbit\":{\"orbit\":[-24,-26,0],\"offset\":[0,0,150],\"minOrbit\":[-90,null,null],\"maxOrbit\":[90,null,null],\"minOffset\":[null,null,0.1],\"maxOffset\":[null,null,10000]}},\"background\":{\"style\":\"RadialGradient\",\"color0\":[0.2,0.25,0.3],\"color1\":[0.01,0.03,0.05]},\"floor\":{\"visible\":false,\"position\":[0,-25,0],\"size\":50,\"color\":[0.6,0.75,0.8],\"opacity\":0.5,\"receiveShadow\":false},\"grid\":{\"visible\":false,\"color\":[0.5,0.7,0.8]},\"tape\":{\"enabled\":false,\"startPosition\":[0,0,0],\"startDirection\":[0,0,0],\"endPosition\":[0,0,0],\"endDirection\":[0,0,0]},\"slicer\":{\"enabled\":false,\"axis\":\"X\",\"inverted\":false,\"position\":0.5}}],\"cameras\":[{\"type\":\"perspective\",\"perspective\":{\"yfov\":52,\"znear\":0.1,\"zfar\":100000}}],\"lights\":[{\"color\":[1,0.95,0.9],\"intensity\":1,\"type\":\"directional\",\"shadowEnabled\":true},{\"color\":[0.9,0.95,1],\"intensity\":0.7,\"type\":\"directional\",\"shadowEnabled\":true},{\"color\":[0.8,0.85,1],\"intensity\":0.5,\"type\":\"directional\"},{\"color\":[0.85,0.9078313,1],\"intensity\":0.6,\"type\":\"directional\"}]}");

/***/ }),

/***/ "./ui/Logo.ts":
/*!********************!*\
  !*** ./ui/Logo.ts ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/ui/CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Logo_1;

////////////////////////////////////////////////////////////////////////////////
let Logo = Logo_1 = class Logo extends _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["default"] {
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-logo");
    }
    render() {
        return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<div class="sv-short">${Logo_1.sunburst}</div><div class="sv-full">${Logo_1.sunburst}${Logo_1.smithsonian}</div>`;
    }
};
Logo.sunburst = _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<div class="sv-sunburst"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 158 158"><defs><style>.si-blue{fill:#009cde;}.si-yellow{fill:#ffcd00;}</style></defs><title>si-sunburst</title><circle class="si-blue" cx="79.02" cy="79" r="79.02"/><path class="si-yellow" d="M126.69,95c-5.12-8.8-13.2-8.9-14.2-8.87v0L146.59,79l-34.1-7.1h0a27.63,27.63,0,0,1,16.93-6.32c7.5-.11,14-9.29,9.85-16.35,0,0-1.23,11.09-15.23,7.39-9.84-2.6-15.63,3-16.32,3.77h0l19.09-29.14L97.67,50.32h0a27.47,27.47,0,0,1,7.49-16.44c5.23-5.39,3.33-16.47-4.59-18.53,0,0,7,8.71-5.54,16-8.8,5.13-8.9,13.21-8.88,14.21h0L79,11.43l-7.1,34.11h0a27.53,27.53,0,0,1-6.33-16.93c-.11-7.5-9.29-14-16.35-9.86,0,0,11.09,1.24,7.39,15.23C54,43.85,59.7,49.64,60.4,50.31h0L31.24,31.22h0L46.8,55l3.54,5.39h0a27.55,27.55,0,0,1-16.45-7.5c-5.39-5.22-16.47-3.32-18.53,4.59,0,0,8.71-7,16,5.55,5.14,8.82,13.26,8.89,14.22,8.87h0L11.45,79l34.1,7.11h0a27.56,27.56,0,0,1-16.93,6.32c-7.51.12-14,9.3-9.86,16.35,0,0,1.24-11.08,15.24-7.39,9.88,2.61,15.67-3.1,16.32-3.78l0,0L31.25,126.79,60.38,107.7a27.51,27.51,0,0,1-7.5,16.44c-5.22,5.39-3.32,16.47,4.59,18.53,0,0-7-8.71,5.55-16,8.82-5.14,8.89-13.25,8.87-14.21h0L79,146.57l7.11-34.09h0a27.67,27.67,0,0,1,6.33,16.94c.11,7.5,9.29,14,16.34,9.85,0,0-11.08-1.23-7.39-15.23,2.61-9.86-3.07-15.65-3.77-16.32l0,0,29.13,19.09L116.73,111.4l-9-13.76h0a27.64,27.64,0,0,1,16.45,7.5c5.38,5.23,16.47,3.33,18.53-4.59C142.69,100.55,134,107.52,126.69,95Z"/></svg></div>`;
Logo.smithsonian = _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<div class="sv-smithsonian"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 990 158"><defs><style>.si-white{fill:#fff;}</style></defs><title>si-text-neg</title><path class="si-white" d="M67,44.45C63.37,31.73,58.2,18,40.91,18c-15.3,0-22.06,11.13-22.06,21.86,0,14.51,9.54,21.27,25.24,29.42,15.5,8,34.39,17.29,34.39,39.55,0,20.87-17.69,37.57-44.13,37.57a69.28,69.28,0,0,1-19.48-3,67.3,67.3,0,0,1-9.74-4.18C3.54,135.09,1,118-.23,108.46l5.76-1.4c3.18,12.13,12.12,32.2,32.6,32.2C53,139.26,62,129.92,62,115.41,62,100.7,51.05,93.75,36.14,85.8,23.42,79,3.34,69.1,3.34,46.64c0-19.08,15.31-35.38,41-35.38,9.14,0,17.49,2.18,25,4.57.8,7.16,1.79,14.91,3.38,27.43Z"/><path class="si-white" d="M200.32,143.44v-5.17c11.73-1.19,13.91-2,13.91-16.1V89c0-14.12-5-23.06-17.49-23.06-7.15,0-14.71,4-22.26,10.33a46.33,46.33,0,0,1,.6,8.35v38.76c0,12.52,1.79,13.72,12.72,14.91v5.17H145.26v-5.17c12.33-1.19,14.12-2.19,14.12-15.31V88.78c0-14.71-5.17-22.86-17.3-22.86-8,0-15.7,5.37-21.66,10.33V123c0,12.92,1.59,14.12,11.33,15.31v5.17H89.81v-5.17c13.12-1.19,14.9-2.39,14.9-15.31V81.82c0-12.72-.59-13.71-12.12-15.5V61.74c8.75-1.59,18.88-4.17,27.63-8.14V69.7c4.17-2.79,8.55-6.37,14.51-10.14,5.17-3.18,9.94-5.37,16.3-5.37,9.54,0,18.08,6,22.06,16.3a185.42,185.42,0,0,1,16.5-11.13c4.17-2.78,9.34-5.17,14.9-5.17,15.51,0,25.25,10.93,25.25,30.41V123c0,13.32,1.59,14.12,12.92,15.31v5.17Z"/><path class="si-white" d="M253.59,143.44v-5.17c12.52-1.19,13.91-2.39,13.91-15.9V81.42c0-12.32-.6-13.12-12.52-15.1V61.55a125.21,125.21,0,0,0,28.22-7.76v68.58c0,13.51,1.39,14.71,14.12,15.9v5.17ZM264.12,26.76a10.22,10.22,0,0,1,10.14-10.33c5.56,0,9.94,4.37,9.94,10.33A10.18,10.18,0,0,1,274.06,36.9,10.42,10.42,0,0,1,264.12,26.76Z"/><path class="si-white" d="M343.82,143.24a20.14,20.14,0,0,1-8.34,2.58c-12.53,0-19.48-7.95-19.48-23.65V64.33H302.28l-.79-2,5.36-5.76H316V42.07L328.92,29l2.78.4V56.58h22.46c1.79,2,1.19,6.36-1.19,7.75H331.7v51.08c0,16.1,6.56,19.08,11.53,19.08s9.54-2,12.32-3.38l1.79,5.17Z"/><path class="si-white" d="M420,143.44v-5.17c11.53-1.19,13.12-2.39,13.12-15.31V90c0-16.3-6.17-24.45-19.48-24.45-7.56,0-15.11,3.78-20.67,10.14V123c0,12.73,1,14.12,12.72,15.31v5.17H363.5v-5.17c11.92-1,13.71-2.19,13.71-15.31V28.15c0-12.52-.39-13.51-13.51-14.71V8.87a218.64,218.64,0,0,0,29.22-6.95V68.7c6.95-7.15,17.69-14.51,28.42-14.51,16.1,0,27.43,10.14,27.43,34V123c0,13.12,1.39,14.32,13.12,15.31v5.17Z"/><path class="si-white" d="M522.91,80c-3.78-11.73-10.74-19.68-20.48-19.68-7.55,0-12.92,6-12.92,13.72,0,8.94,8,13.51,16.9,17.29,14.91,6.16,25,13.32,25,27,0,18.09-16.89,27.43-32.79,27.43-10.14,0-19.28-3.77-22.86-6.76-1.39-2.78-3.18-16.29-3.18-23.45l5.17-1c3.57,13.11,12.52,24.64,24.45,24.64a13.86,13.86,0,0,0,14.11-13.91c0-8.75-5.77-13.52-15.7-18.09-11.93-5.56-24.85-12.12-24.85-27.43,0-13.91,11.93-25.64,30.21-25.64a46.23,46.23,0,0,1,17.69,3.38c1.59,4.57,3.78,16.3,4.38,21.27Z"/><path class="si-white" d="M633,98.52c0,32-23.45,47.3-43.13,47.3-27.23,0-43.53-21.86-43.53-43.92,0-32.8,25.44-47.71,43.53-47.71C614.54,54.19,633,73.87,633,98.52Zm-68.18-3c0,25,10.94,43.72,27.24,43.72,12.32,0,22.46-9.14,22.46-36.37,0-23.26-9.35-42.14-26.64-42.14C575.58,60.75,564.84,73.07,564.84,95.54Z"/><path class="si-white" d="M700.6,143.44v-5.17c11.73-1.19,13.12-2.78,13.12-16.5V88.58c0-13.72-4.77-22.66-18.09-22.66-8,0-15.7,5-21.66,10.14v46.71c0,13.51,1.19,14.31,12.92,15.5v5.17H643.75v-5.17c13.52-1.39,14.52-2.39,14.52-15.5V81.62c0-12.72-1.2-13.32-11.93-15.3V61.74C655.88,60,665.22,57.57,674,53.6V69.5c4-3,8.34-6,13.31-9.35,5.57-3.57,10.74-6,16.5-6,15.7,0,25.64,10.93,25.64,30.21v38.37c0,13.51,1,14.31,12.52,15.5v5.17Z"/><path class="si-white" d="M753.08,143.44v-5.17c12.52-1.19,13.91-2.39,13.91-15.9V81.42c0-12.32-.6-13.12-12.52-15.1V61.55a125.35,125.35,0,0,0,28.22-7.76v68.58c0,13.51,1.39,14.71,14.11,15.9v5.17ZM763.61,26.76a10.22,10.22,0,0,1,10.14-10.33c5.56,0,9.93,4.37,9.93,10.33A10.18,10.18,0,0,1,773.55,36.9,10.42,10.42,0,0,1,763.61,26.76Z"/><path class="si-white" d="M869.74,145.82a16.26,16.26,0,0,1-9.34-3.77,20.82,20.82,0,0,1-4.77-9c-8,5.37-17.49,12.72-23.45,12.72-14.12,0-23.85-11.72-23.85-24.25,0-9.74,5.16-15.9,16.1-19.67,11.92-4,26.43-9.35,30.8-12.92V85.4c0-14.31-6.75-22.46-16.69-22.46a11.23,11.23,0,0,0-8.95,4c-2.58,2.59-4.37,7-6,13.12a5.53,5.53,0,0,1-5.76,4.57c-3.58,0-8.75-4-8.75-8.54,0-3,2.59-5.17,6.36-8,5.57-4,18.49-11.73,29.82-13.92a25.93,25.93,0,0,1,16.3,5.37c6.95,5.76,8.94,13.91,8.94,24.25v37c0,8.94,3.58,11.92,7,11.92a15.11,15.11,0,0,0,7.15-2.18l2,5.17ZM855.23,95.73c-4.17,2.19-13.71,6.36-17.88,8.35-7.76,3.58-12.13,7.36-12.13,14.51,0,10.34,7.95,15.31,14.11,15.31,5.17-.2,12.13-3.58,15.9-7.16Z"/><path class="si-white" d="M948.66,143.44v-5.17c11.72-1.19,13.12-2.78,13.12-16.5V88.58c0-13.72-4.77-22.66-18.09-22.66-8,0-15.71,5-21.67,10.14v46.71c0,13.51,1.2,14.31,12.92,15.5v5.17H891.81v-5.17c13.52-1.39,14.51-2.39,14.51-15.5V81.62c0-12.72-1.19-13.32-11.92-15.3V61.74C903.93,60,913.28,57.57,922,53.6V69.5c4-3,8.35-6,13.32-9.35,5.56-3.57,10.73-6,16.5-6,15.7,0,25.64,10.93,25.64,30.21v38.37c0,13.51,1,14.31,12.52,15.5v5.17Z"/></svg></div>`;
Logo = Logo_1 = __decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["customElement"])("sv-logo")
], Logo);
/* harmony default export */ __webpack_exports__["default"] = (Logo);


/***/ }),

/***/ "./ui/PropertyBoolean.ts":
/*!*******************************!*\
  !*** ./ui/PropertyBoolean.ts ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/ui/CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/* harmony import */ var _ff_ui_Button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/ui/Button */ "../../libs/ff-ui/source/Button.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


////////////////////////////////////////////////////////////////////////////////
let PropertyBoolean = class PropertyBoolean extends _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.property = null;
        this.name = "";
        this.text = null;
        this.language = null;
    }
    firstConnected() {
        this.classList.add("sv-property-view", "sv-property-boolean");
    }
    update(changedProperties) {
        if (!this.property) {
            throw new Error("missing property attribute");
        }
        if (this.property.type !== "boolean") {
            throw new Error("not a boolean property");
        }
        if (changedProperties.has("property")) {
            const property = changedProperties.get("property");
            if (property) {
                property.off("value", this.onUpdate, this);
            }
            if (this.property) {
                this.property.on("value", this.onUpdate, this);
            }
        }
        super.update(changedProperties);
    }
    render() {
        const property = this.property;
        const name = this.name || property.name;
        const text = this.text;
        const language = this.language;
        let label = property.value ?
            Array.isArray(text) ? text[1] : (text || "On") :
            Array.isArray(text) ? text[0] : (text || "Off");
        return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<label class="ff-label ff-off">${name}</label>
            <ff-button .text=${language ? language.getLocalizedString(label) : label} ?selected=${property.value} @click=${this.onButtonClick}></ff-button>`;
    }
    onButtonClick(event) {
        this.property.setValue(!this.property.value);
    }
};
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ attribute: false })
], PropertyBoolean.prototype, "property", void 0);
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: String })
], PropertyBoolean.prototype, "name", void 0);
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ attribute: false })
], PropertyBoolean.prototype, "text", void 0);
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ attribute: false })
], PropertyBoolean.prototype, "language", void 0);
PropertyBoolean = __decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["customElement"])("sv-property-boolean")
], PropertyBoolean);
/* harmony default export */ __webpack_exports__["default"] = (PropertyBoolean);


/***/ }),

/***/ "./ui/PropertyColor.ts":
/*!*****************************!*\
  !*** ./ui/PropertyColor.ts ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_core_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/Color */ "../../libs/ff-core/source/Color.ts");
/* harmony import */ var _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/ui/CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/* harmony import */ var _ff_ui_Button__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/ui/Button */ "../../libs/ff-ui/source/Button.ts");
/* harmony import */ var _ff_ui_ColorEdit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ff/ui/ColorEdit */ "../../libs/ff-ui/source/ColorEdit.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




////////////////////////////////////////////////////////////////////////////////
let PropertyColor = class PropertyColor extends _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super();
        this.property = null;
        this.name = "";
        this.color = new _ff_core_Color__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.pickerActive = false;
        this.onPointerDown = this.onPointerDown.bind(this);
    }
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-property-view", "sv-property-color");
    }
    connected() {
        document.addEventListener("pointerdown", this.onPointerDown, { capture: true, passive: true });
    }
    disconnected() {
        document.removeEventListener("pointerdown", this.onPointerDown);
    }
    update(changedProperties) {
        if (!this.property) {
            throw new Error("missing property attribute");
        }
        if (this.property.type !== "number" || this.property.elementCount !== 3) {
            throw new Error(`not an color property: '${this.property.path}'`);
        }
        if (changedProperties.has("property")) {
            const property = changedProperties.get("property");
            if (property) {
                property.off("value", this.onPropertyChange, this);
            }
            if (this.property) {
                this.property.on("value", this.onPropertyChange, this);
                this.color.fromArray(this.property.value);
            }
        }
        super.update(changedProperties);
    }
    render() {
        const property = this.property;
        const name = this.name || property.name;
        const color = this.color.toString();
        return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_1__["html"] `<label class="ff-label ff-off">${name}</label>
            <ff-button style="background-color: ${color}" @click=${this.onButtonClick}></ff-button>
            ${this.pickerActive ? _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_1__["html"] `<ff-color-edit .color=${this.color} @change=${this.onColorEditChange}></ff-color-edit>` : null}`;
    }
    onButtonClick(event) {
        this.pickerActive = !this.pickerActive;
        this.requestUpdate();
    }
    onColorEditChange(event) {
        this.property.setValue(event.detail.color.toRGBArray());
    }
    onPropertyChange(value) {
        this.color.fromArray(value);
        this.requestUpdate();
    }
    // if color picker is active and user clicks outside, close picker
    onPointerDown(event) {
        if (!this.pickerActive) {
            return;
        }
        if (event.composedPath()[0] instanceof Node && this.contains(event.composedPath()[0])) {
            return;
        }
        this.pickerActive = false;
        this.requestUpdate();
    }
};
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])({ attribute: false })
], PropertyColor.prototype, "property", void 0);
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_1__["property"])({ type: String })
], PropertyColor.prototype, "name", void 0);
PropertyColor = __decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_1__["customElement"])("sv-property-color")
], PropertyColor);
/* harmony default export */ __webpack_exports__["default"] = (PropertyColor);


/***/ }),

/***/ "./ui/PropertyEvent.ts":
/*!*****************************!*\
  !*** ./ui/PropertyEvent.ts ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/ui/CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/* harmony import */ var _ff_ui_Button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/ui/Button */ "../../libs/ff-ui/source/Button.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


////////////////////////////////////////////////////////////////////////////////
let PropertyEvent = class PropertyEvent extends _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.property = null;
        this.name = "";
        this.text = "";
        this.icon = "";
    }
    firstConnected() {
        this.classList.add("sv-property-view", "sv-property-event");
    }
    update(changedProperties) {
        if (!this.property) {
            throw new Error("missing property attribute");
        }
        if (!this.property.schema.event) {
            throw new Error(`not an event property: '${this.property.path}'`);
        }
        if (changedProperties.has("property")) {
            const property = changedProperties.get("property");
            if (property) {
                property.off("value", this.onUpdate, this);
            }
            if (this.property) {
                this.property.on("value", this.onUpdate, this);
            }
        }
        super.update(changedProperties);
    }
    render() {
        const property = this.property;
        const name = this.name || property.name;
        const text = this.text;
        const icon = this.icon;
        return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<label class="ff-label ff-off">${name}</label>
            <div class="sv-options">
                <ff-button .text=${text} .icon=${icon} @click=${this.onButtonClick}></ff-button>
            </div>`;
    }
    onButtonClick(event) {
        this.property.set();
    }
};
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ attribute: false })
], PropertyEvent.prototype, "property", void 0);
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: String })
], PropertyEvent.prototype, "name", void 0);
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: String })
], PropertyEvent.prototype, "text", void 0);
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: String })
], PropertyEvent.prototype, "icon", void 0);
PropertyEvent = __decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["customElement"])("sv-property-event")
], PropertyEvent);
/* harmony default export */ __webpack_exports__["default"] = (PropertyEvent);


/***/ }),

/***/ "./ui/PropertyOptions.ts":
/*!*******************************!*\
  !*** ./ui/PropertyOptions.ts ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/ui/CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/* harmony import */ var _ff_ui_Button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/ui/Button */ "../../libs/ff-ui/source/Button.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


////////////////////////////////////////////////////////////////////////////////
let PropertyOptions = class PropertyOptions extends _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.property = null;
        this.name = "";
        this.options = null;
        this.indexMap = null;
        this.language = null;
    }
    firstConnected() {
        this.classList.add("sv-property-view", "sv-property-options");
    }
    update(changedProperties) {
        if (!this.property) {
            throw new Error("missing property attribute");
        }
        if (this.property.type !== "number" || !this.property.schema.options) {
            throw new Error("not an options property");
        }
        if (changedProperties.has("property")) {
            const property = changedProperties.get("property");
            if (property) {
                property.off("value", this.onUpdate, this);
            }
            if (this.property) {
                this.property.on("value", this.onUpdate, this);
            }
        }
        super.update(changedProperties);
    }
    render() {
        const property = this.property;
        const indexMap = this.indexMap;
        const name = this.name || property.name;
        const options = this.options || property.schema.options;
        const value = property.value;
        const language = this.language;
        let buttons;
        if (indexMap) {
            buttons = indexMap.map(index => _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<ff-button .text=${language ? language.getLocalizedString(options[index]) : options[index]} .index=${index} .selectedIndex=${value} @click=${this.onButtonClick}>
                    </ff-button>`);
        }
        else {
            buttons = options.map((option, index) => _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<ff-button .text=${language ? language.getLocalizedString(option) : option} .index=${index} .selectedIndex=${value} @click=${this.onButtonClick}>
                    </ff-button>`);
        }
        return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<label class="ff-label ff-off">${name}</label><div class="sv-options">${buttons}</div>`;
    }
    onButtonClick(event) {
        const value = event.target.index;
        this.property.setValue(value);
    }
};
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ attribute: false })
], PropertyOptions.prototype, "property", void 0);
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: String })
], PropertyOptions.prototype, "name", void 0);
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ attribute: false })
], PropertyOptions.prototype, "options", void 0);
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ attribute: false })
], PropertyOptions.prototype, "indexMap", void 0);
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ attribute: false })
], PropertyOptions.prototype, "language", void 0);
PropertyOptions = __decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["customElement"])("sv-property-options")
], PropertyOptions);
/* harmony default export */ __webpack_exports__["default"] = (PropertyOptions);


/***/ }),

/***/ "./ui/PropertySlider.ts":
/*!******************************!*\
  !*** ./ui/PropertySlider.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/ui/CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/* harmony import */ var _ff_ui_LinearSlider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/ui/LinearSlider */ "../../libs/ff-ui/source/LinearSlider.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


////////////////////////////////////////////////////////////////////////////////
let PropertySlider = class PropertySlider extends _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.property = null;
        this.name = "";
        this.min = undefined;
        this.max = undefined;
    }
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-property-view", "sv-property-slider");
    }
    update(changedProperties) {
        if (!this.property) {
            throw new Error("missing property attribute");
        }
        if (this.property.type !== "number") {
            throw new Error(`not a number property: '${this.property.path}'`);
        }
        if (changedProperties.has("property")) {
            const property = changedProperties.get("property");
            if (property) {
                property.off("value", this.onUpdate, this);
            }
            if (this.property) {
                this.property.on("value", this.onUpdate, this);
            }
        }
        super.update(changedProperties);
    }
    render() {
        const property = this.property;
        const name = this.name || property.name;
        const value = property.getValidatedValue();
        const min = isFinite(this.min) ? this.min : property.schema.min;
        const max = isFinite(this.max) ? this.max : property.schema.max;
        const v = (value - min) / (max - min);
        return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<label class="ff-label ff-off">${name}</label>
            <ff-linear-slider .value=${v} @change=${this.onSliderChange}></ff-linear-slider>`;
    }
    onSliderChange(event) {
        const property = this.property;
        const min = isFinite(this.min) ? this.min : property.schema.min;
        const max = isFinite(this.max) ? this.max : property.schema.max;
        const value = min + event.detail.value * (max - min);
        property.setValue(value);
    }
};
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ attribute: false })
], PropertySlider.prototype, "property", void 0);
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: String })
], PropertySlider.prototype, "name", void 0);
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: Number })
], PropertySlider.prototype, "min", void 0);
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: Number })
], PropertySlider.prototype, "max", void 0);
PropertySlider = __decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["customElement"])("sv-property-slider")
], PropertySlider);
/* harmony default export */ __webpack_exports__["default"] = (PropertySlider);


/***/ }),

/***/ "./ui/PropertyString.ts":
/*!******************************!*\
  !*** ./ui/PropertyString.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/ui/CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/* harmony import */ var _ff_ui_Button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/ui/Button */ "../../libs/ff-ui/source/Button.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


////////////////////////////////////////////////////////////////////////////////
let PropertyString = class PropertyString extends _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.property = null;
        this.name = "";
    }
    firstConnected() {
        this.classList.add("sv-property-view", "sv-property-string");
    }
    update(changedProperties) {
        if (!this.property) {
            throw new Error("missing property attribute");
        }
        if (this.property.type !== "string") {
            throw new Error(`not a string property: '${this.property.path}'`);
        }
        if (changedProperties.has("property")) {
            const property = changedProperties.get("property");
            if (property) {
                property.off("value", this.onUpdate, this);
            }
            if (this.property) {
                this.property.on("value", this.onUpdate, this);
            }
        }
        super.update(changedProperties);
    }
    render() {
        const property = this.property;
        const name = this.name || property.name;
        const text = property.value;
        return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<label class="ff-label ff-off">${name}</label>
            <div class="ff-string">${text}</div>`;
    }
};
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ attribute: false })
], PropertyString.prototype, "property", void 0);
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: String })
], PropertyString.prototype, "name", void 0);
PropertyString = __decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["customElement"])("sv-property-string")
], PropertyString);
/* harmony default export */ __webpack_exports__["default"] = (PropertyString);


/***/ }),

/***/ "./ui/SceneView.ts":
/*!*************************!*\
  !*** ./ui/SceneView.ts ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_browser_ManipTarget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/browser/ManipTarget */ "../../libs/ff-browser/source/ManipTarget.ts");
/* harmony import */ var _ff_scene_RenderQuadView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/scene/RenderQuadView */ "../../libs/ff-scene/source/RenderQuadView.ts");
/* harmony import */ var _ff_scene_ui_SystemView__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/scene/ui/SystemView */ "../../libs/ff-scene/source/ui/SystemView.ts");
/* harmony import */ var _ff_ui_QuadSplitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ff/ui/QuadSplitter */ "../../libs/ff-ui/source/QuadSplitter.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




////////////////////////////////////////////////////////////////////////////////
/**
 * Displays up to four viewports rendering 3D content from a node/component system.
 * The built-in quad split functionality provides four different layouts: single view, horizontal split,
 * vertical split, and quad split. The split proportions can be adjusted by moving the split handles
 * between viewports.
 */
let SceneView = class SceneView extends _ff_scene_ui_SystemView__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(system) {
        super(system);
        this.view = null;
        this.canvas = null;
        this.overlay = null;
        this.splitter = null;
        this.onResize = this.onResize.bind(this);
        this.manipTarget = new _ff_browser_ManipTarget__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.addEventListener("pointerdown", this.manipTarget.onPointerDown);
        this.addEventListener("pointermove", this.manipTarget.onPointerMove);
        this.addEventListener("pointerup", this.manipTarget.onPointerUpOrCancel);
        this.addEventListener("pointercancel", this.manipTarget.onPointerUpOrCancel);
        this.ownerDocument.addEventListener("pointermove", this.manipTarget.onPointerMove); // To catch out of frame drag releases
        this.ownerDocument.addEventListener("pointerup", this.manipTarget.onPointerUpOrCancel); // To catch out of frame drag releases
        this.ownerDocument.addEventListener("pointercancel", this.manipTarget.onPointerUpOrCancel); // To catch out of frame drag releases
        this.addEventListener("wheel", this.manipTarget.onWheel);
        this.addEventListener("contextmenu", this.manipTarget.onContextMenu);
    }
    firstConnected() {
        this.classList.add("sv-scene-view");
        // disable default touch action on mobile devices
        this.style.touchAction = "none";
        this.setAttribute("touch-action", "none");
        this.canvas = this.appendElement("canvas", {
            display: "block",
            width: "100%",
            height: "100%"
        });
        this.overlay = this.appendElement("div", {
            position: "absolute",
            top: "0", bottom: "0", left: "0", right: "0",
            overflow: "hidden"
        });
        this.overlay.classList.add("sv-content-overlay");
        this.splitter = this.appendElement(_ff_ui_QuadSplitter__WEBPACK_IMPORTED_MODULE_3__["default"], {
            position: "absolute",
            top: "0", bottom: "0", left: "0", right: "0",
            overflow: "hidden"
        });
        this.splitter.onChange = (message) => {
            this.view.horizontalSplit = message.horizontalSplit;
            this.view.verticalSplit = message.verticalSplit;
        };
        this.view = new _ff_scene_RenderQuadView__WEBPACK_IMPORTED_MODULE_1__["default"](this.system, this.canvas, this.overlay);
        this.view.on("layout", event => this.splitter.layout = event.layout);
        this.view.layout = _ff_ui_QuadSplitter__WEBPACK_IMPORTED_MODULE_3__["EQuadViewLayout"].Single;
        this.splitter.layout = _ff_ui_QuadSplitter__WEBPACK_IMPORTED_MODULE_3__["EQuadViewLayout"].Single;
        this.manipTarget.next = this.view;
    }
    connected() {
        this.view.attach();
        window.addEventListener("resize", this.onResize);
        window.dispatchEvent(new CustomEvent("resize"));
    }
    disconnected() {
        this.view.detach();
        window.removeEventListener("resize", this.onResize);
    }
    onResize() {
        this.view.resize();
    }
};
SceneView = __decorate([
    Object(_ff_scene_ui_SystemView__WEBPACK_IMPORTED_MODULE_2__["customElement"])("sv-scene-view")
], SceneView);
/* harmony default export */ __webpack_exports__["default"] = (SceneView);


/***/ }),

/***/ "./ui/Spinner.ts":
/*!***********************!*\
  !*** ./ui/Spinner.ts ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/ui/CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Spinner_1;

////////////////////////////////////////////////////////////////////////////////
let Spinner = Spinner_1 = class Spinner extends _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.visible = false;
    }
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-spinner");
    }
    render() {
        this.style.visibility = this.visible ? "visible" : "hidden";
        return Spinner_1.template;
    }
};
Spinner.template = _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<div class="sv-spinner-wheel"><svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512;" xml:space="preserve"><style type="text/css">.st0{fill:none;stroke:#009ADE;stroke-width:5;stroke-miterlimit:10;}.st1{fill:none;stroke:#FFCD00;stroke-width:5;stroke-miterlimit:10;}</style><circle class="st0" cx="256.6" cy="256" r="252"/><path class="st1" d="M408.6,307c-16.3-28-42.1-28.4-45.3-28.3c0,0,0-0.1,0-0.1L472,256l-108.7-22.6l0,0c1.1-1,22.3-19.7,54-20.2 c23.9-0.4,44.6-29.6,31.4-52.1c0,0-3.9,35.4-48.6,23.6c-31.4-8.3-49.9,9.7-52,12l0,0l60.9-93L316,164.5c0,0,0,0,0,0 c0.1-1.4,1.8-29.6,23.9-52.4c16.7-17.2,10.6-52.5-14.6-59.1c0,0,22.2,27.8-17.7,51c-28.1,16.3-28.4,42.1-28.3,45.3l-0.1,0 L256.6,40.5l-22.7,108.7c0,0,0,0,0,0c-0.9-1-19.7-22.2-20.2-54c-0.4-23.9-29.6-44.6-52.1-31.4c0,0,35.3,3.9,23.6,48.6 c-8.3,31.5,9.8,49.9,12,52.1l0,0l-93-60.9l0,0l0,0l49.6,75.7l11.3,17.2c0,0,0,0,0,0c-0.9,0-29.4-1.6-52.5-23.9 c-17.2-16.7-52.5-10.6-59.1,14.6c0,0,27.8-22.2,51,17.7c16.4,28.1,42.3,28.4,45.3,28.3c0,0,0,0,0,0L41.1,256l108.8,22.7v0 c-0.7,0.7-22,19.7-54,20.2c-23.9,0.4-44.6,29.6-31.4,52.1c0,0,3.9-35.4,48.6-23.6c31.5,8.3,50-9.9,52.1-12c0,0,0,0.1,0.1,0.1 l-60.9,92.9l92.9-60.9c0,1-1.6,29.5-23.9,52.5c-16.7,17.2-10.6,52.5,14.6,59.1c0,0-22.2-27.8,17.7-51c28.1-16.4,28.4-42.2,28.3-45.3 c0,0,0.1,0,0.1,0l22.7,108.7l22.7-108.7l0,0c0.8,0.9,19.7,22.1,20.2,54c0.4,23.9,29.6,44.6,52.1,31.4c0,0-35.3-3.9-23.6-48.5 c8.3-31.5-9.8-49.9-12-52.1c0,0,0.1,0,0.1-0.1l92.9,60.9l-32.1-49.1L348,315.4l0,0c1.3,0.1,29.6,1.7,52.4,23.9 c17.2,16.7,52.5,10.6,59.1-14.6C459.6,324.7,431.8,346.9,408.6,307z"/></svg></div>`;
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ type: Boolean })
], Spinner.prototype, "visible", void 0);
Spinner = Spinner_1 = __decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["customElement"])("sv-spinner")
], Spinner);
/* harmony default export */ __webpack_exports__["default"] = (Spinner);


/***/ }),

/***/ "./ui/explorer/ARMenu.ts":
/*!*******************************!*\
  !*** ./ui/explorer/ARMenu.ts ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_core_Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/Subscriber */ "../../libs/ff-core/source/Subscriber.ts");
/* harmony import */ var _components_CVAnalytics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/CVAnalytics */ "./components/CVAnalytics.ts");
/* harmony import */ var _components_CVARManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/CVARManager */ "./components/CVARManager.ts");
/* harmony import */ var _DocumentView__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DocumentView */ "./ui/explorer/DocumentView.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




////////////////////////////////////////////////////////////////////////////////
let ARMenu = class ARMenu extends _DocumentView__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor() {
        super(...arguments);
        this.documentProps = new _ff_core_Subscriber__WEBPACK_IMPORTED_MODULE_0__["default"]("value", this.onUpdate, this);
        this.shareButtonSelected = false;
    }
    get analytics() {
        return this.system.getMainComponent(_components_CVAnalytics__WEBPACK_IMPORTED_MODULE_1__["default"]);
    }
    get arManager() {
        return this.system.getMainComponent(_components_CVARManager__WEBPACK_IMPORTED_MODULE_2__["default"]);
    }
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-ar-menu-container");
    }
    connected() {
        super.connected();
    }
    disconnected() {
        super.disconnected();
    }
    render() {
        const document = this.activeDocument;
        if (!document) {
            return _DocumentView__WEBPACK_IMPORTED_MODULE_3__["html"] ``;
        }
        const arManager = this.arManager;
        const outs = arManager.outs;
        const setup = document.setup;
        const annotationsButtonVisible = true;
        const annotationsActive = setup.viewer.ins.annotationsVisible.value;
        return outs.isPlaced.value && outs.isPresenting.value ? _DocumentView__WEBPACK_IMPORTED_MODULE_3__["html"] `<div class="sv-ar-menu">
        ${annotationsButtonVisible ? _DocumentView__WEBPACK_IMPORTED_MODULE_3__["html"] `<ff-button icon="comment" title="Show/Hide Annotations"
            ?selected=${annotationsActive} @click=${this.onToggleAnnotations}></ff-button>` : null}
        </div>` : null;
    }
    onToggleReader() {
        const readerIns = this.activeDocument.setup.reader.ins;
        readerIns.enabled.setValue(!readerIns.enabled.value);
        this.analytics.sendProperty("Reader.Enabled", readerIns.enabled.value);
    }
    onToggleAnnotations() {
        //const toolIns = this.toolProvider.ins;
        const viewerIns = this.activeDocument.setup.viewer.ins;
        /*if (toolIns.visible.value) {
            toolIns.visible.setValue(false);
        }*/
        viewerIns.annotationsVisible.setValue(!viewerIns.annotationsVisible.value);
        this.analytics.sendProperty("Annotations.Visible", viewerIns.annotationsVisible.value);
    }
    onActiveDocument(previous, next) {
        if (previous) {
            this.documentProps.off();
            this.arManager.outs.isPlaced.off("value", this.onUpdate, this);
            this.arManager.outs.isPresenting.off("value", this.onUpdate, this);
        }
        if (next) {
            const setup = next.setup;
            this.documentProps.on(setup.viewer.ins.annotationsVisible);
            this.arManager.outs.isPlaced.on("value", this.onUpdate, this);
            this.arManager.outs.isPresenting.on("value", this.onUpdate, this);
        }
        this.requestUpdate();
    }
};
ARMenu = __decorate([
    Object(_DocumentView__WEBPACK_IMPORTED_MODULE_3__["customElement"])("sv-ar-menu")
], ARMenu);
/* harmony default export */ __webpack_exports__["default"] = (ARMenu);


/***/ }),

/***/ "./ui/explorer/ARPrompt.ts":
/*!*********************************!*\
  !*** ./ui/explorer/ARPrompt.ts ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _components_CVARManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../components/CVARManager */ "./components/CVARManager.ts");
/* harmony import */ var _DocumentView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DocumentView */ "./ui/explorer/DocumentView.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


////////////////////////////////////////////////////////////////////////////////
let ARPrompt = class ARPrompt extends _DocumentView__WEBPACK_IMPORTED_MODULE_1__["default"] {
    get arManager() {
        return this.system.getMainComponent(_components_CVARManager__WEBPACK_IMPORTED_MODULE_0__["default"]);
    }
    firstConnected() {
        super.firstConnected();
        //this.classList.add("sv-ar-prompt" /*, "sv-transition"*/);
        //setTimeout(() => this.classList.remove("sv-transition"), 1);
    }
    render() {
        const arManager = this.arManager;
        const outs = arManager.outs;
        return !outs.isPlaced.value && outs.isPresenting.value ? _DocumentView__WEBPACK_IMPORTED_MODULE_1__["html"] `<div class="sv-ar-prompt">
                <div class="sv-content">
                    <div><ff-icon class="ff-off ff-icon sv-ar-icon" name="device-move"}></ff-icon></div>
                    Move the device to place your Smithsonian object!<br><br>**BETA**
                </div>
            </div>` : null;
    }
    onActiveDocument(previous, next) {
        if (previous) {
            this.arManager.outs.isPlaced.off("value", this.onUpdate, this);
            this.arManager.outs.isPresenting.off("value", this.onUpdate, this);
        }
        if (next) {
            this.arManager.outs.isPlaced.on("value", this.onUpdate, this);
            this.arManager.outs.isPresenting.on("value", this.onUpdate, this);
        }
        this.requestUpdate();
    }
};
ARPrompt = __decorate([
    Object(_DocumentView__WEBPACK_IMPORTED_MODULE_1__["customElement"])("sv-ar-prompt-container")
], ARPrompt);
/* harmony default export */ __webpack_exports__["default"] = (ARPrompt);


/***/ }),

/***/ "./ui/explorer/ChromeView.ts":
/*!***********************************!*\
  !*** ./ui/explorer/ChromeView.ts ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_core_Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/Subscriber */ "../../libs/ff-core/source/Subscriber.ts");
/* harmony import */ var _ff_ui_ButtonGroup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/ui/ButtonGroup */ "../../libs/ff-ui/source/ButtonGroup.ts");
/* harmony import */ var _components_CVToolProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/CVToolProvider */ "./components/CVToolProvider.ts");
/* harmony import */ var _Logo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Logo */ "./ui/Logo.ts");
/* harmony import */ var _MainMenu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MainMenu */ "./ui/explorer/MainMenu.ts");
/* harmony import */ var _ToolBar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ToolBar */ "./ui/explorer/ToolBar.ts");
/* harmony import */ var _TourNavigator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TourNavigator */ "./ui/explorer/TourNavigator.ts");
/* harmony import */ var _TourMenu__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TourMenu */ "./ui/explorer/TourMenu.ts");
/* harmony import */ var _LanguageMenu__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./LanguageMenu */ "./ui/explorer/LanguageMenu.ts");
/* harmony import */ var _TagCloud__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./TagCloud */ "./ui/explorer/TagCloud.ts");
/* harmony import */ var _DocumentView__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./DocumentView */ "./ui/explorer/DocumentView.ts");
/* harmony import */ var client_components_CVInterface__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! client/components/CVInterface */ "./components/CVInterface.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};













////////////////////////////////////////////////////////////////////////////////
let ChromeView = class ChromeView extends _DocumentView__WEBPACK_IMPORTED_MODULE_10__["default"] {
    constructor() {
        super(...arguments);
        this.documentProps = new _ff_core_Subscriber__WEBPACK_IMPORTED_MODULE_0__["default"]("value", this.onUpdate, this);
    }
    get toolProvider() {
        return this.system.getMainComponent(_components_CVToolProvider__WEBPACK_IMPORTED_MODULE_2__["default"]);
    }
    firstConnected() {
        this.style.pointerEvents = "none";
        this.setAttribute("pointer-events", "none");
        this.classList.add("sv-chrome-view");
    }
    connected() {
        super.connected();
        this.toolProvider.ins.visible.on("value", this.onUpdate, this);
        this.activeDocument.setup.language.outs.language.on("value", this.onUpdate, this);
    }
    disconnected() {
        this.activeDocument.setup.language.outs.language.off("value", this.onUpdate, this);
        this.toolProvider.ins.visible.off("value", this.onUpdate, this);
        super.disconnected();
    }
    render() {
        const document = this.activeDocument;
        if (!document) {
            return _DocumentView__WEBPACK_IMPORTED_MODULE_10__["html"] ``;
        }
        const setup = document.setup;
        const interfaceVisible = setup.interface.ins.visible.value;
        const logoVisible = setup.interface.ins.logo.value && setup.interface.isShowing(client_components_CVInterface__WEBPACK_IMPORTED_MODULE_11__["EUIElements"].logo);
        const menuVisible = setup.interface.ins.menu.value && setup.interface.isShowing(client_components_CVInterface__WEBPACK_IMPORTED_MODULE_11__["EUIElements"].menu);
        const titleVisible = setup.interface.ins.visibleElements.value && setup.interface.isShowing(client_components_CVInterface__WEBPACK_IMPORTED_MODULE_11__["EUIElements"].title);
        const readerVisible = setup.reader.ins.enabled.value;
        const tours = setup.tours.tours;
        const toursEnabled = setup.tours.ins.enabled.value;
        const tourActive = setup.tours.outs.tourIndex.value >= 0;
        const language = setup.language;
        const languages = language.activeLanguages;
        const activeLanguage = language.outs.language.value;
        const languagesVisible = languages.length > 1 && setup.interface.isShowing(client_components_CVInterface__WEBPACK_IMPORTED_MODULE_11__["EUIElements"].language);
        const isEditing = !!this.system.getComponent("CVStoryApplication", true);
        const toolBarAllowed = isEditing || !toursEnabled;
        // tag cloud is visible if annotations are enabled and there is at least one tag in the cloud
        const tagCloudVisible = setup.viewer.ins.annotationsVisible.value && setup.viewer.outs.tagCloud.value;
        const toolsVisible = !readerVisible && this.toolProvider.ins.visible.value;
        if (!interfaceVisible) {
            return _DocumentView__WEBPACK_IMPORTED_MODULE_10__["html"] ``;
        }
        let title;
        if (toursEnabled) {
            if (!tourActive) {
                title = language.getLocalizedString("Interactive Tours");
            }
            else {
                title = language.getLocalizedString("Tour") + ": " + setup.tours.outs.tourTitle.value;
            }
        }
        else {
            title = document.outs.title.value || document.name || "Untitled Document";
        }
        return _DocumentView__WEBPACK_IMPORTED_MODULE_10__["html"] `
            <div class="sv-chrome-header">
                ${menuVisible ? _DocumentView__WEBPACK_IMPORTED_MODULE_10__["html"] `<sv-main-menu .system=${this.system}></sv-main-menu>` : null}
                <div class="sv-top-bar">
                    ${titleVisible ? _DocumentView__WEBPACK_IMPORTED_MODULE_10__["html"] `<div class="ff-ellipsis sv-main-title">${title}<span class="ff-ellipsis"> </span></div>` : null}
                    ${logoVisible ? _DocumentView__WEBPACK_IMPORTED_MODULE_10__["html"] `<sv-logo></sv-logo>` : null}
                </div>
            </div>
            <div class="ff-flex-spacer"></div>
            ${toursEnabled && tourActive ? _DocumentView__WEBPACK_IMPORTED_MODULE_10__["html"] `<sv-tour-navigator .system=${this.system}></sv-tour-navigator>` : null}
            ${toursEnabled && !tourActive ? _DocumentView__WEBPACK_IMPORTED_MODULE_10__["html"] `<sv-tour-menu .tours=${tours} .activeLanguage=${activeLanguage} @select=${this.onSelectTour}></sv-tour-menu>` : null}
            ${tagCloudVisible && toolBarAllowed ? _DocumentView__WEBPACK_IMPORTED_MODULE_10__["html"] `<sv-tag-cloud .system=${this.system}></sv-tag-cloud>` : null}
            ${toolsVisible && toolBarAllowed ? _DocumentView__WEBPACK_IMPORTED_MODULE_10__["html"] `<div class="sv-tool-bar-container"><sv-tool-bar .system=${this.system} @close=${this.closeTools}></sv-tool-bar></div>` : null}
            <div class="sv-chrome-footer">
                <div class="sv-bottom-bar">
                    ${languagesVisible ? _DocumentView__WEBPACK_IMPORTED_MODULE_10__["html"] `<div id="language" class="ff-ellipsis sv-language-display" @click=${this.openLanguageMenu}>${setup.language.toString()}</div>` : null}
                </div>
            </div>`;
    }
    onSelectTour(event) {
        const tours = this.activeDocument.setup.tours;
        tours.ins.tourIndex.setValue(event.detail.index);
    }
    openLanguageMenu() {
        const language = this.activeDocument.setup.language;
        if (!language.ins.enabled.value) {
            language.ins.enabled.setValue(true);
            _LanguageMenu__WEBPACK_IMPORTED_MODULE_8__["default"].show(this, this.activeDocument.setup.language).then(() => {
                language.ins.enabled.setValue(false);
            });
        }
    }
    closeTools() {
        this.toolProvider.ins.visible.setValue(false);
    }
    onActiveDocument(previous, next) {
        if (previous) {
            this.documentProps.off();
        }
        if (next) {
            const setup = next.setup;
            this.documentProps.on(next.outs.title, next.outs.assetPath, setup.interface.ins.visible, setup.interface.ins.logo, setup.interface.ins.menu, setup.viewer.ins.annotationsVisible, setup.reader.ins.enabled, setup.tours.ins.enabled, setup.tours.outs.tourIndex);
        }
        this.requestUpdate();
    }
};
ChromeView = __decorate([
    Object(_DocumentView__WEBPACK_IMPORTED_MODULE_10__["customElement"])("sv-chrome-view")
], ChromeView);
/* harmony default export */ __webpack_exports__["default"] = (ChromeView);


/***/ }),

/***/ "./ui/explorer/ContentView.ts":
/*!************************************!*\
  !*** ./ui/explorer/ContentView.ts ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_core_Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/Subscriber */ "../../libs/ff-core/source/Subscriber.ts");
/* harmony import */ var client_schema_setup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! client/schema/setup */ "./schema/setup.ts");
/* harmony import */ var _components_CVAnalytics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/CVAnalytics */ "./components/CVAnalytics.ts");
/* harmony import */ var _components_CVAssetManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/CVAssetManager */ "./components/CVAssetManager.ts");
/* harmony import */ var _SceneView__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../SceneView */ "./ui/SceneView.ts");
/* harmony import */ var _Spinner__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Spinner */ "./ui/Spinner.ts");
/* harmony import */ var _ReaderView__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ReaderView */ "./ui/explorer/ReaderView.ts");
/* harmony import */ var _DocumentView__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./DocumentView */ "./ui/explorer/DocumentView.ts");
/* harmony import */ var client_libs_ff_scene_source_components_CRenderer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! client/../../libs/ff-scene/source/components/CRenderer */ "../../libs/ff-scene/source/components/CRenderer.ts");
/* harmony import */ var _ARPrompt__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ARPrompt */ "./ui/explorer/ARPrompt.ts");
/* harmony import */ var _ARMenu__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ARMenu */ "./ui/explorer/ARMenu.ts");
/* harmony import */ var client_components_CVARManager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! client/components/CVARManager */ "./components/CVARManager.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};












////////////////////////////////////////////////////////////////////////////////
let ContentView = class ContentView extends _DocumentView__WEBPACK_IMPORTED_MODULE_7__["default"] {
    constructor() {
        super(...arguments);
        this.sceneView = null;
        this.documentProps = new _ff_core_Subscriber__WEBPACK_IMPORTED_MODULE_0__["default"]("value", this.onUpdate, this);
    }
    get analytics() {
        return this.system.getMainComponent(_components_CVAnalytics__WEBPACK_IMPORTED_MODULE_2__["default"]);
    }
    get assetManager() {
        return this.system.getMainComponent(_components_CVAssetManager__WEBPACK_IMPORTED_MODULE_3__["default"]);
    }
    get reader() {
        return this.activeDocument ? this.activeDocument.setup.reader : null;
    }
    get tours() {
        return this.activeDocument ? this.activeDocument.setup.tours : null;
    }
    get renderer() {
        return this.system.getMainComponent(client_libs_ff_scene_source_components_CRenderer__WEBPACK_IMPORTED_MODULE_8__["default"]);
    }
    get arManager() {
        return this.system.getMainComponent(client_components_CVARManager__WEBPACK_IMPORTED_MODULE_11__["default"]);
    }
    firstConnected() {
        this.classList.add("sv-content-view");
        this.sceneView = new _SceneView__WEBPACK_IMPORTED_MODULE_4__["default"](this.system);
    }
    connected() {
        super.connected();
        this.assetManager.outs.busy.on("value", this.performUpdate, this);
    }
    disconnected() {
        this.assetManager.outs.busy.off("value", this.performUpdate, this);
        super.disconnected();
    }
    render() {
        const system = this.system;
        const isLoading = this.assetManager.outs.busy.value;
        const isInitialLoad = this.assetManager.initialLoad;
        let readerVisible = false;
        let readerPosition = client_schema_setup__WEBPACK_IMPORTED_MODULE_1__["EReaderPosition"].Overlay;
        let tourMenuVisible = false;
        const reader = this.reader;
        const tours = this.tours;
        // TODO - Hack, figure out a better place for this.
        const overlayElement = this.arManager.shadowRoot.querySelector('ff-viewport-overlay');
        if (overlayElement) {
            if (this.arManager.shadowRoot.querySelector('sv-ar-prompt-container') === null) {
                overlayElement.append(new _ARPrompt__WEBPACK_IMPORTED_MODULE_9__["default"](this.system));
            }
            if (this.arManager.shadowRoot.querySelector('sv-ar-menu') === null) {
                overlayElement.append(new _ARMenu__WEBPACK_IMPORTED_MODULE_10__["default"](this.system));
            }
        }
        if (tours) {
            tourMenuVisible = tours.ins.enabled.value && tours.outs.tourIndex.value === -1;
        }
        if (reader) {
            readerVisible = !tourMenuVisible && reader.ins.enabled.value;
            readerPosition = reader.ins.position.value;
            // do not use right reader position on mobile
            if (this.mobileCheck() === true) {
                readerPosition = client_schema_setup__WEBPACK_IMPORTED_MODULE_1__["EReaderPosition"].Overlay;
            }
            /*if(document.documentElement.clientWidth < 1200) {
                readerPosition = EReaderPosition.Overlay;
            }
            else {
                readerPosition = EReaderPosition.Right;
            }*/
        }
        const sceneView = this.sceneView;
        const blurContent = (readerVisible && readerPosition === client_schema_setup__WEBPACK_IMPORTED_MODULE_1__["EReaderPosition"].Overlay) || tourMenuVisible;
        if (!blurContent) {
            sceneView.classList.remove("sv-blur");
        }
        else {
            if (!sceneView.classList.contains("sv-blur")) {
                setTimeout(() => { sceneView.classList.add("sv-blur"); this.renderer.views[0].render(); }, 1); // TODO: Extra for an apparent Android Firefox bug - remove when fixed
            }
        }
        if (!isLoading && isInitialLoad) {
            // send load timer event
            this.analytics.sendProperty("Loading.Time", this.analytics.getTimerTime() / 1000);
            this.analytics.resetTimer();
            this.assetManager.initialLoad = false;
        }
        if (readerVisible) {
            if (readerPosition === client_schema_setup__WEBPACK_IMPORTED_MODULE_1__["EReaderPosition"].Right) {
                return _DocumentView__WEBPACK_IMPORTED_MODULE_7__["html"] `<div class="ff-fullsize sv-content-split">
                    <div class="ff-splitter-section" style="flex-basis: 60%">
                        ${sceneView}
                    </div>
                    <ff-splitter direction="horizontal"></ff-splitter>
                        <div class="ff-splitter-section" style="flex-basis: 40%; max-width: 500px;">
                            <div class="sv-reader-container">
                                <sv-reader-view .system=${system} @close=${this.onReaderClose} ></sv-reader-view>
                            </div>
                        </div>
                    </div>
                    <sv-spinner ?visible=${isLoading}></sv-spinner>`;
            }
            if (readerPosition === client_schema_setup__WEBPACK_IMPORTED_MODULE_1__["EReaderPosition"].Overlay) {
                return _DocumentView__WEBPACK_IMPORTED_MODULE_7__["html"] `<div class="ff-fullsize sv-content-stack">${sceneView}
                    <div class="sv-reader-container">
                        <sv-reader-view .system=${system} @close=${this.onReaderClose}></sv-reader-view>
                    </div>
                    <sv-spinner ?visible=${isLoading}></sv-spinner></div>`;
            }
        }
        return _DocumentView__WEBPACK_IMPORTED_MODULE_7__["html"] `<div class="ff-fullsize sv-content-only">${sceneView}</div>
            <sv-spinner ?visible=${isLoading}></sv-spinner>`;
    }
    onReaderClose() {
        this.reader.ins.enabled.setValue(false);
    }
    onActiveDocument(previous, next) {
        if (previous) {
            this.documentProps.off();
        }
        if (next) {
            this.documentProps.on(next.setup.reader.ins.position, next.setup.reader.ins.enabled, next.setup.tours.outs.tourIndex);
        }
        this.requestUpdate();
    }
    // from detectmobilebrowsers.com
    mobileCheck() {
        var check = false;
        (function (a) { if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4)))
            check = true; })(navigator.userAgent || navigator.vendor);
        return check;
    }
    ;
};
ContentView = __decorate([
    Object(_DocumentView__WEBPACK_IMPORTED_MODULE_7__["customElement"])("sv-content-view")
], ContentView);
/* harmony default export */ __webpack_exports__["default"] = (ContentView);


/***/ }),

/***/ "./ui/explorer/DocumentView.ts":
/*!*************************************!*\
  !*** ./ui/explorer/DocumentView.ts ***!
  \*************************************/
/*! exports provided: customElement, property, html, TemplateResult, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DocumentView; });
/* harmony import */ var _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/ui/CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "customElement", function() { return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["customElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "property", function() { return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "html", function() { return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TemplateResult", function() { return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["TemplateResult"]; });

/* harmony import */ var _ff_scene_ui_SystemView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/scene/ui/SystemView */ "../../libs/ff-scene/source/ui/SystemView.ts");
/* harmony import */ var _components_CVDocumentProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/CVDocumentProvider */ "./components/CVDocumentProvider.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



////////////////////////////////////////////////////////////////////////////////

class DocumentView extends _ff_scene_ui_SystemView__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(...arguments);
        this.activeDocument = null;
    }
    get documentProvider() {
        return this.system.getMainComponent(_components_CVDocumentProvider__WEBPACK_IMPORTED_MODULE_2__["default"]);
    }
    connected() {
        const provider = this.documentProvider;
        provider.on("active-component", this.onActiveDocumentEvent, this);
        const document = provider.activeComponent;
        if (document) {
            this.activeDocument = document;
            this.onActiveDocument(null, document);
        }
    }
    disconnected() {
        const provider = this.documentProvider;
        provider.off("active-component", this.onActiveDocumentEvent, this);
        const document = this.activeDocument;
        if (document) {
            this.activeDocument = null;
            this.onActiveDocument(document, null);
        }
    }
    onActiveDocument(previous, next) {
    }
    onActiveDocumentEvent(event) {
        this.activeDocument = event.next;
        this.onActiveDocument(event.previous, event.next);
    }
}


/***/ }),

/***/ "./ui/explorer/LanguageMenu.ts":
/*!*************************************!*\
  !*** ./ui/explorer/LanguageMenu.ts ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_ui_Popup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/ui/Popup */ "../../libs/ff-ui/source/Popup.ts");
/* harmony import */ var _ff_ui_Button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/ui/Button */ "../../libs/ff-ui/source/Button.ts");
/* harmony import */ var _ff_ui_TextEdit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/ui/TextEdit */ "../../libs/ff-ui/source/TextEdit.ts");
/**
 * 3D Foundation Project
 * Copyright 2020 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var LanguageMenu_1;



////////////////////////////////////////////////////////////////////////////////
let LanguageMenu = LanguageMenu_1 = class LanguageMenu extends _ff_ui_Popup__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(language) {
        super();
        this.language = null;
        this.language = language;
        this.position = "center";
        this.modal = true;
        this.url = window.location.href;
    }
    static show(parent, language) {
        const menu = new LanguageMenu_1(language);
        parent.appendChild(menu);
        return new Promise((resolve, reject) => {
            menu.on("close", () => resolve());
        });
    }
    close() {
        this.dispatchEvent(new CustomEvent("close"));
        this.remove();
    }
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-language-menu");
    }
    renderEntry(language, index) {
        return _ff_ui_Popup__WEBPACK_IMPORTED_MODULE_0__["html"] `<div class="sv-entry" @click=${e => this.onClickLanguage(e, index)} ?selected=${language.name === this.language.toString()}>
            ${language.name}
        </div>`;
    }
    render() {
        const language = this.language;
        return _ff_ui_Popup__WEBPACK_IMPORTED_MODULE_0__["html"] `
        <div class="ff-flex-row">
            <div class="ff-flex-spacer ff-title">${language.getLocalizedString("Set Language")}</div>
            <ff-button icon="close" transparent class="ff-close-button" title=${language.getLocalizedString("Close")} @click=${this.close}></ff-button>
        </div>
        <div class="ff-flex-row">
            <div class="ff-scroll-y">
                ${language.activeLanguages.map((language, index) => this.renderEntry(language, index))}
            </div>
        </div>
        `;
    }
    onClickLanguage(e, index) {
        const language = this.language;
        e.stopPropagation();
        language.ins.language.setValue(language.activeLanguages[index].id);
        this.close();
    }
};
LanguageMenu = LanguageMenu_1 = __decorate([
    Object(_ff_ui_Popup__WEBPACK_IMPORTED_MODULE_0__["customElement"])("sv-language-menu")
], LanguageMenu);
/* harmony default export */ __webpack_exports__["default"] = (LanguageMenu);


/***/ }),

/***/ "./ui/explorer/MainMenu.ts":
/*!*********************************!*\
  !*** ./ui/explorer/MainMenu.ts ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_core_Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/core/Subscriber */ "../../libs/ff-core/source/Subscriber.ts");
/* harmony import */ var _ff_scene_components_CFullscreen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/scene/components/CFullscreen */ "../../libs/ff-scene/source/components/CFullscreen.ts");
/* harmony import */ var _components_CVAnalytics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/CVAnalytics */ "./components/CVAnalytics.ts");
/* harmony import */ var _components_CVToolProvider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/CVToolProvider */ "./components/CVToolProvider.ts");
/* harmony import */ var _components_CVARManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../components/CVARManager */ "./components/CVARManager.ts");
/* harmony import */ var _components_CVScene__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../components/CVScene */ "./components/CVScene.ts");
/* harmony import */ var _components_CVModel2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../components/CVModel2 */ "./components/CVModel2.ts");
/* harmony import */ var _schema_model__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../schema/model */ "./schema/model.ts");
/* harmony import */ var _DocumentView__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./DocumentView */ "./ui/explorer/DocumentView.ts");
/* harmony import */ var _ShareMenu__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ShareMenu */ "./ui/explorer/ShareMenu.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};










////////////////////////////////////////////////////////////////////////////////
let MainMenu = class MainMenu extends _DocumentView__WEBPACK_IMPORTED_MODULE_8__["default"] {
    constructor() {
        super(...arguments);
        this.documentProps = new _ff_core_Subscriber__WEBPACK_IMPORTED_MODULE_0__["default"]("value", this.onUpdate, this);
        this.shareButtonSelected = false;
    }
    get fullscreen() {
        return this.system.getMainComponent(_ff_scene_components_CFullscreen__WEBPACK_IMPORTED_MODULE_1__["default"]);
    }
    get toolProvider() {
        return this.system.getMainComponent(_components_CVToolProvider__WEBPACK_IMPORTED_MODULE_3__["default"]);
    }
    get analytics() {
        return this.system.getMainComponent(_components_CVAnalytics__WEBPACK_IMPORTED_MODULE_2__["default"]);
    }
    get arManager() {
        return this.system.getMainComponent(_components_CVARManager__WEBPACK_IMPORTED_MODULE_4__["default"]);
    }
    get sceneNode() {
        return this.system.getComponent(_components_CVScene__WEBPACK_IMPORTED_MODULE_5__["default"]);
    }
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-main-menu");
    }
    connected() {
        super.connected();
        this.fullscreen.outs.fullscreenActive.on("value", this.onUpdate, this);
        this.toolProvider.ins.visible.on("value", this.onUpdate, this);
        this.activeDocument.setup.language.outs.language.on("value", this.onUpdate, this);
    }
    disconnected() {
        this.activeDocument.setup.language.outs.language.off("value", this.onUpdate, this);
        this.toolProvider.ins.visible.off("value", this.onUpdate, this);
        this.fullscreen.outs.fullscreenActive.off("value", this.onUpdate, this);
        super.disconnected();
    }
    render() {
        const document = this.activeDocument;
        if (!document) {
            return _DocumentView__WEBPACK_IMPORTED_MODULE_8__["html"] ``;
        }
        const isEditing = !!this.system.getComponent("CVStoryApplication", true);
        const setup = document.setup;
        const tourButtonVisible = setup.tours.outs.count.value > 0;
        const toursActive = setup.tours.ins.enabled.value;
        const modeButtonsDisabled = toursActive && !isEditing;
        const readerButtonVisible = true; //setup.reader.articles.length > 0 && !isEditing;
        const readerActive = setup.reader.ins.enabled.value;
        const annotationsButtonVisible = true;
        const annotationsActive = setup.viewer.ins.annotationsVisible.value;
        const fullscreen = this.fullscreen;
        const fullscreenButtonVisible = fullscreen.outs.fullscreenAvailable.value;
        const fullscreenActive = fullscreen.outs.fullscreenActive.value;
        const toolButtonVisible = setup.interface.ins.tools.value;
        const toolsActive = this.toolProvider.ins.visible.value;
        const language = setup.language;
        // TODO - push to ARManager?
        const models = this.sceneNode.getGraphComponents(_components_CVModel2__WEBPACK_IMPORTED_MODULE_6__["default"]);
        const ARderivatives = models[0] ? models[0].derivatives.getByQuality(_schema_model__WEBPACK_IMPORTED_MODULE_7__["EDerivativeQuality"].AR) : [];
        const arButtonVisible = this.arManager.outs.available.value && ARderivatives.length > 0 && models.length >= 1;
        return _DocumentView__WEBPACK_IMPORTED_MODULE_8__["html"] `${arButtonVisible ? _DocumentView__WEBPACK_IMPORTED_MODULE_8__["html"] `<ff-button icon="ar" title=${language.getLocalizedString("Enter AR View")}
            @click=${this.onEnterAR}></ff-button>` : null}
        ${tourButtonVisible ? _DocumentView__WEBPACK_IMPORTED_MODULE_8__["html"] `<ff-button icon="globe" title=${language.getLocalizedString("Interactive Tours")}
            ?selected=${toursActive} @click=${this.onToggleTours}></ff-button>` : null}
        ${readerButtonVisible ? _DocumentView__WEBPACK_IMPORTED_MODULE_8__["html"] `<ff-button icon="article" title=${language.getLocalizedString("Read more...")}
            ?selected=${readerActive} ?disabled=${modeButtonsDisabled} @click=${this.onToggleReader}></ff-button>` : null}
        ${annotationsButtonVisible ? _DocumentView__WEBPACK_IMPORTED_MODULE_8__["html"] `<ff-button icon="comment" title=${language.getLocalizedString("Show/Hide Annotations")}
            ?selected=${annotationsActive} ?disabled=${modeButtonsDisabled} @click=${this.onToggleAnnotations}></ff-button>` : null}
        <ff-button icon="share" title=${language.getLocalizedString("Share Experience")}
            ?selected=${this.shareButtonSelected} @click=${this.onToggleShare}></ff-button>    
        ${fullscreenButtonVisible ? _DocumentView__WEBPACK_IMPORTED_MODULE_8__["html"] `<ff-button icon="expand" title=${language.getLocalizedString("Fullscreen")}
            ?selected=${fullscreenActive} @click=${this.onToggleFullscreen}></ff-button>` : null}
        ${toolButtonVisible ? _DocumentView__WEBPACK_IMPORTED_MODULE_8__["html"] `<ff-button icon="tools" title=${language.getLocalizedString("Tools and Settings")}
            ?selected=${toolsActive} ?disabled=${modeButtonsDisabled} @click=${this.onToggleTools}></ff-button>` : null}`;
    }
    onToggleReader() {
        const readerIns = this.activeDocument.setup.reader.ins;
        readerIns.enabled.setValue(!readerIns.enabled.value);
        this.analytics.sendProperty("Reader.Enabled", readerIns.enabled.value);
    }
    onToggleTours() {
        const tourIns = this.activeDocument.setup.tours.ins;
        const readerIns = this.activeDocument.setup.reader.ins;
        if (tourIns.enabled.value) {
            tourIns.enabled.setValue(false);
        }
        else {
            if (readerIns.enabled.value) {
                readerIns.enabled.setValue(false); // disable reader
            }
            tourIns.enabled.setValue(true); // enable tours
            tourIns.tourIndex.setValue(-1); // show tour menu
        }
        this.analytics.sendProperty("Tours.Enabled", tourIns.enabled.value);
    }
    onToggleAnnotations() {
        const toolIns = this.toolProvider.ins;
        const viewerIns = this.activeDocument.setup.viewer.ins;
        if (toolIns.visible.value) {
            toolIns.visible.setValue(false);
        }
        viewerIns.annotationsVisible.setValue(!viewerIns.annotationsVisible.value);
        this.analytics.sendProperty("Annotations.Visible", viewerIns.annotationsVisible.value);
    }
    onToggleShare() {
        if (!this.shareButtonSelected) {
            this.shareButtonSelected = true;
            this.requestUpdate();
            _ShareMenu__WEBPACK_IMPORTED_MODULE_9__["default"].show(this, this.activeDocument.setup.language).then(() => {
                this.shareButtonSelected = false;
                this.requestUpdate();
            });
            this.analytics.sendProperty("Menu.Share");
        }
    }
    onToggleFullscreen() {
        this.fullscreen.toggle();
        this.analytics.sendProperty("Menu.Fullscreen");
    }
    onToggleTools() {
        const toolIns = this.toolProvider.ins;
        const viewerIns = this.activeDocument.setup.viewer.ins;
        if (viewerIns.annotationsVisible.value) {
            viewerIns.annotationsVisible.setValue(false);
        }
        toolIns.visible.setValue(!toolIns.visible.value);
        this.analytics.sendProperty("Tools.Visible", toolIns.visible.value);
    }
    onEnterAR() {
        const arIns = this.arManager.ins;
        arIns.enabled.setValue(true);
    }
    onActiveDocument(previous, next) {
        if (previous) {
            this.documentProps.off();
        }
        if (next) {
            const setup = next.setup;
            this.documentProps.on(setup.interface.ins.tools, setup.reader.ins.enabled, setup.tours.ins.enabled, setup.tours.outs.count, setup.viewer.ins.annotationsVisible, this.toolProvider.ins.visible);
        }
        this.requestUpdate();
    }
};
MainMenu = __decorate([
    Object(_DocumentView__WEBPACK_IMPORTED_MODULE_8__["customElement"])("sv-main-menu")
], MainMenu);
/* harmony default export */ __webpack_exports__["default"] = (MainMenu);


/***/ }),

/***/ "./ui/explorer/MainView.ts":
/*!*********************************!*\
  !*** ./ui/explorer/MainView.ts ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_scene_components_CFullscreen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/scene/components/CFullscreen */ "../../libs/ff-scene/source/components/CFullscreen.ts");
/* harmony import */ var client_components_CVARManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! client/components/CVARManager */ "./components/CVARManager.ts");
/* harmony import */ var _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/ui/CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/* harmony import */ var _ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ff/ui/Icon */ "../../libs/ff-ui/source/Icon.ts");
/* harmony import */ var _ff_ui_Notification__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ff/ui/Notification */ "../../libs/ff-ui/source/Notification.ts");
/* harmony import */ var _applications_ExplorerApplication__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../applications/ExplorerApplication */ "./applications/ExplorerApplication.ts");
/* harmony import */ var _ContentView__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ContentView */ "./ui/explorer/ContentView.ts");
/* harmony import */ var _ChromeView__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ChromeView */ "./ui/explorer/ChromeView.ts");
/* harmony import */ var _styles_scss__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./styles.scss */ "./ui/explorer/styles.scss");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};









////////////////////////////////////////////////////////////////////////////////
// EXPLORER ICONS
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("globe", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path d="M336.5 160C322 70.7 287.8 8 248 8s-74 62.7-88.5 152h177zM152 256c0 22.2 1.2 43.5 3.3 64h185.3c2.1-20.5 3.3-41.8 3.3-64s-1.2-43.5-3.3-64H155.3c-2.1 20.5-3.3 41.8-3.3 64zm324.7-96c-28.6-67.9-86.5-120.4-158-141.6 24.4 33.8 41.2 84.7 50 141.6h108zM177.2 18.4C105.8 39.6 47.8 92.1 19.3 160h108c8.7-56.9 25.5-107.8 49.9-141.6zM487.4 192H372.7c2.1 21 3.3 42.5 3.3 64s-1.2 43-3.3 64h114.6c5.5-20.5 8.6-41.8 8.6-64s-3.1-43.5-8.5-64zM120 256c0-21.5 1.2-43 3.3-64H8.6C3.2 212.5 0 233.8 0 256s3.2 43.5 8.6 64h114.6c-2-21-3.2-42.5-3.2-64zm39.5 96c14.5 89.3 48.7 152 88.5 152s74-62.7 88.5-152h-177zm159.3 141.6c71.4-21.2 129.4-73.7 158-141.6h-108c-8.8 56.9-25.6 107.8-50 141.6zM19.3 352c28.6 67.9 86.5 120.4 158 141.6-24.4-33.8-41.2-84.7-50-141.6h-108z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("cog", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M444.788 291.1l42.616 24.599c4.867 2.809 7.126 8.618 5.459 13.985-11.07 35.642-29.97 67.842-54.689 94.586a12.016 12.016 0 0 1-14.832 2.254l-42.584-24.595a191.577 191.577 0 0 1-60.759 35.13v49.182a12.01 12.01 0 0 1-9.377 11.718c-34.956 7.85-72.499 8.256-109.219.007-5.49-1.233-9.403-6.096-9.403-11.723v-49.184a191.555 191.555 0 0 1-60.759-35.13l-42.584 24.595a12.016 12.016 0 0 1-14.832-2.254c-24.718-26.744-43.619-58.944-54.689-94.586-1.667-5.366.592-11.175 5.459-13.985L67.212 291.1a193.48 193.48 0 0 1 0-70.199l-42.616-24.599c-4.867-2.809-7.126-8.618-5.459-13.985 11.07-35.642 29.97-67.842 54.689-94.586a12.016 12.016 0 0 1 14.832-2.254l42.584 24.595a191.577 191.577 0 0 1 60.759-35.13V25.759a12.01 12.01 0 0 1 9.377-11.718c34.956-7.85 72.499-8.256 109.219-.007 5.49 1.233 9.403 6.096 9.403 11.723v49.184a191.555 191.555 0 0 1 60.759 35.13l42.584-24.595a12.016 12.016 0 0 1 14.832 2.254c24.718 26.744 43.619 58.944 54.689 94.586 1.667 5.366-.592 11.175-5.459 13.985L444.788 220.9a193.485 193.485 0 0 1 0 70.2zM336 256c0-44.112-35.888-80-80-80s-80 35.888-80 80 35.888 80 80 80 80-35.888 80-80z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("eye", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M569.354 231.631C512.969 135.949 407.81 72 288 72 168.14 72 63.004 135.994 6.646 231.631a47.999 47.999 0 0 0 0 48.739C63.031 376.051 168.19 440 288 440c119.86 0 224.996-63.994 281.354-159.631a47.997 47.997 0 0 0 0-48.738zM288 392c-75.162 0-136-60.827-136-136 0-75.162 60.826-136 136-136 75.162 0 136 60.826 136 136 0 75.162-60.826 136-136 136zm104-136c0 57.438-46.562 104-104 104s-104-46.562-104-104c0-17.708 4.431-34.379 12.236-48.973l-.001.032c0 23.651 19.173 42.823 42.824 42.823s42.824-19.173 42.824-42.823c0-23.651-19.173-42.824-42.824-42.824l-.032.001C253.621 156.431 270.292 152 288 152c57.438 0 104 46.562 104 104z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("palette", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M128 224c-17.7 0-32 14.3-32 32s14.3 32 32 32 32-14.3 32-32-14.4-32-32-32zM418.6 58.1C359.2 9.3 281.3-10 204.6 5 104.9 24.4 24.7 104.2 5.1 203.7c-16.7 84.2 8.1 168.3 67.8 230.6 47.3 49.4 109.7 77.8 167.9 77.8 8.8 0 17.5-.6 26.1-2 24.2-3.7 44.6-18.7 56.1-41.1 12.3-24 12.3-52.7.2-76.6-6.1-12-5.5-26.2 1.8-38 7-11.8 18.7-18.4 32-18.4h72.2c46.4 0 82.8-35.7 82.8-81.3-.2-76.4-34.3-148.1-93.4-196.6zM429.2 288H357c-29.9 0-57.2 15.4-73 41.3-16 26.1-17.3 57.8-3.6 84.9 5.1 10.1 5.1 22.7-.2 32.9-2.6 5-8.7 13.7-20.6 15.6-49.3 7.7-108.9-16.6-152-61.6-48.8-50.9-69-119.4-55.4-188 15.9-80.6 80.8-145.3 161.6-161 62.6-12.3 126.1 3.5 174.3 43.1 48.1 39.5 75.7 97.6 75.9 159.6 0 18.6-15.3 33.2-34.8 33.2zM160 128c-17.7 0-32 14.3-32 32s14.3 32 32 32 32-14.3 32-32-14.4-32-32-32zm96-32.1c-17.7 0-32 14.3-32 32s14.3 32 32 32 32-14.3 32-32c0-17.6-14.3-32-32-32zm96 32.1c-17.7 0-32 14.3-32 32s14.3 32 32 32 32-14.3 32-32-14.3-32-32-32z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("comment", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M256 32C114.6 32 0 125.1 0 240c0 49.6 21.4 95 57 130.7C44.5 421.1 2.7 466 2.2 466.5c-2.2 2.3-2.8 5.7-1.5 8.7S4.8 480 8 480c66.3 0 116-31.8 140.6-51.4 32.7 12.3 69 19.4 107.4 19.4 141.4 0 256-93.1 256-208S397.4 32 256 32z"/></svg>`);
//Icon.add("information", html`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path d="M84.06,204.23h24.07V138.77H93.06A9.06,9.06,0,0,1,84,129.71V108.06A9.06,9.06,0,0,1,93.06,99h56.75a9.07,9.07,0,0,1,9.07,9.06v96.17h24.06a9.06,9.06,0,0,1,9.06,9.06v21.65a9.06,9.06,0,0,1-9.06,9.06H84.06A9.06,9.06,0,0,1,75,234.94V213.29A9.06,9.06,0,0,1,84.06,204.23ZM133.5,12a32.63,32.63,0,1,0,32.63,32.63A32.62,32.62,0,0,0,133.5,12Z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("article", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path d="M224 136V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H248c-13.2 0-24-10.8-24-24zm64 236c0 6.6-5.4 12-12 12H108c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h168c6.6 0 12 5.4 12 12v8zm0-64c0 6.6-5.4 12-12 12H108c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h168c6.6 0 12 5.4 12 12v8zm0-72v8c0 6.6-5.4 12-12 12H108c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h168c6.6 0 12 5.4 12 12zm96-114.1v6.1H256V0h6.1c6.4 0 12.5 2.5 17 7l97.9 98c4.5 4.5 7 10.6 7 16.9z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("document", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path d="M288 248v28c0 6.6-5.4 12-12 12H108c-6.6 0-12-5.4-12-12v-28c0-6.6 5.4-12 12-12h168c6.6 0 12 5.4 12 12zm-12 72H108c-6.6 0-12 5.4-12 12v28c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-28c0-6.6-5.4-12-12-12zm108-188.1V464c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V48C0 21.5 21.5 0 48 0h204.1C264.8 0 277 5.1 286 14.1L369.9 98c9 8.9 14.1 21.2 14.1 33.9zm-128-80V128h76.1L256 51.9zM336 464V176H232c-13.3 0-24-10.7-24-24V48H48v416h288z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("share", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M352 320c-22.608 0-43.387 7.819-59.79 20.895l-102.486-64.054a96.551 96.551 0 0 0 0-41.683l102.486-64.054C308.613 184.181 329.392 192 352 192c53.019 0 96-42.981 96-96S405.019 0 352 0s-96 42.981-96 96c0 7.158.79 14.13 2.276 20.841L155.79 180.895C139.387 167.819 118.608 160 96 160c-53.019 0-96 42.981-96 96s42.981 96 96 96c22.608 0 43.387-7.819 59.79-20.895l102.486 64.054A96.301 96.301 0 0 0 256 416c0 53.019 42.981 96 96 96s96-42.981 96-96-42.981-96-96-96z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("expand", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path d="M241,29V141.53a14,14,0,0,1-14,14h-18.7a14,14,0,0,1-14-14V61.74H114.45a14,14,0,0,1-14-14L100.3,29a14,14,0,0,1,14-14H226.89A14,14,0,0,1,241,29Z"/><path class="cls-1" d="M15,226.67V114.11a14,14,0,0,1,14-14h18.7a14,14,0,0,1,14,14V193.9h79.79a14,14,0,0,1,14,14l.12,18.74a14,14,0,0,1-14,14H29.07A14,14,0,0,1,15,226.67Z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("zoom", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M0 180V56c0-13.3 10.7-24 24-24h124c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H64v84c0 6.6-5.4 12-12 12H12c-6.6 0-12-5.4-12-12zM288 44v40c0 6.6 5.4 12 12 12h84v84c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12V56c0-13.3-10.7-24-24-24H300c-6.6 0-12 5.4-12 12zm148 276h-40c-6.6 0-12 5.4-12 12v84h-84c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h124c13.3 0 24-10.7 24-24V332c0-6.6-5.4-12-12-12zM160 468v-40c0-6.6-5.4-12-12-12H64v-84c0-6.6-5.4-12-12-12H12c-6.6 0-12 5.4-12 12v124c0 13.3 10.7 24 24 24h124c6.6 0 12-5.4 12-12z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("tools", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M501.1 395.7L384 278.6c-23.1-23.1-57.6-27.6-85.4-13.9L192 158.1V96L64 0 0 64l96 128h62.1l106.6 106.6c-13.6 27.8-9.2 62.3 13.9 85.4l117.1 117.1c14.6 14.6 38.2 14.6 52.7 0l52.7-52.7c14.5-14.6 14.5-38.2 0-52.7zM331.7 225c28.3 0 54.9 11 74.9 31l19.4 19.4c15.8-6.9 30.8-16.5 43.8-29.5 37.1-37.1 49.7-89.3 37.9-136.7-2.2-9-13.5-12.1-20.1-5.5l-74.4 74.4-67.9-11.3L334 98.9l74.4-74.4c6.6-6.6 3.4-17.9-5.7-20.2-47.4-11.7-99.6.9-136.6 37.9-28.5 28.5-41.9 66.1-41.2 103.6l82.1 82.1c8.1-1.9 16.5-2.9 24.7-2.9zm-103.9 82l-56.7-56.7L18.7 402.8c-25 25-25 65.5 0 90.5s65.5 25 90.5 0l123.6-123.6c-7.6-19.9-9.9-41.6-5-62.7zM64 472c-13.2 0-24-10.8-24-24 0-13.3 10.7-24 24-24s24 10.7 24 24c0 13.2-10.7 24-24 24z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("environment", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path d="M219.81,14.75H36.19A21.19,21.19,0,0,0,15,35.94V220.06a21.19,21.19,0,0,0,21.19,21.19H219.81A21.19,21.19,0,0,0,241,220.06V35.94A21.19,21.19,0,0,0,219.81,14.75Zm-2.65,205.31H38.84a2.64,2.64,0,0,1-2.65-2.65V38.59a2.64,2.64,0,0,1,2.65-2.65H217.16a2.64,2.64,0,0,1,2.65,2.65V217.41A2.64,2.64,0,0,1,217.16,220.06ZM72.16,71.59A18.32,18.32,0,1,0,90.47,89.91,18.32,18.32,0,0,0,72.16,71.59ZM57.51,198.15H204V141.53l-40.06-40.06a5.49,5.49,0,0,0-7.77,0l-54.72,54.71L83.36,138.09a5.47,5.47,0,0,0-7.76,0L57.51,156.18Z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("bulb", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><path d="M44.73 323.21c-7.65 4.42-10.28 14.2-5.86 21.86l8 13.86c4.42 7.65 14.21 10.28 21.86 5.86l93.26-53.84a207.865 207.865 0 0 1-26.83-39.93l-90.43 52.19zM112.46 168H16c-8.84 0-16 7.16-16 16v16c0 8.84 7.16 16 16 16h100.21a210.423 210.423 0 0 1-3.75-48zm127.6 291.17c0 3.15.93 6.22 2.68 8.84l24.51 36.84c2.97 4.46 7.97 7.14 13.32 7.14h78.85c5.36 0 10.36-2.68 13.32-7.14l24.51-36.84c1.74-2.62 2.67-5.7 2.68-8.84l.05-43.18H240.02l.04 43.18zM44.73 60.78l78.98 45.6c5.37-15.29 12.97-29.48 21.64-42.93L68.73 19.21c-7.65-4.42-17.44-1.8-21.86 5.86l-8 13.86c-4.42 7.65-1.79 17.44 5.86 21.85zm550.54 0c7.65-4.42 10.28-14.2 5.86-21.86l-8-13.86c-4.42-7.65-14.21-10.28-21.86-5.86l-76.61 44.23c8.68 13.41 15.76 27.9 21.2 43.19l79.41-45.84zm0 262.43l-90.97-52.52c-7.33 14.23-15.8 27.88-26.36 40.21l93.33 53.88c7.65 4.42 17.44 1.8 21.86-5.86l8-13.86c4.42-7.64 1.79-17.43-5.86-21.85zM624 168h-96.41c.1 2.68.41 5.3.41 8 0 13.54-1.55 26.89-4.12 40H624c8.84 0 16-7.16 16-16v-16c0-8.84-7.16-16-16-16zM320 80c-52.94 0-96 43.06-96 96 0 8.84 7.16 16 16 16s16-7.16 16-16c0-35.3 28.72-64 64-64 8.84 0 16-7.16 16-16s-7.16-16-16-16zm0-80C217.72 0 144 82.97 144 176c0 44.37 16.45 84.85 43.56 115.78 16.64 18.99 42.74 58.8 52.42 92.16v.06h48v-.12c-.01-4.77-.72-9.51-2.15-14.07-5.59-17.81-22.82-64.77-62.17-109.67-20.53-23.43-31.52-53.14-31.61-84.14-.2-73.64 59.67-128 127.95-128 70.58 0 128 57.42 128 128 0 30.97-11.24 60.85-31.65 84.14-39.11 44.61-56.42 91.47-62.1 109.46a47.507 47.507 0 0 0-2.22 14.3v.1h48v-.05c9.68-33.37 35.78-73.18 52.42-92.16C479.55 260.85 496 220.37 496 176 496 78.8 417.2 0 320 0z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("tape", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><path d="M624 432H362.3c52.1-41 85.7-104.5 85.7-176 0-123.7-100.3-224-224-224S0 132.3 0 256s100.3 224 224 224h400c8.8 0 16-7.2 16-16v-16c0-8.8-7.2-16-16-16zm-400 0c-97 0-176-79-176-176S127 80 224 80s176 79 176 176-79 176-176 176zm0-272c-53 0-96 43-96 96s43 96 96 96 96-43 96-96-43-96-96-96zm0 144c-26.5 0-48-21.5-48-48s21.5-48 48-48 48 21.5 48 48-21.5 48-48 48z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("knife", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M566.28 88.57c12.96-12.5 12.96-32.76 0-45.25L531.07 9.37c-12.96-12.5-33.98-12.5-46.94 0L319.99 160 4.76 464.14c-8.25 7.96-5.38 22.16 5.53 25.69C53.72 503.86 102.37 512 150.51 512c75.83 0 150.42-20.19 201.49-69.35l104.4-100.04c12.95-12.41 13.17-33.05.49-45.73L448 288v-80L566.28 88.57zM496 64c8.84 0 16 7.16 16 16s-7.16 16-16 16-16-7.16-16-16 7.16-16 16-16zM318.71 408.07C281.24 444.14 221.5 464 150.51 464c-23.16 0-46.79-2.1-70.07-6.17L319.4 227.28l91.99 91.99-92.68 88.8zM432 160c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.17 16-16 16z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("bars", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("triangle-left", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path d="M191.33,31.38V224.62a15,15,0,0,1-25.64,10.62L69.07,138.62a15,15,0,0,1,0-21.24l96.62-96.62A15,15,0,0,1,191.33,31.38Z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("triangle-right", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path d="M64.67,224.62V31.38A15,15,0,0,1,90.31,20.76l96.62,96.62a15,15,0,0,1,0,21.24L90.31,235.24A15,15,0,0,1,64.67,224.62Z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("twitter", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("facebook", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 264 512"><path d="M76.7 512V283H0v-91h76.7v-71.7C76.7 42.4 124.3 0 193.8 0c33.3 0 61.9 2.5 70.2 3.6V85h-48.2c-37.8 0-45.1 18-45.1 44.3V192H256l-11.7 91h-73.6v229"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("instagram", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("linkedin", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448.1 512"><path d="M100.3 448H7.4V148.9h92.9V448zM53.8 108.1C24.1 108.1 0 83.5 0 53.8S24.1 0 53.8 0s53.8 24.1 53.8 53.8-24.1 54.3-53.8 54.3zM448 448h-92.7V302.4c0-34.7-.7-79.2-48.3-79.2-48.3 0-55.7 37.7-55.7 76.7V448h-92.8V148.9h89.1v40.8h1.3c12.4-23.5 42.7-48.3 87.9-48.3 94 0 111.3 61.9 111.3 142.3V448h-.1z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("email", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M464 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm0 48v40.805c-22.422 18.259-58.168 46.651-134.587 106.49-16.841 13.247-50.201 45.072-73.413 44.701-23.208.375-56.579-31.459-73.413-44.701C106.18 199.465 70.425 171.067 48 152.805V112h416zM48 400V214.398c22.914 18.251 55.409 43.862 104.938 82.646 21.857 17.205 60.134 55.186 103.062 54.955 42.717.231 80.509-37.199 103.053-54.947 49.528-38.783 82.032-64.401 104.947-82.653V400H48z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("copy", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("ar", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10.844874 7.2009368"><path d="M 4.1805699,5.4542117 H 2.4801904 L 2.2118585,6.5168507 H 1.1187593 L 2.6807334,0.68408928 h 1.296469 L 5.5391781,6.5168507 H 4.4460774 Z M 2.7513476,4.3720517 H 3.9065883 L 3.3303802,2.0514503 Z"/><path d="m 7.5355365,3.2703464 q 0.3417706,0 0.4886463,-0.1758024 0.1497018,-0.1758024 0.1497018,-0.5781942 0,-0.3984876 -0.1497018,-0.5703858 Q 7.8773071,1.7740658 7.5355365,1.7740658 H 7.0779585 V 3.2703464 Z M 7.0779585,4.309544 V 6.5168507 H 5.9905084 V 0.68408928 h 1.6608338 q 0.8332429,0 1.220205,0.38676692 0.3897887,0.3867669 0.3897887,1.2228084 0,0.5781942 -0.2033672,0.9493362 -0.200543,0.371142 -0.607278,0.5469444 0.2231388,0.070308 0.3982608,0.320355 0.1779472,0.2461266 0.358719,0.7500924 L 9.7980008,6.5168507 H 8.6399351 L 8.1258661,5.0674448 Q 7.970517,4.6298909 7.8095182,4.4697134 7.6513422,4.309544 7.3858347,4.309544 Z"/></svg>`);
_ff_ui_Icon__WEBPACK_IMPORTED_MODULE_3__["default"].add("device-move", _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["html"] `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 119.4 57.7"><path d="M47.4,20.7h-34c-0.2,0-0.4-0.1-0.5-0.3l-0.1-0.2l0.1-0.3l9-19.5C21.9,0.2,22.1,0,22.3,0h24.5v1H22.6L14,19.7h33.4V20.7z"/><path d="M103,20.7H71v-1h31.6L95,1H46.8V0h48.3c0.3,0,0.6,0.2,0.7,0.5l7.8,19.2c0.1,0.2,0.1,0.5-0.1,0.7C103.5,20.6,103.2,20.7,103,20.7z M94.9,0.9L94.9,0.9z"/><path d="M49,2.9c-1.1,0-2,0.9-2,2v40c0,1.1,0.9,2,2,2h20c1.1,0,2-0.9,2-2v-40c0-1.1-0.9-2-2-2L49,2.9z M49,3.9h3.6l0,0h0l0,0l0,0l0,0l0,0l0,0v0l0,0l0,0l0,0l0,0v0.5c0,0.6,0.4,1,1,1H64c0.6,0,1-0.4,1-1v0l0,0V4.3c0,0,0,0,0-0.1l0,0l0,0l0,0l0,0l0,0l0,0l0,0l0,0l0,0l0,0l0,0h4c0.6,0,1,0.4,1,1v40c0,0.6-0.4,1-1,1H49c-0.6,0-1-0.4-1-1l0-40.2c0.1-0.5,0-0.8,0.4-1.1C48.5,4,48.8,3.9,49,3.9z"/><path d="M53.3,43.9h11.5c0.3,0,0.6,0.2,0.6,0.5c0,0.3-0.3,0.5-0.6,0.5H53.3c-0.3,0-0.6-0.2-0.6-0.5C52.7,44.1,53,43.8,53.3,43.9z"/><path d="M76,37.8c-0.7,0-1.3,0-2-0.1l0.1-1c1.6,0.2,10,0.7,15.7-5.5c1.8-2,3.1-4.4,3.8-7l1,0.3c-0.7,2.8-2.1,5.3-4,7.5C85.8,37,79.3,37.8,76,37.8z"/><polygon points="96.9,28.6 96,29 93.8,24.6 89.5,27.1 89,26.2 94.3,23.2"/><path d="M42.1,37.4c-3.4,0-9.9-0.8-14.5-6c-1.9-2.1-3.3-4.7-4-7.5l1-0.3c0.7,2.6,1.9,5,3.7,7.1c5.6,6.3,14,5.7,15.7,5.5l0.1,1C43.4,37.4,42.8,37.4,42.1,37.4z"/><polygon points="29,25.8 28.5,26.6 24.3,24.2 22.1,28.6 21.2,28.2 23.8,22.8"/></svg>`);
//Icon.add("name", html``);
////////////////////////////////////////////////////////////////////////////////
/**
 * Main UI view for the Voyager Explorer application.
 */
let MainView = class MainView extends _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(application) {
        super();
        this.application = null;
        if (application) {
            this.application = application;
        }
    }
    get fullscreen() {
        return this.application.system.getMainComponent(_ff_scene_components_CFullscreen__WEBPACK_IMPORTED_MODULE_0__["default"]);
    }
    get arManager() {
        return this.application.system.getMainComponent(client_components_CVARManager__WEBPACK_IMPORTED_MODULE_1__["default"]);
    }
    firstConnected() {
        super.firstConnected();
        if (!this.application) {
            const props = {
                root: this.getAttribute("root"),
                dracoRoot: this.getAttribute("dracoRoot"),
                resourceRoot: this.getAttribute("resourceRoot"),
                document: this.getAttribute("document"),
                model: this.getAttribute("model"),
                geometry: this.getAttribute("geometry"),
                texture: this.getAttribute("texture"),
                quality: this.getAttribute("quality"),
                uiMode: this.getAttribute("uiMode")
            };
            this.application = new _applications_ExplorerApplication__WEBPACK_IMPORTED_MODULE_5__["default"](null, props);
        }
        this.attachShadow({ mode: 'open' });
        const shadowRoot = this.shadowRoot;
        this.arManager.shadowRoot = shadowRoot;
        // add style
        var styleElement = document.createElement("style");
        styleElement.innerText = _styles_scss__WEBPACK_IMPORTED_MODULE_8__["default"];
        shadowRoot.appendChild(styleElement);
        const system = this.application.system;
        shadowRoot.appendChild(new _ContentView__WEBPACK_IMPORTED_MODULE_6__["default"](system));
        shadowRoot.appendChild(new _ChromeView__WEBPACK_IMPORTED_MODULE_7__["default"](system));
        const notifications = document.createElement("div");
        notifications.setAttribute("id", _ff_ui_Notification__WEBPACK_IMPORTED_MODULE_4__["default"].stackId);
        shadowRoot.appendChild(notifications);
        _ff_ui_Notification__WEBPACK_IMPORTED_MODULE_4__["default"].shadowRootNode = shadowRoot;
    }
    connected() {
        this.fullscreen.fullscreenElement = this;
    }
    disconnected() {
        this.fullscreen.fullscreenElement = null;
    }
    //** Pass-through for API functions so they can be called from the main component element */
    toggleAnnotations() {
        if (this.application) {
            this.application.toggleAnnotations();
        }
    }
    toggleReader() {
        if (this.application) {
            this.application.toggleReader();
        }
    }
    toggleTours() {
        if (this.application) {
            this.application.toggleTours();
        }
    }
    toggleTools() {
        if (this.application) {
            this.application.toggleTools();
        }
    }
    enableAR() {
        if (this.application) {
            this.application.enableAR();
        }
    }
    getArticles() {
        if (this.application) {
            const articles = this.application.getArticles();
            return articles;
        }
    }
    getCameraOrbit() {
        if (this.application) {
            const orbit = this.application.getCameraOrbit();
            return orbit;
        }
    }
    setCameraOrbit(yaw, pitch) {
        if (this.application) {
            this.application.setCameraOrbit(yaw, pitch);
        }
    }
    setBackgroundColor(color0, color1) {
        if (this.application) {
            this.application.setBackgroundColor(color0, color1 ? color1 : null);
        }
    }
    setBackgroundStyle(style) {
        if (this.application) {
            this.application.setBackgroundStyle(style);
        }
    }
};
MainView = __decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_2__["customElement"])("voyager-explorer")
], MainView);
/* harmony default export */ __webpack_exports__["default"] = (MainView);


/***/ }),

/***/ "./ui/explorer/NodeView.ts":
/*!*********************************!*\
  !*** ./ui/explorer/NodeView.ts ***!
  \*********************************/
/*! exports provided: customElement, property, html, TemplateResult, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NodeView; });
/* harmony import */ var _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/ui/CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "customElement", function() { return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["customElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "property", function() { return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "html", function() { return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TemplateResult", function() { return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["TemplateResult"]; });

/* harmony import */ var _components_CVNodeProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/CVNodeProvider */ "./components/CVNodeProvider.ts");
/* harmony import */ var _DocumentView__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DocumentView */ "./ui/explorer/DocumentView.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



////////////////////////////////////////////////////////////////////////////////

class NodeView extends _DocumentView__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super(...arguments);
        this.activeNode = null;
    }
    get nodeProvider() {
        return this.system.getMainComponent(_components_CVNodeProvider__WEBPACK_IMPORTED_MODULE_1__["default"]);
    }
    connected() {
        super.connected();
        const provider = this.nodeProvider;
        provider.on("active-node", this.onActiveNodeEvent, this);
        if (provider.activeNode) {
            this.activeNode = provider.activeNode;
            this.onActiveNode(null, provider.activeNode);
        }
    }
    disconnected() {
        const provider = this.nodeProvider;
        provider.off("active-node", this.onActiveNodeEvent, this);
        if (provider.activeNode) {
            this.activeNode = null;
            this.onActiveNode(provider.activeNode, null);
        }
        super.disconnected();
    }
    onActiveNode(previous, next) {
        this.requestUpdate();
    }
    onActiveNodeEvent(event) {
        this.activeNode = event.next;
        this.onActiveNode(event.previous, event.next);
    }
}


/***/ }),

/***/ "./ui/explorer/ReaderView.ts":
/*!***********************************!*\
  !*** ./ui/explorer/ReaderView.ts ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_ui_Button__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/ui/Button */ "../../libs/ff-ui/source/Button.ts");
/* harmony import */ var _DocumentView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DocumentView */ "./ui/explorer/DocumentView.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


////////////////////////////////////////////////////////////////////////////////
let ReaderView = class ReaderView extends _DocumentView__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(...arguments);
        this.reader = null;
        this.language = null;
    }
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-reader-view");
    }
    renderMenuEntry(entry) {
        const article = entry.article;
        return _DocumentView__WEBPACK_IMPORTED_MODULE_1__["html"] `<div class="sv-entry" @click=${e => this.onClickArticle(e, article.id)}>
            <h1>${article.title}</h1>
            <p>${article.lead}</p>
        </div>`;
    }
    render() {
        const reader = this.reader;
        const language = this.language;
        if (!reader) {
            return _DocumentView__WEBPACK_IMPORTED_MODULE_1__["html"] `<div class="ff-placeholder">Please select a document to display its articles.</div>`;
        }
        if (!reader.activeArticle) {
            const articles = reader.articles;
            return _DocumentView__WEBPACK_IMPORTED_MODULE_1__["html"] `<div class="sv-left"></div><div class="sv-article">
                <ff-button class="sv-nav-button" inline title=${language.getLocalizedString("Close Article Reader")} icon="close" @click=${this.onClickClose}></ff-button>
                ${articles.map(entry => this.renderMenuEntry(entry))}
            </div><div class="sv-right"></div>`;
        }
        return _DocumentView__WEBPACK_IMPORTED_MODULE_1__["html"] `<div class="sv-left"></div><div class="sv-article">
                <ff-button class="sv-nav-button" inline title=${language.getLocalizedString("Close Article Reader")} icon="close" @click=${this.onClickClose}></ff-button>
                <ff-button class="sv-nav-button" inline title=${language.getLocalizedString("Article Menu")} icon="bars" @click=${this.onClickMenu}></ff-button>
                <div class="sv-container"></div>
            </div><div class="sv-right"></div>`;
    }
    onClickMenu(event) {
        event.stopPropagation();
        this.reader.ins.articleId.setValue("");
    }
    onClickClose(event) {
        event.stopPropagation();
        this.dispatchEvent(new CustomEvent("close"));
    }
    onClickArticle(e, articleId) {
        this.reader.ins.articleId.setValue(articleId);
    }
    updated(changedProperties) {
        super.updated(changedProperties);
        const reader = this.reader;
        if (reader && reader.activeArticle) {
            const container = this.getElementsByClassName("sv-container").item(0);
            container.innerHTML = reader.outs.content.value;
        }
    }
    onActiveDocument(previous, next) {
        if (previous) {
            previous.setup.language.outs.language.off("value", this.onUpdate, this);
            this.reader.outs.content.off("value", this.onUpdate, this);
            this.reader.outs.article.off("value", this.onUpdate, this);
            this.language = null;
            this.reader = null;
        }
        if (next) {
            this.reader = next.setup.reader;
            this.language = next.setup.language;
            this.reader.outs.content.on("value", this.onUpdate, this);
            this.reader.outs.article.on("value", this.onUpdate, this);
            next.setup.language.outs.language.on("value", this.onUpdate, this);
        }
    }
};
ReaderView = __decorate([
    Object(_DocumentView__WEBPACK_IMPORTED_MODULE_1__["customElement"])("sv-reader-view")
], ReaderView);
/* harmony default export */ __webpack_exports__["default"] = (ReaderView);


/***/ }),

/***/ "./ui/explorer/ShareMenu.ts":
/*!**********************************!*\
  !*** ./ui/explorer/ShareMenu.ts ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_ui_Popup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/ui/Popup */ "../../libs/ff-ui/source/Popup.ts");
/* harmony import */ var _ff_ui_Button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/ui/Button */ "../../libs/ff-ui/source/Button.ts");
/* harmony import */ var _ff_ui_TextEdit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ff/ui/TextEdit */ "../../libs/ff-ui/source/TextEdit.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ShareMenu_1;



////////////////////////////////////////////////////////////////////////////////
let ShareMenu = ShareMenu_1 = class ShareMenu extends _ff_ui_Popup__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(language) {
        super();
        this.language = null;
        this.language = language;
        this.position = "center";
        this.modal = true;
        this.url = window.location.href;
    }
    static show(parent, language) {
        const menu = new ShareMenu_1(language);
        parent.appendChild(menu);
        return new Promise((resolve, reject) => {
            menu.on("close", () => resolve());
        });
    }
    close() {
        this.dispatchEvent(new CustomEvent("close"));
        this.remove();
    }
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-share-menu");
    }
    render() {
        const url = encodeURIComponent(this.url);
        const title = encodeURI("Smithsonian Voyager");
        const language = this.language;
        const twitterShareUrl = `http://twitter.com/share?text=${title}&url=${url}`;
        const facebookShareUrl = `https://www.facebook.com/sharer/sharer.php?u=${url}`;
        const linkedInShareUrl = `https://www.linkedin.com/shareArticle?url=${url}&mini=true&title=${title}`;
        const iFrameEmbedCode = `<iframe name="Smithsonian Voyager" src="${this.url}" width="800" height="450" allow="xr; xr-spatial-tracking; fullscreen"></iframe>`;
        const emailUrl = `mailto:?subject=${title}&body=${url}`;
        return _ff_ui_Popup__WEBPACK_IMPORTED_MODULE_0__["html"] `
        <div class="ff-flex-row">
            <div class="ff-flex-spacer ff-title">${language.getLocalizedString("Share Experience")}</div>
            <ff-button icon="close" transparent class="ff-close-button" title=${language.getLocalizedString("Close")} @click=${this.close}></ff-button>
        </div>
        <div class="ff-flex-row sv-share-buttons">
            <a href=${twitterShareUrl} target="_blank" rel="noopener noreferrer"><ff-button class="sv-share-button-twitter" icon="twitter" title="Twitter"></ff-button></a>
            <a href=${facebookShareUrl} target="_blank" rel="noopener noreferrer"><ff-button class="sv-share-button-facebook" icon="facebook" title="Facebook"></ff-button></a>
            <a href=${linkedInShareUrl} target="_blank" rel="noopener noreferrer"><ff-button class="sv-share-button-linkedin" icon="linkedin" title="LinkedIn"></ff-button></a>
            <a href=${emailUrl} target="_blank"><ff-button class="sv-share-button-email" icon="email" title=${language.getLocalizedString("Email")}></ff-button></a>
        </div>
        <div class="ff-title">${language.getLocalizedString("Embed Link")}</div>
        <div class="ff-flex-row sv-embed-link">
            <ff-text-edit text=${iFrameEmbedCode}></ff-text-edit>
            <ff-button icon="copy" title=${language.getLocalizedString("Copy to Clipboard")} @click=${this.onClickCopy}></ff-button>
        </div>
        `;
    }
    onClickCopy() {
        const textArea = this.getElementsByTagName("ff-text-edit").item(0);
        textArea.select();
        document.execCommand("copy");
    }
};
ShareMenu = ShareMenu_1 = __decorate([
    Object(_ff_ui_Popup__WEBPACK_IMPORTED_MODULE_0__["customElement"])("sv-share-menu")
], ShareMenu);
/* harmony default export */ __webpack_exports__["default"] = (ShareMenu);


/***/ }),

/***/ "./ui/explorer/TagCloud.ts":
/*!*********************************!*\
  !*** ./ui/explorer/TagCloud.ts ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_ui_Button__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/ui/Button */ "../../libs/ff-ui/source/Button.ts");
/* harmony import */ var _DocumentView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DocumentView */ "./ui/explorer/DocumentView.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


////////////////////////////////////////////////////////////////////////////////
let TagCloud = class TagCloud extends _DocumentView__WEBPACK_IMPORTED_MODULE_1__["default"] {
    get activeTags() {
        return this.viewer ? this.viewer.ins.activeTags.value.split(",")
            .map(tag => tag.trim()).filter(tag => !!tag) : [];
    }
    get tagCloud() {
        return this.viewer ? this.viewer.outs.tagCloud.value.split(",")
            .map(tag => tag.trim()).filter(tag => !!tag) : [];
    }
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-bottom-bar-container", "sv-tag-cloud", "sv-transition");
        setTimeout(() => this.classList.remove("sv-transition"), 1);
    }
    render() {
        const activeTags = this.activeTags;
        const tagCloud = this.tagCloud;
        const tagButtons = tagCloud.map(tag => _DocumentView__WEBPACK_IMPORTED_MODULE_1__["html"] `<ff-button class="sv-tag-button" transparent text=${tag}
                ?selected=${activeTags.indexOf(tag) >= 0}
                @click=${e => this.onSelectTag(tag)}></ff-button>`);
        return _DocumentView__WEBPACK_IMPORTED_MODULE_1__["html"] `<div class="sv-blue-bar"><div class="sv-section">
                <ff-button class="sv-section-lead" transparent icon="close" title="Close Tag Menu" @click=${this.onClickClose}></ff-button>
                <div class="sv-tag-buttons">${tagButtons}</div>
        </div></div>`;
    }
    onClickClose() {
        this.viewer.ins.annotationsVisible.setValue(false);
    }
    onSelectTag(tag) {
        let activeTags = this.activeTags;
        const radioTags = this.viewer.ins.radioTags.value;
        const index = activeTags.indexOf(tag);
        if (index >= 0 && !radioTags) {
            activeTags.splice(index, 1);
        }
        else if (index < 0) {
            if (radioTags) {
                activeTags = [tag];
            }
            else {
                activeTags.push(tag);
            }
        }
        this.viewer.ins.activeTags.setValue(activeTags.join(", "));
    }
    onActiveDocument(previous, next) {
        if (previous) {
            this.viewer.ins.activeTags.off("value", this.onUpdate, this);
            this.viewer.outs.tagCloud.off("value", this.onUpdate, this);
        }
        if (next) {
            this.viewer = next.setup.viewer;
            this.viewer.ins.activeTags.on("value", this.onUpdate, this);
            this.viewer.outs.tagCloud.on("value", this.onUpdate, this);
        }
    }
};
TagCloud = __decorate([
    Object(_DocumentView__WEBPACK_IMPORTED_MODULE_1__["customElement"])("sv-tag-cloud")
], TagCloud);
/* harmony default export */ __webpack_exports__["default"] = (TagCloud);


/***/ }),

/***/ "./ui/explorer/ToolBar.ts":
/*!********************************!*\
  !*** ./ui/explorer/ToolBar.ts ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_scene_ui_SystemView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/scene/ui/SystemView */ "../../libs/ff-scene/source/ui/SystemView.ts");
/* harmony import */ var _components_CVToolProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/CVToolProvider */ "./components/CVToolProvider.ts");
/* harmony import */ var client_components_CVLanguageManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! client/components/CVLanguageManager */ "./components/CVLanguageManager.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



let ToolBar = class ToolBar extends _ff_scene_ui_SystemView__WEBPACK_IMPORTED_MODULE_0__["default"] {
    get toolProvider() {
        return this.system.getMainComponent(_components_CVToolProvider__WEBPACK_IMPORTED_MODULE_1__["default"]);
    }
    get language() {
        return this.system.getComponent(client_components_CVLanguageManager__WEBPACK_IMPORTED_MODULE_2__["default"]);
    }
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-bottom-bar-container", "sv-transition", "sv-tool-bar");
        setTimeout(() => this.classList.remove("sv-transition"), 1);
    }
    connected() {
        super.connected();
        this.toolProvider.on("active-component", this.onUpdate, this);
        this.language.outs.language.on("value", this.onUpdate, this);
    }
    disconnected() {
        this.language.outs.language.off("value", this.onUpdate, this);
        this.toolProvider.off("active-component", this.onUpdate, this);
        super.disconnected();
    }
    render() {
        const tools = this.toolProvider.scopedComponents;
        const activeTool = this.toolProvider.activeComponent;
        const language = this.language;
        const toolButtons = tools.map(tool => _ff_scene_ui_SystemView__WEBPACK_IMPORTED_MODULE_0__["html"] `<ff-button class="sv-tool-button" transparent text=${language.getLocalizedString(tool.text)} icon=${tool.icon}
                ?selected=${tool === activeTool} @click=${e => this.onSelectTool(tool)}></ff-button>`);
        return _ff_scene_ui_SystemView__WEBPACK_IMPORTED_MODULE_0__["html"] `<div class="sv-blue-bar">${activeTool ? activeTool.createView() : null}
            <div class="sv-section">
                <ff-button class="sv-section-lead" transparent icon="close" title=${language.getLocalizedString("Close Tools")} @click=${this.onClose}></ff-button>
                <div class="sv-tool-buttons">${toolButtons}</div>
                <sv-tool-menu-view .system=${this.system}></sv-tool-menu-view>
            </div></div>`;
    }
    onSelectTool(tool) {
        this.toolProvider.activeComponent = tool;
    }
    onClose(event) {
        this.dispatchEvent(new CustomEvent("close"));
        event.stopPropagation();
    }
};
ToolBar = __decorate([
    Object(_ff_scene_ui_SystemView__WEBPACK_IMPORTED_MODULE_0__["customElement"])("sv-tool-bar")
], ToolBar);
/* harmony default export */ __webpack_exports__["default"] = (ToolBar);


/***/ }),

/***/ "./ui/explorer/TourMenu.ts":
/*!*********************************!*\
  !*** ./ui/explorer/TourMenu.ts ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/ui/CustomElement */ "../../libs/ff-ui/source/CustomElement.ts");
/* harmony import */ var _ff_ui_Button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ff/ui/Button */ "../../libs/ff-ui/source/Button.ts");
/* harmony import */ var client_schema_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! client/schema/common */ "./schema/common.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



let TourMenu = class TourMenu extends _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["default"] {
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-document-overlay", "sv-article", "sv-tour-menu");
    }
    renderEntry(tour, index) {
        return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<div class="sv-entry" @click=${e => this.onClickTour(e, index)}>
            <h1>${Object.keys(tour.titles).length > 0 ? tour.titles[client_schema_common__WEBPACK_IMPORTED_MODULE_2__["ELanguageType"][this.activeLanguage]] : tour.title}</h1>
            <p>${Object.keys(tour.leads).length > 0 ? tour.leads[client_schema_common__WEBPACK_IMPORTED_MODULE_2__["ELanguageType"][this.activeLanguage]] : tour.lead}</p>
        </div>`;
    }
    render() {
        const tours = this.tours;
        if (tours.length === 0) {
            return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<div class="sv-entry">
                <h1>No tours available.</h1>
            </div>`;
        }
        return _ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["html"] `<div class="ff-scroll-y">
            ${tours.map((tour, index) => this.renderEntry(tour, index))}
        </div>`;
    }
    onClickTour(e, index) {
        e.stopPropagation();
        this.dispatchEvent(new CustomEvent("select", {
            detail: { index }
        }));
    }
};
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ attribute: false })
], TourMenu.prototype, "tours", void 0);
__decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["property"])({ attribute: false })
], TourMenu.prototype, "activeLanguage", void 0);
TourMenu = __decorate([
    Object(_ff_ui_CustomElement__WEBPACK_IMPORTED_MODULE_0__["customElement"])("sv-tour-menu")
], TourMenu);
/* harmony default export */ __webpack_exports__["default"] = (TourMenu);


/***/ }),

/***/ "./ui/explorer/TourNavigator.ts":
/*!**************************************!*\
  !*** ./ui/explorer/TourNavigator.ts ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ff_ui_Button__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ff/ui/Button */ "../../libs/ff-ui/source/Button.ts");
/* harmony import */ var _DocumentView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DocumentView */ "./ui/explorer/DocumentView.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


////////////////////////////////////////////////////////////////////////////////
let TourNavigator = class TourNavigator extends _DocumentView__WEBPACK_IMPORTED_MODULE_1__["default"] {
    firstConnected() {
        super.firstConnected();
        this.classList.add("sv-bottom-bar-container", "sv-tour-navigator", "sv-transition");
        setTimeout(() => this.classList.remove("sv-transition"), 1);
    }
    render() {
        const tours = this.tours;
        const language = this.language;
        const activeTour = tours.activeTour;
        let title, info;
        if (tours && activeTour) {
            const stepNumber = tours.outs.stepIndex.value + 1;
            const stepCount = tours.outs.stepCount.value;
            title = stepCount > 0 ? tours.stepTitle : tours.title;
            info = stepCount > 0 ? `${language.getLocalizedString("Step")} ${stepNumber} ${language.getLocalizedString("of")} ${stepCount}` : language.getLocalizedString("No tour steps defined");
        }
        else {
            title = language.getLocalizedString("No tour selected");
            info = "---";
        }
        return _DocumentView__WEBPACK_IMPORTED_MODULE_1__["html"] `<div class="sv-blue-bar"><div class="sv-section">
            <ff-button class="sv-section-lead" transparent icon="close" title=${language.getLocalizedString("Exit Tour")} ?disabled=${!activeTour} @click=${this.onClickExit}></ff-button>
            <div class="ff-ellipsis sv-content">
                <div class="ff-ellipsis sv-title">${title}</div>
                <div class="ff-ellipsis sv-text">${info}</div>
            </div>
            <ff-button class="sv-section-trail" transparent icon="bars" title=${language.getLocalizedString("Show Tour Menu")} @click=${this.onClickMenu}></ff-button>
            <ff-button class="sv-section-trail" transparent icon="triangle-left" title=${language.getLocalizedString("Go Backward")} ?disabled=${!activeTour} @click=${this.onClickPrevious}></ff-button>
            <ff-button class="sv-section-trail" transparent icon="triangle-right" title=${language.getLocalizedString("Go Forward")} ?disabled=${!activeTour} @click=${this.onClickNext}></ff-button>
        </div></div>`;
    }
    onClickExit() {
        // disable tours
        this.tours.ins.enabled.setValue(false);
    }
    onClickMenu() {
        // enter tour menu
        this.tours.ins.tourIndex.setValue(-1);
    }
    onClickPrevious() {
        // go to previous tour step
        this.tours.ins.previous.set();
    }
    onClickNext() {
        // go to next tour step
        this.tours.ins.next.set();
    }
    onActiveDocument(previous, next) {
        if (previous) {
            this.tours.outs.tourIndex.off("value", this.onUpdate, this);
            this.tours.outs.stepIndex.off("value", this.onUpdate, this);
            this.language.outs.language.off("value", this.onUpdate, this);
        }
        if (next) {
            this.tours = next.setup.tours;
            this.language = next.setup.language;
            this.tours.outs.tourIndex.on("value", this.onUpdate, this);
            this.tours.outs.stepIndex.on("value", this.onUpdate, this);
            this.language.outs.language.on("value", this.onUpdate, this);
        }
        this.requestUpdate();
    }
};
TourNavigator = __decorate([
    Object(_DocumentView__WEBPACK_IMPORTED_MODULE_1__["customElement"])("sv-tour-navigator")
], TourNavigator);
/* harmony default export */ __webpack_exports__["default"] = (TourNavigator);


/***/ }),

/***/ "./ui/explorer/styles.scss":
/*!*********************************!*\
  !*** ./ui/explorer/styles.scss ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("/**\n * 3D Foundation Project\n * Copyright 2019 Smithsonian Institution\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * 3D Foundation Project\n * Copyright 2019 Smithsonian Institution\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * FF Typescript Foundation Library\n * Copyright 2019 Ralph Wiedemeier, Frame Factory GmbH\n *\n * License: MIT\n */\n/*! normalize.css v8.0.0 | MIT License | github.com/necolas/normalize.css */\n/* Document\r\n   ========================================================================== */\n/**\r\n * 1. Correct the line height in all browsers.\r\n * 2. Prevent adjustments of font size after orientation changes in iOS.\r\n */\nhtml {\n  line-height: normal;\n  /* was 1.15 */\n  -webkit-text-size-adjust: 100%;\n  /* 2 */ }\n\n/* Sections\r\n   ========================================================================== */\n/**\r\n * Remove the margin in all browsers.\r\n */\nbody {\n  margin: 0; }\n\n/**\r\n * Correct the font size and margin on `h1` elements within `section` and\r\n * `article` contexts in Chrome, Firefox, and Safari.\r\n */\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0; }\n\n/* Grouping content\r\n   ========================================================================== */\n/**\r\n * 1. Add the correct box sizing in Firefox.\r\n * 2. Show the overflow in Edge and IE.\r\n */\nhr {\n  box-sizing: content-box;\n  /* 1 */\n  height: 0;\n  /* 1 */\n  overflow: visible;\n  /* 2 */ }\n\n/**\r\n * 1. Correct the inheritance and scaling of font size in all browsers.\r\n * 2. Correct the odd `em` font sizing in all browsers.\r\n */\npre {\n  font-family: monospace, monospace;\n  /* 1 */\n  font-size: 1em;\n  /* 2 */ }\n\n/* Text-level semantics\r\n   ========================================================================== */\n/**\r\n * Remove the gray background on active links in IE 10.\r\n */\na {\n  background-color: transparent; }\n\n/**\r\n * 1. Remove the bottom border in Chrome 57-\r\n * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.\r\n */\nabbr[title] {\n  border-bottom: none;\n  /* 1 */\n  text-decoration: underline;\n  /* 2 */\n  text-decoration: underline dotted;\n  /* 2 */ }\n\n/**\r\n * Add the correct font weight in Chrome, Edge, and Safari.\r\n */\nb,\nstrong {\n  font-weight: bolder; }\n\n/**\r\n * 1. Correct the inheritance and scaling of font size in all browsers.\r\n * 2. Correct the odd `em` font sizing in all browsers.\r\n */\ncode,\nkbd,\nsamp {\n  font-family: monospace, monospace;\n  /* 1 */\n  font-size: 1em;\n  /* 2 */ }\n\n/**\r\n * Add the correct font size in all browsers.\r\n */\nsmall {\n  font-size: 80%; }\n\n/**\r\n * Prevent `sub` and `sup` elements from affecting the line height in\r\n * all browsers.\r\n */\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline; }\n\nsub {\n  bottom: -0.25em; }\n\nsup {\n  top: -0.5em; }\n\n/* Embedded content\r\n   ========================================================================== */\n/**\r\n * Remove the border on images inside links in IE 10.\r\n */\nimg {\n  border-style: none; }\n\n/* Forms\r\n   ========================================================================== */\n/**\r\n * 1. Change the font styles in all browsers.\r\n * 2. Remove the margin in Firefox and Safari.\r\n */\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: inherit;\n  /* 1 */\n  font-size: 100%;\n  /* 1 */\n  line-height: 1.15;\n  /* 1 */\n  margin: 0;\n  /* 2 */ }\n\n/**\r\n * Show the overflow in IE.\r\n * 1. Show the overflow in Edge.\r\n */\nbutton,\ninput {\n  /* 1 */\n  overflow: visible; }\n\n/**\r\n * Remove the inheritance of text transform in Edge, Firefox, and IE.\r\n * 1. Remove the inheritance of text transform in Firefox.\r\n */\nbutton,\nselect {\n  /* 1 */\n  text-transform: none; }\n\n/**\r\n * Correct the inability to style clickable types in iOS and Safari.\r\n */\nbutton,\n[type=\"button\"],\n[type=\"reset\"],\n[type=\"submit\"] {\n  -webkit-appearance: button; }\n\n/**\r\n * Remove the inner border and padding in Firefox.\r\n */\nbutton::-moz-focus-inner,\n[type=\"button\"]::-moz-focus-inner,\n[type=\"reset\"]::-moz-focus-inner,\n[type=\"submit\"]::-moz-focus-inner {\n  border-style: none;\n  padding: 0; }\n\n/**\r\n * Restore the focus styles unset by the previous rule.\r\n */\nbutton:-moz-focusring,\n[type=\"button\"]:-moz-focusring,\n[type=\"reset\"]:-moz-focusring,\n[type=\"submit\"]:-moz-focusring {\n  outline: 1px dotted ButtonText; }\n\n/**\r\n * Correct the padding in Firefox.\r\n */\nfieldset {\n  padding: 0.35em 0.75em 0.625em; }\n\n/**\r\n * 1. Correct the text wrapping in Edge and IE.\r\n * 2. Correct the color inheritance from `fieldset` elements in IE.\r\n * 3. Remove the padding so developers are not caught out when they zero out\r\n *    `fieldset` elements in all browsers.\r\n */\nlegend {\n  box-sizing: border-box;\n  /* 1 */\n  color: inherit;\n  /* 2 */\n  display: table;\n  /* 1 */\n  max-width: 100%;\n  /* 1 */\n  padding: 0;\n  /* 3 */\n  white-space: normal;\n  /* 1 */ }\n\n/**\r\n * Add the correct vertical alignment in Chrome, Firefox, and Opera.\r\n */\nprogress {\n  vertical-align: baseline; }\n\n/**\r\n * Remove the default vertical scrollbar in IE 10+.\r\n */\ntextarea {\n  overflow: auto; }\n\n/**\r\n * 1. Add the correct box sizing in IE 10.\r\n * 2. Remove the padding in IE 10.\r\n */\n[type=\"checkbox\"],\n[type=\"radio\"] {\n  box-sizing: border-box;\n  /* 1 */\n  padding: 0;\n  /* 2 */ }\n\n/**\r\n * Correct the cursor style of increment and decrement buttons in Chrome.\r\n */\n[type=\"number\"]::-webkit-inner-spin-button,\n[type=\"number\"]::-webkit-outer-spin-button {\n  height: auto; }\n\n/**\r\n * 1. Correct the odd appearance in Chrome and Safari.\r\n * 2. Correct the outline style in Safari.\r\n */\n[type=\"search\"] {\n  -webkit-appearance: textfield;\n  /* 1 */\n  outline-offset: -2px;\n  /* 2 */ }\n\n/**\r\n * Remove the inner padding in Chrome and Safari on macOS.\r\n */\n[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none; }\n\n/**\r\n * 1. Correct the inability to style clickable types in iOS and Safari.\r\n * 2. Change font properties to `inherit` in Safari.\r\n */\n::-webkit-file-upload-button {\n  -webkit-appearance: button;\n  /* 1 */\n  font: inherit;\n  /* 2 */ }\n\n/* Interactive\r\n   ========================================================================== */\n/*\r\n * Add the correct display in Edge, IE 10+, and Firefox.\r\n */\ndetails {\n  display: block; }\n\n/*\r\n * Add the correct display in all browsers.\r\n */\nsummary {\n  display: list-item; }\n\n/* Misc\r\n   ========================================================================== */\n/**\r\n * Add the correct display in IE 10+.\r\n */\ntemplate {\n  display: none; }\n\n/**\r\n * Add the correct display in IE 10.\r\n */\n[hidden] {\n  display: none; }\n\n.ff-fullsize {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  box-sizing: border-box; }\n\n.ff-container {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  box-sizing: border-box;\n  overflow: hidden; }\n\n.ff-fullsize {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  box-sizing: border-box; }\n\n.ff-caret-down {\n  width: 0;\n  height: 0;\n  border-left: 5px solid transparent;\n  border-right: 5px solid transparent;\n  border-bottom: 5px solid #a0a0a0;\n  transform: rotate(180deg);\n  transition: transform 0.05s; }\n\n.ff-caret-up {\n  width: 0;\n  height: 0;\n  border-left: 5px solid transparent;\n  border-right: 5px solid transparent;\n  border-bottom: 5px solid #a0a0a0;\n  transform: rotate(0deg);\n  transition: transform 0.05s; }\n\n.ff-caret-right {\n  width: 0;\n  height: 0;\n  border-left: 5px solid transparent;\n  border-right: 5px solid transparent;\n  border-bottom: 5px solid #a0a0a0;\n  transform: rotate(90deg);\n  transition: transform 0.05s; }\n\n.ff-caret-left {\n  width: 0;\n  height: 0;\n  border-left: 5px solid transparent;\n  border-right: 5px solid transparent;\n  border-bottom: 5px solid #a0a0a0;\n  transform: rotate(270deg);\n  transition: transform 0.05s; }\n\nhtml {\n  color: #c8c8c8; }\n\nbutton, input {\n  display: block;\n  padding: 0;\n  margin: 0;\n  border: none;\n  background-color: inherit;\n  color: inherit;\n  font-size: inherit;\n  cursor: inherit; }\n\n*:focus {\n  outline: 1px solid #0089bf;\n  outline-offset: 0; }\n\n.ff-fullscreen {\n  position: fixed;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0; }\n\n.ff-noselect {\n  user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none; }\n\n.ff-off {\n  user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  pointer-events: none; }\n\n.ff-on {\n  user-select: auto;\n  -webkit-user-select: none;\n  pointer-events: auto; }\n\n.ff-focusable {\n  tab-index: 0; }\n\n.ff-flex-row {\n  display: flex; }\n\n.ff-flex-column {\n  display: flex;\n  flex-direction: column; }\n\n.ff-flex-wrap {\n  flex-wrap: wrap; }\n\n.ff-flex-centered {\n  align-items: center; }\n\n.ff-flex-item-fixed {\n  flex: 0 0 auto;\n  position: relative; }\n\n.ff-flex-item-stretch, .ff-flex-spacer {\n  flex: 1 1 auto;\n  position: relative; }\n\n.ff-scroll-y {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  box-sizing: border-box;\n  overflow-y: auto; }\n\n.ff-position-above {\n  position: absolute;\n  bottom: 0; }\n\n.ff-position-below {\n  position: absolute;\n  top: 100%; }\n\n.ff-position-left {\n  position: absolute;\n  right: 0; }\n\n.ff-position-right {\n  position: absolute;\n  left: 100%; }\n\n.ff-position-above.ff-align-left, .ff-position-below.ff-align-left {\n  left: 0; }\n\n.ff-position-above.ff-align-right, .ff-position-below.ff-align-right {\n  right: 0; }\n\n.ff-position-left.ff-align-top, .ff-position-right.ff-align-top {\n  top: 0; }\n\n.ff-position-left.ff-align-bottom, .ff-position-right.ff-align-bottom {\n  bottom: 0; }\n\n.ff-ellipsis {\n  text-overflow: ellipsis;\n  overflow: hidden;\n  white-space: nowrap; }\n\n.ff-placeholder {\n  flex: 1 1 auto;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center; }\n\n.ff-splitter-section {\n  flex: 1 1 auto;\n  position: relative;\n  box-sizing: border-box;\n  overflow: hidden; }\n\n.ff-splitter[direction=\"vertical\"] + .ff-splitter-section {\n  border-top: 2px solid #1b1b1b; }\n\n.ff-splitter:not([direction=\"vertical\"]) + .ff-splitter-section {\n  border-left: 2px solid #1b1b1b; }\n\n.ff-frame {\n  padding: 4px; }\n  .ff-frame .ff-control {\n    margin: 4px; }\n\n.ff-icon {\n  display: inline-block;\n  position: relative;\n  height: 1rem;\n  fill: #a0a0a0; }\n  .ff-icon svg {\n    width: inherit;\n    height: inherit; }\n\n.ff-button {\n  cursor: pointer; }\n  .ff-button[vertical] {\n    flex-direction: column; }\n\n.ff-button.ff-inline .ff-icon + .ff-text {\n  padding-left: 0.5em; }\n\n.ff-button.ff-inline .ff-icon {\n  display: inline; }\n\n.ff-button.ff-inline .ff-text {\n  display: inline; }\n\n.ff-button.ff-transparent {\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex: 0 1 auto;\n  flex-wrap: wrap;\n  padding: 5px;\n  background: transparent;\n  fill: #a0a0a0;\n  transition: fill 0.2s; }\n  .ff-button.ff-transparent:hover, .ff-button.ff-transparent:focus {\n    fill: #c8c8c8; }\n  .ff-button.ff-transparent[selected] {\n    fill: #c8c8c8; }\n  .ff-button.ff-transparent > .ff-text {\n    margin: 3px;\n    white-space: nowrap; }\n  .ff-button.ff-transparent > .ff-icon {\n    margin: 3px;\n    height: 1.3em; }\n  .ff-button.ff-transparent > .ff-caret-down {\n    margin: 3px; }\n  .ff-button.ff-transparent.ff-disabled {\n    color: #808080;\n    fill: #606060;\n    user-select: none;\n    pointer-events: none; }\n\n.ff-button.ff-control {\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex: 1 1 auto;\n  flex-wrap: wrap;\n  padding: 5px;\n  background: #4e4e4e;\n  transition: background-color 0.2s; }\n  .ff-button.ff-control:hover, .ff-button.ff-control:focus {\n    background-color: #676767; }\n  .ff-button.ff-control[selected] {\n    background-color: #0089bf; }\n    .ff-button.ff-control[selected]:hover, .ff-button.ff-control[selected]:focus {\n      background-color: #00a6e8; }\n  .ff-button.ff-control > .ff-text {\n    margin: 3px;\n    white-space: nowrap; }\n  .ff-button.ff-control > .ff-icon {\n    margin: 3px;\n    height: 1.3em; }\n  .ff-button.ff-control > .ff-caret-down {\n    margin: 3px; }\n  .ff-button.ff-control.ff-disabled {\n    color: #808080;\n    fill: #606060;\n    user-select: none;\n    pointer-events: none; }\n    .ff-button.ff-control.ff-disabled > .ff-icon {\n      fill: #606060; }\n\n.ff-menu {\n  background-color: #4e4e4e;\n  z-index: 100;\n  display: flex;\n  flex-direction: column; }\n  .ff-menu .ff-divider {\n    height: 1px;\n    padding: 0;\n    background: #a0a0a0; }\n  .ff-menu .ff-button {\n    justify-content: flex-start;\n    margin: 0;\n    padding: 4px 4px; }\n    .ff-menu .ff-button .ff-icon {\n      height: 1.2em;\n      width: 2.2em;\n      margin-right: 4px; }\n\n.ff-dropdown .ff-menu {\n  min-width: 100%;\n  margin-top: 3px; }\n\n.ff-modal-plane {\n  position: fixed;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  background-color: rgba(0, 0, 0, 0.6);\n  opacity: 0;\n  transition: opacity 0.3s;\n  z-index: 990;\n  pointer-events: auto; }\n  .ff-modal-plane.ff-transition {\n    opacity: 1; }\n\nff-dialog {\n  box-sizing: border-box;\n  background: #343434;\n  border: 1px solid #4e4e4e;\n  box-shadow: 3px 3px 24px rgba(0, 0, 0, 0.4); }\n\nff-title-bar {\n  background: #1b1b1b;\n  padding: 2px; }\n  ff-title-bar .ff-text {\n    flex: 1 1 auto;\n    padding-right: 8px; }\n  ff-title-bar .ff-icon {\n    padding: 2px; }\n\nff-popup-button .ff-content {\n  transition: opacity 0.15s; }\n\n.ff-line-edit {\n  display: block;\n  overflow: hidden;\n  background-color: #1b1b1b;\n  min-height: 1.2em; }\n  .ff-line-edit input {\n    padding: 2px; }\n\n.ff-text-edit {\n  box-sizing: border-box;\n  flex: 1 1 auto;\n  display: flex;\n  background-color: #1b1b1b; }\n  .ff-text-edit textarea {\n    display: block;\n    box-sizing: border-box;\n    width: 100%;\n    padding: 2px;\n    resize: none;\n    background: transparent;\n    color: inherit;\n    border: none; }\n\n.ff-color-edit {\n  font-size: 0.8rem; }\n  .ff-color-edit .ff-control {\n    margin: 0; }\n  .ff-color-edit .ff-slider-controls {\n    align-items: stretch;\n    flex: 1 1 auto; }\n  .ff-color-edit .ff-numeric-controls {\n    flex: 0 0 auto;\n    align-items: center;\n    margin-top: 6px; }\n  .ff-color-edit .ff-text {\n    color: #a0a0a0;\n    margin: 0 3px; }\n  .ff-color-edit .ff-line-edit {\n    flex: 4 5 auto; }\n    .ff-color-edit .ff-line-edit.ff-wide {\n      flex: 5 4 auto; }\n  .ff-color-edit .ff-knob {\n    margin: -2px 0 0 -2px;\n    border: 2px solid white;\n    box-shadow: 0 0 5px rgba(0, 0, 0, 0.5); }\n  .ff-color-edit .ff-vector-slider {\n    flex: 1 0 auto;\n    padding: 0 10px 10px 0;\n    background-image: linear-gradient(to bottom, transparent, black), linear-gradient(to right, white, red); }\n    .ff-color-edit .ff-vector-slider .ff-knob {\n      width: 10px;\n      height: 10px; }\n  .ff-color-edit .ff-linear-slider {\n    flex: 0 0 24px;\n    margin-left: 6px;\n    padding-bottom: 10px; }\n    .ff-color-edit .ff-linear-slider .ff-knob {\n      width: 100%;\n      height: 10px; }\n  .ff-color-edit .ff-hue-slider {\n    background: linear-gradient(to bottom, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00); }\n  .ff-color-edit .ff-alpha-slider {\n    color: #4e4e4e; }\n\n.ff-quad-splitter .ff-left {\n  box-sizing: border-box;\n  border-right: 1px solid #343434; }\n\n.ff-quad-splitter .ff-top {\n  box-sizing: border-box;\n  border-bottom: 1px solid #343434; }\n\n#ff-notification-stack {\n  position: fixed;\n  z-index: 100;\n  bottom: 0;\n  right: 0;\n  width: 30%;\n  min-width: 250px;\n  max-width: 500px; }\n\n.ff-notification {\n  position: relative;\n  left: 0;\n  display: flex;\n  margin: 8px;\n  padding: 4px;\n  background: #4e4e4e;\n  box-shadow: 0 0 20px rgba(0, 0, 0, 0.35); }\n  .ff-notification.ff-info > .ff-icon {\n    fill: #73adff; }\n  .ff-notification.ff-success > .ff-icon {\n    fill: #8ae65c; }\n  .ff-notification.ff-warning > .ff-icon {\n    fill: #e6a345; }\n  .ff-notification.ff-error > .ff-icon {\n    fill: #e64545; }\n  .ff-notification > .ff-icon {\n    height: 2em;\n    padding: 8px; }\n  .ff-notification.ff-out {\n    transition: left 0.5s ease-in;\n    left: 100%; }\n  .ff-notification .ff-text {\n    flex: 1;\n    padding: 8px;\n    text-overflow: ellipsis;\n    overflow: hidden; }\n  .ff-notification .ff-button {\n    flex: 0;\n    padding: 8px; }\n\n.ff-message-box {\n  position: relative;\n  min-width: 350px;\n  max-width: 450px;\n  width: 90%;\n  padding: 16px;\n  background: #343434;\n  box-shadow: 0 0 20px rgba(0, 0, 0, 0.35);\n  opacity: 0;\n  transition: opacity 0.15s; }\n  .ff-message-box.ff-transition {\n    opacity: 1; }\n  .ff-message-box .ff-title {\n    align-items: flex-start; }\n    .ff-message-box .ff-title .ff-type-icon {\n      margin: 0 16px 0 0;\n      height: 2.5em; }\n      .ff-message-box .ff-title .ff-type-icon[name=\"prompt\"] {\n        fill: #e6cf5c; }\n      .ff-message-box .ff-title .ff-type-icon[name=\"info\"] {\n        fill: #73adff; }\n      .ff-message-box .ff-title .ff-type-icon[name=\"warning\"] {\n        fill: #e6a345; }\n      .ff-message-box .ff-title .ff-type-icon[name=\"error\"] {\n        fill: #e64545; }\n    .ff-message-box .ff-title .ff-content {\n      flex: 1 1 auto;\n      margin: 0 0 2em 0; }\n    .ff-message-box .ff-title .ff-caption {\n      font-size: 1.5em; }\n    .ff-message-box .ff-title .ff-text {\n      margin: 2em 0 1em 0; }\n    .ff-message-box .ff-title .ff-line-edit {\n      margin: 0 0 1em 0; }\n      .ff-message-box .ff-title .ff-line-edit input {\n        padding: 4px; }\n    .ff-message-box .ff-title .ff-close-button {\n      margin: 0 0 0 16px;\n      padding: 0; }\n  .ff-message-box .ff-button + .ff-button {\n    margin-left: 8px; }\n\n.ff-popup-options {\n  box-sizing: border-box;\n  background: #343434;\n  border: 1px solid #4e4e4e;\n  box-shadow: 3px 3px 24px rgba(0, 0, 0, 0.4);\n  min-width: 6rem; }\n  .ff-popup-options button {\n    padding: 4px 8px;\n    text-align: start;\n    user-select: none; }\n  .ff-popup-options button + button {\n    margin-top: 1px; }\n  .ff-popup-options button:hover {\n    background-color: #4e4e4e; }\n  .ff-popup-options button:focus {\n    outline: none;\n    background-color: #0089bf; }\n\n.ff-list {\n  flex: 1 1 auto;\n  background-color: #272727; }\n  .ff-list .ff-list-item {\n    cursor: pointer;\n    user-select: none;\n    padding: 2px; }\n    .ff-list .ff-list-item:hover {\n      background-color: #343434; }\n    .ff-list .ff-list-item[selected] {\n      background-color: #0089bf; }\n  .ff-list .ff-list-item + .ff-list-item {\n    border-top: 1px solid #343434; }\n\n.ff-table {\n  position: relative;\n  box-sizing: border-box;\n  width: 100%; }\n  .ff-table table {\n    box-sizing: border-box;\n    width: 100%;\n    table-layout: fixed;\n    border-collapse: collapse;\n    border-spacing: 0; }\n  .ff-table tr[selected] {\n    background-color: #0089bf; }\n  .ff-table th, .ff-table td {\n    padding: 4px; }\n  .ff-table th {\n    background-color: #1b1b1b;\n    color: #a0a0a0;\n    text-align: start; }\n  .ff-table .ff-table-sort-icon {\n    height: 0.8em;\n    margin-left: 4px;\n    color: #a0a0a0; }\n\n.ff-tree {\n  position: relative;\n  overflow-y: auto; }\n  .ff-tree .ff-tree-node-container {\n    margin-left: -501px;\n    border-top: 1px solid #3e3e3e;\n    border-bottom: 1px solid #3e3e3e;\n    margin-bottom: -1px; }\n  .ff-tree .ff-tree-node {\n    margin-left: 500px; }\n    .ff-tree .ff-tree-node.ff-inner {\n      background-color: #2f2f2f; }\n    .ff-tree .ff-tree-node.ff-leaf {\n      background-color: #3c3c3c; }\n    .ff-tree .ff-tree-node.ff-root {\n      background-color: #272727; }\n    .ff-tree .ff-tree-node[selected] {\n      background-color: #0089bf; }\n    .ff-tree .ff-tree-node .ff-header {\n      position: relative;\n      cursor: pointer;\n      padding-left: 14px; }\n      .ff-tree .ff-tree-node .ff-header .ff-text {\n        user-select: none; }\n    .ff-tree .ff-tree-node.ff-drop-target > .ff-header {\n      outline: 1px dashed #0089bf; }\n    .ff-tree .ff-tree-node.ff-inner[expanded] > .ff-header:before {\n      content: '';\n      position: absolute;\n      top: 0.6em;\n      left: 3px;\n      width: 0;\n      height: 0;\n      border-left: 4px solid transparent;\n      border-right: 4px solid transparent;\n      border-bottom: 4px solid #a0a0a0;\n      transform: rotate(180deg);\n      transition: transform 0.05s; }\n    .ff-tree .ff-tree-node.ff-inner:not([expanded]) > .ff-header:before {\n      content: '';\n      position: absolute;\n      top: 0.6em;\n      left: 3px;\n      width: 0;\n      height: 0;\n      border-left: 4px solid transparent;\n      border-right: 4px solid transparent;\n      border-bottom: 4px solid #a0a0a0;\n      transform: rotate(90deg);\n      transition: transform 0.05s; }\n    .ff-tree .ff-tree-node.ff-leaf .ff-header {\n      cursor: default; }\n    .ff-tree .ff-tree-node .ff-content {\n      margin-left: 10px; }\n    .ff-tree .ff-tree-node:not([expanded]) > .ff-content {\n      display: none; }\n\nff-tab-container {\n  background: #343434; }\n\nff-tab-container, ff-dock-stack {\n  background: #272727;\n  border: 1px solid #1b1b1b; }\n  ff-tab-container header, ff-dock-stack header {\n    background: #1b1b1b; }\n\nff-tab-header, ff-dock-panel-header {\n  background: #1b1b1b;\n  color: #c8c8c8;\n  padding: 1px 3px 2px 2px; }\n  ff-tab-header[active], ff-dock-panel-header[active] {\n    background: linear-gradient(#626262, #343434);\n    color: #c8c8c8; }\n  ff-tab-header label, ff-dock-panel-header label {\n    pointer-events: none; }\n  ff-tab-header .ff-text, ff-dock-panel-header .ff-text {\n    padding: 0 1px; }\n  ff-tab-header .ff-icon, ff-dock-panel-header .ff-icon {\n    top: 1px;\n    height: 0.8rem;\n    padding: 0 1px; }\n\n.ff-dock-drop-marker {\n  box-sizing: border-box;\n  background: rgba(0, 137, 191, 0.3);\n  border: 1px solid #0089bf; }\n\n/**\n * FF Typescript Foundation Library\n * Copyright 2020 Ralph Wiedemeier, Frame Factory GmbH\n *\n * License: MIT\n */\n.ff-viewport-overlay {\n  padding: 6px;\n  font-size: 0.75rem; }\n  .ff-viewport-overlay .ff-row {\n    display: flex;\n    justify-content: space-between; }\n  .ff-viewport-overlay .ff-labels {\n    display: flex;\n    flex-direction: column; }\n  .ff-viewport-overlay .ff-top-left, .ff-viewport-overlay .ff-bottom-left {\n    align-items: flex-start; }\n  .ff-viewport-overlay .ff-top-center, .ff-viewport-overlay .ff-bottom-center {\n    align-items: center; }\n  .ff-viewport-overlay .ff-top-right, .ff-viewport-overlay .ff-bottom-right {\n    align-items: flex-end; }\n  .ff-viewport-overlay .ff-label-box {\n    box-sizing: border-box;\n    padding: 1px 8px 2px 8px;\n    background: rgba(0, 0, 0, 0.5);\n    border-radius: 2em; }\n\n.sv-article h1 {\n  margin: 0.3em 0;\n  font-family: \"Amiri\", serif;\n  font-size: 2.3em;\n  font-weight: normal;\n  color: #e8e8e8; }\n  .sv-article h1:before {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 75px;\n    height: 5px;\n    background-color: #0089bf; }\n\n.sv-article p, .sv-article h2, .sv-article h3, .sv-article h4, .sv-article h5, .sv-article h6, .sv-article ul, .sv-article ol, .sv-article li {\n  font-family: \"Hind Siliguri\", sans-serif;\n  color: #c8c8c8; }\n\n.sv-article h2, .sv-article h3, .sv-article h4, .sv-article h5, .sv-article h6 {\n  font-size: 1.3em;\n  margin: 1.2em 0 0.8em 0; }\n\n.sv-article p, .sv-article ul, .sv-article ol {\n  font-size: 1.15em;\n  margin: 0.8em 0; }\n\n.sv-article p {\n  line-height: 1.55em; }\n\n.sv-article ul {\n  padding-left: 0.5em;\n  list-style: square inside; }\n\n.sv-article ol {\n  padding-left: 0.5em;\n  list-style: decimal inside; }\n\n.sv-article a:link, .sv-article a:visited, .sv-article a:hover, .sv-article a:active {\n  color: #0089bf; }\n\n.sv-article img {\n  max-width: 100%; }\n\n.sv-content-view {\n  font-family: \"Segoe UI\", \"HelveticaNeue\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  font-weight: 400;\n  font-size: 0.85rem;\n  line-height: 1.35;\n  color: #c8c8c8;\n  background-color: #343434;\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  box-sizing: border-box;\n  overflow: hidden;\n  user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none; }\n\n.sv-logo {\n  flex: 0 50 180px;\n  min-width: 40px;\n  display: flex;\n  flex-wrap: wrap;\n  align-items: center;\n  justify-content: flex-end;\n  overflow: hidden;\n  height: 40px;\n  user-select: none; }\n  .sv-logo .sv-short {\n    flex-grow: 1;\n    width: 0;\n    max-width: 40px; }\n  .sv-logo .sv-full {\n    flex: 1 0 180px;\n    display: flex; }\n    .sv-logo .sv-full .sv-sunburst {\n      flex: 0 0 14%; }\n    .sv-logo .sv-full .sv-smithsonian {\n      flex: 0 0 83%;\n      margin-left: 3%; }\n\n@keyframes spin {\n  100% {\n    transform: rotate(360deg); } }\n\n.sv-spinner {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  box-sizing: border-box;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  pointer-events: none; }\n\n.sv-spinner-wheel {\n  height: 120px;\n  width: 120px;\n  animation: spin 5s linear infinite; }\n\n* {\n  scrollbar-color: #676767 #1b1b1b;\n  scrollbar-width: thin; }\n  * ::-webkit-scrollbar {\n    width: 8px; }\n  * ::-webkit-scrollbar-track {\n    background-color: #1b1b1b; }\n  * ::-webkit-scrollbar-thumb {\n    background-color: #676767; }\n\n.sv-content-only .sv-scene-view, .sv-content-stack .sv-scene-view {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  box-sizing: border-box; }\n\n.sv-reader-container {\n  overflow-y: auto; }\n\n.sv-content-stack .sv-reader-container {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  box-sizing: border-box;\n  margin-top: 52px; }\n\n.sv-content-stack .sv-reader-view {\n  pointer-events: auto;\n  display: flex;\n  justify-content: center; }\n  .sv-content-stack .sv-reader-view .sv-left {\n    flex: 0 0 52px; }\n  .sv-content-stack .sv-reader-view .sv-article {\n    flex: 0 2 720px;\n    background-color: rgba(27, 34, 38, 0.5);\n    padding-bottom: 35px; }\n  .sv-content-stack .sv-reader-view .sv-right {\n    flex: 0 3 16px;\n    background-color: rgba(27, 34, 38, 0.5); }\n\n.sv-content-split {\n  display: flex; }\n  .sv-content-split .sv-reader-container {\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    box-sizing: border-box;\n    margin-top: 52px; }\n  .sv-content-split .sv-scene-view {\n    flex: 1 1 60%; }\n  .sv-content-split .sv-reader-view {\n    pointer-events: auto;\n    flex: 1 1 40%;\n    padding: 0 20px; }\n    .sv-content-split .sv-reader-view .sv-left {\n      flex: 0 0 52px; }\n    .sv-content-split .sv-reader-view .sv-article {\n      flex: 0 2 720px;\n      background-color: rgba(27, 34, 38, 0.5);\n      padding-bottom: 35px;\n      padding-right: 16px; }\n    .sv-content-split .sv-reader-view .sv-right {\n      flex: 0 3 16px;\n      background-color: rgba(27, 34, 38, 0.5); }\n\n.sv-article {\n  position: relative;\n  padding: 5px 0 0 16px; }\n\n.sv-scene-view {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  box-sizing: border-box;\n  overflow: hidden; }\n  .sv-scene-view.sv-blur {\n    filter: brightness(60%) blur(5px);\n    transition: filter 0.5s; }\n\n.sv-annotation {\n  box-sizing: border-box;\n  position: absolute;\n  z-index: 1;\n  user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none; }\n\n.sv-annotation-img {\n  max-width: 100%; }\n\n.sv-circle-annotation {\n  width: 16%;\n  min-width: 160px;\n  max-width: 260px;\n  padding: 4px 8px;\n  background-color: rgba(0, 0, 0, 0.7);\n  border-radius: 4px; }\n  .sv-circle-annotation.sv-align-right {\n    transform: translateX(-100%); }\n  .sv-circle-annotation.sv-align-bottom {\n    transform: translateY(-100%); }\n  .sv-circle-annotation .sv-title {\n    padding: 0 0 2px 0;\n    font-size: 0.85rem;\n    font-weight: bold; }\n  .sv-circle-annotation p {\n    font-family: \"Segoe UI\", \"HelveticaNeue\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n    font-weight: 400;\n    font-size: 0.75rem;\n    line-height: 1.35;\n    color: #c8c8c8;\n    margin: 0.5em 0; }\n  .sv-circle-annotation .ff-button {\n    background: rgba(0, 0, 0, 0.01); }\n    .sv-circle-annotation .ff-button .ff-icon {\n      fill: #a0a0a0; }\n    .sv-circle-annotation .ff-button:hover {\n      text-decoration: underline; }\n  .sv-circle-annotation .sv-content {\n    overflow: hidden;\n    overflow-wrap: break-word; }\n\n.sv-pin-annotation {\n  padding: 0 4px;\n  background-color: rgba(0, 0, 0, 0.5);\n  color: #c8c8c8;\n  transform: translate(-50%, -100%); }\n\n.sv-standard-annotation, .sv-extended-annotation {\n  max-width: 28%;\n  padding: 0 4px;\n  background-color: rgba(0, 0, 0, 0.5);\n  color: #c8c8c8;\n  pointer-events: auto; }\n  .sv-standard-annotation.sv-expanded, .sv-extended-annotation.sv-expanded {\n    width: 20%;\n    min-width: 180px;\n    background-color: rgba(0, 0, 0, 0.8); }\n  .sv-standard-annotation.sv-q0, .sv-extended-annotation.sv-q0 {\n    transform: translate(0, -100%);\n    border-bottom-style: solid;\n    border-bottom-width: 1px;\n    text-align: left; }\n  .sv-standard-annotation.sv-q1, .sv-extended-annotation.sv-q1 {\n    transform: translate(-100%, -100%);\n    border-bottom-style: solid;\n    border-bottom-width: 1px;\n    text-align: right; }\n  .sv-standard-annotation.sv-q2, .sv-extended-annotation.sv-q2 {\n    transform: translate(-100%, 0);\n    border-top-style: solid;\n    border-top-width: 1px;\n    text-align: right; }\n  .sv-standard-annotation.sv-q3, .sv-extended-annotation.sv-q3 {\n    transform: translate(0, 0);\n    border-top-style: solid;\n    border-top-width: 1px;\n    text-align: left; }\n  .sv-standard-annotation.sv-static-width, .sv-extended-annotation.sv-static-width {\n    width: fit-content; }\n  .sv-standard-annotation .sv-title, .sv-extended-annotation .sv-title {\n    padding: 1px 0 2px 0;\n    font-size: 0.85rem;\n    font-weight: bold; }\n  .sv-standard-annotation .sv-content, .sv-extended-annotation .sv-content {\n    padding: 2px 0;\n    font-size: 0.8rem;\n    height: 0;\n    overflow: hidden;\n    overflow-wrap: break-word;\n    transition: height 0.2s; }\n  .sv-standard-annotation p, .sv-extended-annotation p {\n    font-family: \"Segoe UI\", \"HelveticaNeue\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n    font-weight: 400;\n    font-size: 0.75rem;\n    line-height: 1.35;\n    color: #c8c8c8;\n    margin: 0.5em 0; }\n  .sv-standard-annotation .ff-button, .sv-extended-annotation .ff-button {\n    background: rgba(0, 0, 0, 0.01); }\n    .sv-standard-annotation .ff-button .ff-icon, .sv-extended-annotation .ff-button .ff-icon {\n      fill: #a0a0a0; }\n    .sv-standard-annotation .ff-button:hover, .sv-extended-annotation .ff-button:hover {\n      text-decoration: underline; }\n\n.sv-extended-annotation .sv-title {\n  cursor: pointer; }\n\n.sv-standard-annotation {\n  pointer-events: none; }\n\n.sv-ar-prompt {\n  flex: 1 1 auto;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  text-align: center;\n  border-radius: 20px;\n  margin: 30% 0 0 0;\n  overflow: hidden;\n  background-color: rgba(54, 61, 64, 0.6); }\n  .sv-ar-prompt .sv-content {\n    flex: 1;\n    width: 100%;\n    margin: 10px 10px;\n    text-align: center;\n    -webkit-user-select: none;\n    /* Safari */\n    -ms-user-select: none;\n    /* IE 10 and IE 11 */\n    user-select: none; }\n    .sv-ar-prompt .sv-content .sv-ar-icon {\n      height: 10em; }\n\n.sv-ar-menu {\n  display: flex;\n  position: absolute;\n  bottom: 0px;\n  flex-direction: row;\n  margin: 0 0 6px 6px; }\n  .sv-ar-menu > .ff-button {\n    box-sizing: border-box;\n    width: 38px;\n    height: 38px;\n    margin: 0 0 2px 2px;\n    background-color: rgba(74, 82, 87, 0.5);\n    border-radius: 20px;\n    font-size: 17px;\n    transition: all 0.15s;\n    pointer-events: auto; }\n    .sv-ar-menu > .ff-button:hover, .sv-ar-menu > .ff-button:focus {\n      outline: none;\n      background-color: rgba(74, 82, 87, 0.5);\n      fill: #c8c8c8; }\n    .sv-ar-menu > .ff-button[selected] {\n      background-color: #0089bf;\n      color: #f0f0f0; }\n      .sv-ar-menu > .ff-button[selected] > .ff-icon {\n        filter: drop-shadow(1px 1px 6px #00648c);\n        fill: #c8c8c8; }\n      .sv-ar-menu > .ff-button[selected]:hover, .sv-ar-menu > .ff-button[selected]:focus {\n        background-color: #00a6e8; }\n\n.sv-chrome-view {\n  font-family: \"Segoe UI\", \"HelveticaNeue\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  font-weight: 400;\n  font-size: 0.85rem;\n  line-height: 1.35;\n  color: #c8c8c8;\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  box-sizing: border-box;\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n  background: linear-gradient(to bottom, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.15) 10%, transparent 25%);\n  z-index: 1; }\n  .sv-chrome-view .ff-button {\n    flex: 0 1 auto;\n    box-sizing: border-box; }\n    .sv-chrome-view .ff-button:hover, .sv-chrome-view .ff-button:focus {\n      outline: none; }\n      .sv-chrome-view .ff-button:hover > .ff-icon, .sv-chrome-view .ff-button:focus > .ff-icon {\n        fill: #c8c8c8; }\n    .sv-chrome-view .ff-button[selected] {\n      background-color: #0089bf; }\n      .sv-chrome-view .ff-button[selected][disabled] {\n        background-color: #4e4e4e; }\n      .sv-chrome-view .ff-button[selected] > .ff-icon {\n        filter: drop-shadow(1px 1px 6px #00648c);\n        fill: #c8c8c8; }\n\n.sv-chrome-header {\n  display: flex;\n  align-items: flex-start; }\n  .sv-chrome-header .sv-top-bar {\n    flex: 1 1 auto;\n    display: flex;\n    align-items: flex-start;\n    height: 40px;\n    margin: 9px 9px 0 0;\n    overflow: hidden; }\n  .sv-chrome-header .sv-main-title {\n    flex: 1 1 auto;\n    margin: 6px 8px;\n    font-family: \"Hind Siliguri\", sans-serif;\n    font-weight: normal;\n    font-size: 1.2rem;\n    white-space: pre;\n    color: #e8e8e8;\n    user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none; }\n    .sv-chrome-header .sv-main-title span {\n      color: transparent; }\n\n.sv-chrome-footer {\n  display: block;\n  position: absolute;\n  bottom: 0;\n  right: 0;\n  z-index: -1; }\n  .sv-chrome-footer .sv-bottom-bar {\n    flex: 1 1 auto;\n    display: flex;\n    align-items: flex-end;\n    text-align: right;\n    overflow: hidden; }\n  .sv-chrome-footer .sv-language-display {\n    flex: 1 1 auto;\n    margin: 6px 8px;\n    font-family: \"Hind Siliguri\", sans-serif;\n    font-weight: normal;\n    font-size: 1.0rem;\n    white-space: pre;\n    color: #e8e8e8;\n    pointer-events: auto;\n    background: rgba(31, 36, 38, 0.8);\n    border-radius: 4px;\n    padding: 4px 6px;\n    user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none; }\n    .sv-chrome-footer .sv-language-display:hover, .sv-chrome-footer .sv-language-display:focus {\n      outline: none;\n      background-color: rgba(74, 82, 87, 0.5);\n      fill: #c8c8c8; }\n    .sv-chrome-footer .sv-language-display span {\n      color: transparent; }\n\n.sv-main-menu {\n  display: flex;\n  flex-direction: column;\n  margin: 6px 0 0 6px; }\n  .sv-main-menu > .ff-button {\n    box-sizing: border-box;\n    width: 38px;\n    height: 38px;\n    margin: 2px 0;\n    background-color: rgba(31, 36, 38, 0.8);\n    border-radius: 20px;\n    font-size: 17px;\n    transition: all 0.15s;\n    pointer-events: auto; }\n    .sv-main-menu > .ff-button:hover, .sv-main-menu > .ff-button:focus {\n      outline: none;\n      background-color: rgba(74, 82, 87, 0.5);\n      fill: #c8c8c8; }\n    .sv-main-menu > .ff-button[selected] {\n      background-color: #0089bf;\n      color: #f0f0f0; }\n      .sv-main-menu > .ff-button[selected] > .ff-icon {\n        filter: drop-shadow(1px 1px 6px #00648c);\n        fill: #c8c8c8; }\n      .sv-main-menu > .ff-button[selected]:hover, .sv-main-menu > .ff-button[selected]:focus {\n        background-color: #00a6e8; }\n\n.sv-share-menu {\n  position: relative;\n  width: 450px;\n  max-width: 85%;\n  padding: 8px;\n  background: #343434;\n  box-shadow: 0 0 20px rgba(0, 0, 0, 0.35);\n  pointer-events: auto; }\n  .sv-share-menu .ff-title {\n    margin: 0.5em 0 1em 0; }\n  .sv-share-menu .ff-button {\n    flex: 0 0 auto; }\n  .sv-share-menu .ff-text-edit {\n    height: 6.5em; }\n  .sv-share-menu .sv-share-buttons .ff-button {\n    width: 48px;\n    height: 48px;\n    border-radius: 48px;\n    margin: 0 1em 1em 0;\n    padding: 0; }\n    .sv-share-menu .sv-share-buttons .ff-button .ff-icon {\n      height: 30px;\n      fill: #f0f0f0; }\n  .sv-share-menu .sv-share-button-twitter {\n    background-color: #00aced; }\n    .sv-share-menu .sv-share-button-twitter:hover {\n      background-color: #21c2ff; }\n  .sv-share-menu .sv-share-button-facebook {\n    background-color: #3c5a99; }\n    .sv-share-menu .sv-share-button-facebook:hover {\n      background-color: #4e71ba; }\n  .sv-share-menu .sv-share-button-linkedin {\n    background-color: #0077B5; }\n    .sv-share-menu .sv-share-button-linkedin:hover {\n      background-color: #0099e8; }\n  .sv-share-menu .sv-share-button-email {\n    background-color: #d28842; }\n    .sv-share-menu .sv-share-button-email:hover {\n      background-color: #dca26b; }\n\n.sv-document-overlay {\n  position: absolute;\n  left: 52px;\n  top: 52px;\n  right: 6px;\n  bottom: 0;\n  pointer-events: auto; }\n\n.sv-tour-menu .sv-article, .sv-reader-view .sv-article {\n  position: relative; }\n  .sv-tour-menu .sv-article .sv-nav-button, .sv-reader-view .sv-article .sv-nav-button {\n    float: right;\n    margin: 1em 0.5em;\n    padding: 2px; }\n    .sv-tour-menu .sv-article .sv-nav-button .ff-icon, .sv-reader-view .sv-article .sv-nav-button .ff-icon {\n      height: 1.5em; }\n\n.sv-tour-menu .sv-entry, .sv-reader-view .sv-entry {\n  position: relative;\n  cursor: pointer;\n  padding: 5px 0 5px 15px;\n  margin-bottom: 16px;\n  max-width: 960px;\n  background-color: rgba(27, 34, 38, 0.5); }\n  .sv-tour-menu .sv-entry:hover, .sv-reader-view .sv-entry:hover {\n    background-color: rgba(51, 59, 64, 0.5); }\n\n.sv-language-menu {\n  position: relative;\n  width: 225px;\n  max-width: 85%;\n  height: 200px;\n  max-height: 85%;\n  padding: 8px;\n  background: #343434;\n  box-shadow: 0 0 20px rgba(0, 0, 0, 0.35);\n  pointer-events: auto; }\n  .sv-language-menu .ff-title {\n    margin: 0.3em 0 0.3em 0; }\n  .sv-language-menu .ff-button {\n    flex: 0 0 auto; }\n  .sv-language-menu .ff-scroll-y {\n    top: 50px; }\n  .sv-language-menu .sv-entry {\n    position: relative;\n    cursor: pointer;\n    padding: 5px 0 5px 15px;\n    margin-bottom: 2px;\n    max-width: 960px;\n    background-color: rgba(27, 34, 38, 0.5);\n    user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none; }\n    .sv-language-menu .sv-entry:hover {\n      background-color: rgba(51, 59, 64, 0.5); }\n    .sv-language-menu .sv-entry[selected] {\n      background-color: #0089bf;\n      color: #f0f0f0; }\n      .sv-language-menu .sv-entry[selected] > .ff-icon {\n        filter: drop-shadow(1px 1px 6px #00648c);\n        fill: #c8c8c8; }\n      .sv-language-menu .sv-entry[selected]:hover, .sv-language-menu .sv-entry[selected]:focus {\n        background-color: #00a6e8; }\n\n.sv-bottom-bar-container {\n  position: relative;\n  display: flex;\n  justify-content: center;\n  transition: transform 0.3s ease-out, opacity 0.15s ease-out; }\n  .sv-bottom-bar-container.sv-transition {\n    transform: translateY(40px);\n    opacity: 0; }\n  .sv-bottom-bar-container .ff-button {\n    transition: all 0.15s; }\n\n.sv-blue-bar {\n  flex: 0 1 960px;\n  display: flex;\n  flex-direction: column;\n  background-color: rgba(5, 7, 8, 0.85);\n  border-left: 1px solid rgba(0, 137, 191, 0.5);\n  border-right: 1px solid rgba(0, 137, 191, 0.5);\n  margin: 0 -1px 0 -1px;\n  min-width: 0px;\n  pointer-events: auto;\n  user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none; }\n  .sv-blue-bar .sv-group {\n    display: flex;\n    flex-direction: column; }\n  .sv-blue-bar .sv-section {\n    position: relative;\n    display: flex;\n    flex-direction: row;\n    border-top: 1px solid rgba(0, 137, 191, 0.5); }\n  .sv-blue-bar .sv-section-lead, .sv-blue-bar .sv-section-trail {\n    flex: 0 0 auto;\n    padding: 6px;\n    width: 38px; }\n    .sv-blue-bar .sv-section-lead:hover, .sv-blue-bar .sv-section-trail:hover {\n      background-color: rgba(74, 82, 87, 0.5); }\n  .sv-blue-bar .sv-section-lead {\n    border-right: 1px solid rgba(0, 137, 191, 0.5); }\n  .sv-blue-bar .sv-section-trail {\n    border-left: 1px solid rgba(0, 137, 191, 0.5); }\n  .sv-blue-bar .sv-transparent-button {\n    flex: 0 1 auto;\n    padding: 6px;\n    border-radius: 2px; }\n    .sv-blue-bar .sv-transparent-button .ff-text {\n      margin: 1px 2px; }\n    .sv-blue-bar .sv-transparent-button .ff-icon {\n      height: 22px;\n      margin: 1px 2px; }\n\n.sv-tour-navigator {\n  color: #c8c8c8; }\n  .sv-tour-navigator .sv-content {\n    flex: 1;\n    margin: 2px 8px;\n    text-align: center; }\n  .sv-tour-navigator .sv-title {\n    font-size: 1.1em; }\n  .sv-tour-navigator .sv-text {\n    font-size: 0.9em; }\n\n.sv-target-navigator .sv-content {\n  flex: 1;\n  margin: 2px 8px;\n  text-align: center; }\n\n.sv-target-navigator .sv-title {\n  font-size: 1.1em; }\n\n.sv-tag-cloud .sv-tag-buttons {\n  flex: 1 1 auto;\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: center;\n  margin: 4px; }\n\n.sv-tag-cloud .sv-tag-button {\n  flex: 0 1 auto;\n  margin: 3px 3px;\n  padding: 2px 4px;\n  background-color: rgba(31, 36, 38, 0.8);\n  border-radius: 3px;\n  font-size: 0.75rem; }\n  .sv-tag-cloud .sv-tag-button:hover {\n    background-color: rgba(74, 82, 87, 0.5); }\n  .sv-tag-cloud .sv-tag-button[selected] {\n    background-color: #0089bf; }\n  .sv-tag-cloud .sv-tag-button .ff-text {\n    margin: 1px 2px; }\n  .sv-tag-cloud .sv-tag-button .ff-icon {\n    height: 22px;\n    margin: 1px 2px; }\n\n.sv-tool-bar {\n  color: #c8c8c8; }\n  .sv-tool-bar .sv-tool-buttons {\n    flex: 1 1 auto;\n    display: flex;\n    justify-content: center;\n    margin: 4px; }\n  .sv-tool-bar .sv-tool-button {\n    flex: 0 1 auto;\n    margin: 2px;\n    padding: 1px 2px;\n    border-radius: 3px;\n    font-size: 0.75rem; }\n    .sv-tool-bar .sv-tool-button .ff-text {\n      margin: 1px 2px; }\n    .sv-tool-bar .sv-tool-button .ff-icon {\n      height: 22px;\n      margin: 1px 2px; }\n\n.sv-tool-controls {\n  flex: 1 1 auto;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  font-size: 0.75rem; }\n  .sv-tool-controls .sv-property-view {\n    flex: 0 1 auto;\n    align-self: start;\n    display: flex;\n    flex-direction: column;\n    margin: 4px; }\n    .sv-tool-controls .sv-property-view label {\n      height: 1.25em; }\n    .sv-tool-controls .sv-property-view.sv-nogap {\n      margin: 4px 0 !important; }\n  .sv-tool-controls .sv-property-slider {\n    flex: 0 2 180px; }\n    .sv-tool-controls .sv-property-slider .ff-linear-slider {\n      height: 6px;\n      margin: 12px 2px;\n      padding-right: 16px;\n      border-radius: 2px;\n      background-color: #4e4e4e; }\n      .sv-tool-controls .sv-property-slider .ff-linear-slider .ff-knob {\n        width: 16px;\n        height: 26px;\n        margin: -10px 0 0 0;\n        border-radius: 2px;\n        background-color: #0089bf;\n        box-shadow: 0 0 6px black; }\n  .sv-tool-controls .sv-property-color > .ff-button {\n    width: 28px;\n    box-sizing: border-box;\n    border: 1px solid #343434; }\n  .sv-tool-controls .sv-property-color .ff-color-edit {\n    position: absolute;\n    width: 200px;\n    height: 180px;\n    right: 8px;\n    top: -188px; }\n  .sv-tool-controls .sv-options {\n    display: flex; }\n  .sv-tool-controls .ff-label {\n    margin: 2px; }\n  .sv-tool-controls .ff-string {\n    flex: 0 1 auto;\n    height: 26px;\n    margin: 2px;\n    font-size: 1rem; }\n  .sv-tool-controls .ff-button {\n    height: 26px;\n    margin: 2px;\n    padding: 0 4px;\n    background: #343434;\n    border-radius: 2px; }\n\n.sv-view-tool-view .sv-options, .sv-render-tool-view .sv-options, .sv-light-tool-view .sv-options {\n  flex-wrap: wrap; }\n\n.sv-tape-tool-view .sv-tool-controls, .sv-slice-tool-view .sv-tool-controls, .sv-environment-tool-view .sv-tool-controls {\n  flex-wrap: wrap; }\n");

/***/ }),

/***/ "./utils/Pin.ts":
/*!**********************!*\
  !*** ./utils/Pin.ts ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Pin; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

////////////////////////////////////////////////////////////////////////////////
class Pin extends three__WEBPACK_IMPORTED_MODULE_0__["Group"] {
    constructor() {
        super();
        const needlePoints = [
            0, 0,
            0.25, 0.4,
            0.4, 10,
        ];
        const handlePoints = [
            0, 10,
            3.4, 10,
            3.5, 10.1,
            3.5, 11,
            3.45, 11.1,
            2.05, 12.5,
            2, 12.6,
            2, 17.4,
            2.05, 17.5,
            3.45, 18.9,
            3.5, 19,
            3.5, 19.9,
            3.4, 20,
            0, 20,
        ];
        const needleMaterial = new three__WEBPACK_IMPORTED_MODULE_0__["MeshStandardMaterial"]({ color: "white", metalness: 1 });
        needleMaterial.transparent = true;
        const needle = new three__WEBPACK_IMPORTED_MODULE_0__["Mesh"](this.createLatheGeometry(needlePoints), needleMaterial);
        const handleMaterial = new three__WEBPACK_IMPORTED_MODULE_0__["MeshStandardMaterial"](({ color: "#ffcd00", roughness: 0.8, metalness: 0.1 }));
        handleMaterial.transparent = true;
        const handle = new three__WEBPACK_IMPORTED_MODULE_0__["Mesh"](this.createLatheGeometry(handlePoints), handleMaterial);
        needle.matrixAutoUpdate = false;
        this.add(needle);
        handle.matrixAutoUpdate = false;
        this.add(handle);
    }
    dispose() {
    }
    createLatheGeometry(points) {
        const vectors = [];
        for (let i = 0, n = points.length; i < n; i += 2) {
            vectors.push(new three__WEBPACK_IMPORTED_MODULE_0__["Vector2"](points[i], points[i + 1]));
        }
        return new three__WEBPACK_IMPORTED_MODULE_0__["LatheBufferGeometry"](vectors, 16);
    }
}


/***/ }),

/***/ "./utils/unitScaleFactor.ts":
/*!**********************************!*\
  !*** ./utils/unitScaleFactor.ts ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var client_schema_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! client/schema/common */ "./schema/common.ts");
/**
 * 3D Foundation Project
 * Copyright 2019 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

////////////////////////////////////////////////////////////////////////////////
const _unitScaleFactor = {
    "mm": { "mm": 1, "cm": 0.1, "m": 0.001, "km": 1, "in": 0.0393701, "ft": 0.00328084, "yd": 0.00109361, "mi": 1 },
    "cm": { "mm": 10, "cm": 1, "m": 0.01, "km": 1, "in": 0.393701, "ft": 0.0328084, "yd": 0.0109361, "mi": 1 },
    "m": { "mm": 1000, "cm": 100, "m": 1, "km": 1, "in": 39.3701, "ft": 3.28084, "yd": 1.09361, "mi": 1 },
    "km": { "mm": 1000000, "cm": 100000, "m": 1000, "km": 1, "in": 39370.1, "ft": 3280.84, "yd": 1093.61, "mi": 1 },
    "in": { "mm": 25.4, "cm": 2.54, "m": 0.0254, "km": 1, "in": 1, "ft": 0.0833333, "yd": 0.0277778, "mi": 1 },
    "ft": { "mm": 304.8, "cm": 30.48, "m": 0.3048, "km": 1, "in": 12, "ft": 1, "yd": 0.333334, "mi": 1 },
    "yd": { "mm": 914.4, "cm": 91.44, "m": 0.9144, "km": 1, "in": 36, "ft": 3, "yd": 1, "mi": 1 },
    "mi": { "mm": 1.609e+6, "cm": 1.609e+5, "m": 1.609e+3, "km": 1, "in": 63346456.693, "ft": 5278871.391, "yd": 1759623.797, "mi": 1 },
};
/* harmony default export */ __webpack_exports__["default"] = (function (from, to) {
    const fromType = client_schema_common__WEBPACK_IMPORTED_MODULE_0__["EUnitType"][from];
    const toType = client_schema_common__WEBPACK_IMPORTED_MODULE_0__["EUnitType"][to];
    return _unitScaleFactor[fromType][toType] || 1;
});


/***/ }),

/***/ "./xr/XRShadow.ts":
/*!************************!*\
  !*** ./xr/XRShadow.ts ***!
  \************************/
/*! exports provided: Shadow */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shadow", function() { return Shadow; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../../node_modules/three/src/Three.js");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 *
 * From <model-viewer> project (www.modelviewer.dev)
 * Modifications Copyright 2020 Smithsonian Institution
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Nothing within Offset of the bottom of the model casts a shadow
// (this is to avoid having a baked-in shadow plane cast its own shadow).
const OFFSET = 0.001;
// The softness [0, 1] of the shadow is mapped to a resolution between
// 2^LOG_MAX_RESOLUTION and 2^LOG_MIN_RESOLUTION.
const LOG_MAX_RESOLUTION = 9;
const LOG_MIN_RESOLUTION = 6;
// Animated models are not in general contained in their bounding box, as this
// is calculated only for their resting pose. We create a cubic shadow volume
// for animated models sized to their largest bounding box dimesion multiplied
// by this scale factor.
const ANIMATION_SCALING = 2;
/**
 * The Shadow class creates a shadow that fits a given model and follows a
 * target. This shadow will follow the model without any updates needed so long
 * as the shadow and model are both parented to the same object (call it the
 * scene) and this scene is passed as the target parameter to the shadow's
 * constructor. We also must constrain the scene to motion within the horizontal
 * plane and call the setRotation() method whenever the model's Y-axis rotation
 * changes. For motion outside of the horizontal plane, this.needsUpdate must be
 * set to true.
 *
 * The softness of the shadow is controlled by changing its resolution, making
 * softer shadows faster, but less precise.
 */
class Shadow extends three__WEBPACK_IMPORTED_MODULE_0__["DirectionalLight"] {
    constructor(scene, root, softness) {
        super();
        this.shadowMaterial = new three__WEBPACK_IMPORTED_MODULE_0__["ShadowMaterial"];
        this.boundingBox = new three__WEBPACK_IMPORTED_MODULE_0__["Box3"];
        this.size = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"];
        this.isAnimated = false;
        this.needsUpdate = false;
        // We use the light only to cast a shadow, not to light the scene.
        this.intensity = 0;
        this.castShadow = true;
        this.frustumCulled = false;
        this.floor = new three__WEBPACK_IMPORTED_MODULE_0__["Mesh"](new three__WEBPACK_IMPORTED_MODULE_0__["PlaneBufferGeometry"], this.shadowMaterial);
        this.floor.rotateX(-Math.PI / 2);
        this.floor.receiveShadow = true;
        this.floor.castShadow = false;
        this.floor.frustumCulled = false;
        this.add(this.floor);
        this.shadow.camera.up.set(0, 0, 1);
        root.add(this);
        this.target = root;
        this.setModel(scene, softness);
    }
    /**
     * Update the shadow's size and position for a new model. Softness is also
     * needed, as this controls the shadow's resolution.
     */
    setModel(scene, softness) {
        //this.isAnimated = model.animationNames.length > 0;
        this.boundingBox.copy(scene.outs.boundingBox.value);
        scene.outs.boundingBox.value.getSize(this.size);
        const { boundingBox, size } = this;
        if (this.isAnimated) {
            const maxDimension = Math.max(size.x, size.y, size.z) * ANIMATION_SCALING;
            size.y = maxDimension;
            boundingBox.expandByVector(size.subScalar(maxDimension).multiplyScalar(-0.5));
            boundingBox.max.y = boundingBox.min.y + maxDimension;
            size.set(maxDimension, maxDimension, maxDimension);
        }
        const shadowOffset = size.y * OFFSET;
        this.position.y = boundingBox.max.y + shadowOffset;
        boundingBox.getCenter(this.floor.position);
        this.setSoftness(softness);
    }
    /**
     * Update the shadow's resolution based on softness (between 0 and 1). Should
     * not be called frequently, as this results in reallocation.
     */
    setSoftness(softness) {
        const resolution = Math.pow(2, LOG_MAX_RESOLUTION -
            softness * (LOG_MAX_RESOLUTION - LOG_MIN_RESOLUTION));
        this.setMapSize(resolution);
    }
    /**
     * Lower-level version of the above function.
     */
    setMapSize(maxMapSize) {
        const { camera, mapSize, map } = this.shadow;
        const { size, boundingBox } = this;
        if (map != null) {
            map.dispose();
            this.shadow.map = null;
        }
        if (this.isAnimated) {
            maxMapSize *= ANIMATION_SCALING;
        }
        const width = Math.floor(size.x > size.z ? maxMapSize : maxMapSize * size.x / size.z);
        const height = Math.floor(size.x > size.z ? maxMapSize * size.z / size.x : maxMapSize);
        mapSize.set(width, height);
        // These pads account for the softening radius around the shadow.
        const widthPad = 2.5 * size.x / width;
        const heightPad = 2.5 * size.z / height;
        camera.left = -boundingBox.max.x - widthPad;
        camera.right = -boundingBox.min.x + widthPad;
        camera.bottom = boundingBox.min.z - heightPad;
        camera.top = boundingBox.max.z + heightPad;
        this.setScaleAndOffset(camera.zoom, 0);
        this.shadow.updateMatrices(this);
        this.floor.scale.set(size.x + 2 * widthPad, size.z + 2 * heightPad, 1);
        this.needsUpdate = true;
    }
    /**
     * Set the shadow's intensity (0 to 1), which is just its opacity. Turns off
     * shadow rendering if zero.
     */
    setIntensity(intensity) {
        this.shadowMaterial.opacity = intensity;
        if (intensity > 0) {
            this.visible = true;
            this.floor.visible = true;
        }
        else {
            this.visible = false;
            this.floor.visible = false;
        }
    }
    getIntensity() {
        return this.shadowMaterial.opacity;
    }
    /**
     * The shadow does not rotate with its parent transforms, so the rotation must
     * be manually updated here if it rotates in world space. The input is its
     * absolute orientation about the Y-axis (other rotations are not supported).
     */
    setRotation(radiansY) {
        this.shadow.camera.up.set(Math.sin(radiansY), 0, Math.cos(radiansY));
        this.shadow.updateMatrices(this);
    }
    /**
     * The scale is also not inherited from parents, so it must be set here in
     * accordance with any transforms. An offset can also be specified to move the
     * shadow vertically relative to the bottom of the model. Positive is up, so
     * values are generally negative.
     */
    setScaleAndOffset(scale, offset) {
        const sizeY = this.size.y;
        const inverseScale = 1 / scale;
        // Floor plane is up slightly from the bottom of the bounding box to avoid
        // Z-fighting with baked-in shadows and to stay inside the shadow camera.
        const shadowOffset = sizeY * OFFSET;
        this.floor.position.y = 2 * shadowOffset - sizeY + offset * inverseScale;
        const { camera } = this.shadow;
        camera.zoom = scale;
        camera.near = 0;
        camera.far = sizeY * scale - offset;
        camera.projectionMatrix.makeOrthographic(camera.left * scale, camera.right * scale, camera.top * scale, camera.bottom * scale, camera.near, camera.far);
        camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
    }
    /** Clean up */
    dispose() {
        const { floor, shadowMaterial } = this;
        floor.geometry.dispose();
        shadowMaterial.dispose();
        this.floor = null;
        this.shadowMaterial = null;
    }
}


/***/ })

/******/ });
//# sourceMappingURL=voyager-explorer.dev.js.map